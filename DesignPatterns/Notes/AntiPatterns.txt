Development AntiPattern Summaries

Development AntiPatterns utilize various formal and informal refactoring approaches. 
The following summaries provide an overview of the Development AntiPatterns found in this chapter and focus on the development AntiPattern problem. 
Included are descriptions of both development and mini−AntiPatterns. 
The refactored solutions appear in the appropriate AntiPattern templates that follow the summaries.


-> The Blob: 
Procedural−style design leads to one object with a lion’s share of the responsibilities, while most other objects only hold data or execute simple processes. 
The solution includes refactoring the design to distribute responsibilities more uniformly and the effect of changes.

-> Continuous Obsolescence: 
Technology is changing so rapidly that developers often have trouble keeping up with current versions of software and finding combinations of product releases that work together. 
Given that every commercial product line evolves through new releases, the situation is becoming more difficult for developers to cope with.
Finding compatible releases of products that successfully interoperate is even harder.

-> Lava Flow: 
Dead code and forgotten design information is frozen in an ever−changing design. 
This is analogous to a Lava Flow with hardening globules of rocky material. 
The refactored solution includes a configuration management process that eliminates dead code and evolves or refactors design toward increasing quality.

-> Ambiguous Viewpoint: 
Object−oriented analysis and design (OOA&D) models are often presented without clarifying the viewpoint represented by the model. 
By default, OOA&D models denote an implementation viewpoint that is potentially the least useful. 
Mixed viewpoints don’t allow the fundamental separation of interfaces from implementation details, which is one of the primary benefits of the object−oriented paradigm.

-> Functional Decomposition: 
This AntiPattern is the output of experienced, nonobject−oriented developers who design and implement an application in an object−oriented language. 
The resulting code resembles a structural language (Pascal, FORTRAN) in class structure. 
It can be incredibly complex as smart procedural developers devise very “clever” ways to replicate their time−tested methods in an object−oriented architecture.

-> Poltergeists: 
Poltergeists are classes with very limited roles and effective life cycles.
They often start processes for other objects. 
The refactored solution includes a reallocation of responsibilities to longer−lived objects that eliminate the Poltergeists.

-> Boat Anchor: 
A Boat Anchor is a piece of software or hardware that serves no useful purpose on the current project. 
Often, the Boat Anchor is a costly acquisition, which makes the purchase even more ironic.

-> Golden Hammer: 
A Golden Hammer is a familiar technology or concept applied obsessively to many software problems. 
The solution involves expanding the knowledge of developers through education, training, and book study groups to expose developers to alternative technologies and approaches.

-> Dead End: 
A Dead End is reached by modifying a reusable component if the modified component is no longer maintained and supported by the supplier. 
When these modifications are made, the support burden transfers to the application system developers and maintainers. 
Improvements in the reusable component are not easily integrated, and support problems can be blamed upon the modification.

-> Spaghetti Code: 
Adhoc software structure makes it difficult to extend and optimize code. 
Frequent code refactoring can improve software structure, support software maintenance, and enable iterative development.

-> Input Kludge: 
Software that fails straightforward behavioral tests may be an example of an input kludge, 
which occurs when adhoc algorithms are employed for handling program input.

-> Walking through a Minefield: 
Using today’s software technology is analogous to walking through a high−tech mine field [Beizer 97a]. 
Numerous bugs are found in released software products; in fact, experts estimate that original source code contains two to five bugs per line of code.

-> Cut−and−Paste Programming: 
Code reused by copying source statements leads to significant maintenance problems. 
Alternative forms of reuse, including black−box reuse, reduce maintenance issues by having common source code, testing, and documentation.

-> Mushroom Management: 
In some architecture and management circles, there is an explicit policy to keep system developers isolated from the system’s end users.
Requirements are passed second−hand through intermediaries, including architects, managers, or requirements analysts.




Development AntiPattern Discussion



-> The Blob

AntiPattern Name: The Blob
Also Known As: Winnebago [Akroyd 96] and The God Class [Riel 96]
Most Frequent Scale: Application
Refactored Solution Name: Refactoring of Responsibilities
Refactored Solution Type: Software
Root Causes: Sloth, Haste
Unbalanced Forces: Management of Functionality, Performance, Complexity
Anecdotal Evidence: “This is the class that is really the heart of our architecture.”

---> Background
Do you remember the original black−and−white movie The Blob? 
Perhaps you saw only the recent remake. 
In either case, the story line was almost the same: A drip−sized, jellylike alien life form from outer space somehow makes it to Earth. 
Whenever the jelly thing eats (usually unsuspecting earthlings), it grows. 
Meanwhile, incredulous earthlings panic and ignore the one crazy scientist who knows what’s happening. 
Many more people are eaten before they come to their senses. 
Eventually, the Blob grows so large that it threatens to wipe out the entire planet. 
The movie is a good analogy for the Blob AntiPattern, which has been known to consume entire object−oriented architectures.

---> General Form
The Blob is found in designs where one class monopolizes the processing, and other classes primarily encapsulate data. 
This AntiPattern is characterized by a class diagram composed of a single complex controller class surrounded by simple data classes.
The key problem here is that the majority of the responsibilities are allocated to a single class.

In general, the Blob is a procedural design even though it may be represented using object notations and implemented in object−oriented languages. 
A procedural design separates process from data, whereas an object−oriented design merges process and data models, along with partitions. 
The Blob contains the majority of the process, and the other objects contain the data. 
Architectures with the Blob have separated process from data; in other words, they are procedural−style rather than object−oriented architectures.

The Blob can be the result of inappropriate requirements allocation. 
For example, the Blob ay be a software module that is given responsibilities that overlap most other parts of the system for system control or system management. 
The Blob is also frequently a result of iterative development where proof−of−concept code evolves over time into a prototype, and eventually, a production system. 
This is often exacerbated by the use of primarily GUI−centric programming languages, such as Visual Basic, that allow a simple form to evolve its functionality, and therefore purpose, during incremental development or prototyping. 
The allocation of responsibilities is not repartitioned during system evolution, so that one module becomes predominant. 
The Blob is often accompanied by unnecessary code, making it hard to differentiate between the useful functionality of the Blob Class and no−longer−used code (see the Lava Flow AntiPattern).

---> Symptoms And Consequences
• Single class with a large number of attributes, operations, or both. 
A class with 60 or more attributes and operations usually indicates the presence of the Blob [Akroyd 96].
• A disparate collection of unrelated attributes and operations encapsulated in a single class. 
An overall lack of cohesiveness of the attributes and operations is typical of the Blob.
• A single controller class with associated simple, data−object classes.
• An absence of object−oriented design. 
A program main loop inside the Blob class associated with relatively passive data objects. 
The single controller class often nearly encapsulates the applications entire functionality, much like a procedural main program.
• A migrated legacy design that has not been properly refactored into an object−oriented architecture.
• The Blob compromises the inherent advantages of an object−oriented design. 
For example, the Blob limits the ability to modify the system without affecting the functionality of other encapsulated objects. 
Modifications to the Blob affect the extensive software within the Blob’s encapsulation. 
Modifications to other objects in the system are also likely to have impact on the Blob’s software.
• The Blob Class is typically too complex for reuse and testing. 
It may be inefficient, or introduce excessive complexity to reuse the Blob for subsets of its functionality.
• The Blob Class may be expensive to load into memory, using excessive resources, even for simple operations.

---> Typical Causes
• Lack of an object−oriented architecture. 
The designers may not have an adequate understanding of object−oriented principles. 
Alternatively, the team may lack appropriate abstraction skills.
• Lack of (any) architecture. 
The absence of definition of the system components, their interactions, and the specific use of the selected programming languages. 
This allows programs to evolve in an ad hoc fashion because the programming languages are used for other than their intended purposes.
• Lack of architecture enforcement. 
Sometimes this AntiPattern grows accidentally, even after a reasonable architecture was planned. 
This may be the result of inadequate architectural review as development takes place. 
This is especially prevalent with development teams new to object orientation.
• Too limited intervention. 
In iterative projects, developers tend to add little pieces of functionality to existing working classes, rather than add new classes, or revise the class hierarchy for more effective allocation of responsibilities.
• Specified disaster. 
Sometimes the Blob results from the way requirements are specified. 
If the requirements dictate a procedural solution, then architectural commitments may be made during requirements analysis that are difficult to change. 
Defining system architecture as part of requirements analysis is usually inappropriate, and often leads to the Blob AntiPattern, or worse.

---> Known Exceptions
The Blob AntiPattern is acceptable when wrapping legacy systems. 
There is no software partitioning required, just a final layer of code to make the legacy system more accessible.

---> Refactored Solution
As with most of the AntiPatterns in this section, the solution involves a form of refactoring.
The key is to move behavior away from the Blob. 
It may be appropriate to reallocate behavior to some of the encapsulated data objects in a way that makes these objects more capable and the Blob less complex. 
The method for refactoring responsibilities is described as follows:

1. Identify or categorize related attributes and operations according to contracts. 
These contracts should be cohesive in that they all directly relate to a common focus, behavior, or function within the overall system. 
2. The second step is to look for “natural homes” for these contract−based collections of
functionality and then migrate them there. 
3. The third step is to remove all “far−coupled,” or redundant, indirect associations. I
4. Next, where appropriate, we migrate associates to derived classes to a common base
class. 
5. Finally, we remove all transient associations, replacing them as appropriate with type
specifiers to attributes and operations arguments. 

---> Variations
Sometimes, with a system composed of the Blob class and its supporting data objects, too much work has been invested to enable a refactoring of the class architecture. 
An alternative approach may be available that provides an “80%” solution. 
Instead of a bottom−up refactoring of the entire class hierarchy, it may be possible to reduce the Blob class from a controller to a coordinator class. 
The original Blob class manages the system’s functionality; the data classes are extended with some of their own processing. 
The data classes operate at the direction of the modified coordinator class. 
This process may allow the retention of the original class hierarchy, except for the migrations of processing functionality from the Blob class to some of the encapsulated data classes.
Riel identifies two major forms of the Blob AntiPattern. 
He calls these two forms God Classes: Behavioral Form and Data Form [Riel 96]. 
The Behavioral Form is an object that contains a centralized process that interacts with most other parts of the system. 
The Data Form is an object that contains shared data used by most other objects in the system. 
Riel introduces a number of object−oriented heuristics for detect ing and refactoring God Class designs.

---> Applicability To Other Viewpoints And Scales
Both architectural and managerial viewpoints play key roles in the initial prevention of the Blob AntiPattern. 
Avoidance of the Blob may require ongoing policing of the architecture to assure adequate distribution of responsibilities. 
It is through an architectural viewpoint that an emerging Blob is recognized. 
With a mature object−oriented analysis and design process, and an alert manager who understands the design, developers can prevent the cultivation of a Blob.
The most important factor is that, in most cases, it’s much less expensive to create appropriate design than to rework design after implementation. 
Up−front investment in good architecture and team education can ensure a project against the Blob and most other AntiPatterns. 
Ask any insurance salesperson, and he or she may tell you that most insurance is purchased after it was needed by people who are poorer but wiser.

Example
A GUI module that is intended to interface to a processing module gradually takes on the processing functionality of background−processing modules. 
An example of this is a PowerBuilder screen for customer data entry/retrieval. 
The screen can:
1. Display data.
2. Edit data.
3. Perform simple type validation. 
The developer then adds functionality to what was intended to be the decision engine:
• Complex validation.
• Algorithms that use the validated data to assess next actions.
4. The developer then gets new requirements to:
• Extend the GUI to three forms.
• Make it script−driven (including the development of a script engine).
• Add new algorithms to the decision engine.
The developer extends the current module to incorporate all of this functionality. 
So instead of developing several modules, a single module is developed. 
If the intended application is architected and designed, it is easier to maintain and extend. 



-> The Blob



