
The Three States
This the main thing to remember about Git if you want the rest of your learning process to go smoothly. 
Git has three main states that your files can reside in: modified, staged, and committed:
-> Modified means that you have changed the file but have not committed it to your database yet.
-> Staged means that you have marked a modified file in its current version to go into your next commit snapshot.
-> Committed means that the data is safely stored in your local database.


Common commands:

-> Help:
---> git help

-> Stage or add a file one by one to be tracked by git (can be changed files or modified files):
---> git add FileName1 FileName2
-----> Note: git add for deleted files as well

-> Stage or add multiple files to be tracked by git (multiple changed files or modified files):
---> git add .   // all files
---> git add *.html  // all html files
---> git add :/   // adds all files under this directory

-> Unstage or remove a file one by one that is tracked by git (remove file from staging area):
---> git rm FileName1 FileName2
---> git rm --cached FileName1 FileName2
-----> When --cached is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.

-> Track changes:
---> git status

-> Check changes:
---> check changes from current commit
-----> git diff
-----> git diff FileName   // for one file
---> check changes from staging area
-----> git diff --cached

-> Check all commits:
---> git log
-----> by default, git log shows you a flatten version of the version history
---> git log --all --graph --decorate   // shows the changes in a graph
---> git log --all --graph --decorate --oneline   // shows the changes in a graph with less detail

-> Commit to local repository:
---> git commit -m "Message title test" -m "Message description text"
-----> The option "-m <msg> or --message=<msg>" will se the given <msg> as the commit message. 
-----> If multiple -m options are given, their values are concatenated as separate paragraphs.
-----> NOTE: if there is no message, it will fail the commit
---> git commit -am "Message title test" -m "Message description text"
-----> The option "-a or -all" will commit all MODIFIED files (no need to git add, works for MODIFIED files ONLY)
---> git commit -F ../CommitMessageFile.txt    // This is use a text file for the commit message
-----> The option "-F <file> or --file=<file>" will take the commit message from the given file. Use - to read the message from the standard input.

-> push changes to remote repository:
---> git push   // works without any arguments if upstream is set
---> git push origin master   // origin is reserved word the stands for the git remote repository, master is the branch we have to push
---> git push -u origin master   // "-u" is "--set-upstream" sets the upstream to origin so we don't have to type "origin master" in the future
---> git push origin HEAD:refs/for/BranchName   // This is for using a reference

-> pull changes from remote repository:
---> git pull   // works without any arguments if upstream is set
---> git push origin master   // origin is reserved word the stands for the location of the git remote repository, master is the branch we have to pull
---> git pull --set-upstream origin master   // "--set-upstream" sets the upstream to origin we don't have to type "origin master" in the future
-----> git pull = git fetch + git merge

-> fetch changes from remote repository and track it to GIT but dont change any files in local directory
---> git fetch
-----> only gets the changes from remote repository, but doesn't change local files
-----> check origin using git log
-----> git pull = git fetch + git merge
---> fetch from review:
-----> git fetch "ssh://malba@gerrit.ext.net.nokia.com:29418/MN/WCDMA/CPLANE/tcom" refs/changes/64/1785164/8 && git checkout FETCH_HEAD

-> undoing changes
---> undo staging (git add was already used, and we need to undo "git add")
-----> git reset   // undo staging for all changes
-----> git reset FileName   // undo staging for one file
-------> NOTE: The changes still exists we just "unstage" it. Do "git status" to check.
---> undo a commit (git commit was already used, and we need to undo "git commit")
-----> git reset HEAD~1  // HEAD points to the last commit, "~1" means the one commit before that. 
-------> NOTE: The changes still exists we just let git point to one commit before HEAD. Do "git status" to check.
---> go to a specific commit (git commit were used multiple times, and we need to undo several "git commits)
-----> get the unique hash of the commit
-------> git log
-----> use the unique hash of the commit in git reset
-------> git reset HashOfTheCommit
---------> NOTE: The changes still exists we just let git point to a commit. Do "git status" to check.
-----> undo changes and reflect it on the files
-------> git reset --hard
---------> NOTE: The "--hard" option means that the changes are also removed. Do "git status" to check.
---> undo a git merge
-----> git merge --abort

-> ignore files for staging
---> create file ".gitignore"
-----> touch .gitignore
---> then we can add FileToIgnore in ".gitignore" (put it in a new line)
---> then we can add DirectoryToIgnore in ".gitignore" (put it in a new line)
---> then we can add *.html in ".gitignore" (put it in a new line)

-> delete unversioned files:
---> discard changes
-----> git checkout
---> check files to removed
-----> git clean -n
---> remove files (forced)
-----> git clean -f
---> remove directories (forced)
-----> git clean -fd

-> apply diffs:
---> git apply --check --verbose DiffName.diff
---> git apply --verbose DiffName.diff

-> get diff from a commit:
---> git format-patch -1 <commit hash value>

-> blame
---> git blame FileName

-> show changes (useful after git blame)
---> git show HashStringOfTheCommit

-> stash
---> git stash
-----> save the changes in git and revert the local files to latest commit
---> git stash pop
-----> revert back the local files with the changes




Less common commands:

-> Set name and email 
---> git config --global user.email "detectivemark7@gmail.com"
---> git config --global user.name "detectivemark7"

-> Clone:
---> git clone git@github.com:detectivemark7/aprg.git
---> git clone --shallow URL    // --shallow means avoid getting the whole version history and get just the latest snapshot (useful for big repositories)

-> Create a git local repository:
---> git init   
-----> NOTE: This repository is not connected to origin (since this not remotely created(github)). 
-----> When this is pushed and the remote repository is not connected, GIT will say I have no idea where to push this to.

-> Connect your local repository to remote repository (not necessarily in the web but the common repository for other collaborators)
---> git remote add origin git@github.com:detectivemark7/aprgPython.git
---> git remote add origin DirectoryPathOfCommonRepository
-----> Then you can create a branch in the remote using:
-------> git push -u RemoteName LocalBranch:RemoteBranch
-------> git push -u origin master:master   // this creates a master branch in remote does not have one
-----> Then you can set the upstream as master using:
-------> git push -u origin master   // you can use --set-upstream as well
-------> git branch --set-upstream-to=origin master   // you can use git branch as well

-> Check what is the connected remote repository of this local repository:
---> git remote -v

-> For local branches (for feature branches or hot fix branches):
---> To view branches: 
-----> git branch
-------> outputs the local branches available currently
-------> * represents that its currently on that branch
-----> git branch -vv    // Very verbose (shows origin branch details as well)
---> create a new branch: 
-----> git branch BranchName (this does not switch the current branch)
-----> git checkout -b BranchName (this also switch the current branch)
---> delete a branch: 
-----> git branch -d BranchName
---> switch branches: 
-----> git checkout BranchName
-----> git checkout master
---> remotely git checkout can also be used to discard changes in the working directory
-----> git checkout FileName ...
---> before merging, check what is the diff of the specified branch with respect to the current branch
-----> git diff BranchName
---> merge diff of the specified branch to the current branch
-----> git merge BranchName
-----> git merge --verbose BranchName
-------> useful to merge a feature branch to master (for pushing changes to remote master)
-------> useful to merge a master to a feature branch (for keeping up with remote master)
---------> If there is a conflict, manually change the file (delete "<<<<<<< HEAD" "=======" and ">>>>>>> master" ), 
---------> then use git add for the conflicted files
---------> then use git merge --continue (or use git commit to apply the changes).
-----> git merge --abort
-------> undo the previous git merge
-----> git merge --continue
-------> after fixing the conflicts
---> push a specified branch to a remote repository (creating this specified branch in the remote repository)
-----> git push -u origin FakeFeatureBranch   // you can use --set-upstream as well
-------> this commits a FakeFeatureBranch to remote repository, then we can merge this branch to the master branch of the remote repository using a remote tool(GitHub, generate a pull request)
---> checkout to a specific version of the current branch:
-----> git checkout b32d6f740504
-------> Puts HEAD reference in a "detached HEAD state". The HEAD is not the latest commit of the branch anymore.
---> checkout to a specific version of a specific branch:
-----> git checkout BranchName b32d6f740504 (this also switch the current branch)

-> prints detail of a git object (see "GIT underneath")
---> git cat-file -p 42fb7a2    // prints details about an object, notice that only first 6 digits of the hash string of an object can be used as argument
---> git cat-file -p 42fb7a21b52dd0f6026a0d9d434129db61acb4bf2    // prints details about an object, notice that all 40 digits of an object can be used as argument


-> Forking
---> Can be done on remote repository (github)
---> Copy a separate repository and make it your own
-----> Useful to capture a separate repository at specific time (useful to copy external sources)
-------> Can send changes or make a contribution on the external sources (generate a pull request)




SSH key related:

-> SSH key guide:
---> https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent

-> Generating a new SSH key: 
---> ssh-keygen -t ed25519 -C "detectivemark7@gmail.com"

-> SSH key location: 
---> C:\Users\detectivemark7\.ssh

-> Note about the keys:
---> ~/.ssh/id_ed25519       // This is the private key (don't share this with anyone).
---> ~/.ssh/id_ed25519.pub   // This is the public key
---> ~/.ssh/puttyKey.ppk     // This is the putty key that tortoiseGit uses (generated from id_ed25519 using Putty Key Generator)

-> Copy SSH public key:
---> clip < ~/.ssh/id_ed25519.pub




GIT underneath:

-> Git uses this constructs:
---> "tree" stands for folder
---> "blob" stands for a file
---> "commit" contains information about a commit
-----> parents: array of commits
-----> author: string
-----> message: string
-----> snapshot: tree
-----> Actually objects are addressed by their hash
-----> The relationship between commits is a DAG (Directed acyclic graph)
---> "object" can be a "tree", "blob" or a "commit"

-> git maintains a map of objects in its DB
---> objects = map<hash string, object>
---> NOTE: Git commits uses SHA1 hash of the object (40 characters)
---> storing an object into this map just sets the hash string of the object to the object 
-----> objects[getHash(object)] = object
---> getting an object just use the hash string of the object
-----> objects.at(getHash(object))

-> git maintains a map of references in its DB
---> objects = map<human readable name, hash string>
-----> HEAD is a human readable name of the current commit or the current snapshot of the current branch
-----> master is a human readable name of latest commit of a the first/default branch
-----> origin is human readable name for the git remote repository (not necessarily on the web but the common repository for other collaborators)

-> objects are immutable (because hash string is derived from the contents of the object)
-> git has a "staging area" which tells what changes should be included in the next snapshot we take

-> commands explanation
-> git init
---> creates the git contents (but still empty)
-> git add
---> adds a change in the staging area
-> git commit
---> creates a object(commit) and adds it in the DB
-> git log
---> by default, git log shows you a flatten version of the version history
-> git cat-file
---> prints details about an object
-> git checkout
---> wacky command that lets you do a bunch of things
---> this moves the HEAD reference and also modifies the current directory

-> In merge, "Fast forward" means it just moved from commit to commit in the DAG (no merge happened)




Other interesting topics:

-> Git is highly configurable
---> use git config
---> edit ".gitconfig" manually

-> git bisect can be used to find when a test started to fail







