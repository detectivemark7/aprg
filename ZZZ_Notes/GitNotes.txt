
Common commands:

-> Help:
---> git help

-> Stage or add a file one by one to be tracked by git (can be changed files or modified files):
---> git add FileName1 FileName2
-----> Note: git add for deleted files as well

-> Stage or add multiple files to be tracked by git (multiple changed files or modified files):
---> git add .   // all files
---> git add *.html  // all html files
---> git add :/   // adds all files under this directory

-> Unstage and remove a file one by one that is tracked by git (remove file from staging area):
---> git rm FileName1 FileName2
---> git rm --cached FileName1 FileName2
-----> Use this when you dont want to delete the file on disk, just in the staging area.
-----> When --cached is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.
-------> From git docs: "--cached" Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.

-> Track changes:
---> git status

-> Check changes:
---> check changes from current commit
-----> git diff
-----> git diff FileName   // for one file
---> check changes from staging area
-----> "git diff --cached" "git diff -- staged"
-------> --staged is a synonym of --cached
---> check the changes from a range of commits
-----> git diff HashStringOfTheOldestCommit..HashStringOfTheNewestCommit
-----> git diff HashStringOfTheOldestCommit..HashStringOfTheNewestCommit FileName (to just check for a specific file)
-----> git diff HashStringOfTheOldestCommit.. // (if end of ".." is blank then it means use HEAD as end)
---> show changes with colors
-----> git diff --color-words

-> Check all commits:
---> git log
-----> by default, git log shows you a flatten version of the version history
---> git log --all --graph --decorate   // shows the changes in a graph
---> git log --all --graph --decorate --oneline   // shows the changes in a graph with less 
---> git log --oneline // shows a list of commits, each line shows hash string id of the commit and the commit message
---> git log --patch // shows the diff of each commit

-> Commit to local repository:
---> git commit -m "Message title test" -m "Message description text"
-----> The option "-m <msg> or --message=<msg>" will se the given <msg> as the commit message. 
-----> If multiple -m options are given, their values are concatenated as separate paragraphs.
-----> NOTE: if there is no message, it will fail the commit
---> git commit -am "Message title test" -m "Message description text"
-----> The option "-a or -all" will commit all MODIFIED files (no need to git add, works for MODIFIED files ONLY)
---> git commit -F ../CommitMessageFile.txt    // This is use a text file for the commit message
-----> The option "-F <file> or --file=<file>" will take the commit message from the given file. Use - to read the message from the standard input.
---> git commit --amend
-----> Amend the current commit with this change. Basically undo the current commit, then redo it with this change.

-> push changes to remote repository:
---> git push   // works without any arguments if upstream is set
---> git push origin master   // origin is reserved word the stands for the git remote repository, master is the branch we have to push
---> git push -u origin master   // "-u" is "--set-upstream" sets the upstream to origin so we don't have to type "origin master" in the future
---> git push origin HEAD:refs/for/BranchName   // This is for using a reference
---> git push origin master HEAD // This just sets the remotes/origin/master to point to HEAD
-----> Note: this is equivalent to "git push" if upstream is set

-> pull changes from remote repository:
---> git pull   // works without any arguments if upstream is set
---> git push origin master   // origin is reserved word the stands for the location of the git remote repository, master is the branch we have to pull
---> git pull --set-upstream origin master   // "--set-upstream" sets the upstream to origin we don't have to type "origin master" in the future
-----> git pull = git fetch + git merge

-> fetch changes from remote repository and track it to GIT but dont change any files in local directory
---> git fetch
-----> only gets the changes from remote repository, but doesn't change local files
-----> check origin using git log
-----> git pull = git fetch + git merge
---> fetch from review:
-----> git fetch "ssh://malba@gerrit.ext.net.nokia.com:29418/MN/WCDMA/CPLANE/tcom" refs/changes/64/1785164/8 && git checkout FETCH_HEAD

-> undoing changes
---> Note: reset has two meanings:
-----> (1) Undo/remove a staged change
-----> (2) Change were the current branch points
---> undo staging (git add was already used, and we need to undo "git add")
-----> git reset   // undo staging for all changes
-----> git reset FileName   // undo staging for one file
-------> NOTE: The changes still exists we just "unstage" it. Do "git status" to check.
---> undo a commit (git commit was already used, and we need to undo "git commit")
-----> git reset HEAD~1  // HEAD points to the last commit, "~1" means the one commit before that. 
-------> NOTE: The changes still exists we just let git point to one commit before HEAD. Do "git status" to check.
---> place HEAD to a specific commit (git commit were used multiple times, and we need to undo several "git commits)
-----> get the unique hash of the commit
-------> git log
-----> use the unique hash of the commit in git reset
-------> git reset HashOfTheCommit
---------> NOTE: The changes still exists we just let git point to a commit. Do "git status" to check.
-----> undo changes and reflect it on the files
-------> git reset --hard
---------> NOTE: The "--hard" option means that the changes are also removed. Do "git status" to check.
---> undo a git merge
-----> git merge --abort

-> ignore files for staging
---> create file ".gitignore"
-----> touch .gitignore
---> then we can add FileToIgnore in ".gitignore" (put it in a new line)
---> then we can add DirectoryToIgnore in ".gitignore" (put it in a new line)
---> then we can add *.html in ".gitignore" (put it in a new line)

-> delete unversioned files:
---> discard changes
-----> git checkout
---> check files to removed
-----> git clean -n
---> remove files (forced)
-----> git clean -f
---> remove directories (forced)
-----> git clean -fd

-> show changes (useful after git blame)
---> git show HashStringOfTheCommit
---> git show HEAD // shows the latest commit on the current branch

-> apply diffs:
---> git apply --check --verbose DiffName.diff
---> git apply --verbose DiffName.diff

-> get diff from a commit:
---> git format-patch -1 <commit hash value>

-> blame
---> git blame FileName 

-> revert
---> git revert HashStringOfTheCommit 
-----> creates a new commit that revert the changes of a previous commit (it commits it directly no need for "git commit")
---> The command "revert" is also good when you have ten commits and a-three ago you messed one little thing up. 
-----> "git revert HEAD~3" will commit the opposite of that commit on top. You have undone it.

-> Check commit IDs / HashStringOfTheCommit
---> git rev-parse HEAD
---> git rev-parse master
---> git rev-parse remotes/origin/master

-> shows changes in a window
---> gitk -all
-----> separate application




Less common commands:

-> Set name and email 
---> git config --global user.email "detectivemark7@gmail.com"
---> git config --global user.name "detectivemark7"

-> Clone:
---> git clone git@github.com:detectivemark7/aprg.git
---> git clone --shallow URL    // --shallow means avoid getting the whole version history and get just the latest snapshot (useful for big repositories)

-> Create a git local repository:
---> git init   
-----> NOTE: This repository is not connected to origin (since this not remotely created(github)). 
-----> When this is pushed and the remote repository is not connected, GIT will say I have no idea where to push this to.

-> Connect your local repository to remote repository (not necessarily in the web but the common repository for other collaborators)
---> git remote add origin git@github.com:detectivemark7/aprgPython.git
---> git remote add origin DirectoryPathOfCommonRepository
-----> Then you can create a branch in the remote using:
-------> git push -u RemoteName LocalBranch:RemoteBranch
-------> git push -u origin master:master   // this creates a master branch in remote does not have one
-----> Then you can set the upstream as master using:
-------> git push -u origin master   // you can use --set-upstream as well
-------> git branch --set-upstream-to=origin master   // you can use git branch as well

-> Check what is the connected remote repository of this local repository:
---> git remote -v

-> Change history/log of the commits
---> git rebase -i HEAD~6..HEAD~1
-----> The command "rebase" takes sequence of commits, undo all of them, and redo them in a different way
-----> "-i" just means interactive 
-------> Interactive mode shows you a list of commands to change. Just check/follow the rules on the description to do what you want.
-------> "fixup" command is interesting because its delete the entry of the commit but the changes are still there
-------> "squash" (like "fixup" but keeps the commit message) is also interesting if you just need the overall change and not the partial commits
---------> When working on opensource project, it might be best to "squash" your commits so that the maintainers dont need to check partial commits.
-----> HEAD~6..HEAD~1 means the last six commits excluding the last one
-------> HEAD~6 means the last six commits (if end of ".." is blank then it means use HEAD as end)
---> git rebase --continue
-----> to apply the changes of the history/log

-> stash
---> git stash
-----> save the changes in git and revert the local files to latest commit
---> git stash pop
-----> revert back the local files with the changes

-> For local branches (for feature branches or hot fix branches):
---> To view branches: 
-----> git branch 
-------> outputs the local branches available currently
-------> * represents that its currently on that branch
-----> git branch -vv    // Very verbose (shows origin branch details as well)
---> create a new branch: 
-----> git branch BranchName // this does not switch the current branch
-----> git checkout -b BranchName // this also switch the current branch
---> delete a branch: 
-----> git branch -d BranchName
---> switch branches: 
-----> git checkout BranchName
-----> git checkout master
-----> git checkout - // switch to previous branch
---> remotely git checkout can also be used to discard changes in the working directory
-----> git checkout FileName ...
---> before merging, check what is the diff of the specified branch with respect to the current branch
-----> git diff BranchName
---> merge diff of the specified branch to the current branch
-----> Note: You can also use "git mergetool"
-----> git merge BranchName
-------> Note: The diff use for this can actually be found using this: git diff master^..BranchName (carat mean the last fork of the line (see Carat vs Tilde section))
-----> git merge --verbose BranchName
-------> useful to merge a feature branch to master (for pushing changes to remote master)
-------> useful to merge a master to a feature branch (for keeping up with remote master)
---------> If there is a conflict, manually change the file (delete "<<<<<<< HEAD" "=======" and ">>>>>>> master" ), 
---------> then use git add for the conflicted files
---------> then use git merge --continue (or use git commit to apply the changes).
-----> git merge --abort
-------> undo the previous git merge
-----> git merge --continue
-------> after fixing the conflicts
---> push a specified branch to a remote repository (creating this specified branch in the remote repository) 
-----> git push -u origin FakeFeatureBranch   // you can use --set-upstream as well
-------> this commits a FakeFeatureBranch to remote repository, then we can merge this branch to the master branch of the remote repository using a remote tool(GitHub, generate a pull request)
---> checkout to a specific version of the current branch:
-----> git checkout b32d6f740504
-------> Puts HEAD reference in a "detached HEAD state". The HEAD is not the latest commit of the branch anymore.
---> checkout to a specific version of a specific branch:
-----> git checkout BranchName b32d6f740504 (this also switch the current branch)

-> prints detail of a git object (see "GIT underneath")
---> git cat-file -p 42fb7a2    // prints details about an object, notice that only first 6 digits of the hash string of an object can be used as argument
---> git cat-file -p 42fb7a21b52dd0f6026a0d9d434129db61acb4bf2    // prints details about an object, notice that all 40 digits of an object can be used as argument

-> Forking
---> Can be done on remote repository (github)
---> Copy a separate repository and make it your own
-----> Useful to capture a separate repository at specific time (useful to copy external sources)
-------> Can send changes or make a contribution on the external sources (generate a pull request)




Carat vs Tilde (specifying revisions):
-> Source: https://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git/2222920#2222920

-> Rules of thumb
---> Use ~ most of the time — to go back a number of generations, usually what you want
---> Use ^ on merge commits — because they have two or more (immediate) parents

-> Mnemonics:
---> Tilde ~ is almost linear in appearance and wants to go backward in a straight line
---> Caret ^ suggests an interesting segment of a tree or a fork in the road

-> Tilde
---> The “Specifying Revisions” section of the git rev-parse documentation defines ~ as
-----> <rev>~<n>, e.g. master~3
-----> A suffix ~<n> to a revision parameter means the commit object that is the nth generation ancestor of the named commit object, following only the first parents. 
-----> For example, <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1 …
---> You can get to parents of any commit, not just HEAD. 
---> You can also move back through generations: for example, master~2 means the grandparent of the tip of the master branch, favoring the first parent on merge commits.

-> Caret
---> Git history is nonlinear: a directed acyclic graph (DAG) or tree. 
-----> For a commit with only one parent, rev~ and rev^ mean the same thing. 
-----> The caret selector becomes useful with merge commits because each one is the child of two or more parents — and strains language borrowed from biology.
---> HEAD^ means the first immediate parent of the tip of the current branch. HEAD^ is short for HEAD^1, and you can also address HEAD^2 and so on as appropriate. The same section of the git rev-parse documentation defines it as
-----> <rev>^, e.g. HEAD^, v1.5.1^0
-----> A suffix ^ to a revision parameter means the first parent of that commit object. 
-----> ^<n> means the nth parent ([e.g.] <rev>^ is equivalent to <rev>^1). 
-----> As a special rule, <rev>^0 means the commit itself and is used when <rev> is the object name of a tag object that refers to a commit object.




SSH key related:

-> SSH key guide:
---> https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent

-> Generating a new SSH key: 
---> ssh-keygen -t ed25519 -C "detectivemark7@gmail.com"

-> SSH key location: 
---> C:\Users\detectivemark7\.ssh

-> Note about the keys:
---> ~/.ssh/id_ed25519       // This is the private key (don't share this with anyone).
---> ~/.ssh/id_ed25519.pub   // This is the public key
---> ~/.ssh/puttyKey.ppk     // This is the putty key that tortoiseGit uses (generated from id_ed25519 using Putty Key Generator)

-> Copy SSH public key:
---> clip < ~/.ssh/id_ed25519.pub




The Three States: 
-> This the main thing to remember about Git if you want the rest of your learning process to go smoothly. 
-> Git has three main states that your files can reside in: modified, staged, and committed:
---> Modified means that you have changed the file but have not committed it to your database yet.
---> Staged means that you have marked a modified file in its current version to go into your next commit snapshot.
---> Committed means that the data is safely stored in your local database.




GIT underneath (data model):

-> Git uses this constructs:
---> "tree" stands for folder
---> "blob" stands for a file
---> "commit" contains information about a commit
-----> parents: array of commits
-----> author: string
-----> message: string
-----> snapshot: tree

-> Example of a directory:
   (root)
    |
    |-> folder1 (this is a tree)
    |     |
    |     |-> file1.txt (this is a blob)
    |
    |-> file2.txt (this is a blob)
 

-> Commits
---> The relationship between commits is a DAG (Directed acyclic graph)

-> Example of a commit graph:
     Commit1 <---- Commit2 <---- CommitFeature <---- MergedCommit
                     ^                                    |
                     |                                    |
                     |<--------- CommitBugFix <------------

-> Objects
---> Objects are used for git to keep track of the changes.
---> An "object" can be a "tree", "blob" or a "commit"
---> Actually objects are addressed by their hash
---> Some pseudocode to demonstrate how objects are defined
      type blob = array <bytes>
      type tree = map <string, tree | blob>
      type commit = struct {
         parents: array <commit>
         author: string
         message: string
         snapshot: tree
      }
      type object =  blob | tree | commit
      objects = map<hash string, object>

-> git maintains a map of objects in its DB
---> This is what actually saved on disk.
---> NOTE: Git commits uses SHA1 hash of the object (40 characters)
---> storing an object into this map just sets the hash string of the object to the object 
-----> objects[getHash(object)] = object
---> getting an object just use the hash string of the object
-----> objects.at(getHash(object))

-> git maintains a map of references (human readable names) in its DB
---> objects = map<human readable name, hash string>
-----> HEAD is a human readable name of the current commit or the current snapshot of the current branch
-----> master is a human readable name of latest commit of a the first/default branch
-----> origin is human readable name for the git remote repository (not necessarily on the web but the common repository for other collaborators)
-----> NOTE: remember a branch is really just a name that points to a commit (intially it points to empty commit)
-----> ME: WHAT DO THEY CALL IT A BRANCH? JUST TELL IT WHAT IT IS. ITS A COMMIT

-> Important insights:
---> All of git commands are just manipulations of objects data or reference data 
---> Objects are immutable (because hash string is derived from the contents of the object)
---> Git has a "staging area" which tells what changes should be included in the next snapshot we take

-> commands explanation
-> git init
---> creates the git contents (but still empty)
-> git add
---> adds a change in the staging area
-> git commit
---> creates a object(commit) and adds it in the DB
-> git log
---> by default, git log shows you a flatten version of the version history
-> git cat-file
---> prints details about an object
-> git checkout
---> wacky command that lets you do a bunch of things
---> this moves the HEAD reference and also modifies the current directory

-> In merge, "Fast forward" means it just moved from commit to commit in the DAG (no merge happened)

-> NOTE: Remember about the message: "You care in 'detached HEAD' state." 
---> It just means there are no names that refers to where we currently at.
---> If you make commits in this state, no name is gonna be pointing on those commits.
---> You can still commits in this state, but they will just be stored in git with no easy names to remember it by.



Other interesting topics:

-> Git is highly configurable
---> use git config
---> edit ".gitconfig" manually

-> git bisect can be used to find when a test started to fail

-> What do you do when you committed sensitive information that needs to be deleted in your git history?
---> https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository
---> user git filter-repo




---> Version Control (2019 missing semester lecture)

-----> Whenever you are working on something that changes over time, it’s useful to be able to track those changes. 
-------> This can be for a number of reasons: it gives you a record of what changed, how to undo it, who changed it, and possibly even why. 
-------> Version control systems (VCS) give you that ability. 
-------> They let you commit changes to a set of files, along with a message describing the change, as well as look at and undo changes you’ve made in the past.
-----> Most VCS support sharing the commit history between multiple users. 
-------> This allows for convenient collaboration: you can see the changes I’ve made, and I can see the changes you’ve made. 
-------> And since the VCS tracks changes, it can often (though not always) figure out how to combine our changes as long as they touch relatively disjoint things.
-----> There a lot of VCSes out there that differ a lot in what they support, how they function, and how you interact with them. 
-------> Here, we’ll focus on git, one of the more commonly used ones, but I recommend you also take a look at Mercurial.
-----> With that all said – to the cliffnotes!

---> Is git dark magic?

---> not quite.. you need to understand the data model. 
---> we’re going to skip over some of the details, but roughly speaking, the core “thing” in git is a commit.
-----> every commit has a unique name, “revision hash” a long hash like 998622294a6c520db718867354bf98348ae3c7e2 often shortened to a short (unique-ish) prefix: 9986222
-----> commit has author + commit message
-----> also has the hash of any ancestor commits usually just the hash of the previous commit
-----> commit also represents a diff, a representation of how you get from the commit’s ancestors to the commit 
-----> (e.g., remove this line in this file, add these lines to this file, rename that file, etc.)
-------> in reality, git stores the full before and after state
-------> probably don’t want to store big files that change!

-----> initially, the repository (roughly: the folder that git manages) has no content, and no commits. let’s set that up:
-------> $ git init hackers
-------> $ cd hackers
-------> $ git status

-----> the output here actually gives us a good starting point. let’s dig in and make sure we understand it all.
-----> first, “On branch master”.
-------> don’t want to use hashes all the time.
-------> branches are names that point to hashes.
-------> master is traditionally the name for the “latest” commit. 
-------> every time a new commit is made, the master name will be made to point to the new commit’s hash.
-------> special name HEAD refers to “current” name
-------> you can also make your own names with git branch (or git tag) we’ll get back to that

-----> let’s skip over “No commits yet” because that’s all there is to it.
-----> then, “nothing to commit”.
-------> every commit contains a diff with all the changes you made. but how is that diff constructed in the first place?
-------> could just always commit all changes you’ve made since the last commit
---------> sometimes you want to only commit some of them (e.g., not TODOs)
---------> sometimes you want to break up a change into multiple commits to give a separate commit message for each one
-------> git lets you stage changes to construct a commit
---------> add changes to a file or files to the staged changes with git add
-----------> add only some changes in a file with git add -p
-----------> without argument git add operates on “all known files”
---------> remove a file and stage its removal with git rm
---------> empty the set of staged changes git reset
-----------> note that this does not change any of your files! it only means that no changes will be included in a commit
-----------> to remove only some staged changes: git reset FILE or git reset -p
---------> check staged changes with git diff --staged
---------> see remaining changes with git diff
---------> when you’re happy with the stage, make a commit with git commit
-----------> if you just want to commit all changes: git commit -a
-----------> git help add has a bunch more helpful info
-----> while you’re playing with the above, try to run git status to see what git thinks you’re doing – it’s surprisingly helpful!

---> A commit you say…

-----> okay, we have a commit, now what?
-------> we can look at recent changes: git log (or git log --oneline)
-------> we can look at the full changes: git log -p
-------> we can show a particular commit: git show master
---------> or with -p for full diff/patch
-------> we can go back to the state at a commit using git checkout NAME
---------> if NAME is a commit hash, git says we’re “detached”. 
---------> this just means there’s no NAME that refers to this commit, so if we make commits, no-one will know about them.
-------> we can revert a change with git revert NAME
---------> applies the diff in the commit at NAME in reverse.
-------> we can compare an older version to this one using git diff NAME..
---------> a..b is a commit range. if either is left out, it means HEAD.
-------> we can show all the commits between using git log NAME..
---------> -p works here too
-------> we can change master to point to a particular commit (effectively undoing everything since) with git reset NAME:
---------> huh, why? wasn’t reset to change staged changes? reset has a “second” form (see git help reset) which sets HEAD to the commit pointed to by the given name.
---------> notice that this didn’t change any files – git diff now effectively shows git diff NAME...

---> What’s in a name?

-----> clearly, names are important in git. and they’re the key to understanding a lot of what goes on in git. 
-----> so far, we’ve talked about commit hashes, master, and HEAD. but there’s more!
-------> you can make your own branches (like master) with git branch b
---------> creates a new name, b, which points to the commit at HEAD
---------> you’re still “on” master though, so if you make a new commit, master will point to that new commit, b will not.
---------> switch to a branch with git checkout b
-----------> any commits you make will now update the b name
-----------> switch back to master with git checkout master
-------------> all your changes in b are hidden away
-----------> a very handy way to be able to easily test out changes
-------> tags are other names that never change, and that have their own message. often used to mark releases + changelogs.
-------> NAME^ means “the commit before NAME
---------> can apply recursively: NAME^^^
---------> you most likely mean ~ when you use ~
-----------> ~ is “temporal”, whereas ^ goes by ancestors
-----------> ~~ is the same as ^^
-----------> with ~ you can also write X~3 for “3 commits older than X
-----------> you don’t want ^3
---------> git diff HEAD^
-------> - means “the previous name”
-------> most commands operate on HEAD unless you give another argument

---> Clean up your mess

-----> your commit history will very often end up as:
-------> add feature x – maybe even with a commit message about x!
-------> forgot to add file
-------> fix bug
-------> typo
-------> typo2
-------> actually fix
-------> actually actually fix
-------> tests pass
-------> fix example code
-------> typo
-------> x
-------> x
-------> x
-------> x

-----> that’s fine as far as git is concerned, but is not very helpful to your future self, or to other people who are curious about what has changed. 
-------> git lets you clean up these things:

-------> git commit --amend: fold staged changes into previous commit
---------> note that this changes the previous commit, giving it a new hash!
-------> git rebase -i HEAD~13 is magical. for each commit from past 13, choose what to do:
---------> default is pick; do nothing
---------> r: change commit message
---------> e: change commit (add or remove files)
---------> s: combine commit with previous and edit commit message
---------> f: “fixup” – combine commit with previous; discard commit msg
---------> at the end, HEAD is made to point to what is now the last commit
---------> often referred to as squashing commits
---------> what it really does: rewind HEAD to rebase start point, then re-apply the commits in order as directed.
-------> git reset --hard NAME: reset the state of all files to that of NAME (or HEAD if no name is given). handy for undoing changes.

---> Playing with others

-----> a common use-case for version control is to allow multiple people to make changes to a set of files without stepping on each other’s toes. 
-------> or rather, to make sure that if they step on each other’s toes, they won’t just silently overwrite each other’s changes.
-----> git is a distributed VCS: everyone has a local copy of the entire repository (well, of everything others have chosen to publish). 
-------> some VCSes are centralized (e.g., subversion): a server has all the commits, clients only have the files they have “checked out”. 
-------> basically, they only have the current files, and need to ask the server if they want anything else.
-----> every copy of a git repository can be listed as a “remote”. 
-------> you can copy an existing git repository using git clone ADDRESS (instead of git init). 
-------> this creates a remote called origin that points to ADDRESS. you can fetch names and the commits they point to from a remote with git fetch REMOTE. 
-------> all names at a remote are available to you as REMOTE/NAME, and you can use them just like local names.
-----> if you have write access to a remote, you can change names at the remote to point to commits you’ve made using git push. 
-------> for example, let’s make the master name (branch) at the remote origin point to the commit that our master branch currently points to:
---------> git push origin master:master
---------> for convenience, you can set origin/master as the default target for when you git push from the current branch with -u
---------> consider: what does this do? git push origin master:HEAD^
-----> often you’ll use GitHub, GitLab, BitBucket, or something else as your remote. there’s nothing “special” about that as far as git is concerned. 
-------> it’s all just names and commits. 
-------> if someone makes a change to master and updates github/master to point to their commit (we’ll get back to that in a second), 
-------> then when you git fetch github, you’ll be able to see their changes with git log github/master.

---> Working with others

-----> so far, branches seem pretty useless: you can create them, do work on them, but then what? eventually, you’ll just make master point to them anyway, right?
-------> what if you had to fix something while working on a big feature?
-------> what if someone else made a change to master in the meantime?

-----> inevitably, you will have to merge changes in one branch with changes in another, whether those changes are made by you or someone else. 
-------> git lets you do this with, unsurprisingly, git merge NAME. merge will:
---------> look for the latest point where HEAD and NAME shared a commit ancestor (i.e., where they diverged)
---------> (try to) apply all those changes to the current HEAD
---------> produce a commit that contains all those changes, and lists both HEAD and NAME as its ancestors
---------> set HEAD to that commit’s hash

-----> once your big feature has been finished, you can merge its branch into master, and git will ensure that you don’t lose any changes from either branch!

-----> if you’ve used git in the past, you may recognize merge by a different name: pull. when you do git pull REMOTE BRANCH, that is:
-------> git fetch REMOTE
-------> git merge REMOTE/BRANCH
-------> where, like push, REMOTE and BRANCH are often omitted and use the “tracking” remote branch (remember -u?)

-----> this usually works great. as long as the changes to the branches being merged are disjoint. 
-------> if they are not, you get a merge conflict. sounds scary…
-------> a merge conflict is just git telling you that it doesn’t know what the final diff should look like
-------> git pauses and asks you to finish staging the “merge commit”
-------> open the conflicted file in your editor and look for lots of angle brackets (<<<<<<<). 
---------> the stuff above ======= is the change made in the HEAD since the shared ancestor commit. the stuff below is the change made in the NAME since the shared commit.
-------> git mergetool is pretty handy – opens a diff editor
-------> once you’ve resolved the conflict by figuring out what the file should now look like, stage those changes with git add.
-------> when all the conflicts are resolved, finish with git commit
---------> you can give up with git merge --abort

-----> you’ve just resolved your first git merge conflict! \o/ now you can publish your finished changes with git push

---> When worlds collide

-----> when you push, git checks that no-one else’s work is lost if you update the remote name you’re pushing too. 
-------> it does this by checking that the current commit of the remote name is an ancestor of the commit you are pushing. 
-------> if it is, git can safely just update the name; this is called fast-forwarding. if it is not, git will refuse to update the remote name, and tell you there have been changes.

-----> if your push is rejected, what do you do?
-----> 
-------> merge remote changes with git pull (i.e., fetch + merge)
-------> force the push with --force: this will lose other people’s changes!
---------> there’s also --force-with-lease, which will only force the change if the remote name hasn’t changed since the last time you fetched from that remote. much safer!
---------> if you’ve rebased local commits that you’ve previously pushed (“history rewriting”; probably don’t do this), you’ll have to force push. think about why!
-------> try to re-apply your changes “on top of” the changes made remotely
---------> this is a rebase!
-----------> rewind all local commits since shared ancestor
-----------> fast-forward HEAD to commit at remote name
-----------> apply local commits in-order
-------------> may have conflicts you have to manually resolve
-------------> git rebase --continue or --abort
-----------> lots more here
---------> git pull --rebase will start this process for you
---------> whether you should merge or rebase is a hot topic! some good reads:
-----------> this
-----------> this
-----------> this

---> Further reading
-----> XKCD on git
-----> Learn git branching
-----> How to explain git in simple words
-----> Git from the bottom up
-----> Git for computer scientists
-----> Oh shit, git!
-----> The Pro Git book



-> Version Control (Git) (2020 missing semester lecture)

---> Version control systems (VCSs) are tools used to track changes to source code (or other collections of files and folders). 
-----> As the name implies, these tools help maintain a history of changes; furthermore, they facilitate collaboration. 
-----> VCSs track changes to a folder and its contents in a series of snapshots, where each snapshot encapsulates the entire state of files/folders within a top-level directory. 
-----> VCSs also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.
---> Why is version control useful? 
-----> Even when you’re working by yourself, it can let you look at old snapshots of a project, 
-----> keep a log of why certain changes were made, work on parallel branches of development, and much more. 
-----> When working with others, it’s an invaluable tool for seeing what other people have changed, as well as resolving conflicts in concurrent development.
---> Modern VCSs also let you easily (and often automatically) answer questions like:
-----> Who wrote this module?
-----> When was this particular line of this particular file edited? By whom? Why was it edited?
-----> Over the last 1000 revisions, when/why did a particular unit test stop working?
---> While other VCSs exist, Git is the de facto standard for version control. 
-----> Because Git’s interface is a leaky abstraction, learning Git top-down (starting with its interface / command-line interface) can lead to a lot of confusion. 
-------> It’s possible to memorize a handful of commands and think of them as magic incantations, and follow the approach in the comic above whenever anything goes wrong.
---> While Git admittedly has an ugly interface, its underlying design and ideas are beautiful. 
-----> While an ugly interface has to be memorized, a beautiful design can be understood. 
-----> For this reason, we give a bottom-up explanation of Git, starting with its data model and later covering the command-line interface. 
-----> Once the data model is understood, the commands can be better understood in terms of how they manipulate the underlying data model.

---> Git’s data model

-----> There are many ad-hoc approaches you could take to version control. 
-------> Git has a well-thought-out model that enables all the nice features of version control, like maintaining history, supporting branches, and enabling collaboration.

-----> Snapshots

-------> Git models the history of a collection of files and folders within some top-level directory as a series of snapshots. 
---------> In Git terminology, a file is called a “blob”, and it’s just a bunch of bytes. 
---------> A directory is called a “tree”, and it maps names to blobs or trees (so directories can contain other directories). 
---------> A snapshot is the top-level tree that is being tracked. For example, we might have a tree as follows:
-----------> <root> (tree)
-----------> |
-----------> +- foo (tree)
-----------> |  |
-----------> |  + bar.txt (blob, contents = "hello world")
-----------> |
-----------> +- baz.txt (blob, contents = "git is wonderful")
-------> The top-level tree contains two elements, a tree “foo” (that itself contains one element, a blob “bar.txt”), and a blob “baz.txt”.

-----> Modeling history: relating snapshots

-------> How should a version control system relate snapshots? 
---------> One simple model would be to have a linear history. 
---------> A history would be a list of snapshots in time-order. 
---------> For many reasons, Git doesn’t use a simple model like this.
-------> In Git, a history is a directed acyclic graph (DAG) of snapshots. 
---------> That may sound like a fancy math word, but don’t be intimidated. 
---------> All this means is that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. 
---------> It’s a set of parents rather than a single parent (as would be the case in a linear history) because a snapshot might descend from multiple parents, 
---------> for example, due to combining (merging) two parallel branches of development.
-------> Git calls these snapshots “commit”s. Visualizing a commit history might look something like this:
---------> o <-- o <-- o <-- o
--------->             ^
--------->              \
--------->               --- o <-- o
-------> In the ASCII art above, the os correspond to individual commits (snapshots). 
---------> The arrows point to the parent of each commit (it’s a “comes before” relation, not “comes after”). 
---------> After the third commit, the history branches into two separate branches. 
---------> This might correspond to, for example, two separate features being developed in parallel, independently from each other. 
---------> In the future, these branches may be merged to create a new snapshot that incorporates both of the features, 
---------> producing a new history that looks like this, with the newly created merge commit shown in bold:
-----------> o <-- o <-- o <-- o <---- o
----------->             ^            /
----------->              \          v
----------->               --- o <-- o
-------> Commits in Git are immutable. 
---------> This doesn’t mean that mistakes can’t be corrected, however; it’s just that “edits” to the commit history are actually creating entirely new commits, 
---------> and references (see below) are updated to point to the new ones.

-----> Data model, as pseudocode

-------> It may be instructive to see Git’s data model written down in pseudocode:
---------> // a file is a bunch of bytes
---------> type blob = array<byte>
---------> 
---------> // a directory contains named files and directories
---------> type tree = map<string, tree | blob>
---------> 
---------> // a commit has parents, metadata, and the top-level tree
---------> type commit = struct {
--------->     parents: array<commit>
--------->     author: string
--------->     message: string
--------->     snapshot: tree
---------> }
-------> It’s a clean, simple model of history.

-----> Objects and content-addressing

-------> An “object” is a blob, tree, or commit:
---------> type object = blob | tree | commit
-------> In Git data store, all objects are content-addressed by their SHA-1 hash.
---------> objects = map<string, object>
---------> 
---------> def store(object):
--------->     id = sha1(object)
--------->     objects[id] = object
---------> 
---------> def load(id):
--------->     return objects[id]
-------> Blobs, trees, and commits are unified in this way: they are all objects. 
---------> When they reference other objects, they don’t actually contain them in their on-disk representation, but have a reference to them by their hash.
-------> For example, the tree for the example directory structure above (visualized using git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d), looks like this:
---------> 100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
---------> 040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
-------> The tree itself contains pointers to its contents, baz.txt (a blob) and foo (a tree). 
---------> If we look at the contents addressed by the hash corresponding to baz.txt with git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85, we get the following:
-----------> git is wonderful

-----> References

-------> Now, all snapshots can be identified by their SHA-1 hashes. 
---------> That’s inconvenient, because humans aren’t good at remembering strings of 40 hexadecimal characters.
-------> Git’s solution to this problem is human-readable names for SHA-1 hashes, called “references”. 
---------> References are pointers to commits. 
---------> Unlike objects, which are immutable, references are mutable (can be updated to point to a new commit). 
---------> For example, the master reference usually points to the latest commit in the main branch of development.
-----------> references = map<string, string>
-----------> 
-----------> def update_reference(name, id):
----------->     references[name] = id
-----------> 
-----------> def read_reference(name):
----------->     return references[name]
-----------> 
-----------> def load_reference(name_or_id):
----------->     if name_or_id in references:
----------->         return load(references[name_or_id])
----------->     else:
----------->         return load(name_or_id)
-------> With this, Git can use human-readable names like “master” to refer to a particular snapshot in the history, instead of a long hexadecimal string.
-------> One detail is that we often want a notion of “where we currently are” in the history, so that when we take a new snapshot, 
---------> we know what it is relative to (how we set the parents field of the commit). 
---------> In Git, that “where we currently are” is a special reference called “HEAD”.

-----> Repositories
-------> Finally, we can define what (roughly) is a Git repository: it is the data objects and references.
-------> On disk, all Git stores are objects and references: that’s all there is to Git’s data model.
---------> All git commands map to some manipulation of the commit DAG by adding objects and adding/updating references.
-------> Whenever you’re typing in any command, think about what manipulation the command is making to the underlying graph data structure. 
---------> Conversely, if you’re trying to make a particular kind of change to the commit DAG, e.g. “discard uncommitted changes and make the ‘master’ ref point to commit 5d83f9e”, 
---------> there’s probably a command to do it (e.g. in this case, git checkout master; git reset --hard 5d83f9e).

-----> Staging area

-------> This is another concept that’s orthogonal to the data model, but it’s a part of the interface to create commits.
-------> One way you might imagine implementing snapshotting as described above is to have a “create snapshot” command that creates a new snapshot based on the current state of the working directory. 
---------> Some version control tools work like this, but not Git. 
---------> We want clean snapshots, and it might not always be ideal to make a snapshot from the current state.
---------> For example, imagine a scenario where you’ve implemented two separate features, and you want to create two separate commits,
---------> where the first introduces the first feature, and the next introduces the second feature. 
---------> Or imagine a scenario where you have debugging print statements added all over your code, along with a bugfix; you want to commit the bugfix while discarding all the print statements.
-------> Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.

-----> Git command-line interface

-------> To avoid duplicating information, we’re not going to explain the commands below in detail. 
-------> See the highly recommended Pro Git for more information, or watch the lecture video.

---------> Basics
-----------> git help <command>: get help for a git command
-----------> git init: creates a new git repo, with data stored in the .git directory
-----------> git status: tells you what’s going on
-----------> git add <filename>: adds files to staging area
-----------> git commit: creates a new commit
-------------> Write good commit messages!
-------------> Even more reasons to write good commit messages!
-----------> git log: shows a flattened log of history
-----------> git log --all --graph --decorate: visualizes history as a DAG
-----------> git diff <filename>: show changes you made relative to the staging area
-----------> git diff <revision> <filename>: shows differences in a file between snapshots
-----------> git checkout <revision>: updates HEAD and current branch

---------> Branching and merging
-----------> git branch: shows branches
-----------> git branch <name>: creates a branch
-----------> git checkout -b <name>: creates a branch and switches to it
-------------> same as git branch <name>; git checkout <name>
-----------> git merge <revision>: merges into current branch
-----------> git mergetool: use a fancy tool to help resolve merge conflicts
-----------> git rebase: rebase set of patches onto a new base

---------> Remotes
-----------> git remote: list remotes
-----------> git remote add <name> <url>: add a remote
-----------> git push <remote> <local branch>:<remote branch>: send objects to remote, and update remote reference
-----------> git branch --set-upstream-to=<remote>/<remote branch>: set up correspondence between local and remote branch
-----------> git fetch: retrieve objects/references from a remote
-----------> git pull: same as git fetch; git merge
-----------> git clone: download repository from remote

---------> Undo
-----------> git commit --amend: edit a commit’s contents/message
-----------> git reset HEAD <file>: unstage a file
-----------> git checkout -- <file>: discard changes

---------> Advanced Git
-----------> git config: Git is highly customizable
-----------> git clone --depth=1: shallow clone, without entire version history
-----------> git add -p: interactive staging
-----------> git rebase -i: interactive rebasing
-----------> git blame: show who last edited which line
-----------> git stash: temporarily remove modifications to working directory
-----------> git bisect: binary search history (e.g. for regressions)
-----------> .gitignore: specify intentionally untracked files to ignore

---> Miscellaneous

-----> GUIs: there are many GUI clients out there for Git. 
-------> We personally don’t use them and use the command-line interface instead.
-----> Shell integration: it’s super handy to have a Git status as part of your shell prompt (zsh, bash). 
-------> Often included in frameworks like Oh My Zsh.
-----> Editor integration: similarly to the above, handy integrations with many features. 
-------> fugitive.vim is the standard one for Vim.
-----> Workflows: we taught you the data model, plus some basic commands; we didn’t tell you what practices to follow when working on big projects (and there are many different approaches).
-----> GitHub: Git is not GitHub. 
-----> GitHub has a specific way of contributing code to other projects, called pull requests.
-----> Other Git providers: GitHub is not special: there are many Git repository hosts, like GitLab and BitBucket.

---> Resources

-----> Pro Git is highly recommended reading. 
-----> Going through Chapters 1–5 should teach you most of what you need to use Git proficiently, now that you understand the data model. 
-----> The later chapters have some interesting, advanced material.
-----> Oh Shit, Git!?! is a short guide on how to recover from some common Git mistakes.
-----> Git for Computer Scientists is a short explanation of Git’s data model, with less pseudocode and more fancy diagrams than these lecture notes.
-----> Git from the Bottom Up is a detailed explanation of Git’s implementation details beyond just the data model, for the curious.
-----> How to explain git in simple words
-----> Learn Git Branching is a browser-based game that teaches you Git.

---> Exercises

-----> (1) If you don’t have any past experience with Git, either try reading the first couple chapters of Pro Git or go through a tutorial like Learn Git Branching.
-------> As you’re working through it, relate Git commands to the data model.
-----> (2) Clone the repository for the class website.
-------> Explore the version history by visualizing it as a graph.
-------> Who was the last person to modify README.md? (Hint: use git log with an argument).
-------> What was the commit message associated with the last modification to the collections: line of _config.yml? (Hint: use git blame and git show).
-----> (3) One common mistake when learning Git is to commit large files that should not be managed by Git or adding sensitive information. 
-------> Try adding a file to a repository, making some commits and then deleting that file from history (you may want to look at this).
-----> (4) Clone some repository from GitHub, and modify one of its existing files. 
-------> What happens when you do git stash? What do you see when running git log --all --oneline? 
-------> Run git stash pop to undo what you did with git stash. In what scenario might this be useful?
-----> (5) Like many command line tools, Git provides a configuration file (or dotfile) called ~/.gitconfig. 
-------> Create an alias in ~/.gitconfig so that when you run git graph, you get the output of git log --all --graph --decorate --oneline. 
-------> Information about git aliases can be found here.
-----> (6) You can define global ignore patterns in ~/.gitignore_global after running git config --global core.excludesfile ~/.gitignore_global. 
-------> Do this, and set up your global gitignore file to ignore OS-specific or editor-specific temporary files, like .DS_Store.
-----> (7) Fork the repository for the class website, find a typo or some other improvement you can make, and submit a pull request on GitHub (you may want to look at this).

-----> (1) On a repo try modifying an existing file. 
-------> What happens when you do git stash? What do you see when running git log --all --oneline? 
-------> Run git stash pop to undo what you did with git stash. In what scenario might this be useful?
-----> (2) One common mistake when learning git is to commit large files that should not be managed by git or adding sensitive information. 
---------> Try adding a file to a repository, making some commits and then deleting that file from history (you may want to look at this). 
---------> Also if you do want git to manage large files for you, look into Git-LFS
-----> (3) Git is really convenient for undoing changes but one has to be familiar even with the most unlikely changes
-------> [1] If a file is mistakenly modified in some commit it can be reverted with git revert. 
---------> However if a commit involves several changes revert might not be the best option. 
---------> How can we use git checkout to recover a file version from a specific commit?
-------> [2] Create a branch, make a commit in said branch and then delete it. Can you still recover said commit? 
---------> Try looking into git reflog. (Note: Recover dangling things quickly, git will periodically automatically clean up commits that nothing points to.)
-------> [3] If one is too trigger happy with git reset --hard instead of git reset changes can be easily lost. 
---------> However since the changes were staged, we can recover them. (look into git fsck --lost-found and .git/lost-found)
-----> (4) In any git repo look under the folder .git/hooks you will find a bunch of scripts that end with .sample. 
-------> If you rename them without the .sample they will run based on their name.  
-------> For instance pre-commit will execute before doing a commit. Experiment with them
-----> (5) Like many command line tools git provides a configuration file (or dotfile) called ~/.gitconfig . 
-------> Create and alias using ~/.gitconfig so that when you run git graph you get the output of git log --oneline --decorate --all --graph (this is a good command to quickly visualize the commit graph)
-----> (6) Git also lets you define global ignore patterns under ~/.gitignore_global, this is useful to prevent common errors like adding RSA keys. 
-------> Create a ~/.gitignore_global file and add the pattern *rsa, then test that it works in a repo.
-----> (7) Once you start to get more familiar with git, you will find yourself running into common tasks, 
-------> such as editing your .gitignore. git extras provides a bunch of little utilities that integrate with git. 
-------> For example git ignore PATTERN will add the specified pattern to the .gitignore file in your repo 
-------> and git ignore-io LANGUAGE will fetch the common ignore patterns for that language from gitignore.io. 
-------> Install git extras and try using some tools like git alias or git ignore.
-----> (8) Git GUI programs can be a great resource sometimes. 
-------> Try running gitk in a git repo an explore the different parts of the interface. 
-------> Then run gitk --all what are the differences?
-----> (9) Once you get used to command line applications GUI tools can feel cumbersome/bloated. 
-------> A nice compromise between the two are ncurses based tools which can be navigated from the command line and still provide an interactive interface. 
-------> Git has tig, try installing it and running it in a repo. You can find some usage examples here.


