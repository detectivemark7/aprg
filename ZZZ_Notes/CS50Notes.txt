Virtual Machines

-> What are VMs?
---> Simulated computers
---> Lets you run an entire OS and bunch of software thats isolates your host environment
---> Its configurable. So you can set your how much resources can be used in the VM.

-> Usage of VMs
---> You can use it to experiment with the OS and new software without any risks.
---> You can use it for applications that run in a specific operating system.
---> You can use it for buggy and malicious software without any risks.
-----> VMs can give pretty good isolation to the host environment

-> One example of a VM is the "Virtual Box"

-> Snapshots
---> One cool thing you can do with VMs is the "snapshot".
---> "Snapshot" are captured data of the entire machine state (everything from the disk, the memory and what is in CPU registers)
---> Since the entire VM is simulated you can freeze it and collect data of its state.
---> Useful if you want to do something that is really dangerous and you dont want to break anything.
-----> For example: Manually delete you boot disk. You can undo by loading again a previous snapshot.

-> Guest addons
---> Makes it easier to communicate with the host machine.
-----> Examples:
-------> Clipboard usage
-------> Drag files in and out of the VMs with the host machine

-> How are they implemented?
---> It simulation of the various HW (memory/disk).
---> It has big interpreter that simulates CPU instructions.
---> Modern hardware have actual support for this kind of stuffs.
-----> VMs can be pretty efficient.
-------> There are exceptions like in games using the video card.



Containers

-> This is the solution if you have to isolate environments, and they look the same, and you want to share as much as possible (operating system is shared).
---> Instead of using multiple VMs, use multiple containers to reduce redundant work (boot time, operating system resources)
-----> In multiple VMs, we have different instances of the OS and simulated HW.
-----> This has faster/better performance, but has weaker isolation to each containers.

-> Heavily used by:
---> Github
-----> Sending GIT commands to the website typically uses a container.
---> Amazon
-----> Saves time because less setup time (no more OS boot time), instead of having minutes to load, you have seconds to load.
---> Automated testing

-> Containers can only be executed in a machine that has a similar configuration.
---> If you want to run a windows container on a linux machine, you need to run these containers in a VM.

-> Examples:
---> Docker
---> RKT/Rocket
---> LXC/Linux container stack
---> Amazon fire crackers
---> Used on hosting website (having a base container with its dependencies setup hastens the deployment of a website)

-> Underneath
---> Its just like running the application but there are jail/fences to make it think that its running alone.  
-----> APIs called to the operating system are hacked so that we can make the application isolated to the rest of the system.



Shell and scripting

-> Shell is really efficient textual interface to your computer.
---> You can do almost anything in the shell.

-> Common commands
---> mkdir
---> cd
---> ls
---> mv
---> cp
---> touch - create an empty file
---> which - lets you know the location of application
---> chmod - change permissions. chmod +x hello.sh

-> CTRL+L - lets you clear your screen

-> Shell provides you more than commands
---> You can invoke any program in your computer
---> Command line tools exist for pretty much anything you may want.
---> More efficient than their GUI counterparts.

-> Shell provides an interactive programming language (often referred to as scripting)
---> A lot of different shells that have different languages.
-----> Examples: sh, bash (born again shell), csh (c shell, looks like c language), fish, zsh, ksh

-> Shell programming is useful tool
---> You can write commands in the command line.
---> You can also stick this commands into a file.
-----> Create a .sh file
-----> At the top of the file, add this: "#!/bin/sh" or "#!/bin/bash"
-------> This is known as a hash bang line.
-------> This feeds the entire contents of the file to the program mentioned in the hash bang line.
-------> Also works in python: "#!/usr/bin/python"

-> Loops
---> for i in $(seq 1 5); do echo hello; done
-----> This reads: For i in list (1 to 5); 
-----> Note: New lines are semicolon and semicolons are new lines (they are interchangable)
-----> Note: Bash has no curly brackets, it usually instead have unique keyword for starting and ending a block ("do" and "done" in this case)
-----> Note: The list is actually just space separated.
-------> All the command "seq 1 5" does is to just print 1 to 5
-------> So this for command is just gonna assign i for every space separated value on the list.

-> Program substitution
---> Note: This part "$( )" is also known as program substitution.
-----> Basically what it does is just run whatever command is inside the parenthesis, and the output of the command is replaced where "$( )" is.
-----> So this means that this loop "for i in $(seq 1 5);" is the same as "for i in 1 2 3 4 5;"
-------> So what bash does is:
---------> Put 1 2 3 4 5 (with white space) in the loop command
---------> Assign i for each of the value
---------> Run the body of the loop (after do keyword)

-> Path variable
---> In the previous example, echo is just a program
-----> In fact run: "which echo" -> and it will print the location of echo command ("/usr/bin/echo")
---> All the commands that dont need the absolute directory (like echo), are found using the variable called $PATH 
---> $PATH is colon separated list of directories where your shell looks for programs.

-> Another loop example
---> for f in $(ls); do echo $f; done
-----> This prints all files/directories listed in the directory.

-> Variable
---> For loop assignment works: "for f in $(ls)"
---> Setting a value also works: foo=bar
-----> echo $foo -> this prints -> bar
-----> Note that bash is really picky about the syntax so this will not work: "foo = bar"
-------> This means run the program "foo", with the first argument "=", and the second argument "bar"

-> Special variables:
---> $0 is the name of the current program
---> $1 to $9 are the arguments given to the program
---> $# is the number of arguments
---> $$ is the Process ID of the current shell 
---> $? is the current exit code
---> $! is the Process ID of the last run process

-> Loop example with if statement
---> for f in $(ls); do if test -d $f; then echo dir $f; fi; done
-----> This prints only the directories listed in the directory.
-----> This follows the form: if CONDITION; then BODY; fi
-----> Every program you run in the command line will exit with an exit code
-------> $? has the current exit code
-------> In general, every non zero exit code is a failure and zero means success.
-----> The if statement just runs the command in the CONDITION, and if the exit code is zero it will run the BODY.
-----> The "test" command has applications (strings, integers, file) and in general it just test the condition and exit with an exit code depending on its usage.
-------> Check the manual for "test" for more information
---> "elif" and "else" are also some keywords you can use

-> Open and close square brackets ([])
---> Open square bracket program is just the same with the test command (check manual of test)
---> Close square bracket is just an argument to opern square bracket program on your machine.
---> Open square bracket program requires that the last argument of the program is a close square bracket
---> You can do this(equivalent to the previous example): for f in $(ls); do if [ -d $f ]; then echo dir $f; fi; done
---> Open square bracket is just a program on your machine.
-----> In fact run: "which [" -> and it will print the location of echo command ("/usr/bin/[")

-> Problem with white spaces
---> This loop is problematic: "for f in $(ls)", because if something is named with a whitespace it will in different entries.
-----> Having a folder with a name "My Documents" will have two separate entries: "My" and "Documents"
---> This is really big source of bugs in bash.
---> You can fix this problem by wrapping it in quotations and using globbing
-----> Original: for f in $(ls); do if [ -d $f ]; then echo dir $f; fi; done
-----> Fixed: for f in *; do if [ -d "$f" ]; then echo dir $f; fi; done
-------> Notice you need to wrap it in quotations on the parameter given in the "[" program ("[" only expects one filename)
-------> Notice globbing is used in the loop assingment

-> Problem with new lines 
---> Newlines are generally stored as carriage return, which forces the cursor at the back of the line.

-> Globbing
---> "*" lets you match any string of characters that are files/directories in the current directory
-----> "ls *" will list all files/directories 
-----> "echo b/c/*.txt" will display all txt files in "b/c" path
---> "?" lets you match any single character
-----> "ls ???" will list any files/directories with 3 characters
---> "{}" lets you match two conditions
-----> "ls {b,r}*" will list any files/directories that starts with a "b" or "r"
-----> this expands to "ls b* r*"
-------> note that "mv aaa(.txt)" -> expands to "mv aaa aaa.txt" -> which renames aaa to aaa.txt
-----> "touch {a,b}{a,b}.txt" lets create 4 empty files
-------> aa.txt, ab.txt, ba.txt, bb.txt
---> "**" lets you match any path
-----> "echo **/*.txt" will display all txt files in all paths in the current directory

-> Globbing examples with loop statement
---> for f in a*; do if [ -d "$f" ]; then echo dir $f; fi; done
-----> This loops for any files/directories that starts with "a"
---> for f in foo/*.txt; do if [ -d "$f" ]; then echo dir $f; fi; done
-----> This loops for any ".txt" file that starts with inside the directory "foo"
---> for f in foo/*.txt; do if [ -d "$f" ]; then echo dir $f; fi; done
-----> This loops for any ".txt" file that starts with inside the directory "foo"

-> Problem with white spaces
---> When no argument is given $1 to $9 expands to nothing (not a null string)
-----> This causes a lot of bash script errors.
-----> Example: if [ $1 = "bar" ]
-------> If there is no argument, this expands to: if [  = "bar" ]
---------> This flags an error if run.
-------> Common hack is: if [ x$1 = "xbar" ]
-------> Or use this bash fix ("[[", "]]") : if [[ $1 = "xbar" ]]
---------> Cannot be used in "sh"

-> Composability
---> The shell is powerful because it lets compose multiple programs.
---> You can chain multiple programs together.
---> The character for doing this is pipe "|"
-----> For example: "a | b" this means:
-------> Run "a"
-------> Run "b"
-------> Send all the output of "a" as input to "b"
-------> Print the output of "b"
---> All processes you launch has basically 3 streams
-----> input stream or stdin
-----> output stream or stdout
-----> error stream or stderr
-----> For example: "a | b" also means:
-------> Change stdout of "a" to be equal to stdin of "b" 
-------> So its not depedent on your input anymore, but rather the output of preceeding program

-> cat command
---> This command just prints its input.
---> This command just reads from stdin and writes to stdout

-> ">" means to write the output stream into a file
---> cat > file.txt
-----> This writes to file with the output of cat. 

-> "<" means to read a file and put to stdin
---> cat < file.txt
-----> This reads from file as the input of cat. 

-> Example: cat < in.txt > out.txt
---> This reads from in.txt and writes to out.txt
---> This is basically copy.

-> "2>"
---> Redirects stderr

-> "&>" 
---> Redirects everything

-> grep examples:
---> ls | grep o
-----> This display every file/directory with an "o" in it.
---> ls | grep [REGEX EXPRESSION]
-----> This display every file/directory that satisfies the regex expression
---> journalctrl -b | grep -i kernel | tail -n5
-----> This displays the last file lines of boot log with the word "kernel" on it.

-> sendmail examples:
---> who | sendmail -t me@example.com
-----> This sends an email containing the current users of the machine.

-> (;) lets you combine outputs
---> (who; ps aux) | grep jon | head -n 5
-----> This shows the current users of the machine and the process report containing the word "jon" and just shows the first 5 lines.

-> Process substitution
---> Lets you want to find the difference between the boot logs.
-----> You can do this:
-------> journalctl -b -1 > LastBoot.txt
-------> journalctl -b -2 > SecondToTheLastBoot.txt
-------> diff -u LastBoot.txt SecondToTheLastBoot.txt
-----> Better way is:
-------> diff -u <(journalctl -b -1) <(journalctl -b -2)
---------> diff needs 2 file names
---------> bash starts both journalctl commands and creates sort of temporary files for the result of each
---------> The output of both "<(journalctl -b -1)" and "<(journalctl -b -2)" are the file names of the temporary files
-----------> In fact this command prints the filenames: echo <(journalctl -b -1) <(journalctl -b -2)

-> Running things on the background
---> The ampersand "&" suffix tells bash to run it in the background
-----> For example: "./server &"
-------> Runs the server in the background
-----> The output of this contains the job number and the process id.
-------> For example: "[1] 19436"
---------> It has a job number of 1 and process id of 19436
---> The command "jobs" list all the jobs started with &
---> The command "fg" can run it in the foreground.
-----> For example: "fg"
-------> Puts the most recent process to the foreground
-----> For example: "fg %1"
-------> Puts the process with job number 1 to the foreground
---> The command "bg" can run it in the background.
-----> For example: "bg %1"
-------> Puts the process with job number 1 to the background
---> CTRL+Z stops the current process and put in the background
-----> You need to run bg to start it again.
---> Note: If you close the shell, you are also closing all the background jobs.
---> The command "disown" will let the background processes continue on even if shell is closed
-----> For example: "disown %1"
-------> The process with job number 1 will continue to run even if shell is closed.

-> Tail follow example:
---> Create file count.sh that has this line (this will count to 1000 per second):
-----> "for i in $(seq 1 1000); do echo hello; sleep 1; done"
---> Run count.sh in the background and put its output to a file
-----> "./count.sh > count.log &"
---> Use tail to display the latest values
-----> "tail -f count.log"
-----> -f means follow and this continuously prints the lines in the file

-> Processes commands
---> ps 
-----> lists the running process from the current user of the machine
---> ps -A
-----> lists the running process from all users on the machine
---> pgrep -af server
-----> list all the running process with word "server" on it 
---> pstree
-----> lists the running process in a tree
---> kill
-----> sends a signal to a process
---> pkill 
-----> sends a signal to process the matches the pgrep
-----> These are similar: 
-------> pkill server
-------> kill &(pgrep server)
---> kill -l
-----> lists all the signals that kill can send
-------> default is SIGKILL(9), which tells the process to exit right now
---> kill -s TERM 20156
-----> tells process with pid 20156 to exit politely
-----> SIGTERM tells the process to exit, equivalent to CTRL+C
-----> SIGKILL tells the kernel to forcefully exit the process, equivalent to CTRL+\

-> Common meanings of flags
---> Note: You can combine flags:
-----> "-v -v" is equivalent to "-vv"
---> "-h" or "--help" shows help contents of the command (short version of the man page)
---> "-v" or "--verbose" shows verbose output
---> "-vv" shows more verbose output (pass multiple -v for more verbose output)
---> "-V" or "--version" shows the version
---> "-a" or "--all" means all
---> "-f" or "--forced" means forced
---> "--" means after this you should not interpret arguments as a flag
-----> If you want to create "-a" file, instead of "touch -a", do "touch -- -a"



Command line environment

-> Aliases
---> Create an alias for a command.
---> You can do this:
-----> alias l2="ls -l"
-----> l2
---> You can shorten git status:
-----> alias gs="git status"
-----> gs
---> You can know what is being aliased using "which" command:
-----> which l2
---> Aliases can be compounded:
-----> alias l3="l2 -a"
---> Aliases can be overwritten, for example its completely legal to do this:
-----> alias ls=l3
-------> ls expands to l3, l3 expands to "l2 -a", l2 expands to the command "ls -l"
---> You can call the non-aliased command using back slash:
-----> \ls
---> You can call the non-aliased function using "command":
-----> command ls
---> You can remove the alias by using "unalias"
-----> unalias ls
---> Note: Aliases needs to be done everytime a new command line session is started
-----> You can add it to .bashrc or .bash_profile.
-----> It might be a good idea to use source:
-------> source ~/.aliases



