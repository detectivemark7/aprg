
-> To format your code on Visual studio nn Windows: Shift + Alt + F.

-> Two major versions of python (python 2 and python 3)
---> Similar anyway if you learn python 3, you can easily learn python 2 as well



-> Printing

---> Basics:
-----> print("Hello World") 

---> Drawing a shape
-----> print("   /|")
-----> print("  / |") 
-----> print(" /  |")
-----> print("/___|")



-> Variables

---> Assigning variables:
-----> character_name = "John"
-----> character_age = "35"

---> Printing variables:
-----> print("There once was a man named " + character_name + ", ")
-----> print("he was " + character_age + " years old. ")



-> Working with strings

---> Printing
-----> print("Giraffe\nAcademy")  # line breaks can inserted on strings
-----> print("Giraffe\"Academy")  # escape character needed for special characters

---> String manipulation
-----> phrase = "Giraffe Academy"

---> Concatenation
-----> print(phrase + "is cool")  # concatenation

---> Case modifiers
-----> print(phrase.lower())  # converts to lower case
-----> print(phrase.upper())  # converts to upper case

---> Case checkers
-----> print(phrase.isupper())  # returns true if all uppercase
-----> print(phrase.upper().isupper())  # returns true

---> Length
-----> print(len(phrase))  # prints the length

---> Element access
-----> print(phrase[0])  # prints 'G' (element access)

---> Index search
-----> print(phrase.index("a"))  # prints 3 (gets the index)
-----> print(phrase.index("Acad"))  # prints 8 (gets the index)
-----> # print(phrase.index("z")) # returns an error ('z' does not exist on the string)

---> Find and replace
-----> print(phrase.replace("Giraffe", "Elephant"))  # replace string with another string
-----> print(phrase.replace("Ant", "Insect"))  # it does not replace when its not found (no error)



-> Working with numbers

---> Integer
-----> print(2)  # prints 2

---> Floating value
-----> print(2.0987)  # prints 2.0987
-----> print(-2.0987)  # prints -2.0987

---> Math operations
-----> print(3*4.5)  # prints 13.5
-----> print(3*4+5)  # prints 17
-----> print(10 % 3)  # prints 1
-----> print(10 ** 3)  # prints 1000 (exponent function)

---> Number variables
-----> my_num = 5
-----> print(my_num)  # prints 5
-----> print(str(my_num))  # prints 5 (converts to string and then print)
-----> # print(my_num + " is my favorite number") # error cause python does not automatically convert this
-----> print(str(my_num) + " is my favorite number")  # prints 5 is my favorite number
-----> my_num = -5

---> Other operations
-----> print(my_num)  # prints -5
-----> print(abs(my_num))  # prints 5
-----> print(pow(my_num, 2))  # prints 25
-----> print(min(4, 6))  # prints 4
-----> print(max(4, 6))  # prints 6
-----> print(round(3.2))  # prints 3
-----> print(round(3.7))  # prints 4



-> Working with numbers (with import)
---> Other operations with import
-----> from math import *
-----> print(floor(3.7))
-----> print(ceil(3.7))
-----> print(sqrt(36))



-> Getting Input From Users

---> Example with strings:
-----> name = input("Enter your name: ")  # gets input from user
-----> age = input("Enter your age: ")
-----> print("Hello " + name + "! You are " + age + ".")
---> NOTE: By default, python gets input as a string. 

---> Example with adding integers from user input:
-----> num1 = input("Enter a number: ")
-----> num2 = input("Enter another number: ")
-----> result = int(num1) + int(num2)
-----> print(result)

---> Example with adding floating numbers from user input:
-----> num1 = input("Enter a number: ")
-----> num2 = input("Enter another number: ")
-----> result = float(num1) + float(num2)
-----> print(result)



-> Lists

---> Python recognizes [] as the wrapper for list
---> Lists are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Lists are Mutable (you can still change it after its created)
---> Lists allows duplicate elements 

---> Construction:
-----> friends = list()  # creates an empty list
-----> friends = list(("Kevin", "Karen", "Jim"))  # using the list function and passing a iterable (in this case a tuple) on it
-----> lonely_person = ["Pam"] * 5  # creates a list with five "Pam"s
-----> friends = ["Kevin", "Karen", "Jim"]  # creates a list with items

---> Element access:
-----> friends = ["Kevin", "Karen", "Jim"]
-----> print(friends)  # prints ['Kevin', 'Karen', 'Jim']
-----> print(friends[0])  # prints Kevin
-----> print(friends[2])  # prints Jim
-----> print(friends[-1])  # prints Jim (last item, you can access from the end using negative numbers)
-----> print(friends[-2])  # prints Karen
-----> print(friends[-3])  # prints Kevin
-----> # print(friends[100])  # IndexError: list index out of range

---> Iteration
-----> friends = ["Kevin", "Karen", "Jim"]
-----> for friend in friends:
----->     print(friend)

---> if statement to check if item exist in the list
-----> friends = ["Kevin", "Karen", "Jim"]
-----> if "Jim" in friends:
----->     print("yes")
-----> else:
----->     print("no")

---> Length
-----> friends = ["Kevin", "Karen", "Jim"]
-----> print(len(friends))  # prints the length

---> Slicing:
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> print(friends[1:])  # prints ['Karen', 'Jim', 'Oscar', 'Toby'] (you can slice using a starting point)
-----> print(friends[1:3])  # prints ['Karen', 'Jim'] (you can slice using a range, half open at the end)
-----> print(friends[:3])  # prints ['Kevin', 'Karen', 'Jim'] (you can slice using an ending point, half open at the end)
-----> print(friends[0::2])  # prints ['Kevin', 'Jim', 'Toby'] (starts at index 0, then take every second item in the list (step index 2))
-----> print(friends[::-1])  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin'] (take the reverse of the list (step index -1))

---> List elements can be modified:
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends[1] = "Mike"
-----> print(friends)  # prints ['Kevin', 'Mike', 'Jim', 'Oscar', 'Toby']

---> Append as last element
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends.append("Creed")
-----> print(friends)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Extend (concatenation)
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> lucky_numbers = [4, 8, 15, 16, 23, 42]
-----> same_friends = friends + lucky_numbers  # concatenation
-----> friends.extend(lucky_numbers)  # concatenation
-----> print(friends)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed', 4, 8, 15, 16, 23, 42]

---> Insert
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends.insert(1, "Kelly")
-----> print(friends)  # prints ['Kevin', 'Kelly', 'Karen', 'Jim', 'Oscar', 'Toby']

---> Specified item removal (remove function)
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends.remove("Jim")
-----> print(friends)  # prints ['Kevin', 'Karen', 'Oscar', 'Toby']

---> Last item removal (pop function)
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends.pop()
-----> print(friends)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar']

---> Index search
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> print(friends.index("Creed"))  # prints 2
-----> # print(friends.index("Mike")) # ValueError: Mike is not in list

---> Count items
-----> friends = ["Kevin", "Oscar", "Karen", "Jim", "Oscar", "Toby"]
-----> print(friends.count("Oscar"))  # prints 2

---> Reverse
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> friends.reverse()
-----> print(friends)  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin']

---> Sort
-----> # friends.sort() # error because we have integers and string in the list
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> new_friends = sorted(friends) # creates a new list with sorted elements (if you dont want to sort inplace)
-----> friends.sort()
-----> print(friends)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']
-----> print(new_friends)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']

---> Clear
-----> friends.clear()
-----> print(friends)  # prints []

---> Copying
-----> # assigning is not copying (similar to java, both points to the same memory)
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby", "Creed"]
-----> friends2 = friends
-----> friends2[0] = "Mark"
-----> print(friends)
-----> print(friends2)
-----> # to copy using copy function
-----> friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby", "Creed"]
-----> friends2 = friends.copy()  # returns a copy (using the copy function)
-----> friends2 = list(friends)  # this creates a copy (using the list function)
-----> friends2 = friends[:]  # this also makes a copy (using slicing)
-----> friends2[0] = "Mark"
-----> print(friends)
-----> print(friends2)

---> List comprehension (cool feature)
-----> numbers = [1,2,3,4,5,6]
-----> squared_numbers = [n*n for n in numbers]
-----> print(numbers)  # prints [1, 2, 3, 4, 5, 6]
-----> print(squared_numbers)  # prints [1, 4, 9, 16, 25, 36]


-> Tuples

---> Python recognizes comma separated elements as a tuple (not inside a known construct (a list for example))
---> They can be grouped by parentheses but its optional
---> Tuples are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Tuples are Immutable (once its created you cannot change it)
---> Tuples allows duplicate elements 
---> Tuples are generally used for data that it isnt gonna change in the duration of the program
-----> Because Tuples are immutable python can make internal optimizations compared to a list (especially when working with large data)

---> Construction:
-----> my_tuple = ("Max", 28, Boston) 
-----> my_tuple = "Max", 28, Boston  # the parentheses are optional
-----> print(my_tuple)

---> Construction of one element:
-----> my_str = "Max"
-----> print(type(my_str))  # this is a string
-----> my_str = ("Max") 
-----> print(type(my_str))  # this is a string (the parentheses are optional)
-----> my_str = "Max",
-----> print(type(my_str))  # this is a tuple
-----> my_str = ("Max",) 
-----> print(type(my_str))  # this is a tuple (the parentheses are optional)

---> Construction using the tuple function:
-----> my_tuple = tuple(["Max", 28, Boston])  # using the tuple function and passing a iterable (in this case a list) on it

---> Element access
-----> my_tuple = "Max", 28, Boston
-----> print(my_tuple[1])  # prints 28
-----> print(my_tuple[-1])  # prints Boston
-----> print(my_tuple[-2])  # prints 28
-----> # print(my_tuple[3])  # IndexError: tuple index out of range
 
---> Tuples are immutable:
-----> coordinate = (4, 5)
-----> print(coordinate[1])  # prints 5
-----> # coordinate[1] = 10 # TypeError: 'tuple' object does not support item assignment

---> A list of tuples can be changed:
-----> coordinates = [(4, 5), (6, 7), (80, 34)]
-----> print(coordinates)  # prints [(4, 5), (6, 7), (80, 34)]
-----> coordinates[0] = (9, 9)
-----> print(coordinates)  # prints [(9, 9), (6, 7), (80, 34)] (a list of tuples can be changed)

---> Iteration
-----> my_tuple = "Max", 28, Boston
-----> for item in my_tuple:
----->     print(item)

---> if statement to check if item exist in the list
-----> my_tuple = "Max", 28, Boston
-----> if "Boston" in my_tuple:
----->     print("yes")
-----> else:
----->     print("no")

---> Length
-----> my_tuple = "Max", 28, Boston
-----> print(len(my_tuple))  # prints the length

---> Count items
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.count('p'))  # prints 2

---> Index search
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.count('l'))  # prints 3

---> Conversion to list
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(list(my_tuple))  # prints ['a', 'p', 'p', 'l', 'e'] (converts to list then print) 

---> Conversion back to tuple
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> my_list = list(my_tuple)
-----> print(list(my_list))  # prints ('a', 'p', 'p', 'l', 'e') (converts back to tuple then print) 

---> Slicing:
-----> my_tuple = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
-----> print(my_tuple[2:])  # prints (3, 4, 5, 6, 7, 8, 9, 10 (you can slice using a starting point)
-----> print(my_tuple[2:5])  # prints (3, 4, 5) (you can slice using a range, half open at the end)
-----> print(my_tuple[:5])  # prints (1, 2, 3, 4, 5) (you can slice using an ending point, half open at the end)
-----> print(my_tuple[0::2])  # prints (1, 3, 5, 7, 9) (starts at index 0, then take every second item in the list (step index 2))
-----> print(my_tuple[::-1])  # prints (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) (take the reverse of the list (step index -1))

---> Unpacking (similar to structure bindings)
-----> my_tuple = "Max", 28, Boston
-----> name, age, city = "Max", 28, Boston
-----> print(name)  # prints Max
-----> print(age)  # prints 28
-----> print(Boston)  # prints Boston
-----> name, age = "Max", 28, Boston  # ValueError: Too many values to unpack
 
---> Unpacking with *
-----> my_tuple = 0, 1, 2, 3, 4
-----> i1, *i2, i3 = my_tuple
-----> print(i1)  # prints 0
-----> print(i3)  # prints 4
-----> print(i2)  # prints [1,2,3] (Note the its converted to a list)

---> Comparing tuples with lists (memory consumption)
-----> import sys
-----> my_list = [0, 1, 2, "hello", True]
-----> my_tuple = (0, 1, 2, "hello", True)
-----> print(sys.getsizeof(my_list), "bytes")  # prints 96 bytes (list is larger even though they have the same items)
-----> print(sys.getsizeof(my_tuple), "bytes")  # prints 80 bytes (tuple is larger even though they have the same items)

---> Comparing tuples with lists (duration)


-> Functions
---> Python recognizes "def" as the keyword for functions
---> The code the goes inside the function needs to be indented
---> Printing example: 
-----> def say_hi(name, age):
----->     print("Hello " + name + "! You are " + str(age) + ".")
-----> print("Top")  # prints Top
-----> say_hi("Mike", 35)  # prints Hello Mike! You are 35.
-----> say_hi("Steve", 70)  # prints Hello Steve! You are 70.
-----> print("Bottom")  # prints Bottom
---> Return statement example: 
-----> def cube(num):
----->     return num*num*num
----->     print("This is will not be printed")  # The functions exists at the return statement so this line will not be executed.
-----> print(cube(4)) # prints 64
-----> result = cube(5)
-----> print(result) # prints 125

-> If statement
---> Python recognizes "if", "elif", "else" as the keywords for if statements
---> If statements with boolean variables:
-----> is_male = True
-----> is_tall = True
-----> if is_male or is_tall:
----->     print("You are a male or tall or both.")
-----> else:
----->     print("You are neither male nor tall.")
-----> if is_male and is_tall:
----->     print("You are a tall male.")
-----> elif is_male and not(is_tall):
----->     print("You are a short male.")
-----> elif not(is_male) and is_tall:
----->     print("You are not a male but are tall.")
-----> else:
----->     print("You are either not a male and not tall.")
---> If statements with comparison operators:
-----> def is_equal(parameter1, parameter2):
----->     return parameter1 == parameter2
-----> def is_not_equal(parameter1, parameter2):
----->     return parameter1 != parameter2
-----> def max_of_three(num1, num2, num3):
----->     if num1 >= num2 and num1 >= num3:
----->         return num1
----->     elif num2 >= num2 and num2 >= num3:
----->         return num2
----->     else:
----->         return num3
-----> print(is_equal(1, 1))  # prints True
-----> print(is_equal(1, 2))  # prints False
-----> print(is_equal("Jose", "Jose"))  # prints True
-----> print(is_equal("Jose", "Pancho"))  # prints False
-----> print(is_not_equal(1, 1))  # prints False
-----> print(is_not_equal(1, 2))  # prints True
-----> print(is_not_equal("Jose", "Jose"))  # prints False
-----> print(is_not_equal("Jose", "Pancho"))  # prints True
-----> print(max_of_three(1, 2, 3))  # prints 3
-----> print(max_of_three(300, 40, 5))  # prints 300
-----> print(max_of_three("300", "40", "5"))  # prints 5 (lexicographically compared)
---> Calculator example:
-----> num1 = float(input("Enter first number:"))
-----> op = input("Enter operator:")
-----> num2 = float(input("Enter second number:"))
-----> if op == '+':
----->     print(num1+num2)
-----> elif op == '-':
----->     print(num1-num2)
-----> elif op == '*':
----->     print(num1*num2)
-----> elif op == '/':
----->     print(num1/num2)
-----> else:
----->     print("Invalid operator.")

-> Dictionaries
---> Python recognizes {} as the wrapper for dictionaries
---> Similar to map in C++, it has key-value pairs.
-----> And values are searchable with the keys.
-----> monthNameShortToLong = {"Jan": "January", "Feb": "February", "Mar": "March", "Apr": "April", "May": "May", "Jun": "June",
----->                         "Jul": "July", "Aug": "August", "Sep": "September", "Oct": "Oct", "Nov": "November", "Dec": "December"}
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}
-----> print(monthNameShortToLong["Mar"])  # prints March
-----> print(monthNameShortToLong.get("Mar"))  # prints March
-----> print(monthNameShortToLong.get("NotAMonth"))  # prints None
-----> print(monthNameShortToLong.get("NotAMonth", "Not a valid key"))  # prints Not a valid key

-> While loop
---> Simple loop that counts 1 to 10:
-----> i = 1
-----> while i <= 10:
----->     print(i)
----->     # i++ # The operator ++ does not exist
----->     i += 1
-----> print("Done with loop")secret_word = "giraffe"
---> Guessing game:
-----> guess = ""
-----> guess_count = 0
-----> guess_limit = 3
-----> while guess != secret_word and guess_count < guess_limit:
----->     guess = input("Enter guess: ")
----->     guess_count += 1
-----> 
-----> if guess_count < guess_limit:
----->     print("You win!")
-----> else:
----->     print("Out of guesses!")

-> for loop
---> Prints in collection
-----> for letter in "Giraffe Academy":
----->     print(letter)  # prints letter in Giraffe Academy in separate lines
-----> friends = ["Jim", "Karen", "Kevin"]
-----> for friend in friends:
----->     print(friend)  # prints Jim Karen Kevin in separate lines
-----> for index in range(10):
----->     print(index)  # prints 0-9 in separate lines
-----> for index in range(3, 10):
----->     print(index)  # prints 3-9 in separate lines
-----> for index in range(len(friends)):
----->     print(friends[index])  # prints Jim Karen Kevin in separate lines

-> 2D list
---> number_grid = [
--->     [1, 2, 3],
--->     [4, 5, 6],
--->     [7, 8, 9],
--->     [0]
---> ]
---> print(number_grid[0][0])  # prints 1
---> print(number_grid[2][1])  # prints 8
---> for row in number_grid:
--->     for col in row:
--->         print(col)  # prints all elements in the grid

-> Translation example (convert all vowels to g)
---> def translate(phrase):
--->     # this function converts all the vowels to g
--->     result=""
--->     for letter in phrase:
--->         if letter.lower() in "aeiou": # letter is a vowel
--->             result += "g"
--->         else:
--->             result += letter
--->     return result
---> print(translate(input("Enter a phrase: ")))

-> Comments
---> # Single line comment
---> '''
---> These are multiline comments.
---> These are useful when debugging a chunk of code.
---> But these are not recommended in terms of style (prefer to use single line comments).
---> '''

-> Try except block
---> try:
--->     number = 1/0
---> except:
--->     print("This will catch all exceptions. This is not recommended.")
---> try:
--->     number = 1/0
---> except ZeroDivisionError:
--->     print("Divided by zero")
---> try:
--->     number = 1/0
---> except ZeroDivisionError as error_message:
--->     print(error_message)
---> try:
--->     number = int(input("Enter a number: "))
--->     print(number)
---> except ValueError as error_message:
--->     print("Invalid input: " + str(error_message))

-> Reading from files:
---> sample_file = open("sample.txt", "r")
---> # "r" for read
---> # "w" for write
---> # "a" for append
---> # "r+" for read and write
---> print("Is readable:" + str(sample_file.readable()))  # This returns a boolean if the file can be read (files opened by write will return false)
---> print("The entire contents:" + sample_file.read())  # This prints the entire contents of the file
---> sample_file.seek(0)  # reset at the start of the file
---> print("First line: " + sample_file.readline())  # This prints one line of the file
---> print("Second line: " + sample_file.readline())  # This prints one line of the file
---> print(sample_file.readline())  # This prints one line of the file
---> sample_file.seek(0)  # reset at the start of the file
---> while True:
--->     line = sample_file.readline()
--->     if not line:
--->         break
--->     print("Line at the loop:" + line.strip())
---> sample_file.seek(0)  # reset at the start of the file
---> print(sample_file.readlines())  # This prints all line in a list (readlines() put all lines in a list)
---> sample_file.seek(0)  # reset at the start of the file
---> for line in sample_file.readlines():
--->     print("Line at the loop:" + line.strip())
---> sample_file.close()

-> Writing to file:
---> # appending to a file
---> sample_file = open("sample.txt", "a")
---> sample_file.write("Toby - Human Resources\n") # This appends to the last line.
---> sample_file.close()
---> # writing to a file
---> sample_file = open("sample.txt", "w")
---> sample_file.write("Toby - Human Resources\n")  # This writes a line to the file (and erasing it previous contents).
---> sample_file.close()

-> Modules
---> How to use your own module:
-----> import utilities
-----> print(utilities.compute_something())
---> Check python docs to know what modules you need:
-----> google: python docs list of modules
-----> https://docs.python.org/3/py-modindex.html
-----> Some libraries are built-in (you dont have to add them in the file) some are external (you have to manually add them thru import)
-------> Check your python installation directory and look for the lib folder.

-> pip
---> Some third party libraries can be installed using pip
---> Example (python-docx is libaries that write word documents):
-----> pip install python-docx
-------> If python is not added in PATH, you can find pip here and manually run it: C:\Users\detec\AppData\Local\Programs\Python\Python310\Scripts
-----> The libraries installed by pip are on the directoy site-packages

-> Classes and objects

---> Simple example:
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa, is_on_probation):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
------->         self.is_on_probation = is_on_probation
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student("Jim", "Business", 3.1, False)  # the initializer is called
-------> student2 = Student("Pam", "Art", 2.5, True)
-------> print(student1.gpa)
-------> print(student2.gpa)

---> Multiple choice questionaire:
-----> On utilities.py:
-------> class Question:
------->     def __init__(self, prompt, answer):
------->         self.prompt = prompt
------->         self.answer = answer
-----> On application.py:
-------> from utilities import Question  # from utilities file import the Question class
-------> questions_prompts = [
------->     "What color are apples?\n(a) Red/Green\n(b) Purple\n(c) Orange\n\n",
------->     "What color are bananas?\n(a) Teal\n(b) Magenta\n(c) Yellow\n\n",
------->     "What color are strawberries?\n (a) Yellow\n(b) Red\n(c) Blue\n\n"
-------> ]
-------> questions = [
------->     Question(questions_prompts[0], "a"),
------->     Question(questions_prompts[1], "c"), 
------->     Question(questions_prompts[2], "b")
------->     ]
-------> def run_test(questions):
------->     score = 0
------->     for question in questions:
------->         answer = input(question.prompt)
------->         if answer == question.answer:
------->             score+=1
------->     print("You got " + str(score) +  "/" + str(len(questions))+ " correct")
-------> run_test(questions)

---> Student Honor Roll (in class function example):
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
-------> 
------->     def is_on_honor_roll(self):
------->         if self.gpa >= 3.5: 
------->             return True
------->         else:
------->             return False
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student("Oscar", "Accounting", 3.1)
-------> student2 = Student("Phyllis", "Business", 3.8)
-------> print(student1.is_on_honor_roll())
-------> print(student2.is_on_honor_roll())

---> Chef (inheritance example):
-----> On utilities.py:
-------> class Chef:
------->     def make_chicken(self):
------->         print("The chef makes a chicken.")
------->     def make_salad(self):
------->         print("The chef makes a salad.")
------->     def make_special_dish(self):
------->         print("The chef makes bbq ribs.")
-------> class Chinese_Chef(Chef):
------->     def make_special_dish(self):
------->         print("The chef makes orange chicken.")
------->     def make_fried_rice(self):
------->         print("The chef makes fried rice.")
-----> On application.py:
-------> from utilities import Chef, Chinese_Chef
-------> my_chef = Chef()
-------> my_chef.make_special_dish()
-------> my_chinese_chef=Chinese_Chef()
-------> my_chinese_chef.make_special_dish()







