
-> To format your code on Visual studio nn Windows: Shift + Alt + F.

-> Two major versions of python (python 2 and python 3)
---> Similar anyway if you learn python 3, you can easily learn python 2 as well



-> Printing

---> Basics:
-----> print("Hello World") 
-----> print("String1", "String2")  # prints String1 String2



-> Variables

---> Assigning variables:
-----> character_name = "John"
-----> character_age = "35"

---> Printing variables:
-----> print("There once was a man named " + character_name + ", ")
-----> print("he was " + character_age + " years old. ")



-> Working with numbers

---> Integer
-----> print(2)  # prints 2

---> Floating value
-----> print(2.0987)  # prints 2.0987
-----> print(-2.0987)  # prints -2.0987

---> Math operations
-----> print(3*4.5)  # prints 13.5
-----> print(3*4+5)  # prints 17
-----> print(10 % 3)  # prints 1
-----> print(10 ** 3)  # prints 1000 (exponent function)

---> Number variables
-----> my_num = 5
-----> print(my_num)  # prints 5
-----> print(str(my_num))  # prints 5 (converts to string and then print)
-----> # print(my_num + " is my favorite number") # error cause python does not automatically convert this
-----> print(str(my_num) + " is my favorite number")  # prints 5 is my favorite number
-----> my_num = -5

---> Other operations
-----> print(my_num)  # prints -5
-----> print(abs(my_num))  # prints 5
-----> print(pow(my_num, 2))  # prints 25
-----> print(min(4, 6))  # prints 4
-----> print(max(4, 6))  # prints 6
-----> print(round(3.2))  # prints 3
-----> print(round(3.7))  # prints 4

---> Other operations with import
-----> from math import *
-----> print(floor(3.7))
-----> print(ceil(3.7))
-----> print(sqrt(36))



-> Strings

---> Python recognizes "" (double quotes) or '' (single quotes) as the wrapper for strings
---> Strings are Homogeneous (characters are the only contents)
---> Strings are Immutable (once its created you cannot change it)
---> Strings allows duplicate elements 
---> Strings are used in text representation
---> Note: Unlike in C++, there are no characters in python (they are strings as well)
-----> Note: Hence, all examples below apply to a single character or a substring.

---> Printing
-----> print("Giraffe\nAcademy")  # line breaks can inserted on strings
-----> print("Giraffe\"Academy")  # escape character needed for special characters
-----> print("Giraffe", "Academy")  # prints Giraffe Academy

---> Construction:
-----> my_string1 = 'Using single quotes'  # single quotes are probably more common in practice
-----> my_string2 = "Using double quotes"
-----> my_string3 = 'Escaping single quotes \'\''
-----> my_string4 = "Double quotes to have single quotes ''"
-----> my_string5 = 'Escaping double quotes \"\"'
-----> my_string6 = 'Single quotes to have double quotes ""'
-----> my_string7 = """This is a multi line...
-----> string"""  # This is also used for multi line comments
-----> my_string8 = """This is a single line\
-----> string"""  # Backslash (\) can be used to escape new line to form a single line
-----> print(my_string1)
-----> print(my_string2)
-----> print(my_string3)
-----> print(my_string4)
-----> print(my_string5)
-----> print(my_string6)
-----> print(my_string7)
-----> print(my_string8)

---> Length
-----> phrase = "Giraffe Academy"
-----> print(len(phrase))  # prints the length

---> Element access
-----> phrase = "Giraffe Academy"
-----> print(phrase[0])  # prints G
-----> print(phrase[-1])  # prints y
-----> print(phrase[-2])  # prints m
-----> # phrase[0]= 'B'  # TypeError: 'str' object does not support item assignment (strings are immutable)

---> Slicing:
-----> phrase = "Giraffe Academy"
-----> print(phrase[1:])  # prints iraffe Academy (you can slice using a starting point)
-----> print(phrase[1:3])  # prints ir (you can slice using a range, half open at the end)
-----> print(phrase[:3])  # prints Gir (you can slice using an ending point, half open at the end)
-----> print(phrase[0::2])  # prints GrfeAaey (starts at index 0, then take every second item in the list (step index 2))
-----> print(phrase[::-1])  # prints ymedacA effariG (take the reverse of the list (step index -1))

---> Concatenation
-----> greeting = "Hello"
-----> name = "Tom"
-----> sentence = greeting + " " + name  # plus (+) is concatenation
-----> print(sentence)

---> Iteration
-----> phrase = "Giraffe Academy"
-----> for character in phrase:
----->     print(character)  # prints every character

---> if statement to check if substring (or character) exist in the string
-----> phrase = "Giraffe Academy"
-----> if "ell" in phrase:
----->     print("yes")  # prints yes
-----> else:
----->     print("no")

---> White space removal on the edges
-----> phrase = "           Giraffe      Academy          "
-----> phrase = phrase.strip()  # prints Giraffe      Academy
-----> print(phrase)

---> Case modifiers
-----> phrase = "Giraffe Academy"
-----> print(phrase.lower())  # converts to lower case
-----> print(phrase.upper())  # converts to upper case

---> Case checkers
-----> phrase = "Giraffe Academy"
-----> print(phrase.isupper())  # returns true if all uppercase
-----> print(phrase.upper().isupper())  # returns true

---> Edge checkers
-----> phrase = "Giraffe Academy"
-----> print(phrase.startswith("H"))  # returns false
-----> print(phrase.startswith("G"))  # returns true
-----> print(phrase.startswith("Gira"))  # returns true
-----> print(phrase.endswith("x"))  # returns false
-----> print(phrase.endswith("y"))  # returns true
-----> print(phrase.endswith("demy"))  # returns true

---> Index search
-----> phrase = "Giraffe Academy"
-----> print(phrase.index("a"))  # prints 3 (gets the index)
-----> print(phrase.index("Acad"))  # prints 8 (gets the index)
-----> # print(phrase.index("z")) # returns an error ('z' does not exist on the string)

---> Count matches
-----> phrase = "Giraffe Academy"
-----> print(phrase.count("a"))  # prints 2
-----> print(phrase.count("ff"))  # prints 1
-----> print(phrase.count("x"))  # prints 0

---> Find and replace
-----> phrase = "Giraffe Academy"
-----> print(phrase.replace("Giraffe", "Elephant"))  # replace string with another string
-----> print(phrase.replace("Ant", "Insect"))  # it does not replace when its not found (no error)

---> Split string into a list of substrings
-----> my_string = "How are you doing?"
-----> my_list = my_string.split(); # by default its splits by space
-----> print(my_list)  # prints ['How', 'are', 'you', 'doing?']
-----> my_string = "item1,item2,item3"
-----> my_list = my_string.split(","); # you can specify the delimiter
-----> print(my_list)  # prints ['item1', 'item2', 'item3']

---> Concatenate a list of strings into one string
-----> my_list = ["This", "Is", "Supposed", "To", "Be", "A", "Sentence"]
-----> string_without_spaces = "".join(my_list)
-----> string_with_spaces = " ".join(my_list)
-----> string_with_commas = ",".join(my_list)
-----> print(string_without_spaces)  # prints ThisIsSupposedToBeASentence
-----> print(string_with_spaces)  # prints This Is Supposed To Be A Sentence
-----> print(string_with_commas)  # This,Is,Supposed,To,Be,A,Sentence
---> Note: Use the .join method DONT append repetitively (THIS IS BAD PYTHON CODE, its much slower)
-----> # this is bad python code
-----> my_list = ["This", "Is", "Supposed", "To", "Be", "A", "Sentence"]
-----> my_string = str()
-----> for i in my_list : 
----->     my_string += i  # this is an expensive step
-----> print(my_string) 

---> Formatting
-----> # Using % (old way)
-----> stringItem = "Tom"
-----> numberItem = 123.45678
-----> my_string1 = "The item is [%s]." % stringItem
-----> my_string2 = "The item is [%d]." % numberItem
-----> my_string3 = "The item is [%f]." % numberItem
-----> my_string4 = "The item is [%.3f]." % numberItem
-----> print(my_string1)
-----> print(my_string2)
-----> print(my_string3)
-----> print(my_string4)
-----> # Using format (the new way)
-----> stringItem = "Tom"
-----> numberItem = 123.45678
-----> my_string1 = "The item is [{}].".format(stringItem)
-----> my_string2 = "The item is [{}].".format(numberItem)
-----> my_string3 = "The item is [{:.2f}].".format(numberItem)
-----> my_string4 = "The items are [{}, {:.2f}].".format(stringItem, numberItem)
-----> print(my_string1)
-----> print(my_string2)
-----> print(my_string3)
-----> print(my_string4)
-----> # Using fstring (the newest and best way, available in python 3.6 or newer)
-----> stringItem = "Tom"
-----> numberItem = 123.45678
-----> my_string1 = f"The item is [{stringItem}]."
-----> my_string2 = f"The item is [{numberItem}]."
-----> my_string3 = f"The item is [{numberItem:.2f}]."
-----> my_string3 = f"The items are [{stringItem}, {numberItem:.2f}]."
-----> my_string3 = f"The items are [{stringItem}, {numberItem*4:.2f}]." # can be an expression
-----> print(my_string1)
-----> print(my_string2)
-----> print(my_string3)



-> Lists

---> Python recognizes [] as the wrapper for list
---> Lists are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Lists are Mutable (you can still change it after its created)
---> Lists allows duplicate elements 

---> Construction using the brackets:
-----> my_list = ["Kevin", "Karen", "Jim"]  # creates a list with items

---> Construction using the list function:
-----> my_list = list()  # creates an empty list
-----> my_list = list(("Kevin", "Karen", "Jim"))  # using the list function and passing a iterable (in this case a tuple) on it

---> Construction using the brackets and star:
-----> lonely_person = ["Pam"] * 5  # creates a list with five "Pam"s

---> Element access:
-----> my_list = ["Kevin", "Karen", "Jim"]
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim']
-----> print(my_list[0])  # prints Kevin
-----> print(my_list[2])  # prints Jim
-----> print(my_list[-1])  # prints Jim (last item, you can access from the end using negative numbers)
-----> print(my_list[-2])  # prints Karen
-----> print(my_list[-3])  # prints Kevin
-----> # print(my_list[100])  # IndexError: list index out of range

---> Iteration
-----> my_list = ["Kevin", "Karen", "Jim"]
-----> for item in my_list:
----->     print(item)

---> if statement to check if item exist in the list
-----> my_list = ["Kevin", "Karen", "Jim"]
-----> if "Jim" in my_list:
----->     print("yes")
-----> else:
----->     print("no")

---> Length
-----> my_list = ["Kevin", "Karen", "Jim"]
-----> print(len(my_list))  # prints the length

---> Slicing:
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> print(my_list[1:])  # prints ['Karen', 'Jim', 'Oscar', 'Toby'] (you can slice using a starting point)
-----> print(my_list[1:3])  # prints ['Karen', 'Jim'] (you can slice using a range, half open at the end)
-----> print(my_list[:3])  # prints ['Kevin', 'Karen', 'Jim'] (you can slice using an ending point, half open at the end)
-----> print(my_list[0::2])  # prints ['Kevin', 'Jim', 'Toby'] (starts at index 0, then take every second item in the list (step index 2))
-----> print(my_list[::-1])  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin'] (take the reverse of the list (step index -1))

---> List elements can be modified:
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list[1] = "Mike"
-----> print(my_list)  # prints ['Kevin', 'Mike', 'Jim', 'Oscar', 'Toby']

---> Append as last element
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.append("Creed")
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Extend (concatenation)
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> lucky_numbers = [4, 8, 15, 16, 23, 42]
-----> same_my_list = my_list + lucky_numbers  # concatenation
-----> my_list.extend(lucky_numbers)  # concatenation
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed', 4, 8, 15, 16, 23, 42]

---> Insert
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.insert(1, "Kelly")
-----> print(my_list)  # prints ['Kevin', 'Kelly', 'Karen', 'Jim', 'Oscar', 'Toby']

---> Specified item removal (remove function)
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.remove("Jim")
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Oscar', 'Toby']

---> Last item removal (pop function)
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.pop()
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar']

---> Index search
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> print(my_list.index("Creed"))  # prints 2
-----> # print(my_list.index("Mike")) # ValueError: Mike is not in list

---> Count items
-----> my_list = ["Kevin", "Oscar", "Karen", "Jim", "Oscar", "Toby"]
-----> print(my_list.count("Oscar"))  # prints 2

---> Reverse
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.reverse()
-----> print(my_list)  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin']

---> Sort
-----> # my_list.sort() # error because we have integers and string in the list
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> new_my_list = sorted(my_list) # creates a new list with sorted elements (if you dont want to sort inplace)
-----> my_list.sort()
-----> print(my_list)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']
-----> print(new_my_list)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']

---> Clear
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
-----> my_list.clear()
-----> print(my_list)  # prints []

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby", "Creed"]
-----> my_list2 = my_list
-----> my_list2[0] = "Mark"
-----> print(my_list)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list2)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Copying
-----> my_list = ["Kevin", "Karen", "Jim", "Oscar", "Toby", "Creed"]
-----> my_list2 = my_list.copy()  # the copy function returns a new instance
-----> my_list3 = list(my_list)  # this creates a new instance (using the list function)
-----> my_list4 = my_list[:]  # this also makes a copy (using slicing)
-----> my_list2[0] = "Mark"
-----> my_list3[0] = "Mike"
-----> my_list4[0] = "Millie"
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list2)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list3)  # prints ['Mike', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list4)  # prints ['Millie', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> List comprehension (cool feature)
-----> numbers = [1, 2, 3, 4, 5, 6]
-----> squared_numbers = [n*n for n in numbers]
-----> even_numbers = [n for n in numbers if n % 2 == 0]
-----> print(numbers)  # prints [1, 2, 3, 4, 5, 6]
-----> print(squared_numbers)  # prints [1, 4, 9, 16, 25, 36]
-----> print(even_numbers)  # prints [2, 4, 6]

-> Tuples

---> Python recognizes comma separated elements as a tuple (but not inside a known construct (a list for example))
---> They can be grouped by parentheses but its optional
---> Tuples are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Tuples are Immutable (once its created you cannot change it)
---> Tuples allows duplicate elements 
---> Tuples are generally used for data that it isnt gonna change in the duration of the program
-----> Because Tuples are immutable python can make internal optimizations compared to a list (especially when working with large data)

---> Construction:
-----> my_tuple = ("Max", 28, Boston) 
-----> my_tuple = "Max", 28, Boston  # the parentheses are optional
-----> print(my_tuple)

---> Construction of one element:
-----> my_str = "Max"
-----> print(type(my_str))  # this is a string
-----> my_str = ("Max") 
-----> print(type(my_str))  # this is a string (the parentheses are optional)
-----> my_str = "Max",
-----> print(type(my_str))  # this is a tuple
-----> my_str = ("Max",) 
-----> print(type(my_str))  # this is a tuple (the parentheses are optional)

---> Construction using the tuple function:
-----> my_tuple = tuple(["Max", 28, Boston])  # using the tuple function and passing a iterable (in this case a list) on it

---> Element access
-----> my_tuple = "Max", 28, Boston
-----> print(my_tuple[1])  # prints 28
-----> print(my_tuple[-1])  # prints Boston
-----> print(my_tuple[-2])  # prints 28
-----> # print(my_tuple[3])  # IndexError: tuple index out of range
 
---> Tuples are immutable:
-----> coordinate = (4, 5)
-----> print(coordinate[1])  # prints 5
-----> # coordinate[1] = 10 # TypeError: 'tuple' object does not support item assignment

---> A list of tuples can be changed:
-----> coordinates = [(4, 5), (6, 7), (80, 34)]
-----> print(coordinates)  # prints [(4, 5), (6, 7), (80, 34)]
-----> coordinates[0] = (9, 9)
-----> print(coordinates)  # prints [(9, 9), (6, 7), (80, 34)] (a list of tuples can be changed)

---> Iteration
-----> my_tuple = "Max", 28, Boston
-----> for item in my_tuple:
----->     print(item)

---> if statement to check if item exist in the list
-----> my_tuple = "Max", 28, Boston
-----> if "Boston" in my_tuple:
----->     print("yes")
-----> else:
----->     print("no")

---> Length
-----> my_tuple = "Max", 28, Boston
-----> print(len(my_tuple))  # prints the length

---> Count items
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.count('p'))  # prints 2

---> Index search
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.count('l'))  # prints 3

---> Conversion to list
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(list(my_tuple))  # prints ['a', 'p', 'p', 'l', 'e'] (converts to list then print) 

---> Conversion back to tuple
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> my_list = list(my_tuple)
-----> print(list(my_list))  # prints ('a', 'p', 'p', 'l', 'e') (converts back to tuple then print) 

---> Slicing:
-----> my_tuple = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
-----> print(my_tuple[2:])  # prints (3, 4, 5, 6, 7, 8, 9, 10 (you can slice using a starting point)
-----> print(my_tuple[2:5])  # prints (3, 4, 5) (you can slice using a range, half open at the end)
-----> print(my_tuple[:5])  # prints (1, 2, 3, 4, 5) (you can slice using an ending point, half open at the end)
-----> print(my_tuple[0::2])  # prints (1, 3, 5, 7, 9) (starts at index 0, then take every second item in the list (step index 2))
-----> print(my_tuple[::-1])  # prints (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) (take the reverse of the list (step index -1))

---> Unpacking (similar to structure bindings)
-----> my_tuple = "Max", 28, Boston
-----> name, age, city = "Max", 28, Boston
-----> print(name)  # prints Max
-----> print(age)  # prints 28
-----> print(Boston)  # prints Boston
-----> name, age = "Max", 28, Boston  # ValueError: Too many values to unpack
 
---> Unpacking with *
-----> my_tuple = 0, 1, 2, 3, 4
-----> i1, *i2, i3 = my_tuple
-----> print(i1)  # prints 0
-----> print(i3)  # prints 4
-----> print(i2)  # prints [1,2,3] (Note the its converted to a list)

---> Comparing tuples with lists (memory consumption)
-----> import sys
-----> my_list = [0, 1, 2, "hello", True]
-----> my_tuple = (0, 1, 2, "hello", True)
-----> print(sys.getsizeof(my_list), "bytes")  # prints 96 bytes (list is larger even though they have the same items)
-----> print(sys.getsizeof(my_tuple), "bytes")  # prints 80 bytes (tuple is larger even though they have the same items)

---> Comparing tuples with lists (duration)
-----> import timeit
-----> print(timeit.timeit(stmt="[0,1,2,3,4,5]", number=1000000)) # prints 0.13339190000260714 (list is slower)
-----> print(timeit.timeit(stmt="(0,1,2,3,4,5)", number=1000000)) # prints 0.08034780000161845 (tuple is faster)



-> Dictionaries

---> Python recognizes {} as the wrapper for sets and dictionaries
---> Similar to map classes in C++, it has key-value pairs.
---> Dictionaries are Heterogeneous for both the keys and values (you can put any type (string, int, boolean) in different positions)
---> Dictionaries are Mutable (you can still change it after its created)
---> Dictionaries allows duplicate values, but the keys need to be unique (any duplicate keys has its value overwritten) 
---> The values in the Dictionaries are searchable with the keys.

---> Construction using braces
-----> monthNameShortToLong =
-----> {"Jan": "January", "Feb": "February", "Mar": "March", "Apr": "April", "May": "May", "Jun": "June",
----->  "Jul": "July", "Aug": "August", "Sep": "September", "Oct": "Oct", "Nov": "November", "Dec": "December"}
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}

---> Construction using dict function (take note that there are no quotations in the keys)
-----> monthNameShortToLong = dict(
----->     Jan="January", Feb="February", Mar="March", Apr="April", May="May", Jun="June",
----->     Jul="July", Aug="August", Sep="September", Oct="October", Nov="November", Dec="December")
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}

---> Element Access
-----> monthNameShortToLong =
-----> {"Jan": "January", "Feb": "February", "Mar": "March", "Apr": "April", "May": "May", "Jun": "June",
----->  "Jul": "July", "Aug": "August", "Sep": "September", "Oct": "Oct", "Nov": "November", "Dec": "December"}
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}
-----> print(monthNameShortToLong["Mar"])  # prints March
-----> # print(monthNameShortToLong["NotAMonth"])  # KeyError: NotAMonth
-----> print(monthNameShortToLong.get("Mar"))  # prints March
-----> print(monthNameShortToLong.get("NotAMonth"))  # prints None
-----> print(monthNameShortToLong.get("NotAMonth", "Not a valid key"))  # prints Not a valid key

---> Modifying Elements
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> my_dict["email"] = "max@xyz.com"  # adds email key with value
-----> print(my_dict)  # prints with email
-----> my_dict["email"] = "coolmax@xyz.com"  # modifies value on email key
-----> print(my_dict)  # prints with new email

---> Removing Elements
-----> my_dict = {"name": "Max", "age": 28, "city": "New York", "email": "coolmax@xyz.com"}
-----> del my_dict["email"]  # deletes email key (and its value)
-----> print(my_dict)  # prints without email
-----> my_dict.pop("age")  # deletes age key (and its value)
-----> print(my_dict)  # prints without age
-----> my_dict.popitem()  # deletes last item (key-value pair)
-----> print(my_dict)  # prints without city (last added item) 

---> Clear
-----> my_set = {1, 2, 3}
-----> my_set.clear()
-----> print(my_list)  # prints {}

---> Iteration
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> for key in my_dict:
----->     print(key)
-----> for key in my_dict.keys():  # same as above
----->     print(key)
-----> for value in my_dict.values():
----->     print(value)
-----> for key, value in my_dict.items():
----->     print(key)
----->     print(value)

---> if statement to check if key exist in the list
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> if "name" in my_dict:
----->     print(my_dict["name"])  # prints Max
-----> if "DoesNotExist" in my_dict:  # this is false
----->     print(my_dict["DoesNotExist"])  # this doesnt get executed

---> try except statement to try to do things with key that might not exist
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> try:
----->     print(my_dict["DoesNotExist"])
-----> except:
----->     print("Error")

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> my_dict2 = my_dict
-----> my_dict2["name"] = "Mark"
-----> print(my_dict)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}
-----> print(my_dict2)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}

---> Copying
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> my_dict2 = my_dict.copy()  # the copy function returns a new instance
-----> my_dict3 = dict(my_dict)  # this creates a new instance (using the dict function)
-----> my_dict2["name"] = "Mark"
-----> my_dict3["name"] = "Mike"
-----> print(my_dict)  # prints {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> print(my_dict2)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}
-----> print(my_dict3)  # prints {'name': 'Mike', 'age': 28, 'city': 'New York'}

---> Combining dictionaries (overwrite and add)
-----> my_dict = {"name": "Max", "age": 28, "city": "New York"}
-----> my_dict2 = {"name": "Mary", "age": 27, "email": "Boston"}
-----> my_dict.update(my_dict2)
-----> print(my_dict) # prints {'name': 'Mary', 'age': 27, 'city': 'New York', 'email': 'Boston'} (some got overwritten, some got added)

---> Keys need to be a hashable type (int, str, floating types, tuples are hashable, list is not hashable(its mutable))
-----> dict_with_hashable_keys = {
----->     "one": 100, 2: "two hundred", 3.5 : "three hundred and fifty", (4, 5) : "four hundred and fifty"}
-----> print(dict_with_hashable_keys)
-----> # dict_with_unhashable_keys = {[5, 5] : "five hundred and fifty"} # TypeError: unhashable type: 'list'
-----> # print(dict_with_unhashable_keys)



-> Sets

---> Python recognizes {} as the wrapper for sets and dictionaries
---> Sets are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Sets are Mutable (you can still change it after its created)
---> Sets need its items to be unique (any duplicate items are discarded) 

---> Construction using braces
-----> my_set = {1, 2, 3, 1, 2, "hello"}
-----> print(my_set) # prints {1, 2, 3, 'hello'} (duplicate items are discarded)

---> Construction using set function
-----> my_set = set([1, 2, 3, 1, 2, "hello"]) # using the set function and passing a iterable (in this case a list) on it
-----> print(my_set)  # prints {1, 2, 3, 'hello'} (duplicate items are discarded)

---> Construction using set function with a string
-----> my_set = set("hello") # using the set function and passing a iterable (in this case a string) on it
-----> print(my_set)  # prints {'l', 'o', 'h', 'e'} (duplicate items are discarded)

---> Construction of an empty set
-----> my_dict = {} # empty braces is recognized as a dictionary 
-----> print(type(my_dict))  # shows dictionary
-----> my_set = set()
-----> print(type(my_set))   # shows set

---> Adding elements
-----> my_set = set()
-----> my_set.add(1)
-----> my_set.add(2)
-----> my_set.add(3)
-----> print(my_set)  # prints {1, 2, 3}

---> Removing elements (using remove)
-----> my_set = {1, 2, 3}
-----> my_set.remove(2)
-----> # my_set.remove(4) # KeyError: 4
-----> print(my_set)  # prints {1, 3}

---> Removing elements (using discard)
-----> my_set = {1, 2, 3}
-----> my_set.discard(2)
-----> my_set.discard(4) # Nothing happens
-----> print(my_set)  # prints {1, 3}

---> Removing elements (using pop)
-----> my_set = {1, 2, 3}
-----> print(my_set.pop())  # prints 1 (pop returns a value)
-----> print(my_set)  # prints {2, 3}

---> Clear
-----> my_set = {1, 2, 3}
-----> my_set.clear()
-----> print(my_list)  # prints set()

---> Iteration
-----> my_set = {1, 2, 3}
-----> for item in my_set:
----->     print(item)

---> if statement to check if item exist in the set
-----> my_set = {1, 2, 3}
-----> if "1" in my_set:
----->     print("Yes")  # prints Max
-----> if "DoesNotExist" in my_set:  # this is false
----->     print("Yes")  # this doesnt get executed

---> Union
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> union_set = set1.union(set2)
-----> print(union_set) # prints {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

---> Intersection
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> intersection_set = set1.intersection(set2)
-----> print(intersection_set) # prints {1, 2, 3}

---> Difference 
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> difference_set = set1.difference(set2)
-----> print(difference_set) # prints {4, 5, 6, 7, 8, 9}

---> Symmetric Difference 
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> sym_diff_set = set1.symmetric_difference(set2)
-----> print(sym_diff_set) # prints {4, 5, 6, 7, 8, 9}

---> Union update (combining using union)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.update(set2)
-----> print(set1)  # prints {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

---> Intersection update (combining using intersection)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.intersection_update(set2)
-----> print(set1)  # prints {1, 2, 3}

---> Difference update (combining using difference)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.difference_update(set2)
-----> print(set1)  # prints {4, 5, 6, 7, 8, 9}

---> Symmetric difference update (combining using symmetric difference)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.symmetric_difference_update(set2)
-----> print(set1)  # prints {4, 5, 6, 7, 8, 9, 10, 11, 12}

---> issubset
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> print(set1.issubset(set2))  # prints False
-----> print(set2.issubset(set1))  # prints True

---> issuperset
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> print(set1.issuperset(set2))  # prints True
-----> print(set2.issuperset(set1))  # prints False

---> isdisjoint
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> set3 = {7, 8, 9}
-----> print(set1.isdisjoint(set2))  # prints False
-----> print(set2.isdisjoint(set3))  # prints True

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_set = {1, 2, 3, 4, 5, 6}
-----> my_set2 = my_set
-----> my_set2.add(7)
-----> print(my_set)  # prints {1, 2, 3, 4, 5, 6, 7}
-----> print(my_set2)  # prints {1, 2, 3, 4, 5, 6, 7}

---> Copying
-----> my_set = {1, 2, 3, 4, 5, 6}
-----> my_set2 = my_set.copy()  # the copy function returns a new instance
-----> my_set3 = set(my_set)  # this creates a new instance (using the list function)
-----> my_set2.add(7)
-----> my_set3.add(8)
-----> print(my_set)  # prints {1, 2, 3, 4, 5, 6}
-----> print(my_set2)  # prints {1, 2, 3, 4, 5, 6, 7}
-----> print(my_set3)  # prints {1, 2, 3, 4, 5, 6, 8}

---> frozenset (immutable version of a set)
-----> my_frozen_set = frozenset([1, 2, 3, 4])
-----> my_frozen_set.add(5)  # AttributeError: 'frozenset' object has no attribute 'add'
-----> my_frozen_set.remove(1)  # AttributeError: 'frozenset' object has no attribute 'remove'




-> Getting Input From Users

---> Example with strings:
-----> name = input("Enter your name: ")  # gets input from user
-----> age = input("Enter your age: ")
-----> print("Hello " + name + "! You are " + age + ".")
---> NOTE: By default, python gets input as a string. 

---> Example with adding integers from user input:
-----> num1 = input("Enter a number: ")
-----> num2 = input("Enter another number: ")
-----> result = int(num1) + int(num2)
-----> print(result)

---> Example with adding floating numbers from user input:
-----> num1 = input("Enter a number: ")
-----> num2 = input("Enter another number: ")
-----> result = float(num1) + float(num2)
-----> print(result)



-> Functions

---> Python recognizes "def" as the keyword for functions
---> The code the goes inside the function needs to be indented
---> Printing example: 
-----> def say_hi(name, age):
----->     print("Hello " + name + "! You are " + str(age) + ".")
-----> print("Top")  # prints Top
-----> say_hi("Mike", 35)  # prints Hello Mike! You are 35.
-----> say_hi("Steve", 70)  # prints Hello Steve! You are 70.
-----> print("Bottom")  # prints Bottom
---> Return statement example: 
-----> def cube(num):
----->     return num*num*num
----->     print("This is will not be printed")  # The functions exists at the return statement so this line will not be executed.
-----> print(cube(4)) # prints 64
-----> result = cube(5)
-----> print(result) # prints 125



-> If statement

---> Python recognizes "if", "elif", "else" as the keywords for if statements
---> If statements with boolean variables:
-----> is_male = True
-----> is_tall = True
-----> if is_male or is_tall:
----->     print("You are a male or tall or both.")
-----> else:
----->     print("You are neither male nor tall.")
-----> if is_male and is_tall:
----->     print("You are a tall male.")
-----> elif is_male and not(is_tall):
----->     print("You are a short male.")
-----> elif not(is_male) and is_tall:
----->     print("You are not a male but are tall.")
-----> else:
----->     print("You are either not a male and not tall.")
---> If statements with comparison operators:
-----> def is_equal(parameter1, parameter2):
----->     return parameter1 == parameter2
-----> def is_not_equal(parameter1, parameter2):
----->     return parameter1 != parameter2
-----> def max_of_three(num1, num2, num3):
----->     if num1 >= num2 and num1 >= num3:
----->         return num1
----->     elif num2 >= num2 and num2 >= num3:
----->         return num2
----->     else:
----->         return num3
-----> print(is_equal(1, 1))  # prints True
-----> print(is_equal(1, 2))  # prints False
-----> print(is_equal("Jose", "Jose"))  # prints True
-----> print(is_equal("Jose", "Pancho"))  # prints False
-----> print(is_not_equal(1, 1))  # prints False
-----> print(is_not_equal(1, 2))  # prints True
-----> print(is_not_equal("Jose", "Jose"))  # prints False
-----> print(is_not_equal("Jose", "Pancho"))  # prints True
-----> print(max_of_three(1, 2, 3))  # prints 3
-----> print(max_of_three(300, 40, 5))  # prints 300
-----> print(max_of_three("300", "40", "5"))  # prints 5 (lexicographically compared)
---> Calculator example:
-----> num1 = float(input("Enter first number:"))
-----> op = input("Enter operator:")
-----> num2 = float(input("Enter second number:"))
-----> if op == '+':
----->     print(num1+num2)
-----> elif op == '-':
----->     print(num1-num2)
-----> elif op == '*':
----->     print(num1*num2)
-----> elif op == '/':
----->     print(num1/num2)
-----> else:
----->     print("Invalid operator.")



-> While loop

---> Simple loop that counts 1 to 10:
-----> i = 1
-----> while i <= 10:
----->     print(i)
----->     # i++ # The operator ++ does not exist
----->     i += 1
-----> print("Done with loop")secret_word = "giraffe"

---> Guessing game:
-----> guess = ""
-----> guess_count = 0
-----> guess_limit = 3
-----> while guess != secret_word and guess_count < guess_limit:
----->     guess = input("Enter guess: ")
----->     guess_count += 1
-----> 
-----> if guess_count < guess_limit:
----->     print("You win!")
-----> else:
----->     print("Out of guesses!")

-> for loop
---> Prints in collection
-----> for letter in "Giraffe Academy":
----->     print(letter)  # prints letter in Giraffe Academy in separate lines
-----> my_list = ["Jim", "Karen", "Kevin"]
-----> for item in my_list:
----->     print(item)  # prints Jim Karen Kevin in separate lines
-----> for index in range(10):
----->     print(index)  # prints 0-9 in separate lines
-----> for index in range(3, 10):
----->     print(index)  # prints 3-9 in separate lines
-----> for index in range(len(my_list)):
----->     print(my_list[index])  # prints Jim Karen Kevin in separate lines

-> 2D list
---> number_grid = [
--->     [1, 2, 3],
--->     [4, 5, 6],
--->     [7, 8, 9],
--->     [0]
---> ]
---> print(number_grid[0][0])  # prints 1
---> print(number_grid[2][1])  # prints 8
---> for row in number_grid:
--->     for col in row:
--->         print(col)  # prints all elements in the grid

-> Translation example (convert all vowels to g)
---> def translate(phrase):
--->     # this function converts all the vowels to g
--->     result=""
--->     for letter in phrase:
--->         if letter.lower() in "aeiou": # letter is a vowel
--->             result += "g"
--->         else:
--->             result += letter
--->     return result
---> print(translate(input("Enter a phrase: ")))

-> Comments
---> # Single line comment
---> '''
---> These are multiline comments.
---> These are useful when debugging a chunk of code.
---> But these are not recommended in terms of style (prefer to use single line comments).
---> '''



-> Try except block
---> try:
--->     number = 1/0
---> except:
--->     print("This will catch all exceptions. This is not recommended.")
---> try:
--->     number = 1/0
---> except ZeroDivisionError:
--->     print("Divided by zero")
---> try:
--->     number = 1/0
---> except ZeroDivisionError as error_message:
--->     print(error_message)
---> try:
--->     number = int(input("Enter a number: "))
--->     print(number)
---> except ValueError as error_message:
--->     print("Invalid input: " + str(error_message))



-> Reading from files:
---> sample_file = open("sample.txt", "r")
---> # "r" for read
---> # "w" for write
---> # "a" for append
---> # "r+" for read and write
---> print("Is readable:" + str(sample_file.readable()))  # This returns a boolean if the file can be read (files opened by write will return false)
---> print("The entire contents:" + sample_file.read())  # This prints the entire contents of the file
---> sample_file.seek(0)  # reset at the start of the file
---> print("First line: " + sample_file.readline())  # This prints one line of the file
---> print("Second line: " + sample_file.readline())  # This prints one line of the file
---> print(sample_file.readline())  # This prints one line of the file
---> sample_file.seek(0)  # reset at the start of the file
---> while True:
--->     line = sample_file.readline()
--->     if not line:
--->         break
--->     print("Line at the loop:" + line.strip())
---> sample_file.seek(0)  # reset at the start of the file
---> print(sample_file.readlines())  # This prints all line in a list (readlines() put all lines in a list)
---> sample_file.seek(0)  # reset at the start of the file
---> for line in sample_file.readlines():
--->     print("Line at the loop:" + line.strip())
---> sample_file.close()



-> Writing to file:
---> # appending to a file
---> sample_file = open("sample.txt", "a")
---> sample_file.write("Toby - Human Resources\n") # This appends to the last line.
---> sample_file.close()
---> # writing to a file
---> sample_file = open("sample.txt", "w")
---> sample_file.write("Toby - Human Resources\n")  # This writes a line to the file (and erasing it previous contents).
---> sample_file.close()

-> Modules
---> How to use your own module:
-----> import utilities
-----> print(utilities.compute_something())
---> Check python docs to know what modules you need:
-----> google: python docs list of modules
-----> https://docs.python.org/3/py-modindex.html
-----> Some libraries are built-in (you dont have to add them in the file) some are external (you have to manually add them thru import)
-------> Check your python installation directory and look for the lib folder.



-> pip
---> Some third party libraries can be installed using pip
---> Example (python-docx is libaries that write word documents):
-----> pip install python-docx
-------> If python is not added in PATH, you can find pip here and manually run it: C:\Users\detec\AppData\Local\Programs\Python\Python310\Scripts
-----> The libraries installed by pip are on the directoy site-packages



-> Classes and objects

---> Simple example:
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa, is_on_probation):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
------->         self.is_on_probation = is_on_probation
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student("Jim", "Business", 3.1, False)  # the initializer is called
-------> student2 = Student("Pam", "Art", 2.5, True)
-------> print(student1.gpa)
-------> print(student2.gpa)

---> Multiple choice questionaire:
-----> On utilities.py:
-------> class Question:
------->     def __init__(self, prompt, answer):
------->         self.prompt = prompt
------->         self.answer = answer
-----> On application.py:
-------> from utilities import Question  # from utilities file import the Question class
-------> questions_prompts = [
------->     "What color are apples?\n(a) Red/Green\n(b) Purple\n(c) Orange\n\n",
------->     "What color are bananas?\n(a) Teal\n(b) Magenta\n(c) Yellow\n\n",
------->     "What color are strawberries?\n (a) Yellow\n(b) Red\n(c) Blue\n\n"
-------> ]
-------> questions = [
------->     Question(questions_prompts[0], "a"),
------->     Question(questions_prompts[1], "c"), 
------->     Question(questions_prompts[2], "b")
------->     ]
-------> def run_test(questions):
------->     score = 0
------->     for question in questions:
------->         answer = input(question.prompt)
------->         if answer == question.answer:
------->             score+=1
------->     print("You got " + str(score) +  "/" + str(len(questions))+ " correct")
-------> run_test(questions)

---> Student Honor Roll (in class function example):
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
-------> 
------->     def is_on_honor_roll(self):
------->         if self.gpa >= 3.5: 
------->             return True
------->         else:
------->             return False
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student("Oscar", "Accounting", 3.1)
-------> student2 = Student("Phyllis", "Business", 3.8)
-------> print(student1.is_on_honor_roll())
-------> print(student2.is_on_honor_roll())

---> Chef (inheritance example):
-----> On utilities.py:
-------> class Chef:
------->     def make_chicken(self):
------->         print("The chef makes a chicken.")
------->     def make_salad(self):
------->         print("The chef makes a salad.")
------->     def make_special_dish(self):
------->         print("The chef makes bbq ribs.")
-------> class Chinese_Chef(Chef):
------->     def make_special_dish(self):
------->         print("The chef makes orange chicken.")
------->     def make_fried_rice(self):
------->         print("The chef makes fried rice.")
-----> On application.py:
-------> from utilities import Chef, Chinese_Chef
-------> my_chef = Chef()
-------> my_chef.make_special_dish()
-------> my_chinese_chef=Chinese_Chef()
-------> my_chinese_chef.make_special_dish()



-> Collections

---> The collections module provide special containers that provide additional functionality

---> Counter
-----> Dict subclass for counting hashable items.
-----> Sometimes called a bag or multiset.  
-----> Elements are stored as dictionary keys and their counts are stored as dictionary values.
-----> Example usage:
-------> from collections import Counter
-------> a = "aaaaabbbbccc"
-------> my_counter = Counter(a)
-------> print(my_counter)  # prints Counter({'a': 5, 'b': 4, 'c': 3})
-------> print(my_counter.items())  # prints dict_items([('a', 5), ('b', 4), ('c', 3)])
-------> print(my_counter.keys())  # prints dict_keys(['a', 'b', 'c'])
-------> print(my_counter.values())  # prints dict_values([5, 4, 3])
-------> print(my_counter.most_common(1))  # prints [('a', 5)] (a list of tuples)
-------> print(my_counter.most_common(2))  # prints [('a', 5), ('b', 4)] (a list of tuples)
-------> print(list(my_counter.elements()))  # prints ['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c']

---> namedtuple
-----> Returns a new subclass of tuple with named fields.
-----> Example usage:
-------> from collections import namedtuple
-------> Point = namedtuple('Point', 'x,y')  # this will create a class (or a struct) with fields x and y
-------> pt = Point(1, -4)
-------> print(pt)  # prints Point(x=1, y=-4)
-------> print(pt.x, pt.y)  # prints 1 -4

---> OrderedDict
-----> Dictionary that remembers insertion order
-----> Outdated class because the dictionary class in newer python versions have the ability to remember the order
-----> It might be necessary still if you are working in older python versions.
-----> Example usage:
-------> from collections import OrderedDict
-------> my_dictionary = OrderedDict()
-------> my_dictionary["d"] = 4
-------> my_dictionary["c"] = 3
-------> my_dictionary["b"] = 2
-------> my_dictionary["a"] = 1
-------> print(my_dictionary)  # prints OrderedDict([('d', 4), ('c', 3), ('b', 2), ('a', 1)])

---> defaultdict
-----> Same with a dictionary but the difference is that it will set a default value if the value is not set yet
-----> Example usage:
-------> from collections import defaultdict
-------> my_dictionary = defaultdict(int)
-------> my_dictionary["a"] = 1
-------> my_dictionary["b"] = 2
-------> print(my_dictionary["a"])  # prints 1
-------> print(my_dictionary["b"])  # prints 2
-------> print(my_dictionary["DoesNotExist"])  # prints 0 (no KeyError even if doesnt exist and note that the default value of int is zero)

---> deque
-----> Double ended queue (similar to C++)
-----> Example usage:
-------> from collections import deque
-------> my_deque = deque()
-------> my_deque.append(1)
-------> my_deque.append(2)
-------> my_deque.appendleft(0)
-------> print(my_deque)  # prints deque([0, 1, 2])
-------> my_deque.pop()
-------> print(my_deque)  # prints deque([0, 1])
-------> my_deque.popleft()
-------> print(my_deque)  # prints deque([1])
-------> my_deque.extend([3, 4, 5])
-------> print(my_deque)  # prints deque([1, 3, 4, 5])
-------> my_deque.extendleft([-1, -2, -3])
-------> print(my_deque)  # prints deque([-3, -2, -1, 1, 3, 4, 5])
-------> my_deque.rotate(2)
-------> print(my_deque)  # prints deque([4, 5, -3, -2, -1, 1, 3])
-------> my_deque.rotate(-1)
-------> print(my_deque)  # prints deque([5, -3, -2, -1, 1, 3, 4])



-> Itertools

---> The itertools module has different tools of handling iterators
---> Iterators are iterables (can be used in a for loop, etc).

---> product
-----> This provides iterating in a "cartesian product way"
-----> Example usage:
-------> from itertools import product
-------> a = [1, 2]
-------> b = [3, 4]
-------> my_iterable = product(a, b)  # creates a  itertools object (an iterator)
-------> print(list(my_iterable))  # prints [(1, 3), (1, 4), (2, 3), (2, 4)]
-------> a = [1, 2]
-------> b = [3]
-------> my_iterable = product(a, b, repeat=2)  # can specify a repeat
-------> print(list(my_iterable))  # prints [(1, 3, 1, 3), (1, 3, 2, 3), (2, 3, 1, 3), (2, 3, 2, 3)]

---> product
-----> This provides iterating in a "cartesian product way"
-----> Example usage:
-------> from itertools import permutations
-------> my_list = [1, 2, 3]
-------> my_iterable = permutations(my_list)  # creates a itertools object (an iterator)
-------> print(list(my_iterable))  # prints [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]

---> permutations
-----> This provides iterating through permutations
-----> Example usage:
-------> from itertools import permutations
-------> my_list = [1, 2, 3]
-------> my_iterable = permutations(my_list)  # creates a itertools object (an iterator)
-------> print(list(my_iterable))  # prints [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
-------> my_iterable = permutations(my_list, 2)  # can specify the length
-------> print(list(my_iterable))  # prints [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

---> combinations
-----> This provides iterating through combinations
-----> Example usage:
-------> from itertools import combinations, combinations_with_replacement
-------> my_list = [1, 2, 3]
-------> my_iterable = combinations(my_list, 2)  # creates a itertools object (an iterator), length is mandatory
-------> print(list(my_iterable))  # prints [(1, 2), (1, 3), (2, 3)]
-------> my_iterable = combinations_with_replacement(my_list, 2)  # 
-------> print(list(my_iterable))  # prints [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

---> accumulate
-----> This provides iterating by getting partial sums
-----> This similar to std::accumulate
-----> Example usage:
-------> from itertools import accumulate
-------> import operator
-------> my_list = [1, 2, 3, 2, 1]
-------> my_iterable = accumulate(my_list)
-------> print(list(my_iterable))  # prints [1, 3, 6, 8, 9]
-------> my_iterable = accumulate(my_list, func=operator.mul)
-------> print(list(my_iterable))  # prints [1, 2, 6, 12, 12]
-------> my_iterable = accumulate(my_list, func=max)
-------> print(list(my_iterable))  # prints [1, 2, 3, 3, 3]

---> groupby
-----> This similar to std::partition
-----> Example usage:
-------> from itertools import groupby
-------> def smaller_than_3(x):
------->     return x < 3
-------> my_list = [1, 2, 3, 4]
-------> groupby_object = groupby(my_list, key=smaller_than_3)
-------> #print(list(groupby_object))  # prints gibberish about a groupby object
-------> for key, value_iterable in groupby_object:
------->     print(key, list(value_iterable)) # prints True [1, 2] and False [3, 4]
-------> groupby_object = groupby(my_list, key=lambda x: x<3)  # can specify a lambda as well
-------> #print(list(groupby_object))  # prints gibberish about a groupby object
-------> for key, value_iterable in groupby_object:
------->     print(key, list(value_iterable)) # prints True [1, 2] and False [3, 4]

---> count
-----> This counts to infinity.
-----> Example usage:
-------> from itertools import count
-------> for i in count(10):  # generates a count from 10 to infinity
------->     print(i)
------->     break  # necessary break to avoid an infinite loop

---> cycle
-----> This cycles to an iterable.
-----> Example usage:
-------> from itertools import cycle
-------> my_list = [1, 2, 3]
-------> for i in cycle(my_list):  # cycles through the list infinitely
------->     print(i)
------->     break  # necessary break to avoid an infinite loop

---> repeat
-----> This repeats an object.
-----> Example usage:
-------> from itertools import repeat
-------> for i in repeat(1):  # repeats 1 infinitely
------->     print(i)
------->     break  # necessary break to avoid an infinite loop
-------> for i in repeat(1, 4):  # repeats 1 four times
------->     print(i)



-> lambda

---> Impromptu functions that evaluates the expression using the arguments and returns the result.
---> These are practically the same as a normal function.
---> These are normally used for functions that will be only be used once.
---> The format is lambda [ARGUMENTS]: [EXPRESSION]
---> Example usage:
-----> add10 = lambda x: x+10
-----> print(add10(5))
-----> mult = lambda x,y: x*y
-----> print(mult(2,7))
---> Example usage on sorted function:
-----> points = [(1, 2), (15, 1), (5, -1), (10, 4)]
-----> points_sorted_in_y = sorted(points, key=lambda x: x[1])  # key expects a function (which can be a lambda)
-----> points_sorted_by_sum = sorted(points, key=lambda x: x[0]+x[1])  # key expects a function (which can be a lambda)
-----> print(points)  # prints [(1, 2), (15, 1), (5, -1), (10, 4)]
-----> print(points_sorted_in_y)  # prints [(5, -1), (15, 1), (1, 2), (10, 4)]
-----> print(points_sorted_by_sum)  # prints [(1, 2), (5, -1), (10, 4), (15, 1)]
---> Example usage on map function (syntax wise its better to use list comprehension):
---> This is like the std::generate/std::generate_n function.
-----> my_list = [1, 2, 3, 4, 5]
-----> my_iterable = map(lambda x: x*2, my_list)
-----> print(list(my_iterable))  # prints [2, 4, 6, 8, 10]
---> Example usage on filter function (syntax wise its better to use list comprehension):
---> This is like the std::copy_if function.
-----> my_list = [1, 2, 3, 4, 5, 6]
-----> my_iterable = filter(lambda x: x%2==0, my_list)
-----> print(list(my_iterable))  # prints [2, 4, 6]
---> Example usage on filter function (syntax wise its better to use list comprehension):
---> This is like the std::accumulate/std::reduce function.
-----> from functools import reduce
-----> my_list = [1, 2, 3, 4, 5, 6]
-----> my_value = reduce(lambda x, y: x*y, my_list)
-----> print(my_value)  # prints 720









-> Timers

---> Get the duration
-----> from timeit import default_timer as timer
-----> start = timer()
-----> # do something here
-----> stop = timer()
-----> print(stop-start)



