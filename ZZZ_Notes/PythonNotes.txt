
-> THIS IS A GOOD RESOURCE: https://www.pythoncheatsheet.org/cheatsheet/basics

-> To format your code on Visual studio nn Windows: Shift + Alt + F.

-> Two major versions of python (python 2 and python 3)
---> Similar anyway if you learn python 3, you can easily learn python 2 as well



-> Modules

---> How to use your own module:
-----> import utilities
-----> print(utilities.compute_something())
---> Check python docs to know what modules you need:
-----> google: python docs list of modules
-----> https://docs.python.org/3/py-modindex.html
-----> Some libraries are built-in (you dont have to add them in the file) some are external (you have to manually add them thru import)
-------> Check your python installation directory and look for the lib folder.



-> pip

---> Some third party libraries can be installed using pip
---> Example (python-docx is libaries that write word documents):
-----> pip install python-docx
-------> If python is not added in PATH, you can find pip here and manually run it: C:\Users\detec\AppData\Local\Programs\Python\Python310\Scripts
-----> The libraries installed by pip are on the directory site-packages


-> Create your own standalone executable?
---> https://pyinstaller.org/en/stable/installation.html
---> PyInstaller bundles a Python application and all its dependencies into a single package.
---> The user can run the packaged app without installing a Python interpreter or any modules. 
---> Note: pyinstaller can be flagged a virus (happened to me with windows defender) 
-----> https://stackoverflow.com/questions/43777106/program-made-with-pyinstaller-now-seen-as-a-trojan-horse-by-avg



-> Virtual Environment

---> The use of a Virtual Environment is to test python code in encapsulated environments, 
---> and to also avoid filling the base Python installation with libraries we might use for only one project.
---> Check this python libaries:
-----> virtualenv
-----> Poetry
-----> Pipenv
-----> Anaconda



-> Python

---> Python is an easy to learn, powerful programming language.
---> Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development.



-> Basic Data Types in Python

---> (1) Integers
-----> In Python 3, there is effectively no limit to how long an integer value can be. 
-----> Of course, it is constrained by the amount of memory your system has, as are all things,
-----> but beyond that an integer can be as long as you need it to be.

---> (2) Floating-Point Numbers
-----> The float type in Python designates a floating-point number. 
-----> float values are specified with a decimal point. 
-----> Optionally, the character e or E followed by a positive or negative integer may be appended to specify scientific notation.

---> (3) Complex Numbers
-----> Complex numbers are specified as <real part>+<imaginary part>j.

---> (4) Strings
-----> Strings are sequences of character data. 
-----> The string type in Python is called str.

---> (5) Boolean Type
-----> Objects of Boolean type may have one of two values, True or False:

---> Type function
-----> You can use the type function to know the type.
-------> my_variable = 10
-------> print(type(my_variable))  # prints <class 'int'>



-> Operators

---> Math Operators (from Highest to Lowest precedence)
-----> (1) Exponent (**)
-------> 2 ** 3 = 8
-----> (2) Modulus/Remainder (%)
-------> 22 % 8 = 6
-----> (3) Integer division (//)
-------> 22 // 8 = 2
-----> (4) Division (/)
-------> 22 / 8 = 2.75
-----> (5) Multiplication (*)
-------> 3 * 3 = 9
-----> (6) Subtraction (-)
-------> 5 - 2 = 3
-----> (7) Addition (+)
-------> 2 + 2 = 4
-----> Examples of expressions:
-------> 2 + 3 * 6  # 20
-------> (2 + 3) \* 6  # 30
-------> 2 ** 8  #256
-------> 23 // 7  # 3
-------> 23 % 7  # 2
-------> (5 - 1) * ((7 + 1) / (3 - 1))  # 16.0

---> Augmented Assignment Operators
-----> var += 1 -> var = var + 1
-----> var -= 1 -> var = var - 1
-----> var *= 1 -> var = var * 1
-----> var /= 1 -> var = var / 1
-----> var %= 1 -> var = var % 1
-----> Examples:
-------> greeting = 'Hello'
-------> greeting += ' world!'
-------> print(greeting)  # 'Hello world!'
-------> number = 1
-------> number += 1
-------> print(number)  # 2
-------> my_list = ['item']
-------> my_list *= 3
-------> print(my_list)  # ['item', 'item', 'item']



-> Comments

---> Inline comment:
-----> # Single line comment
-----> # This is a
-----> # multiline comment

---> Multiline comment:
-----> '''
-----> These are also multiline comments.
-----> These are useful when debugging a chunk of code.
-----> But these are not recommended in terms of style (prefer to use single line comments).
-----> '''

---> Code with a comment:
-----> a = 1  # initialization
-----> NOTE: its good practice to have the two spaces in front of the comment.

---> Function docstring:
-----> def foo():
----->     """
----->     This is a function docstring
----->     You can also use:
----->     ''' Function Docstring '''
----->     """



-> Printing

---> The print() Function
-----> The print() function writes the value of the argument(s) it is given.
-----> It handles multiple arguments, floating point-quantities, and strings. 
-----> Strings are printed without quotes, and a space is inserted between items, so you can format things nicely:
-------> print('Hello world!')  # Hello world!
-------> a = 1
-------> print('Hello world!', a)  # Hello world! 1

-----> The end keyword
-------> The keyword argument end can be used to avoid the newline after the output, or end the output with a different string:
---------> phrase = ['printed', 'with', 'a', 'dash', 'in', 'between']
---------> for word in phrase:
--------->    print(word, end='-')  # printed-with-a-dash-in-between-

-----> The sep keyword
-------> The keyword sep specify how to separate the objects, if there is more than one:
---------> print('cats', 'dogs', 'mice', sep=',')  # cats,dogs,mice



-> Variables

---> Variable declaration rules:
-----> (1) It can be only one word.
-------> # bad
-------> my variable = 'Hello'
-------> # good
-------> var = 'Hello'
-----> (2) It can use only letters, numbers, and the underscore (_) character.
-------> # bad
-------> %$@variable = 'Hello'
-------> # good
-------> my_var = 'Hello'
-------> # good
-------> my_var_2 = 'Hello'
-----> (3) It can’t begin with a number.
-------> # this wont work
-------> 23_var = 'hello'
-----> (4) Variable name starting with an underscore (_) are considered as “unuseful”.
-------> # _span should not be used again in the code
-------> _spam = 'Hello'

---> Assigning variables:
-----> Assigning one variable per line:
-------> character_name = 'John'
-------> character_age = '35'
-----> Assigning multiple variables in one line:
-------> character_name, character_age = 'John', '35'

---> Printing variables:
-----> Using concatenation:
-------> print('There once was a man named ' + character_name + ', ')
-------> print('he was ' + character_age + ' years old. ')
-----> Using f-strings (better way, it can be used with integers and floats as well):
-------> print(f'There once was a man named {character_name}, ')  
-------> print(f'he was {character_age} years old. ')



-> Working with numbers

---> Integer
-----> print(2)  # prints 2

---> Floating value
-----> print(2.0987)  # prints 2.0987
-----> print(-2.0987)  # prints -2.0987

---> Math operations
-----> print(3*4.5)  # prints 13.5
-----> print(3*4+5)  # prints 17
-----> print(10 % 3)  # prints 1
-----> print(10 ** 3)  # prints 1000 (exponent function)
-----> print(10 / 3)  # prints 3.3333333333333335 (real division)
-----> print(10 // 3)  # prints 3 (integer division)


---> Number variables
-----> my_num = 5
-----> print(my_num)  # prints 5
-----> print(str(my_num))  # prints 5 (converts to string and then print)
-----> # print(my_num + ' is my favorite number') # error cause python does not automatically convert this
-----> print(str(my_num) + ' is my favorite number')  # prints 5 is my favorite number
-----> my_num = -5

---> Other operations
-----> print(my_num)  # prints -5
-----> print(abs(my_num))  # prints 5
-----> print(pow(my_num, 2))  # prints 25
-----> print(min(4, 6))  # prints 4
-----> print(max(4, 6))  # prints 6
-----> print(round(3.2))  # prints 3
-----> print(round(3.7))  # prints 4

---> Other operations with import
-----> from math import *
-----> print(floor(3.7))
-----> print(ceil(3.7))
-----> print(sqrt(36))



-> Getting Input From Users

---> The input() Function
-----> This function takes the input from the user and converts it into a string:
-------> print('What is your name?')   # ask for their name
-------> my_name = input()
-------> print('Hi, {}'.format(my_name))
-------> # What is your name?
-------> # Martha
-------> # Hi, Martha
-----> input() can also set a default message without using print():
-------> my_name = input('What is your name? ')  # default message
-------> print('Hi, {}'.format(my_name))
-------> # What is your name? Martha
-------> # Hi, Martha

---> Example with strings:
-----> name = input('Enter your name: ')  # gets input from user
-----> age = input('Enter your age: ')
-----> print('Hello ' + name + '! You are ' + age + '.')
---> NOTE: By default, python gets input as a string. 

---> Example with adding integers from user input:
-----> num1 = input('Enter a number: ')
-----> num2 = input('Enter another number: ')
-----> result = int(num1) + int(num2)
-----> print(result)

---> Example with adding floating numbers from user input:
-----> num1 = input('Enter a number: ')
-----> num2 = input('Enter another number: ')
-----> result = float(num1) + float(num2)
-----> print(result)



-> Commonly used functions

---> The len() Function
-----> Evaluates to the integer value of the number of characters in a string, list, dictionary, etc.:
-------> len('hello')  # 5
-------> len(['cat', 3, 'dog'])  # 3
-----> Test of emptiness (IMPORTANT)
-------> Test of emptiness of strings, lists, dictionaries, etc., should not use len, but prefer direct boolean evaluation.
-------> Test of emptiness example:
---------> a = [1, 2, 3]
---------> # bad
---------> if len(a) > 0:  # evaluates to True
--------->     print('the list is not empty!')
---------> # good
---------> if a: # evaluates to True
--------->     print('the list is not empty!')

---> The str(), int(), and float() Functions
-----> These functions allow you to change the type of variable. For example, you can transform from an integer or float to a string:
-------> str(29)  # '29'
-------> str(-3.14)  # '-3.14'
-----> Or from a string to an integer or float:
-----> int('11')  # 11
-----> float('3.14')  # 3.14

---> enumerate() function
-----> Often, when dealing with iterators, we also get need to keep a count of iterations. 
-----> Python eases the programmers’ task by providing a built-in function enumerate() for this task. 
-----> Enumerate() method adds a counter to an iterable and returns it in a form of enumerating object. 
-----> This enumerated object can then be used directly for loops or converted into a list of tuples using the list() method.
-----> Syntax:  enumerate(iterable, start=0)
-----> Example usage:
-------> my_list = ['Jim', 'Karen', 'Kevin']
-------> my_str = 'Steve'
-------> print (list(enumerate(my_list)))  # prints [(0, 'Jim'), (1, 'Karen'), (2, 'Kevin')]
-------> print (list(enumerate(my_str, 2)))  # prints [(2, 'S'), (3, 't'), (4, 'e'), (5, 'v'), (6, 'e')]



-> Time/Timers

---> Get the duration
-----> from timeit import default_timer as timer
-----> start = timer()
-----> # do something here
-----> stop = timer()
-----> print(stop-start)

---> Sleep
-----> import time
-----> time.sleep(0.8)



-> Built-in Functions

---> abs() -> Return the absolute value of a number.
---> aiter() -> Return an asynchronous iterator for an asynchronous iterable.
---> all() -> Return True if all elements of the iterable are true.
---> any() -> Return True if any element of the iterable is true.
---> ascii() -> Return a string with a printable representation of an object.
---> bin() -> Convert an integer number to a binary string.
---> bool() -> Return a Boolean value.
---> breakpoint() -> Drops you into the debugger at the call site.
---> bytearray() -> Return a new array of bytes.
---> bytes() -> Return a new “bytes” object.
---> callable() -> Return True if the object argument is callable, False if not.
---> chr() -> Return the string representing a character.
---> classmethod() -> Transform a method into a class method.
---> compile() -> Compile the source into a code or AST object.
---> complex() -> Return a complex number with the value real + imag*1j.
---> delattr() -> Deletes the named attribute, provided the object allows it.
---> dict() -> Create a new dictionary.
---> dir() -> Return the list of names in the current local scope.
---> divmod() -> Return a pair of numbers consisting of their quotient and remainder.
---> enumerate() -> Return an enumerate object.
---> eval() -> Evaluates and executes an expression.
---> exec() -> This function supports dynamic execution of Python code.
---> filter() -> Construct an iterator from an iterable and returns true.
---> float() -> Return a floating point number from a number or string.
---> format() -> Convert a value to a “formatted” representation.
---> frozenset() -> Return a new frozenset object.
---> getattr() -> Return the value of the named attribute of object.
---> globals() -> Return the dictionary implementing the current module namespace.
---> hasattr() -> True if the string is the name of one of the object’s attributes.
---> hash() -> Return the hash value of the object.
---> help() -> Invoke the built-in help system.
---> hex() -> Convert an integer number to a lowercase hexadecimal string.
---> id() -> Return the “identity” of an object.
---> input() -> This function takes an input and converts it into a string.
---> int() -> Return an integer object constructed from a number or string.
---> isinstance() -> Return True if the object argument is an instance of an object.
---> issubclass() -> Return True if class is a subclass of classinfo.
---> iter() -> Return an iterator object.
---> len() -> Return the length (the number of items) of an object.
---> list() -> Rather than being a function, list is a mutable sequence type.
---> locals() -> Update and return a dictionary with the current local symbol table.
---> map() -> Return an iterator that applies function to every item of iterable.
---> max() -> Return the largest item in an iterable.
---> min() -> Return the smallest item in an iterable.
---> next() -> Retrieve the next item from the iterator.
---> object() -> Return a new featureless object.
---> oct() -> Convert an integer number to an octal string.
---> open() -> Open file and return a corresponding file object.
---> ord() -> Return an integer representing the Unicode code point of a character.
---> pow() -> Return base to the power exp.
---> print() -> Print objects to the text stream file.
---> property() -> Return a property attribute.
---> repr() -> Return a string containing a printable representation of an object.
---> reversed() -> Return a reverse iterator.
---> round() -> Return number rounded to ndigits precision after the decimal point.
---> set() -> Return a new set object.
---> setattr() -> This is the counterpart of getattr().
---> slice() -> Return a sliced object representing a set of indices.
---> sorted() -> Return a new sorted list from the items in iterable.
---> staticmethod() -> Transform a method into a static method.
---> str() -> Return a str version of object.
---> sum() -> Sums start and the items of an iterable.
---> super() -> Return a proxy object that delegates method calls to a parent or sibling.
---> tuple() -> Rather than being a function, is actually an immutable sequence type.
---> type() -> Return the type of an object.
---> vars() -> Return the dict attribute for any other object with a dict attribute.
---> zip() -> Iterate over several iterables in parallel.
---> import() -> This function is invoked by the import statement.



-> Control Flow

---> Control flow is the order in which individual statements, instructions, or function calls are executed or evaluated. 
---> The control flow of a Python program is regulated by conditional statements, loops, and function calls.

-> Comparison Operators
---> Equal to(==)
---> Not equal to (!=)
---> Less than (<)
---> Greater Than (>)
---> Less than or Equal to (<=)
---> Greater than or Equal to (>=)
---> These operators evaluate to True or False depending on the values you give them.
---> Examples usage:
-----> 42 == 42  # True
-----> 40 == 42  # False
-----> 'hello' == 'hello'  # True
-----> 'hello' == 'Hello'  # False
-----> 'dog' != 'cat'  # True
-----> 42 == 42.0  # True
-----> 42 == '42'  # False

-> Boolean Operators

---> There are three Boolean operators: and, or, and not.
-----> The and Operator’s Truth Table:
-------> True and True = True
-------> True and False = False
-------> False and True = False
-------> False and False = False
-----> The or Operator’s Truth Table:
-------> True or True = True
-------> True or False = True
-------> False or True = True
-------> False or False = False
-----> The not Operator’s Truth Table:
-------> not True = False
-------> not False = True

-> Mixing Boolean and Comparison Operators
---> (4 < 5) and (5 < 6)  # True
---> (4 < 5) and (9 < 6)  # False
---> (1 == 2) or (2 == 2)  # True
---> You can also use multiple Boolean operators in an expression, along with the comparison operators:
-----> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2  # True



-> if Statements

---> Python recognizes 'if', 'elif', 'else' as the keywords for if statements.

---> The if statement evaluates an expression, and if that expression is True, it then executes the following indented code:
-----> name = 'Debora'
-----> if name == 'Debora':
----->     print('Hi, Debora')  # Hi, Debora
-----> if name != 'George':
----->     print('You are not George')  # You are not George

---> The else statement executes only if the evaluation of the if and all the elif expressions are False:
-----> name = 'Debora'
-----> if name == 'George':
----->     print('Hi, George.')
-----> else:
----->     print('You are not George')  # You are not George

---> Only after the if statement expression is False, the elif statement is evaluated and executed:
-----> name = 'George'
-----> if name == 'Debora':
----->     print('Hi Debora!')
-----> elif name == 'George':
----->     print('Hi George!')  # Hi George!

---> the elif and else parts are optional.
-----> name = 'Antony'
-----> if name == 'Debora':
----->     print('Hi Debora!')
-----> elif name == 'George':
----->     print('Hi George!')
-----> else:
----->     print('Who are you?') # Who are you?

---> if statements example with boolean variables:
-----> is_male = True
-----> is_tall = True
-----> if is_male or is_tall:
----->     print('You are a male or tall or both.')
-----> else:
----->     print('You are neither male nor tall.')
-----> if is_male and is_tall:
----->     print('You are a tall male.')
-----> elif is_male and not(is_tall):
----->     print('You are a short male.')
-----> elif not(is_male) and is_tall:
----->     print('You are not a male but are tall.')
-----> else:
----->     print('You are either not a male and not tall.')

---> if statements example with comparison operators:
-----> def is_equal(parameter1, parameter2):
----->     return parameter1 == parameter2
-----> def is_not_equal(parameter1, parameter2):
----->     return parameter1 != parameter2
-----> def max_of_three(num1, num2, num3):
----->     if num1 >= num2 and num1 >= num3:
----->         return num1
----->     elif num2 >= num2 and num2 >= num3:
----->         return num2
----->     else:
----->         return num3
-----> print(is_equal(1, 1))  # prints True
-----> print(is_equal(1, 2))  # prints False
-----> print(is_equal('Jose', 'Jose'))  # prints True
-----> print(is_equal('Jose', 'Pancho'))  # prints False
-----> print(is_not_equal(1, 1))  # prints False
-----> print(is_not_equal(1, 2))  # prints True
-----> print(is_not_equal('Jose', 'Jose'))  # prints False
-----> print(is_not_equal('Jose', 'Pancho'))  # prints True
-----> print(max_of_three(1, 2, 3))  # prints 3
-----> print(max_of_three(300, 40, 5))  # prints 300
-----> print(max_of_three('300', '40', '5'))  # prints 5 (lexicographically compared)

---> if statements example in a calculator:
-----> num1 = float(input('Enter first number:'))
-----> op = input('Enter operator:')
-----> num2 = float(input('Enter second number:'))
-----> if op == '+':
----->     print(num1+num2)
-----> elif op == '-':
----->     print(num1-num2)
-----> elif op == '*':
----->     print(num1*num2)
-----> elif op == '/':
----->     print(num1/num2)
-----> else:
----->     print('Invalid operator.')



-> Ternary Conditional Operator

---> Many programming languages have a ternary operator, which define a conditional expression. 
---> The most common usage is to make a terse, simple conditional assignment statement. 
---> In other words, it offers one-line code to evaluate the first expression if the condition is true, and otherwise it evaluates the second expression.
---> Format is: <expression1> if <condition> else <expression2>

---> Basic Example:
-----> # Using if statements
-----> age = 15
-----> # this if statement:
-----> if age < 18:
----->     print('kid')  # prints kid
-----> else:
----->     print('adult')
-----> # Using ternary operator
-----> print('kid' if age < 18 else 'adult')  # prints kid

---> Ternary operators can be chained:
-----> # Using if statements
-----> if age < 18:
----->      if age < 13:
----->          print('kid')
----->      else:
----->          print('teen')  # prints teen
-----> else:
----->      print('adult')
-----> age = 15
-----> # Using ternary operator
-----> print('kid' if age < 13 else 'teen' if age < 18 else 'adult')  # prints teen

---> Ternary operator example in a toggle switch:
-----> toggle_switch = True if toggle_switch == False else False



-> while Loop Statements

---> The while statement is used for repeated execution as long as an expression is True:
-----> spam = 0
-----> while spam < 5:
----->      print('Hello, world.')
----->      spam = spam + 1

---> break Statements
-----> If the execution reaches a break statement, it immediately exits the while loop’s clause:
-------> while True:
------->      name = input('Please type your name: ')
------->      if name == 'your name':
------->          break
-------> print('Thank you!')

---> continue Statements
-----> When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop.
-------> while True:
------->      name = input('Who are you? ')
------->      if name != 'Joe':
------->          continue
------->      password = input('Password? (It is a fish.): ')
------->      if password == 'swordfish':
------->          break
-------> print('Access granted.')

---> while loop example that counts from 1 to 10:
-----> i = 1
-----> while i <= 10:
----->     print(i)
----->     # i++ # The operator ++ does not exist
----->     i += 1
-----> print('Done with loop')secret_word = 'giraffe'

---> while loop example in a guessing game:
-----> guess = ''
-----> guess_count = 0
-----> guess_limit = 3
-----> while guess != secret_word and guess_count < guess_limit:
----->     guess = input('Enter guess: ')
----->     guess_count += 1
-----> if guess_count < guess_limit:
----->     print('You win!')
-----> else:
----->     print('Out of guesses!')



-> for loop

---> The for loop iterates over a list, tuple, dictionary, set or string:
-----> pets = ['Bella', 'Milo', 'Loki']
-----> for pet in pets:
----->      print(pet)

---> The range() function
-----> The range() function returns a sequence of numbers. It starts from 0, increments by 1, and stops before a specified number:
-------> for i in range(5):
------->      print(f'Will stop at 5! or 4? ({i})')
-----> The range() function can also modify it’s 3 defaults arguments. 
-----> The first two will be the start and stop values, and the third will be the step argument. 
-----> The step is the amount that the variable is increased by after each iteration.
-------> for i in range(start=0, stop=10, step=2):
------->     print(i)  # prints even numbers from 0 to 8 
-----> You can even use a negative number for the step argument to make the for loop count down instead of up.
-------> for i in range(5, -1, -1):
------->     print(i)  # prints decreasing numbers from 5 to -1 

---> For else statement
-----> This allows to specify a statement to execute in case of the full loop has been executed. 
-----> Only useful when a break condition can occur in the loop:
-------> for i in [1, 2, 3, 4, 5]:
------->     if i == 3:
------->         break
-------> else:
------->     print('only executed when no item is equal to 3')

-> for loop example with a 2D list:
---> number_grid = [
--->     [1, 2, 3],
--->     [4, 5, 6],
--->     [7, 8, 9],
--->     [0]
---> ]
---> print(number_grid[0][0])  # prints 1
---> print(number_grid[2][1])  # prints 8
---> for row in number_grid:
--->     for col in row:
--->         print(col)  # prints all elements in the grid

->  for loop converter example that converts all vowels to g
---> def translate(phrase):
--->     # this function converts all the vowels to g
--->     result=''
--->     for letter in phrase:
--->         if letter.lower() in 'aeiou': # letter is a vowel
--->             result += 'g'
--->         else:
--->             result += letter  # its better to use join method instead of appending continuously
--->     return result
---> print(translate(input('Enter a phrase: ')))



-> Ending a Program with sys.exit()

---> exit() function allows exiting Python.
-----> import sys
-----> while True:
----->      feedback = input('Type exit to exit: ')
----->      if feedback == 'exit':
----->          sys.exit()
----->      print(f'You typed {feedback}.')  # prints You typed exit



-> Functions

---> Python recognizes 'def' as the keyword for functions
---> The code the goes inside the function needs to be indented.
---> Functions provide better modularity for your application and reuse-ability.

---> Function arguments
-----> A function can take arguments and return values:
-----> In the following example, the function say_hello receives the argument “name” and prints a greeting:
-------> def say_hello(name):
------->     print(f'Hello {name}')
-------> say_hello('Carlos')  # prints Hello Carlos
-------> say_hello('Wanda'))  # prints Hello Wanda
-------> say_hello('Rose'))  # prints Hello Rose

---> Keyword Arguments
-----> To improve code readability, we should be as explicit as possible. We can achieve this in our functions by using Keyword Arguments:
-------> def say_hi(name, greeting):
------->     print(f'{greeting} {name}')
-------> # without keyword arguments
-------> say_hi('John', 'Hello')  # prints Hello John
-------> # with keyword arguments
-------> say_hi(name='Anna', greeting='Hi')  # prints Hi Anna

---> Return Values
-----> When creating a function using the def statement, you can specify what the return value should be with a return statement. 
-----> A return statement consists of the following:
-------> (1) The return keyword.
-------> (2) The value or expression that the function should return.
-----> Example usage:
-------> def sum_of_two_numbers(number_1, number_2):
------->     return number_1 + number_2
------->     print('This is will not be printed')  # The functions exists at the return statement so this line will not be executed.
-------> result = sum_of_two_numbers(7, 8)
-------> print(result)  # prints 15

---> Local and Global Scope
-----> Code in the global scope cannot use any local variables.
-----> However, a local scope can access global variables.
-----> Code in a function’s local scope cannot use variables in any other local scope.
-----> You can use the same name for different variables if they are in different scopes. 
-----> That is, there can be a local variable named spam and a global variable also named spam.
-----> Example usage:
-------> global_variable = 'I am available everywhere'
-------> def some_function():
------->      print(global_variable)  # because is global
------->      local_variable = 'only available within this function'
------->      print(local_variable)  # NameError: name 'local_variable' is not defined
-------> # the following code will throw error because
-------> # 'local_variable' only exists inside 'some_function'
-------> print(local_variable)

---> The global Statement
-----> If you need to modify a global variable from within a function, use the global statement:
-------> def spam():
------->      global eggs
------->      eggs = 'spam'
-------> eggs = 'global'
-------> spam()
-------> print(eggs)

---> There are four rules to tell whether a variable is in a local scope or global scope:
-----> (1) If a variable is being used in the global scope (that is, outside all functions), then it is always a global variable.
-----> (2) If there is a global statement for that variable in a function, it is a global variable.
-----> (3) Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.
-----> (4) But if the variable is not used in an assignment statement, it is a global variable.

---> Lambda Functions (check lambda functions section)



-> with statement (and context managers)

---> The with statement in Python is used in exception handling to make the code cleaner and much more readable. 
-----> It simplifies the management of common resources like file streams. 

---> Basic example (comparison without 'with statement'):
-----> # without using 'with statement'
-----> file = open('file_path', 'w')
-----> try:
----->     file.write('hello world')
-----> finally:
----->     file.close()
-----> # using with 'with statement'
-----> with open('file_path', 'w') as file:
----->     file.write('hello world !')

---> Supporting the 'with' statement in user defined objects
-----> Supporting the with statement in your objects will ensure that you never leave any resource open.
-----> To use with statement, you only need to add the methods __enter__() and __exit__() in the object methods.  
-------> # a simple file writer object
-------> class MessageWriter(object):
------->     def __init__(self, file_name):
------->         self.file_name = file_name
------->     def __enter__(self):
------->         self.file_stream = open(self.file_name, 'w')
------->         return self.file_stream
------->     def __exit__(self, exception_type, exception_value, exception_traceback):
------->         if self.file_stream:
------->             self.file_stream.close()
------->         # You can handle exceptions here via the exception parameters.
------->         # You can 'return True' and not stop the exception from being propagating after this function
-------> # using with statement with MessageWriter
-------> with MessageWriter('my_file.txt') as my_file:
------->     my_file.write('Writing some stuffs to file')

---> Context managers
-----> A context manager is an object that is notified when a context (a block of code) starts and ends. 
-----> You commonly use one with the with statement. 
-----> It takes care of the notifying.
-----> For example, file objects are context managers. 
-----> When a context ends, the file object is closed automatically:
-------> with open(filename) as f:
------->     file_contents = f.read()
-----> Anything that ends execution of the block causes the context manager’s exit method to be called. 
-----> This includes exceptions, and can be useful when an error causes you to prematurely exit an open file or connection. 
-----> Exiting a script without properly closing files/connections is a bad idea, that may cause data loss or other problems (resource leak). 
-----> By using a context manager, you can ensure that precautions are always taken to prevent damage or loss in this way.

---> The contextlib module
-----> The contextlib module provides a few more abstractions built upon the basic context manager interface.
-----> Here is how we can rewrite the context manager for the MessageWriter object using the contextlib module.
-------> import contextlib
-------> class MessageWriter(object):
------->     def __init__(self, file_name):
------->         self.file_name = file_name
------->     @contextlib.contextmanager
------->     def open_file(self):
------->         try:
------->             file = open(self.file_name, 'w')
------->             yield file  # this is generator
------->         finally:
------->             file.close()
-------> # write to file
-------> message_writer = MessageWriter('my_file.txt')
-------> with message_writer.open_file() as my_file:  # uses a function instead of a whole class
------->     my_file.write('Writing some stuffs to file')
-------> # print file contents
-------> with open('my_file.txt', 'r') as my_file:  # uses a function instead of a whole class
------->     print(my_file.read())  # prints Writing some stuffs to file



-> pass keyword

---> The pass statement is used as a placeholder for future code.
---> When the pass statement is executed, nothing happens, but you avoid getting an error when empty code is not allowed.
---> Empty code is not allowed in loops, function definitions, class definitions, or in if statements.

---> Pass keyword used in a function:
-----> def myfunction():
----->     pass



-> Main top-level script environment

---> __main__ is the name of the scope in which top-level code executes. 
-----> A module’s name is set equal to __main__ when read from standard input, a script, or from an interactive prompt.
---> A module can discover whether it is running in the main scope by checking its own __name__, 
-----> which allows a common idiom for conditionally executing code in a module. 
-----> When it is run as a script or with python -m but not when it is imported:
-------> if __name__ == "__main__":
------->     # execute only if run as a script
------->     main()

---> For a package, the same effect can be achieved by including a main.py module, 
-----> the contents of which will be executed when the module is run with -m.
-----> For example, we are developing a script designed to be used as a module, we should do:
-------> def add(a, b):
------->     return a+b
-------> if __name__ == "__main__":
------->     add(3, 5)

---> Advantages
-----> (1) Every Python module has it’s __name__ defined and if this is __main__, 
-------> it implies that the module is run standalone by the user, and we can do corresponding appropriate actions.
-----> (2) If you import this script as a module in another script, the name is set to the name of the script/module.
-----> (3) Python files can act as either reusable modules, or as standalone programs.
-----> (4) if __name__ == “main”: is used to execute some code only if the file run directly, and is not being imported.



-> enum class

---> Enum is a class in python for creating enumerations, which are a set of symbolic names (members) bound to unique, constant values.
---> The members of an enumeration can be compared by these symbolic anmes, and the enumeration itself can be iterated over. 
---> An enum has the following characteristics.
-----> The enums are evaluatable string representation of an object also called repr().
-----> The name of the enum is displayed using ‘name’ keyword.
-----> Using type() we can check the enum types.

---> Example usage:
-----> import enum
-----> # Using enum class create enumerations
-----> class Days(enum.Enum):
----->    Sun = 1
----->    Mon = 2
----->    Tue = 3
-----> print(Days.Mon)



-> Classes and objects

---> Simple example:
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa, is_on_probation):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
------->         self.is_on_probation = is_on_probation
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student('Jim', 'Business', 3.1, False)  # the initializer is called
-------> student2 = Student('Pam', 'Art', 2.5, True)
-------> print(student1.gpa)
-------> print(student2.gpa)

---> Multiple choice questionaire:
-----> On utilities.py:
-------> class Question:
------->     def __init__(self, prompt, answer):
------->         self.prompt = prompt
------->         self.answer = answer
-----> On application.py:
-------> from utilities import Question  # from utilities file import the Question class
-------> questions_prompts = [
------->     'What color are apples?\n(a) Red/Green\n(b) Purple\n(c) Orange\n\n',
------->     'What color are bananas?\n(a) Teal\n(b) Magenta\n(c) Yellow\n\n',
------->     'What color are strawberries?\n (a) Yellow\n(b) Red\n(c) Blue\n\n'
-------> ]
-------> questions = [
------->     Question(questions_prompts[0], 'a'),
------->     Question(questions_prompts[1], 'c'), 
------->     Question(questions_prompts[2], 'b')
------->     ]
-------> def run_test(questions):
------->     score = 0
------->     for question in questions:
------->         answer = input(question.prompt)
------->         if answer == question.answer:
------->             score+=1
------->     print('You got ' + str(score) +  '/' + str(len(questions))+ ' correct')
-------> run_test(questions)

---> Student Honor Roll (in class function example):
-----> On utilities.py:
-------> class Student:
------->     def __init__(self, name, major, gpa):
------->         self.name = name
------->         self.major = major
------->         self.gpa = gpa
-------> 
------->     def is_on_honor_roll(self):
------->         if self.gpa >= 3.5: 
------->             return True
------->         else:
------->             return False
-----> On application.py:
-------> from utilities import Student  # from utilities file import the Student class
-------> student1 = Student('Oscar', 'Accounting', 3.1)
-------> student2 = Student('Phyllis', 'Business', 3.8)
-------> print(student1.is_on_honor_roll())
-------> print(student2.is_on_honor_roll())

---> Chef (inheritance example):
-----> On utilities.py:
-------> class Chef:
------->     def make_chicken(self):
------->         print('The chef makes a chicken.')
------->     def make_salad(self):
------->         print('The chef makes a salad.')
------->     def make_special_dish(self):
------->         print('The chef makes bbq ribs.')
-------> class Chinese_Chef(Chef):
------->     def make_special_dish(self):
------->         print('The chef makes orange chicken.')
------->     def make_fried_rice(self):
------->         print('The chef makes fried rice.')
-----> On application.py:
-------> from utilities import Chef, Chinese_Chef
-------> my_chef = Chef()
-------> my_chef.make_special_dish()
-------> my_chinese_chef=Chinese_Chef()
-------> my_chinese_chef.make_special_dish()

---> Inheritance notes:
-----> You can access the super class by using 'super().'



-> Python Dataclasses

---> Dataclasses are python classes, but are suited for storing data objects. 
-----> This module provides a decorator and functions for automatically adding generated special methods such as __init__() and __repr__() to user-defined classes.

---> Features
-----> They store data and represent a certain data type. Ex: A number. 
-------> For people familiar with ORMs, a model instance is a data object. 
-------> It represents a specific kind of entity. 
-------> It holds attributes that define or represent the entity.
-----> They can be compared to other objects of the same type. Ex: A number can be greater than, less than, or equal to another number.

---> Python 3.7 provides a decorator dataclass that is used to convert a class into a dataclass.
-----> 'class number' originally:
-------> class Number:
------->     def __init__(self, val):
------->         self.val = val
-------> obj = Number(2)
-------> print(obj.val)  # prints 2
-----> 'class number' as a dataclass:
-------> @dataclass
-------> class Number:
------->     val: int
-------> obj = Number(2)
-------> print(obj.val)  # prints 2

---> Default values
-----> It is easy to add default values to the fields of your data class.
-------> @dataclass
-------> class Product:
------->     name: str
------->     count: int = 0
------->     price: float = 0.0
-------> obj = Product("Python")
-------> print(obj.name)  # prints Python
-------> print(obj.count)  # prints 0
-------> print(obj.price)  # prints 0.0

---> Type hints
-----> It is mandatory to define the data type in dataclass. 
-------> However, If you would rather not specify the datatype then, use typing.Any.
-------> from dataclasses import dataclass
-------> from typing import Any
-------> @dataclass
-------> class WithoutExplicitTypes:
------->     name: Any
------->     value: Any = 42



-> Strings

---> Python recognizes "" (double quotes) or '' (single quotes) as the wrapper for strings
---> Strings are Homogeneous (characters are the only contents)
---> Strings are Immutable (once its created you cannot change it)
---> Strings allows duplicate elements 
---> Strings are used in text representation
---> Note: Unlike in C++, there are no characters in python (they are strings as well)
-----> Note: Hence, all examples below apply to a single character or a substring.

---> Escape characters
-----> An escape character is created by typing a backslash \ followed by the character you want to insert.
-----> Examples:
-------> Single quote (\')
-------> Double quote (\')
-------> Tab (\t)
-------> Newline (line break) (\n)
-------> Backslash (\\)
-------> Backspace (\b)
-------> Octal value (\ooo)
-------> Carriage Return (\r)

---> Printing
-----> print('Giraffe\nAcademy')  # line breaks can inserted on strings
-----> print('Giraffe\'Academy')  # escape character needed for special characters
-----> print('Giraffe', 'Academy')  # prints Giraffe Academy

---> Raw strings
-----> A raw string entirely ignores all escape characters and prints any backslash that appears in the string.
-------> raw_string = r'Hello there!\nHow are you?\nI\'m doing fine.'
-------> non_raw_string = 'Hello there!\nHow are you?\nI\'m doing fine.'
-------> print(raw_string)  # prints Hello there!\nHow are you?\nI\'m doing fine.
-------> print(non_raw_string)  # prints Hello there![Newline]How are you?[Newline]I\'m doing fine.

---> Construction (with quotes):
-----> my_string1 = 'Using single quotes'  # single quotes are probably more common in practice
-----> my_string2 = "Using double quotes"
-----> my_string3 = 'Escaping single quotes \'\''
-----> my_string4 = "Double quotes to have single quotes ''"
-----> my_string5 = 'Escaping double quotes \"\"'
-----> my_string6 = 'Single quotes to have double quotes ""'
-----> my_string7 = """This is a multi line...
-----> string"""  # This is also used for multi line comments
-----> my_string8 = """This is a single line \
-----> string"""  # Backslash (\) can be used to escape new line to form a single line
-----> print(my_string1)  # prints Using single quotes
-----> print(my_string2)  # prints Using double quotes
-----> print(my_string3)  # prints Escaping single quotes ''
-----> print(my_string4)  # prints Double quotes to have single quotes ''
-----> print(my_string5)  # prints Escaping double quotes ""
-----> print(my_string6)  # prints Single quotes to have double quotes ""
-----> print(my_string7)  # prints This is a multi line...\n string
-----> print(my_string8)  # prints This is a single line string

---> Construction (with replication)
-------> my_string1 = 'ThisWillRepeat' * 3
-------> print(my_string1)  # ThisWillRepeatThisWillRepeatThisWillRepeat

---> Construction (with concatenation)
-------> my_string1 = 'String1' 'String2'
-------> print(my_string1)  # String1String2

---> Concatenation
-----> greeting = 'Hello'
-----> name = 'Tom'
-----> sentence = greeting + ' ' + name  # plus (+) is concatenation
-----> print(sentence)

---> Slicing:
-----> # Note: Remember splicing arguments are start_index:end_index:step_size
-----> phrase = 'Giraffe Academy'
-----> print(phrase[1:])  # prints iraffe Academy (you can slice using a starting point)
-----> print(phrase[1:3])  # prints ir (you can slice using a range, half open at the end)
-----> print(phrase[:3])  # prints Gir (you can slice using an ending point, half open at the end)
-----> print(phrase[0::2])  # prints GrfeAaey (starts at index 0, then take every second item in the list (step index 2))
-----> print(phrase[::-1])  # prints ymedacA effariG (reverse of the list (step index -1))

---> Length
-----> phrase = 'Giraffe Academy'
-----> print(len(phrase))  # prints the length

---> Element access
-----> phrase = 'Giraffe Academy'
-----> print(phrase[0])  # prints G
-----> print(phrase[-1])  # prints y
-----> print(phrase[-2])  # prints m
-----> # phrase[0]= 'B'  # TypeError: 'str' object does not support item assignment (strings are immutable)

---> Iteration
-----> phrase = 'Giraffe Academy'
-----> for character in phrase:
----->     print(character)  # prints every character

---> if statement to check if substring (or character) exist in the string
-----> phrase = 'Giraffe Academy'
-----> if 'ell' in phrase:
----->     print('yes')  # prints yes
-----> else:
----->     print('no')

---> Index search
-----> phrase = 'Giraffe Academy'
-----> print(phrase.index('a'))  # prints 3 (gets the index)
-----> print(phrase.index('Acad'))  # prints 8 (gets the index)
-----> # print(phrase.index('z')) # returns an error ('z' does not exist on the string)

---> Case modifiers
-----> phrase = 'Giraffe Academy'
-----> print(phrase.lower())  # converts to lower case
-----> print(phrase.upper())  # converts to upper case

---> Case checkers
-----> phrase = 'Giraffe Academy'
-----> print(phrase.isupper())  # prints False
-----> print(phrase.upper().isupper())  # prints True
-----> print(phrase.islower())  # prints False
-----> print(phrase.lower().islower())  # prints True

---> Edge checkers
-----> phrase = 'Giraffe Academy'
-----> print(phrase.startswith('H'))  # prints False
-----> print(phrase.startswith('G'))  # prints True
-----> print(phrase.startswith('Gira'))  # prints True
-----> print(phrase.endswith('x'))  # prints False
-----> print(phrase.endswith('y'))  # prints True
-----> print(phrase.endswith('demy'))  # prints True

---> The is... string methods
-----> isalpha() -> returns True if the string consists only of letters.
-----> isalnum() -> returns True if the string consists only of letters and numbers.
-----> isdecimal() -> returns True if the string consists only of numbers.
-----> isspace() -> returns True if the string consists only of spaces, tabs, and new-lines.
-----> istitle() -> returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase characters.

---> Count matches
-----> phrase = 'Giraffe Academy'
-----> print(phrase.count('a'))  # prints 2
-----> print(phrase.count('ff'))  # prints 1
-----> print(phrase.count('x'))  # prints 0

---> Removing whitespace on the edges
-----> phrase = '           Giraffe      Academy          '
-----> phrase = phrase.strip()  # prints Giraffe      Academy
-----> print(phrase)

---> Removing whitespace with strip(), rstrip(), and lstrip()
-----> spam = '    Hello World     '
-----> print(spam.strip())  # prints 'Hello World'
-----> print(spam.lstrip())  # prints 'Hello World '
-----> print(spam.rstrip())  # prints '    Hello World'

---> Removing characters on the edges
-----> spam = 'SpamSpamBaconSpamEggsSpamSpam'
-----> print(spam.strip('ampS'))  # prints 'BaconSpamEggs'

---> Find and replace
-----> phrase = 'Giraffe Academy'
-----> print(phrase.replace('Giraffe', 'Elephant'))  # replace string with another string
-----> print(phrase.replace('Ant', 'Insect'))  # it does not replace when its not found (no error)

---> Split string into a list of substrings (using split)
-----> my_string = 'How are you doing?'
-----> my_list = my_string.split(); # by default its splits by space
-----> print(my_list)  # prints ['How', 'are', 'you', 'doing?']
-----> my_string = 'item1,item2,item3'
-----> my_list = my_string.split(','); # you can specify the delimiter
-----> print(my_list)  # prints ['item1', 'item2', 'item3']

---> Concatenate an iterable of strings into one string (using join)
-----> my_list = ['This', 'Is', 'Supposed', 'To', 'Be', 'A', 'Sentence']
-----> string_without_spaces = ''.join(my_list)
-----> string_with_spaces = ' '.join(my_list)
-----> string_with_commas = ','.join(my_list)
-----> print(string_without_spaces)  # prints ThisIsSupposedToBeASentence
-----> print(string_with_spaces)  # prints This Is Supposed To Be A Sentence
-----> print(string_with_commas)  # This,Is,Supposed,To,Be,A,Sentence
---> Note: Use the .join method instead and DONT append repetitively (THIS IS BAD PYTHON CODE, its much slower)
-----> # this is bad python code
-----> my_list = ['This', 'Is', 'Supposed', 'To', 'Be', 'A', 'Sentence']
-----> my_string = str()
-----> for i in my_list : 
----->     my_string += i  # this is an expensive step
-----> print(my_string) 

---> Justifying text with rjust(), ljust() and center()
-----> phrase = 'Giraffe Academy'
-----> print(phrase.rjust(20))  # prints [     Giraffe Academy]
-----> print(phrase.ljust(20))  # prints [Giraffe Academy     ]
-----> print(phrase.center(20))  # prints [  Giraffe Academy   ]
-----> print(phrase.rjust(20, '*'))  # prints [*****Giraffe Academy]
-----> print(phrase.ljust(20, '-'))  # prints [Giraffe Academy-----]
-----> print(phrase.center(20, '='))  # prints [==Giraffe Academy===]



-> String Formatting

---> The formatting operations described here (% operator) exhibit a variety of quirks that lead to a number of common errors. 
---> Using the newer formatted string literals helps avoid these errors. 
---> These alternatives also provide more powerful, flexible and extensible approaches to formatting text. 

---> Formatting using % operator (the old way)
-----> For new code, using str.format, or formatted string literals (Python 3.6+) over the % operator is strongly recommended. 
-----> Example usage:
-------> stringItem = 'Tom'
-------> numberItem = 123.45678
-------> my_string1 = 'The item is [%s].' % stringItem
-------> my_string2 = 'The item is [%d].' % numberItem
-------> my_string3 = 'The item is [%f].' % numberItem
-------> my_string4 = 'The item is [%.3f].' % numberItem
-------> print(my_string1)
-------> print(my_string2)
-------> print(my_string3)
-------> print(my_string4)

---> Formatting using str.format (a preferred way)
-----> This is available in python 3
-----> Example usage:
-------> stringItem = 'Tom'
-------> numberItem = 123.45678
-------> my_string1 = 'The item is [{}].'.format(stringItem)
-------> my_string2 = 'The item is [{:3d}].'.format(numberItem)
-------> my_string3 = 'The item is [{:.2f}].'.format(numberItem)
-------> my_string4 = 'The items are [{}, {:.2f}].'.format(stringItem, numberItem)
-------> print(my_string1)
-------> print(my_string2)
-------> print(my_string3)
-------> print(my_string4)

---> Formatting using fstrings (formatted strings) (this is the newest and best way)
-----> This is available in python 3.6 or newer.
-----> A formatted string literal or f-string is a string literal that is prefixed with `f` or `F`. 
-----> These strings may contain replacement fields, which are expressions delimited by curly braces {}. 
-----> While other string literals always have a constant value, formatted strings are really expressions evaluated at run time. 
-----> Example usage:
-------> stringItem = 'Tom'
-------> numberItem = 123.45678
-------> my_string1 = f'The item is [{stringItem}].'
-------> my_string2 = f'The item is [{numberItem}].'
-------> my_string3 = f'The item is [{numberItem:.2f}].'
-------> my_string3 = f'The items are [{stringItem}, {numberItem:.2f}].'
-------> my_string3 = f'The items are [{stringItem}, {numberItem*4:.2f}].' # can be an expression
-------> print(my_string1)
-------> print(my_string2)
-------> print(my_string3)

---> Formatting Digits
-----> Adding thousands separator
-------> a = 10000000
-------> print(f'{a:,}')  # prints '10,000,000'
-----> Rounding
-------> a = 3.1415926
-------> print(f'{a:.2f}')  # prints '3.14'
-----> Showing as Percentage
-------> a = 0.816562
-------> f'{a:.2%}'  # prints '81.66%'

---> Number formatting table
-------------------------------------------------
| Number     | Format  | Output    | Description
-------------------------------------------------
| 3.1415926  | {:.2f}  | 3.14      | Format float 2 decimal places
| 3.1415926  | {:+.2f} | +3.14     | Format float 2 decimal places with sign
| -1         | {:+.2f} | -1.00     | Format float 2 decimal places with sign
| 2.71828    | {:.0f}  | 3         | Format float with no decimal places
| 4          | {:0>2d} | 04        | Pad number with zeros (left padding, width 2)
| 4          | {:x<4d} | 4xxx      | Pad number with x’s (right padding, width 4)
| 10         | {:x<4d} | 10xx      | Pad number with x’s (right padding, width 4)
| 1000000    | {:,}    | 1,000,000 | Number format with comma separator
| 0.35       | {:.2%}  | 35.00%    | Format percentage
| 1000000000 | {:.2e}  | 1.00e+09  | Exponent notation
| 11         | {:11d}  | 11        | Right-aligned (default, width 10)
| 11         | {:<11d} | 11        | Left-aligned (width 10)
| 11         | {:^11d} | 11        | Center aligned (width 10)
-------------------------------------------------

---> Template Strings
-----> A simpler and less powerful mechanism, but it is recommended when handling strings generated by users. 
-----> Due to their reduced complexity, template strings are a safer choice.
-----> Example usage:
-------> from string import Template
-------> name = 'Elizabeth'
-------> t = Template('Hey $name!')
-------> print(t.substitute(name=name)) # 'Hey Elizabeth!'



-> Lists

---> Python recognizes [] as the wrapper for list
---> Lists are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Lists are Mutable (you can still change it after its created)
---> Lists allows duplicate elements 

---> Construction using the brackets:
-----> my_list = ['Kevin', 'Karen', 'Jim']  # creates a list with items

---> Construction using the list function:
-----> my_list = list()  # creates an empty list
-----> my_list = list(('Kevin', 'Karen', 'Jim'))  # using the list function and passing a iterable (in this case a tuple) on it

---> Construction with replication
-----> lonely_person = ['Pam'] * 5  # creates a list with five 'Pam's

---> Concatenation
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_numbers = [4, 8, 15, 16, 23, 42]
-----> my_list.extend(my_numbers)  # concatenation using extend
-----> same_as_my_list = my_list + my_numbers  # concatenation using '+'
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed', 4, 8, 15, 16, 23, 42]
-----> print(same_as_my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed', 4, 8, 15, 16, 23, 42]

---> Slicing:
-----> # Note: Remember splicing arguments are start_index:end_index:step_size
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> print(my_list[1:])  # prints ['Karen', 'Jim', 'Oscar', 'Toby'] (you can slice using a starting point)
-----> print(my_list[1:3])  # prints ['Karen', 'Jim'] (you can slice using a range, half open at the end)
-----> print(my_list[:3])  # prints ['Kevin', 'Karen', 'Jim'] (you can slice using an ending point, half open at the end)
-----> print(my_list[0::2])  # prints ['Kevin', 'Jim', 'Toby'] (starts at index 0, then take every second item in the list (step index 2))
-----> print(my_list[::-1])  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin'] (reverse of the list (step index -1))
-----> Slicing the complete list will perform a copy (see copying section for more information):
-------> my_list2 = my_list[:]
-------> print(my_list2)   # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']

---> Length
-----> my_list = ['Kevin', 'Karen', 'Jim']
-----> print(len(my_list))  # prints the length

---> Element access:
-----> my_list = ['Kevin', 'Karen', 'Jim']
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim']
-----> print(my_list[0])  # prints Kevin
-----> print(my_list[2])  # prints Jim
-----> print(my_list[-1])  # prints Jim (last item, you can access from the end using negative numbers)
-----> print(my_list[-2])  # prints Karen
-----> print(my_list[-3])  # prints Kevin
-----> # print(my_list[100])  # IndexError: list index out of range

---> List elements can be modified:
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list[1] = 'Mike'
-----> print(my_list)  # prints ['Kevin', 'Mike', 'Jim', 'Oscar', 'Toby']

---> Iteration
-----> my_list = ['Kevin', 'Karen', 'Jim']
-----> for item in my_list:
----->     print(item)

---> if statement to check if item exist in the list
-----> my_list = ['Kevin', 'Karen', 'Jim']
-----> if 'Jim' in my_list:
----->     print('yes')
-----> else:
----->     print('no')

---> Index search (index function)
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> print(my_list.index('Creed'))  # prints 2
-----> # print(my_list.index('Mike')) # ValueError: Mike is not in list

---> Getting the index in a loop with enumerate()
-----> furniture = ['table', 'chair', 'rack', 'shelf']
-----> for index, item in enumerate(furniture):
----->      print(f'index: {index} - item: {item}')

---> Append as last element
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.append('Creed')
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Insert
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.insert(1, 'Kelly')
-----> print(my_list)  # prints ['Kevin', 'Kelly', 'Karen', 'Jim', 'Oscar', 'Toby']

---> Item removal using the index (del function)
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> del my_list[2]
-----> # del my_list[5]  # IndexError list assignment index out of range
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Oscar', 'Toby']

---> Item removal using the item (remove function)
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.remove('Jim')
-----> # my_list.remove('DudeIsNotBornYet')  # ValueError: list.remove(x) x not in list
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Oscar', 'Toby']
-----> # NOTE: If the value appears multiple times in the list, only the first instance of the value will be removed. 

---> Last item removal (pop function)
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.pop()
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar']

---> Clear
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.clear()
-----> print(my_list)  # prints []

---> Count items
-----> my_list = ['Kevin', 'Oscar', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> print(my_list.count('Oscar'))  # prints 2

---> Reverse
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-----> my_list.reverse()
-----> print(my_list)  # prints ['Toby', 'Oscar', 'Jim', 'Karen', 'Kevin']

---> Sort
-----> You can sort using .sort or sorted() function
-------> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-------> new_my_list = sorted(my_list) # creates a new list with sorted elements (if you dont want to sort inplace)
-------> my_list.sort()
-------> print(my_list)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']
-------> print(new_my_list)  # prints ['Jim', 'Karen', 'Kevin', 'Oscar', 'Toby']
-----> You cannot sort with different items you cant compare:
-------> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 4, 8, 15, 16, 23, 42]
-------> # my_list.sort() # error because we have integers and string in the list
-----> You can also pass True for the reverse keyword argument to have sort() sort the values in reverse order:
-------> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby']
-------> my_list.sort(reverse=True)
-------> print(my_list)  # prints ['Toby', 'Oscar', 'Kevin', 'Karen', 'Jim']
-----> You can also pass a comparator for sorting:
-------> letters = ['a', 'z', 'A', 'Z']
-------> letters.sort(key=str.lower)
-------> print(letters))  # prints ['a', 'A', 'z', 'Z']

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> my_list2 = my_list
-----> my_list2[0] = 'Mark'
-----> print(my_list)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list2)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Copying
-----> my_list = ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> my_list2 = my_list.copy()  # the copy function returns a new instance
-----> my_list3 = list(my_list)  # this creates a new instance (using the list function)
-----> my_list4 = my_list[:]  # this also makes a copy (using slicing)
-----> my_list2[0] = 'Mark'
-----> my_list3[0] = 'Mike'
-----> my_list4[0] = 'Millie'
-----> print(my_list)  # prints ['Kevin', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list2)  # prints ['Mark', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list3)  # prints ['Mike', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']
-----> print(my_list4)  # prints ['Millie', 'Karen', 'Jim', 'Oscar', 'Toby', 'Creed']

---> Looping Through Multiple Lists with zip()
-----> furniture = ['table', 'chair', 'rack', 'shelf']
-----> price = [100, 50, 80, 40]
-----> for item, amount in zip(furniture, price):
----->      print(f'The {item} costs ${amount}')

---> The in and not in operators
-----> 'rack' in ['table', 'chair', 'rack', 'shelf']  # True
-----> 'bed' in ['table', 'chair', 'rack', 'shelf']  # False
-----> 'bed' not in furniture  # True
-----> 'rack' not in furniture  # False

---> Unpacking (The Multiple Assignment Trick)
-----> The multiple assignment trick is a shortcut that lets you assign multiple variables with the values in a list in one line of code. 
-----> So instead of doing this:
-------> furniture = ['table', 'chair', 'rack', 'shelf']
-------> table = furniture[0]
-------> chair = furniture[1]
-------> rack = furniture[2]
-------> shelf = furniture[3]
-----> You could type this line of code:
-------> furniture = ['table', 'chair', 'rack', 'shelf']
-------> table, chair, rack, shelf = furniture
-----> The multiple assignment trick can also be used to swap the values in two variables:
-------> a, b = 'table', 'chair'
-------> a, b = b, a
-------> print(a)  # prints chair
-------> print(b)  # prints table




-> Tuples

---> Python recognizes comma separated elements as a tuple (but not inside a known construct (a list for example))
---> They can be grouped by parentheses but its optional
---> Tuples are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Tuples are Immutable (once its created you cannot change it)
---> Tuples allows duplicate elements 
---> Tuples are generally used for data that it isnt gonna change in the duration of the program
-----> Because Tuples are immutable python can make internal optimizations compared to a list (especially when working with large data)
---> Tuples are generally more memory efficient than the lists. 

---> Construction:
-----> my_tuple = ('Max', 28, Boston) 
-----> my_tuple = 'Max', 28, Boston  # the parentheses are optional
-----> print(my_tuple)

---> Construction of one element:
-----> my_str = 'Max'
-----> print(type(my_str))  # this is a string
-----> my_str = ('Max') 
-----> print(type(my_str))  # this is a string (the parentheses are optional)
-----> my_str = 'Max',
-----> print(type(my_str))  # this is a tuple
-----> my_str = ('Max',) 
-----> print(type(my_str))  # this is a tuple (the parentheses are optional)

---> Construction using the tuple function:
-----> my_tuple = tuple(['Max', 28, Boston])  # using the tuple function and passing a iterable (in this case a list) on it

---> Construction with replication
-----> lonely_person = ('Max') * 5  # creates a tuple with five 'Max's

---> Concatenation
-----> my_tuple = ('Kevin', 'Karen', 'Jim', 'Oscar', 'Toby')
-----> my_numbers = (4, 8, 15, 16, 23, 42)
-----> my_tuple = my_tuple + my_numbers  # concatenation using '+'
-----> print(my_tuple)

---> Slicing:
-----> # Note: Remember splicing arguments are start_index:end_index:step_size
-----> my_tuple = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
-----> print(my_tuple[2:])  # prints (3, 4, 5, 6, 7, 8, 9, 10 (you can slice using a starting point)
-----> print(my_tuple[2:5])  # prints (3, 4, 5) (you can slice using a range, half open at the end)
-----> print(my_tuple[:5])  # prints (1, 2, 3, 4, 5) (you can slice using an ending point, half open at the end)
-----> print(my_tuple[0::2])  # prints (1, 3, 5, 7, 9) (starts at index 0, then take every second item in the list (step index 2))
-----> print(my_tuple[::-1])  # prints (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) (reverse of the list (step index -1))

---> Length
-----> my_tuple = 'Max', 28, Boston
-----> print(len(my_tuple))  # prints the length

---> Element access
-----> my_tuple = 'Max', 28, Boston
-----> print(my_tuple[1])  # prints 28
-----> print(my_tuple[-1])  # prints Boston
-----> print(my_tuple[-2])  # prints 28
-----> # print(my_tuple[3])  # IndexError: tuple index out of range
 
---> Immutability
-----> Tuples are immutable:
-------> coordinate = (4, 5)
-------> print(coordinate[1])  # prints 5
-------> # coordinate[1] = 10 # TypeError: 'tuple' object does not support item assignment
-----> Hoewever A list of tuples can be changed:
-------> coordinates = [(4, 5), (6, 7), (80, 34)]
-------> print(coordinates)  # prints [(4, 5), (6, 7), (80, 34)]
-------> coordinates[0] = (9, 9)
-------> print(coordinates)  # prints [(9, 9), (6, 7), (80, 34)] (a list of tuples can be changed)

---> Iteration
-----> my_tuple = 'Max', 28, Boston
-----> for item in my_tuple:
----->     print(item)

---> if statement to check if item exist in the list
-----> my_tuple = 'Max', 28, Boston
-----> if 'Boston' in my_tuple:
----->     print('yes')
-----> else:
----->     print('no')

---> Index search
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.index('l'))  # prints 3

---> Count items
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(my_tuple.count('p'))  # prints 2

---> Conversion to list
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> print(list(my_tuple))  # prints ['a', 'p', 'p', 'l', 'e'] (converts to list then print) 

---> Conversion back to tuple
-----> my_tuple = 'a', 'p', 'p', 'l', 'e'
-----> my_list = list(my_tuple)
-----> print(list(my_list))  # prints ('a', 'p', 'p', 'l', 'e') (converts back to tuple then print) 

---> Unpacking (similar to structure bindings)
-----> my_tuple = 'Max', 28, Boston
-----> name, age, city = 'Max', 28, Boston
-----> print(name)  # prints Max
-----> print(age)  # prints 28
-----> print(Boston)  # prints Boston
-----> name, age = 'Max', 28, Boston  # ValueError: Too many values to unpack
 
---> Unpacking with *
-----> my_tuple = 0, 1, 2, 3, 4
-----> i1, *i2, i3 = my_tuple
-----> print(i1)  # prints 0
-----> print(i3)  # prints 4
-----> print(i2)  # prints [1,2,3] (Note the its converted to a list)

---> Comparing memory consumption of tuples and lists
-----> import sys
-----> my_list = [0, 1, 2, 'hello', True]
-----> my_tuple = (0, 1, 2, 'hello', True)
-----> print(sys.getsizeof(my_list), 'bytes')  # prints 96 bytes (list is larger even though they have the same items)
-----> print(sys.getsizeof(my_tuple), 'bytes')  # prints 80 bytes (tuple is larger even though they have the same items)

---> Comparing duration of tuples and lists construction
-----> import timeit
-----> print(timeit.timeit(stmt='[0,1,2,3,4,5]', number=1000000)) # prints 0.13339190000260714 (list is slower)
-----> print(timeit.timeit(stmt='(0,1,2,3,4,5)', number=1000000)) # prints 0.08034780000161845 (tuple is faster)



-> Dictionaries

---> A dictionary is an ordered collection of key: value pairs.
---> Python recognizes {} as the wrapper for sets and dictionaries
---> Similar to map classes in C++, it has key-value pairs.
---> Dictionaries are Heterogeneous for both the keys and values (you can put any type (string, int, boolean) in different positions)
---> Dictionaries are Mutable (you can still change it after its created)
---> Dictionaries allows duplicate values, but the keys need to be unique (any duplicate keys has its value overwritten) 
---> The values in the Dictionaries are searchable with the keys.

---> Pretty Printing
-----> import pprint
-----> wife = {'name': 'Rose', 'age': 33, 'has_hair': True, 'hair_color': 'brown', 'height': 1.6, 'eye_color': 'brown'}
-----> pprint.pprint(wife)
-----> # Sample print:
-----> # {'age': 33,
-----> #  'eye_color': 'brown',
-----> #  'hair_color': 'brown',
-----> #  'has_hair': True,
-----> #  'height': 1.6,
-----> #  'name': 'Rose'}

---> Construction using braces
-----> monthNameShortToLong =
-----> {'Jan': 'January', 'Feb': 'February', 'Mar': 'March', 'Apr': 'April', 'May': 'May', 'Jun': 'June',
----->  'Jul': 'July', 'Aug': 'August', 'Sep': 'September', 'Oct': 'Oct', 'Nov': 'November', 'Dec': 'December'}
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}

---> Construction using dict function (take note that there are no quotations in the keys)
-----> monthNameShortToLong = dict(
----->     Jan='January', Feb='February', Mar='March', Apr='April', May='May', Jun='June',
----->     Jul='July', Aug='August', Sep='September', Oct='October', Nov='November', Dec='December')
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}

---> Element Access
-----> monthNameShortToLong =
-----> {'Jan': 'January', 'Feb': 'February', 'Mar': 'March', 'Apr': 'April', 'May': 'May', 'Jun': 'June',
----->  'Jul': 'July', 'Aug': 'August', 'Sep': 'September', 'Oct': 'Oct', 'Nov': 'November', 'Dec': 'December'}
-----> print(monthNameShortToLong)  # prints {'Jan': 'January', 'Feb': 'February', ...}
-----> print(monthNameShortToLong['Mar'])  # prints March
-----> # print(monthNameShortToLong['NotAMonth'])  # KeyError: NotAMonth
-----> print(monthNameShortToLong.get('Mar'))  # prints March
-----> print(monthNameShortToLong.get('NotAMonth'))  # prints None
-----> print(monthNameShortToLong.get('NotAMonth', 'Not a valid key'))  # prints Not a valid key

---> Iteration
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> for key in my_dict:  # Note: Notice that default iteration has only its keys in it.
----->     print(key)
-----> for key in my_dict.keys():  # same as above
----->     print(key)
-----> for value in my_dict.values():
----->     print(value)
-----> for key, value in my_dict.items():
----->     print(key)
----->     print(value)

---> if statement to check if key exist in the dict
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> if 'name' in my_dict:
----->     print(my_dict['name'])  # prints Max
-----> if 'DoesNotExist' in my_dict:  # this is false
----->     print('This doesnt get executed')

---> if statement to check if value exist in the dict
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> if 'Max' in my_dict.values():
----->     print(my_dict['name'])  # prints Max
-----> if 'DoesNotExist' in my_dict.values():  # this is false
----->     print('This doesnt get executed')

---> Modifying Elements
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict['email'] = 'max@xyz.com'  # adds email key with value
-----> print(my_dict)  # prints with email
-----> my_dict['email'] = 'coolmax@xyz.com'  # modifies value on email key
-----> print(my_dict)  # prints with new email
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict.set_default('phone', '4190215')  # adds email key with value

---> Removing Elements
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York', 'email': 'coolmax@xyz.com'}
-----> del my_dict['email']  # deletes email key (and its value)
-----> print(my_dict)  # prints without email
-----> my_dict.pop('age')  # deletes age key (and its value)
-----> print(my_dict)  # prints without age
-----> my_dict.popitem()  # deletes last item (key-value pair)
-----> print(my_dict)  # prints without city (last added item) 

---> Clear
-----> my_set = {1, 2, 3}
-----> my_set.clear()
-----> print(my_list)  # prints {}

---> try except statement to try to do things with key that might not exist
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> try:
----->     print(my_dict['DoesNotExist'])
-----> except:
----->     print('Error')

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict2 = my_dict
-----> my_dict2['name'] = 'Mark'
-----> print(my_dict)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}
-----> print(my_dict2)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}

---> Copying
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict2 = my_dict.copy()  # the copy function returns a new instance
-----> my_dict3 = dict(my_dict)  # this creates a new instance (using the dict function)
-----> my_dict2['name'] = 'Mark'
-----> my_dict3['name'] = 'Mike'
-----> print(my_dict)  # prints {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> print(my_dict2)  # prints {'name': 'Mark', 'age': 28, 'city': 'New York'}
-----> print(my_dict3)  # prints {'name': 'Mike', 'age': 28, 'city': 'New York'}

---> Merging dictionaries (using update)
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict2 = {'name': 'Mary', 'age': 27, 'email': 'Boston'}
-----> my_dict.update(my_dict2)
-----> print(my_dict) # prints {'name': 'Mary', 'age': 27, 'city': 'New York', 'email': 'Boston'} (some got overwritten, some got added)

---> Merging dictionaries (using unpacking)
-----> my_dict = {'name': 'Max', 'age': 28, 'city': 'New York'}
-----> my_dict2 = {'name': 'Mary', 'age': 27, 'email': 'Boston'}
-----> my_dict3 = {**my_dict, **my_dict2}
-----> print(my_dict3) # prints {'name': 'Mary', 'age': 27, 'city': 'New York', 'email': 'Boston'} (some got overwritten, some got added)

---> Keys need to be a hashable type (int, str, floating types, tuples are hashable, list is not hashable(its mutable))
-----> dict_with_hashable_keys = {
----->     'one': 100, 2: 'two hundred', 3.5 : 'three hundred and fifty', (4, 5) : 'four hundred and fifty'}
-----> print(dict_with_hashable_keys)
-----> # dict_with_unhashable_keys = {[5, 5] : 'five hundred and fifty'} # TypeError: unhashable type: 'list'
-----> # print(dict_with_unhashable_keys)



-> Sets

---> A set is an unordered collection with no duplicate elements. 
---> Python recognizes {} as the wrapper for sets and dictionaries
---> Sets are Heterogeneous (you can put any type (string, int, boolean) in different positions)
---> Sets are Mutable (you can still change it after its created)
---> Sets need its items to be unique (any duplicate items are discarded) 

---> Construction using braces
-----> my_set = {1, 2, 3, 1, 2, 'hello'}
-----> print(my_set) # prints {1, 2, 3, 'hello'} (duplicate items are discarded)

---> Construction using set function
-----> my_set = set([1, 2, 3, 1, 2, 'hello']) # using the set function and passing a iterable (in this case a list) on it
-----> print(my_set)  # prints {1, 2, 3, 'hello'} (duplicate items are discarded)

---> Construction of an empty set
-----> my_dict = {} # empty braces is recognized as a dictionary 
-----> print(type(my_dict))  # shows dictionary
-----> my_set = set()
-----> print(type(my_set))   # shows set

---> Construction using set function with a string
-----> my_set = set('hello') # using the set function and passing a iterable (in this case a string) on it
-----> print(my_set)  # prints {'l', 'o', 'h', 'e'} (duplicate items are discarded)

---> Length
-----> my_set = set([1, 2, 3, 1, 2, 'hello'])
-----> print(len(my_set))  # prints 3

---> Sets cannot be indexed (And as an unordered data type)
-----> s = {1, 2, 3}
-----> s[0] = 0  # TypeError: 'set' object does not support indexing

---> Iteration
-----> my_set = {1, 2, 3}
-----> for item in my_set:
----->     print(item)

---> if statement to check if item exist in the set
-----> my_set = {1, 2, 3}
-----> if '1' in my_set:
----->     print('Yes')  # prints Max
-----> if 'DoesNotExist' in my_set:  # this is false
----->     print('Yes')  # this doesnt get executed

---> Adding elements
-----> my_set = set()
-----> my_set.add(1)
-----> my_set.add(2)
-----> my_set.add(3)
-----> print(my_set)  # prints {1, 2, 3}

---> Removing elements (using remove)
-----> my_set = {1, 2, 3}
-----> my_set.remove(2)
-----> # my_set.remove(4) # KeyError: 4
-----> print(my_set)  # prints {1, 3}

---> Removing elements (using discard (discard() won’t raise any errors))
-----> my_set = {1, 2, 3}
-----> my_set.discard(2)
-----> my_set.discard(4) # Nothing happens
-----> print(my_set)  # prints {1, 3}

---> Removing elements (using pop)
-----> my_set = {1, 2, 3}
-----> print(my_set.pop())  # prints 1 (pop returns a value)
-----> print(my_set)  # prints {2, 3}

---> Clear
-----> my_set = {1, 2, 3}
-----> my_set.clear()
-----> print(my_list)  # prints set()

---> Union
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> union_set = set1.union(set2)
-----> print(union_set) # prints {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

---> Intersection
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> intersection_set = set1.intersection(set2)
-----> print(intersection_set) # prints {1, 2, 3}

---> Difference 
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> difference_set = set1.difference(set2)
-----> print(difference_set) # prints {4, 5, 6, 7, 8, 9}

---> Symmetric Difference 
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> sym_diff_set = set1.symmetric_difference(set2)
-----> print(sym_diff_set) # prints {4, 5, 6, 7, 8, 9}

---> Union update (combining using union)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.update(set2)
-----> print(set1)  # prints {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

---> Intersection update (combining using intersection)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.intersection_update(set2)
-----> print(set1)  # prints {1, 2, 3}

---> Difference update (combining using difference)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.difference_update(set2)
-----> print(set1)  # prints {4, 5, 6, 7, 8, 9}

---> Symmetric difference update (combining using symmetric difference)
-----> set1 = {1, 2, 3, 4, 5, 6, 7, 8, 9} 
-----> set2 = {1, 2, 3, 10, 11, 12}
-----> set1.symmetric_difference_update(set2)
-----> print(set1)  # prints {4, 5, 6, 7, 8, 9, 10, 11, 12}

---> issubset
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> print(set1.issubset(set2))  # prints False
-----> print(set2.issubset(set1))  # prints True

---> issuperset
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> print(set1.issuperset(set2))  # prints True
-----> print(set2.issuperset(set1))  # prints False

---> isdisjoint
-----> set1 = {1, 2, 3, 4, 5, 6}
-----> set2 = {1, 2, 3}
-----> set3 = {7, 8, 9}
-----> print(set1.isdisjoint(set2))  # prints False
-----> print(set2.isdisjoint(set3))  # prints True

---> Assigning is not copying (similar to java, variables can point to the same memory)
-----> my_set = {1, 2, 3, 4, 5, 6}
-----> my_set2 = my_set
-----> my_set2.add(7)
-----> print(my_set)  # prints {1, 2, 3, 4, 5, 6, 7}
-----> print(my_set2)  # prints {1, 2, 3, 4, 5, 6, 7}

---> Copying
-----> my_set = {1, 2, 3, 4, 5, 6}
-----> my_set2 = my_set.copy()  # the copy function returns a new instance
-----> my_set3 = set(my_set)  # this creates a new instance (using the list function)
-----> my_set2.add(7)
-----> my_set3.add(8)
-----> print(my_set)  # prints {1, 2, 3, 4, 5, 6}
-----> print(my_set2)  # prints {1, 2, 3, 4, 5, 6, 7}
-----> print(my_set3)  # prints {1, 2, 3, 4, 5, 6, 8}

---> frozenset (immutable version of a set)
-----> my_frozen_set = frozenset([1, 2, 3, 4])
-----> my_frozen_set.add(5)  # AttributeError: 'frozenset' object has no attribute 'add'
-----> my_frozen_set.remove(1)  # AttributeError: 'frozenset' object has no attribute 'remove'



-> Comprehension (this is cool feature)

---> List Comprehensions are a special kind of syntax that let us create lists out of other lists, 
---> and are incredibly useful when dealing with numbers and with one or two levels of nested for loops.
---> Comprehensions are applicable to list, set and dictionaries.

---> List comprehension using an existing list:
-----> numbers = [1, 2, 3, 4, 5, 6]
-----> numbers_string = [str(number) for number in numbers]
-----> squared_numbers = [n*n for n in numbers]
-----> even_numbers = [n for n in numbers if n % 2 == 0]
-----> print(numbers)  # prints [1, 2, 3, 4, 5, 6]
-----> print(numbers_string)  # ['1', '2', '3', '4', '5', '6']
-----> print(squared_numbers)  # prints [1, 4, 9, 16, 25, 36]
-----> print(even_numbers)  # prints [2, 4, 6]

---> List comprehension using a range (range is an iterable object):
-----> numbers_string = [str(n) for n in range(1, 10)]
-----> squared_numbers = [n*n for n in range(1, 10)]
-----> even_numbers = [n for n in range(1, 10) if n % 2 == 0]
-----> print(numbers_string)  # prints ['1', '2', '3', '4', '5', '6', '7', '8', '9']
-----> print(squared_numbers)  # prints [1, 4, 9, 16, 25, 36, 49, 64, 81]
-----> print(even_numbers)  # prints [2, 4, 6, 8]

---> Set comprehension using an existing set:
-----> numbers = {1, 2, 3, 4, 5, 6}
-----> numbers_string = {str(number) for number in numbers}
-----> squared_numbers = {n*n for n in numbers}
-----> even_numbers = {n for n in numbers if n % 2 == 0}
-----> print(numbers)  # prints {1, 2, 3, 4, 5, 6}
-----> print(numbers_string)  # {'3', '5', '6', '4', '1', '2'}
-----> print(squared_numbers)  # prints {1, 4, 36, 9, 16, 25}
-----> print(even_numbers)  # prints {2, 4, 6}

---> Set comprehension using a range (range is an iterable object):
-----> numbers_string = {str(n) for n in range(1, 10)}
-----> squared_numbers = {n*n for n in range(1, 10)}
-----> even_numbers = {n for n in range(1, 10) if n % 2 == 0}
-----> print(numbers_string)  # prints {'4', '9', '2', '5', '3', '7', '8', '6', '1'}
-----> print(squared_numbers)  # prints {64, 1, 4, 36, 9, 16, 49, 81, 25}
-----> print(even_numbers)  # prints {8, 2, 4, 6}

---> Dict comprehension
-----> my_dict = {'name': 'Pooka', 'age': 5}
-----> new_dict = {v: k for k, v in my_dict.items()}
-----> print(new_dict)  # prints {'Pooka': 'name', 5: 'age'}

---> List comprehension from a dictionary
-----> my_dict = {'name': 'Pooka', 'first_name': 'Oooka'}
-----> my_list = ['{}:{}'.format(k.upper(), v.upper()) for k, v in my_dict.items()]
-----> print(my_list)



-> Datetime

---> The Datetime module allows us to work with date and time objects. 
---> It provides three additional data types: date, time and datetime.

---> date()
-----> Signature: datetime.date(year: int, month: int, day: int)
-----> The date method return a date object with the year, month and day attributes:
-------> from datetime import date
-------> obj = date(2022, 12, 1)
-------> print(obj.year)  # prints 2022
-------> print(obj.month)  # prints 12
-------> print(obj.day)  # prints 1

---> time()
-----> Signature: datetime.time(hour: int, minute: int, second: int)
-----> The time method return a time object with the hour, minute, second, microsecond and tzinfo attributes:
-------> from datetime import time
-------> obj = time(10, 20, 33)
-------> print(obj.hour)  # prints 10
-------> print(obj.second)  # prints 33
-------> print(obj.microsecond)  # prints 0

---> datetime()
-----> Signature: datetime.datetime(year, month, day, hour, minute, second)
-----> Signature: The datetime returns an object with both, the date and time objects attributes:
-------> from datetime import datetime
-------> obj = datetime(2024, 12, 1, 15, 35, 59)
-------> print(obj.year)  # prints 2024
-------> print(obj.month)  # prints 12
-------> print(obj.day)  # prints 1
-------> print(obj.hour)  # prints 15
-------> print(obj.second)  # prints 59

---> now() and today()
-----> now and today methods return a datetime object with system’s exact day and time:
-------> from datetime import datetime
-------> now = datetime.now()
-------> print(now)  # prints datetime.datetime(2022, 7, 23, 19, 56, 49, 589806)
-------> print(now.date())  # prints datetime.date(2022, 7, 23)
-------> print(now.time())  # prints datetime.time(19, 56, 49, 589806)
-------> print(now.year)  # prints 2022
-------> print(now.month)  # prints 7
-------> print(now.day)  # prints 23
-------> print(now.hour)  # prints 19
-------> print(now.minute)  # prints 56
-------> print(now.second)  # prints 49
-------> print(now.microsecond)  # prints 589806
-----> Additionally, now can take a timezone object as an optional parameter:
-------> from datetime import datetime, timezone
-------> datetime.now(timezone.utc)  # prints datetime.datetime(2022, 7, 24, 0, 20, 8, 265634, tzinfo=datetime.timezone.utc)
-----> NOTE: If a timezone parameter is not specified, now will default to the system timezone.

---> strftime() and strptime()
-----> You can easily transform between strings and datetime objects with the strftime and strptime methods.

---> strftime()
-----> strftime allow us to create human formatted strings out of a Python datetime object:
-------> from datetime import datetime
-------> now = datetime.now()
-------> print(now)  # prints datetime.datetime(2022, 7, 23, 20, 31, 19, 751479)
-------> now.strftime("%d-%b-%Y")  # prints '23-Jul-2022'
-------> now.strftime("%d-%m-%Y")  # prints '23-07-2022'
-------> now.strftime("%d-%b-%Y")  # prints '23-Jul-2022'
-------> now.strftime("%d-%m-%Y")  # prints '23-07-2022'
-------> now.strftime("%m/%d/%Y")  # prints '07/23/2022'
-------> now.strftime("%b/%d/%Y - %H:%M:%S")  # prints 'Jul/23/2022 - 20:31:19'
-----> You may find the strings passed to strftime to be a little strange, but it is pretty easy to understand its meaning. 
-----> For example, %m/%d/%Y will return the month, day, and year separated by / (07/23/2022).

---> strptime()
-----> The strptime method creates a datetime object from a string.
-----> This method accepts two parameters: obj.strptime(datetime_string, format)
-------> A string representing a datetime object.
-------> The python format code equivalent to that string.
-----> Example usage:
-------> from datetime import datetime
-------> datetime_str = '12-Jul-2023'
-------> datetime.strptime(datetime_str, '%d-%b-%Y')  # prints datetime.datetime(2023, 7, 12, 0, 0)
-------> datetime_str = 'Jul/12/2023 - 14:38:37'
-------> datetime.strptime(datetime_str, "%b/%d/%Y - %H:%M:%S")  # prints datetime.datetime(2023, 7, 12, 14, 38, 37)

---> Format Codes
-----> %a -> Weekday as locale’s abbreviated name. Sun, Mon, …, Sat (en_US)
-----> %A -> Weekday as locale’s full name. Sunday, Monday, …, Saturday (en_US)
-----> %w -> Weekday as a decimal number, where 0 is Sunday and 6 is Saturday. 0, 1, …, 6
-----> %d -> Day of the month as a zero-padded decimal number. 01, 02, …, 31
-----> %b -> Month as locale’s abbreviated name. Jan, Feb, …, Dec (en_US)
-----> %B -> Month as locale’s full name. January, February, …, December (en_US)
-----> %m -> Month as a zero-padded decimal number. 01, 02, …, 12
-----> %y -> Year without century as a zero-padded decimal number. 00, 01, …, 99
-----> %Y -> Year with century as a decimal number. 0001, 0002, …, 2013, 2014, …, 9998, 9999
-----> %H -> Hour (24-hour clock) as a zero-padded decimal number. 00, 01, …, 23
-----> %I -> Hour (12-hour clock) as a zero-padded decimal number. 01, 02, …, 12
-----> %p -> Locale’s equivalent of either AM or PM. AM, PM (en_US)
-----> %M -> Minute as a zero-padded decimal number. 00, 01, …, 59
-----> %S -> Second as a zero-padded decimal number. 00, 01, …, 59
-----> %f -> Microsecond as a decimal number, zero-padded on the left. 000000, 000001, …, 999999
-----> %z -> UTC offset in the form ±HHMM[SS[.ffffff]] (empty string if the object is naive). (empty), +0000, -0400, +1030, +063415, -030712.345216
-----> %Z -> Time zone name (empty string if the object is naive). (empty), UTC, GMT
-----> %j -> Day of the year as a zero-padded decimal number. 001, 002, …, 366
-----> %U -> Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0. 00, 01, …, 53
-----> %W -> Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0. 00, 01, …, 53
-----> %c -> Locale’s appropriate date and time representation. Tue Aug 16 21:30:00 1988 (en_US)
-----> %x -> Locale’s appropriate date representation. 08/16/88 (None)
-----> %X -> Locale’s appropriate time representation. 21:30:00 (en_US)
-----> %% -> A literal '%' character. %

---> timedelta()
-----> The timedelta object represents the difference between two dates or times.
-------> from datetime import datetime
-------> date_1 = datetime.strptime('12-Jul-2023', '%d-%b-%Y')
-------> date_2 = datetime.strptime('01-Jan-2024', '%d-%b-%Y')
-------> difference = date_2 - date_1
-------> difference  # prints datetime.timedelta(days=173)
-------> difference.days  # prints 173
-----> timedelta can add days, seconds and microseconds to a datetime object:
-------> from datetime import datetime, timedelta
-------> now = datetime.now()
-------> print(now)  # prints datetime.datetime(2022, 7, 23, 21, 25, 2, 341081)
-------> print(now + timedelta(days=10, seconds=15))  # prints datetime.datetime(2022, 8, 2, 21, 25, 17, 341081)
-----> And can subtract days, seconds and microseconds to a datetime object:
-------> from datetime import datetime, timedelta
-------> now = datetime.now()
-------> print(now)  # prints datetime.datetime(2022, 7, 23, 21, 25, 2, 341081)
-------> print(now - timedelta(days=10, seconds=15))  # prints datetime.datetime(2022, 7, 13, 21, 59, 41, 100883)



-> Collections

---> The collections module provide special containers that provide additional functionality

---> Counter
-----> Dict subclass for counting hashable items.
-----> Sometimes called a bag or multiset.  
-----> Elements are stored as dictionary keys and their counts are stored as dictionary values.
-----> Example usage:
-------> from collections import Counter
-------> a = 'aaaaabbbbccc'
-------> my_counter = Counter(a)
-------> print(my_counter)  # prints Counter({'a': 5, 'b': 4, 'c': 3})
-------> print(my_counter.items())  # prints dict_items([('a', 5), ('b', 4), ('c', 3)])
-------> print(my_counter.keys())  # prints dict_keys(['a', 'b', 'c'])
-------> print(my_counter.values())  # prints dict_values([5, 4, 3])
-------> print(my_counter.most_common(1))  # prints [('a', 5)] (a list of tuples)
-------> print(my_counter.most_common(2))  # prints [('a', 5), ('b', 4)] (a list of tuples)
-------> print(list(my_counter.elements()))  # prints ['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c']

---> namedtuple
-----> Returns a new subclass of tuple with named fields.
-----> Example usage:
-------> from collections import namedtuple
-------> Point = namedtuple('Point', 'x,y')  # this will create a class (or a struct) with fields x and y
-------> pt = Point(1, -4)
-------> print(pt)  # prints Point(x=1, y=-4)
-------> print(pt.x, pt.y)  # prints 1 -4

---> OrderedDict
-----> Dictionary that remembers insertion order
-----> Outdated class because the dictionary class in newer python versions have the ability to remember the order
-----> It might be necessary still if you are working in older python versions.
-----> Example usage:
-------> from collections import OrderedDict
-------> my_dictionary = OrderedDict()
-------> my_dictionary['d'] = 4
-------> my_dictionary['c'] = 3
-------> my_dictionary['b'] = 2
-------> my_dictionary['a'] = 1
-------> print(my_dictionary)  # prints OrderedDict([('d', 4), ('c', 3), ('b', 2), ('a', 1)])

---> defaultdict
-----> Same with a dictionary but the difference is that it will set a default value if the value is not set yet
-----> Example usage:
-------> from collections import defaultdict
-------> my_dictionary = defaultdict(int)
-------> my_dictionary['a'] = 1
-------> my_dictionary['b'] = 2
-------> print(my_dictionary['a'])  # prints 1
-------> print(my_dictionary['b'])  # prints 2
-------> print(my_dictionary['DoesNotExist'])  # prints 0 (no KeyError even if doesnt exist and note that the default value of int is zero)

---> deque
-----> Double ended queue (similar to C++)
-----> Example usage:
-------> from collections import deque
-------> my_deque = deque()
-------> my_deque.append(1)
-------> my_deque.append(2)
-------> my_deque.appendleft(0)
-------> print(my_deque)  # prints deque([0, 1, 2])
-------> my_deque.pop()
-------> print(my_deque)  # prints deque([0, 1])
-------> my_deque.popleft()
-------> print(my_deque)  # prints deque([1])
-------> my_deque.extend([3, 4, 5])
-------> print(my_deque)  # prints deque([1, 3, 4, 5])
-------> my_deque.extendleft([-1, -2, -3])
-------> print(my_deque)  # prints deque([-3, -2, -1, 1, 3, 4, 5])
-------> my_deque.rotate(2)
-------> print(my_deque)  # prints deque([4, 5, -3, -2, -1, 1, 3])
-------> my_deque.rotate(-1)
-------> print(my_deque)  # prints deque([5, -3, -2, -1, 1, 3, 4])



-> Itertools

---> The itertools module has different tools of handling iterators
---> Iterators are iterables (can be used in a for loop, etc).

---> permutations
-----> This provides a way of iterating through permutations
-----> Example usage:
-------> from itertools import permutations
-------> my_list = [1, 2, 3]
-------> my_iterable = permutations(my_list)  # creates a itertools object (an iterator)
-------> print(list(my_iterable))  # prints [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
-------> my_iterable = permutations(my_list, 2)  # can specify the length
-------> print(list(my_iterable))  # prints [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

---> combinations (with combinations_with_replacement) 
-----> This provides a way of iterating through combinations
-----> Takes an iterable and a integer. This will create all the unique combination that have r members.
-----> Example usage:
-------> from itertools import combinations, combinations_with_replacement
-------> my_list = [1, 2, 3]
-------> my_iterable = combinations(my_list, 2)  # creates a itertools object (an iterator), length is mandatory
-------> print(list(my_iterable))  # prints [(1, 2), (1, 3), (2, 3)]
-------> my_iterable = combinations_with_replacement(my_list, 2)  # 
-------> print(list(my_iterable))  # prints [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

---> product
-----> This provides a way of iterating in a 'cartesian product way'
-----> This creates the cartesian products from a series of iterables.
-----> Example usage:
-------> from itertools import product
-------> a = [1, 2]
-------> b = [3, 4]
-------> my_iterable = product(a, b)  # creates a  itertools object (an iterator)
-------> print(list(my_iterable))  # prints [(1, 3), (1, 4), (2, 3), (2, 4)]
-------> a = [1, 2]
-------> b = [3]
-------> my_iterable = product(a, b, repeat=2)  # can specify a repeat
-------> print(list(my_iterable))  # prints [(1, 3, 1, 3), (1, 3, 2, 3), (2, 3, 1, 3), (2, 3, 2, 3)]

---> product
-----> This makes an iterator that computes the function using arguments obtained from the iterable.
-----> Example usage:
-------> from itertools import starmap
-------> import operator
-------> my_list = [(2, 6), (8, 4), (7, 3)]
-------> my_iterable = starmap(operator.mul, my_list)
-------> print(list(my_iterable))  # prints [12, 32, 21]

---> accumulate
-----> This provides a way of iterating by getting partial sums.
-----> This makes an iterator that returns the results of a function.
-----> This similar to std::accumulate
-----> Example usage:
-------> from itertools import accumulate
-------> import operator
-------> my_list = [1, 2, 3, 2, 1]
-------> my_iterable = accumulate(my_list)
-------> print(list(my_iterable))  # prints [1, 3, 6, 8, 9]
-------> my_iterable = accumulate(my_list, func=operator.mul)
-------> print(list(my_iterable))  # prints [1, 2, 6, 12, 12]
-------> my_iterable = accumulate(my_list, func=max)
-------> print(list(my_iterable))  # prints [1, 2, 3, 3, 3]

---> chain
-----> This provides a way of iterating by connect/chaining other iterables.
-----> This takes a series of iterables and return them as one long iterable.
-----> Example usage:
-------> from itertools import chain
-------> from itertools import accumulate
-------> colors = ['red', 'orange']
-------> shapes = ['circle', 'triangle']
-------> my_list = [1, 2, 1]
-------> partial_sums = accumulate(my_list)
-------> my_iterable = chain(colors, shapes, partial_sums)
-------> print(list(my_iterable))  # prints ['red', 'orange', 'circle', 'triangle', 1, 3, 4]

---> islice
-----> This function is very much like slices. 
-------> This allows you to cut out a piece of an iterable.
-----> Example usage:
-------> from itertools import islice
-------> colors = ['red', 'orange', 'yellow', 'green', 'blue']
-------> my_iterable = islice(colors, 2)
-------> print(list(my_iterable))  # prints ['red', 'orange']

---> tee()
-----> This returns n independent iterators from a single iterable.
-----> Example usage:
-------> from itertools import tee
-------> colors = ['red', 'orange', 'yellow', 'green', 'blue']
-------> my_iterable1, my_iterable2 = tee(colors)
-------> print(list(my_iterable1))  # prints ['red', 'orange', 'yellow', 'green', 'blue']
-------> print(list(my_iterable2))  # prints ['red', 'orange', 'yellow', 'green', 'blue']

---> compress
-----> This filters one iterable with another.
-----> This similar to std::copy_if
-----> Example usage:
-------> from itertools import compress
-------> shapes = ['circle', 'triangle', 'square', 'pentagon']
-------> selections = [True, False, True, False]
-------> my_iterable = compress(shapes, selections)
-------> print(list(my_iterable))  # prints ['circle', 'square']

---> dropwhile
-----> This makes an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element.
-----> Example usage:
-------> from itertools import dropwhile
-------> my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]
-------> my_iterable = dropwhile(lambda x: x<5, my_list)
-------> print(list(my_iterable))  # prints [5, 6, 7, 8, 9, 10, 1]

---> filterfalse
-----> This makes an iterator that filters elements from iterable returning only those for which the predicate is False.
-----> This similar to std::copy_if
-----> Example usage:
-------> from itertools import filterfalse
-------> my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]
-------> my_iterable = filterfalse(lambda x: x<5, my_list)
-------> print(list(my_iterable))  # prints [5, 6, 7, 8, 9, 10]

---> takewhile
-----> The opposite of dropwhile().
-----> This makes an iterator and returns elements from the iterable as long as the predicate is true.
-----> Example usage:
-------> from itertools import takewhile
-------> my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]
-------> my_iterable = takewhile(lambda x: x<5, my_list)
-------> print(list(my_iterable))  # prints [1, 2, 3, 4]

---> groupby
-----> Simply put, this function groups things together.
-----> This similar to std::partition
-----> Example usage:
-------> from itertools import groupby
-------> def smaller_than_3(x):
------->     return x < 3
-------> my_list = [1, 2, 3, 4]
-------> groupby_object = groupby(my_list, key=smaller_than_3)
-------> #print(list(groupby_object))  # prints gibberish about a groupby object
-------> for key, value_iterable in groupby_object:
------->     print(key, list(value_iterable)) # prints True [1, 2] and False [3, 4]
-------> groupby_object = groupby(my_list, key=lambda x: x<3)  # can specify a lambda as well
-------> #print(list(groupby_object))  # prints gibberish about a groupby object
-------> for key, value_iterable in groupby_object:
------->     print(key, list(value_iterable)) # prints True [1, 2] and False [3, 4]

---> zip_longest
-----> This makes an iterator that aggregates elements from each of the iterables. 
-----> If the iterables are of uneven length, missing values are filled-in with fillvalue. 
-----> Iteration continues until the longest iterable is exhausted.
-----> Example usage:
-------> from itertools import zip_longest
-------> colors = ['red', 'orange', 'yellow', 'green', 'blue']
-------> data = [1, 2, 3, 4, 5, 6]
-------> my_iterable = zip_longest(colors, data, fillvalue=None)
-------> print(list(my_iterable))  # prints [('red', 1), ('orange', 2), ('yellow', 3), ('green', 4), ('blue', 5), (None, 6)]

---> count
-----> This iterates infinitely.
-----> This counts to infinity.
-----> This makes an iterator that returns evenly spaced values starting with number start.
-----> Example usage:
-------> from itertools import count
-------> for i in count(10):  # generates a count from 10 to infinity
------->     print(i)
------->     break  # necessary break to avoid an infinite loop

---> cycle
-----> This iterates infinitely.
-----> This cycles to an iterable.
-----> This function cycles through an iterator endlessly.
-------> When the end of the iterable is reached, its start over again from the beginning.
-----> Example usage:
-------> from itertools import cycle
-------> my_list = [1, 2, 3]
-------> for i in cycle(my_list):  # cycles through the list infinitely
------->     print(i)
------->     break  # necessary break to avoid an infinite loop

---> repeat
-----> This iterates infinitely.
-----> This function will repeat an object over and over again. 
-------> Unless, there is a times argument.
-----> This repeats an object.
-----> Example usage:
-------> from itertools import repeat
-------> for i in repeat(1):  # repeats 1 infinitely
------->     print(i)
------->     break  # necessary break to avoid an infinite loop
-------> for i in repeat(1, 4):  # repeats 1 four times
------->     print(i)



-> lambda functions

---> A lambda function is a single-line, anonymous function, which can have any number of arguments, but it can only have one expression.
---> lambda is a minimal function definition that can be used inside an expression. Unlike FunctionDef, body holds a single node.
---> Single line expression: Lambda functions can only evaluate an expression, like a single line of code.
---> These are normally used for functions that will be only be used once.
---> The format is lambda [ARGUMENTS]: [EXPRESSION]

---> Example usage (comparison to normal functions):
-----> add10 = lambda x: x+10
-----> print(add10(5))
-----> mult = lambda x,y: x*y
-----> # This is the same but in function format
-----> def add10(x): return x+10
-----> print(add10(5))
-----> def mult(x, y): return x*y
-----> print(mult(2, 7))
-----> print(mult(2,7))

---> Like regular nested functions, lambdas also work as lexical closures:
-----> def make_adder(n):
----->      return lambda x: x + n
-----> plus_3 = make_adder(3)
-----> plus_5 = make_adder(5)
-----> plus_3(4)  # prints 7
-----> plus_5(4)  # prints 9

---> Example usage on sorted function:
-----> points = [(1, 2), (15, 1), (5, -1), (10, 4)]
-----> points_sorted_in_y = sorted(points, key=lambda x: x[1])  # key expects a function (which can be a lambda)
-----> points_sorted_by_sum = sorted(points, key=lambda x: x[0]+x[1])  # key expects a function (which can be a lambda)
-----> print(points)  # prints [(1, 2), (15, 1), (5, -1), (10, 4)]
-----> print(points_sorted_in_y)  # prints [(5, -1), (15, 1), (1, 2), (10, 4)]
-----> print(points_sorted_by_sum)  # prints [(1, 2), (5, -1), (10, 4), (15, 1)]

---> Example usage on map function (syntax wise its better to use list comprehension):
---> This is like the std::generate/std::generate_n function.
-----> my_list = [1, 2, 3, 4, 5]
-----> my_iterable = map(lambda x: x*2, my_list)
-----> print(list(my_iterable))  # prints [2, 4, 6, 8, 10]

---> Example usage on filter function (syntax wise its better to use list comprehension):
---> This is like the std::copy_if function.
-----> my_list = [1, 2, 3, 4, 5, 6]
-----> my_iterable = filter(lambda x: x%2==0, my_list)
-----> print(list(my_iterable))  # prints [2, 4, 6]

---> Example usage on filter function (syntax wise its better to use list comprehension):
---> This is like the std::accumulate/std::reduce function.
-----> from functools import reduce
-----> my_list = [1, 2, 3, 4, 5, 6]
-----> my_value = reduce(lambda x, y: x*y, my_list)
-----> print(my_value)  # prints 720



-> Errors and Exceptions
---> A python program terminates as soon as it encounters an error (can be a syntax error or an exception).

---> Syntax errors
-----> Syntax errors happen when the parser detects a syntactically incorrect statement.
-----> Examples:
-------> my_value = a5 print(my_value)  # no new line
-------> print(my_value))  # too many parentheses

---> Exceptions
-----> Exceptions happen when an internal error happens when executing a statement.
-----> Examples:
-------> some_variable = 5+'10'  # TypeError: unsupported operand type(s) for +: 'int' and 'str'
-------> import DoesNotExistModule  # ModuleNotFoundError: No module named 'DoesNotExistModule'
-------> some_variable =  not_defined_yet_variable  # NameError: name 'not_defined_yet_variable' is not defined
-------> file = open('FileDoesNotExist.txt')  #FileNotFoundError: No such file or directory: 'FileDoesNotExist.txt'

---> Exception handling
-----> Python has many built-in exceptions that are raised when a program encounters an error, and most external libraries, 
-----> like the popular Requests, include his own custom exceptions that we will need to deal to.

---> Raising an exception
-----> Using the raise statement
-------> x = -5
-------> if x < 0:
------->     raise Exception('x should be positive')  # The program went through here, raise an exception then terminates.
-----> Using the assert statement
-------> x = -5
-------> assert(x >= 0)  # AssertionError
-------> assert(x >= 0), 'x is not positive'  # AssertionError: x is not positive

---> Disabling Assertions
-----> Assertions can be disabled by passing the -O option when running Python.

---> Catching an exception (using the try except block)
-----> Catch all exceptions
-------> try:
------->     some_number = 1/0
------->     print('This statement will not be executed because exception happened before this.')
-------> except:  # catch all exceptions (not recommended)
------->     print('This will catch all exceptions. This is not recommended.')
-----> Catch only one exception
-------> try:
------->     some_number = 1/0
-------> except ZeroDivisionError:  # catch ZeroDivisionError only
------->     print('This caught the exception due to dividing a number by zero.')
-----> Catch only one exception and its error message
-------> try:
------->     some_number = 1/0
-------> except ZeroDivisionError as error_message:  # catch ZeroDivisionError only and its error message
------->     print(error_message)
-----> Catch multiple exceptions (and their error messages)
-------> try:
------->     some_number = 1/0
------->     some_variable = 5+'10'  # This will not be executed because exception happened before this.
-------> except ZeroDivisionError as error_message
------->     print(error_message)
-------> except TypeError as error_message
------->     print(error_message)
-----> Catch exceptions with else and finally
-------> try:
------->     some_number = 1/0
-------> except ZeroDivisionError as error_message
------->     print(error_message)
-------> else:  # This will be executed if there is no exception.
------->     print(some_number)
-------> finally:  # This will be executed always (regardless if theres an exception or not, this is normally used for cleanup operations).
------->     print(some_number)
-----> Common usage of exceptions is to catch invalid inputs 
-------> try:  
------->     some_number = int(input('Enter a number: '))
------->     print(some_number)
-------> except ValueError as error_message:
------->     print('Invalid input: ' + str(error_message))

---> Creating our own exceptions (user defined exceptions)
-----> class ValueTooHighError(Exception):  # its good practice to have the suffix 'Error' at the end
----->     pass
-----> class ValueTooLowError(Exception): 
----->     def __init__(self, message, value):  # has additional parameters on its construction
----->         self.message = message
----->         self.value = value
-----> def check_value(x):
----->     if x > 100:
----->         raise ValueTooHighError('Value is too high.')
----->     if x < -100:
----->         raise ValueTooLowError('Value is too low.', x)
-----> try:
----->     check_value(-200);  # comment out depending on which exception you want to raise
----->     check_value(200);
-----> except ValueTooHighError as error_message:
----->     print(error_message)  # prints Value is too high.
-----> except ValueTooLowError as error_message:
----->     print(error_message)  # prints ('Value is too low.', -200) 

---> Getting the Traceback as a string
-----> The traceback is displayed by Python whenever a raised exception goes unhandled. 
-----> But can also obtain it as a string by calling traceback.format_exc().
-----> This function is useful if you want the information from an exception’s traceback but also want an except statement to gracefully handle the exception. 
-----> You will need to import Python’s traceback module before calling this function.
-------> import traceback
-------> try:
------->     raise Exception('This is the error message.')
-------> except:
------->     with open('errorInfo.txt', 'w') as error_file:
------->         error_file.write(traceback.format_exc())
------->     print('The traceback info was written to errorInfo.txt.')
-------> # The traceback info was written to errorInfo.txt.
-----> This traceback text was written to errorInfo.txt:
-------> Traceback (most recent call last):
------->   File '<pyshell#28>', line 2, in <module>
-------> Exception: This is the error message.



-> Logging

---> Python already has powerful logging modules (so you can quickly add logging to your applications).

---> Logging levels
-----> Logging levels provide a way to categorize your log messages by importance. 
-----> Messages can be logged at each level using a different logging function.
-----> Log levels:
-------> logging.debug() -> The lowest level. Used for small details. Usually you care about these messages only when diagnosing problems.
-------> logging.info() -> Used to record information on general events in your program or confirm that things are working at their point in the program.
-------> logging.warning() -> Used to indicate a potential problem that doesn’t prevent the program from working but might do so in the future.
-------> logging.error() -> Used to record an error that caused the program to fail to do something.
-------> logging.critical() -> The highest level. Used to indicate a fatal error that has caused or is about to cause the program to stop running entirely.
-----> By default, only levels above warnings are printed (to change this you have to specify the logging configuration):
-------> import logging
-------> logging.debug('This is a debug message')  # this is NOT printed by default
-------> logging.info('This is an info message')  # this is NOT printed by default
-------> logging.warning('This is an warning message')  # this is printed by default
-------> logging.error('This is an error message')  # this is printed by default
-------> logging.critical('This is an critical message')  # this is printed by default

---> Setting the logging configuration:
-----> import logging
-----> logging.basicConfig(level=logging.DEBUG, format='%(asctime)s | %(name)s on %(levelname)s: %(message)s', datefmt='%m/%d/%Y %H:%M:%S')
-----> # Check the documentation for additional parameters of basicConfig (https://docs.python.org/3/lib rary/logging.html#logging.basicConfig).
-----> logging.debug('This is a debug message')  # prints 08/01/2022 15:03:11 | root on DEBUG: This is a debug message
-----> logging.info('This is an info message')  # prints 08/01/2022 15:03:11 | root on INFO: This is an info message
-----> logging.warning('This is an warning message')  # prints 08/01/2022 15:03:11 | root on WARNING: This is an warning message
-----> logging.error('This is an error message')  # prints 08/01/2022 15:03:11 | root on ERROR: This is an error message
-----> logging.critical('This is an critical message')  # prints 08/01/2022 15:03:11 | root on CRITICAL: This is an critical message

---> Disabling Logging
-----> After you’ve debugged your program, you probably don’t want all these log messages cluttering the screen. 
-----> The logging.disable() function disables these so that you don’t have to go into your program and remove all the logging calls by hand.
-------> import logging
-------> logging.basicConfig(level=logging.INFO, format=' %(asctime)s -%(levelname)s - %(message)s')
-------> logging.critical('Critical error! Critical error!')  # 2015-05-22 11:10:48,054 - CRITICAL - Critical error! Critical error!
-------> logging.disable(logging.CRITICAL)
-------> logging.critical('Critical error! Critical error!')
-------> logging.error('Error! Error!')

---> Logging to a File
-----> Instead of displaying the log messages to the screen, you can write them to a text file. 
-----> The logging.basicConfig() function takes a filename keyword argument, like so:
-------> import logging
-------> logging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

---> Create your own internal logger
-----> Its best practice NOT to use the root logger.
-----> Its also good practice to name your logger in the file where its executed.
-------> import logging
-------> logger = logging.getLogger(name=__name__)  # this uses the name of file as the name of the logger

---> Avoiding propagation of logs
-----> Since you can create your own loggers this can cause a hierarchy of loggers.
-----> Its starts at the root logger, and all this new loggers gets added to this hierarchy.
-----> And they propagate their message up to the base logger.
-----> One way to avoid this is to avoid propagation:
-------> logger.propagate = False  # now this will not print when executed in other files (when other loggers exists)

---> Log handlers
-----> You can add log handlers to have different ways of logging the same logs.
-------> import logging
-------> logger = logging.getLogger(__name__)
-------> # create handlers
-------> handler_for_console = logging.StreamHandler()
-------> handler_for_file = logging.FileHandler('Log.txt')
-------> # level and the format
-------> handler_for_console.setLevel(logging.WARNING)  # Sets the filtering in the console log
-------> handler_for_file.setLevel(logging.ERROR)  # Sets the filtering in the file log
-------> # creating custom formatters
-------> formatter_for_console = logging.Formatter('%(name)s on %(levelname)s: %(message)s') 
-------> formatter_for_file = logging.Formatter('%(asctime)s | %(name)s on %(levelname)s: %(message)s') 
-------> handler_for_console.setFormatter(formatter_for_console)
-------> handler_for_file.setFormatter(formatter_for_file)
-------> # Add handlers to logger
-------> logger.addHandler(handler_for_console)
-------> logger.addHandler(handler_for_file)
-------> # Do logging 
-------> logger.warning('This is a warning.')
-------> logger.error('This is an error.')

---> Log configuration file
-----> You dont have to hard code your logging, you can load a configuration file instead.
-----> In the configuration file (typically named 'logging.conf' or 'logging.ini')
-------> # See https://docs.python.org/3/library/logging.config.html#configuration-file-format
-------> [loggers]
-------> keys=root, internal, external
-------> [handlers]
-------> keys=handler_for_console, handler_for_file
-------> [formatters]
-------> keys=formatter_for_console, formatter_for_file
-------> [logger_root]
-------> level=WARNING
-------> handlers=handler_for_console
-------> [logger_external]
-------> level=INFO
-------> handlers=handler_for_console, handler_for_file
-------> propagate=0
-------> qualname=ExternalLogger
-------> [logger_internal]
-------> level=DEBUG
-------> handlers=handler_for_console, handler_for_file
-------> propagate=0
-------> qualname=InternalLogger
-------> [handler_handler_for_console]
-------> class=StreamHandler
-------> level=DEBUG
-------> formatter=formatter_for_console
-------> args=(sys.stdout, )
-------> [handler_handler_for_file]
-------> class=FileHandler
-------> level=DEBUG
-------> formatter=formatter_for_file
-------> args=('Log.txt', 'w')
-------> [formatter_formatter_for_console]
-------> format='%(asctime)s | %(name)s on %(levelname)s: %(message)s'
-------> [formatter_formatter_for_file]
-------> format='%(name)s on %(levelname)s: %(message)s'
-------> datefmt='%m/%d/%Y %H:%M:%S'
-----> Example usage of the configuration file:
-------> import logging
-------> import logging.config
-------> logging.config.fileConfig('logging.conf')
-------> logger = logging.getLogger('InternalLogger')
-------> logger.debug('This is a debug message')
-------> logger.info('This is an info message')
-------> logger.warning('This is an warning message')
-------> logger.error('This is an error message')
-------> logger.critical('This is an critical message')
-----> NOTE: You can also use a dictConfig file but it has a different format.

---> Stack trace logging
-----> To get the stack trace of the exception you can do this.
-----> If you want to catch the stack trace of a specific exception:
-------> import logging
-------> try:
------->     my_list = [1, 2, 3]
------->     my_number = my_list[4]
-------> except IndexError as error_message:
------->     logging.error(error_message, exc_info=True)
-----> If you want to catch the stack trace of all exceptions (using traceback module):
-------> import logging
-------> import traceback
-------> try:
------->     my_list = [1, 2, 3]
------->     my_number = my_list[4]
-------> except:
------->     logging.error('The error is %s', traceback.format_exc())

---> Rotating file handler
-----> This keeps the file at a specific size and keeps the most recent logs.
-----> Example usage:
-------> import logging
-------> from logging.handlers import RotatingFileHandler 
-------> logger= logging.getLogger(__name__)
-------> logger.setLevel(logging.INFO)
-------> # roll over after 2KB, and keep back logs log.txt.1, log.txt.2, etc
-------> handler = RotatingFileHandler('log.txt', maxBytes=2000, backupCount=3)  # max size of 2KB and keeps 3 backups
-------> logger.addHandler(handler)
-------> for _ in range(10000):
------->     logger.info('Hello, world!')  # Fill the logs with 'Hello, world!'

---> Timed rotating file handler
-----> The rotation of the log is determined by time instead.
-----> Example usage:
-------> import logging
-------> from logging.handlers import TimedRotatingFileHandler
-------> logger= logging.getLogger(__name__)
-------> logger.setLevel(logging.INFO)
-------> handler = TimedRotatingFileHandler('log.txt', when='s', interval=5, backupCount=3) # every 5 seconds a new file will be created
-------> # when can be set as s(seconds), m(minutes), h(hours), d(days), midnight, w0(monday), w1(tuesday)
-------> logger.addHandler(handler)
-------> for _ in range(10000):
------->     logger.info('Hello, world!')



-> Profiling 

---> How do you debug slow code?
-----> Profile it!

---> Basic example:
-----> Code:
-------> # start of code to test
-------> import time
-------> def sub_function1():
------->     print("sub_function1", 'doing something')
------->     time.sleep(1)
-------> def sub_function2():
------->     print("sub_function2", 'doing something')
------->     time.sleep(2)
-------> def sub_function3():
------->     print("sub_function3", 'doing something')
------->     time.sleep(1)
-------> def my_slow_function():
------->     sub_function1()
------->     sub_function2()
------->     sub_function3()
-------> # end of code to test
-------> # start of profiling
-------> def main():
------->     import cProfile
------->     import pstats
------->     with cProfile.Profile() as pr:
------->         my_slow_function()
------->     stats = pstats.Stats(pr)
------->     stats.sort_stats(pstats.SortKey.TIME)  # sort such that functions that make more time are at the top
------->     stats.print_stats()
------->     # stats.dump_stats(filename='stats.prof')  # for collecting stats and using them in a graph (snakeviz)
-------> if __name__ == '__main__':
------->     main()
-------> # end of profiling
-----> Console ouput:
-------> ncalls  tottime  percall  cumtime  percall filename:lineno(function)
------->      3    4.010    1.337    4.010    1.337 {built-in method time.sleep}
------->      3    0.001    0.000    0.001    0.000 {built-in method builtins.print}
------->      1    0.000    0.000    4.011    4.011 f:\Branches\APRG_GIT\aprg\aprg\Python\OtherProjects\app.py:11(my_slow_function)
------->      1    0.000    0.000    0.000    0.000 C:\Users\detec\AppData\Local\Programs\Python\Python310\lib\cProfile.py:117(__exit__)
------->      1    0.000    0.000    1.006    1.006 f:\Branches\APRG_GIT\aprg\aprg\Python\OtherProjects\app.py:2(sub_function1)
------->      1    0.000    0.000    2.002    2.002 f:\Branches\APRG_GIT\aprg\aprg\Python\OtherProjects\app.py:5(sub_function2)
------->      1    0.000    0.000    1.002    1.002 f:\Branches\APRG_GIT\aprg\aprg\Python\OtherProjects\app.py:8(sub_function3)
------->      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
-----> Notes:
-------> First check the 'tottime' or the total time.

---> snakeviz
-----> To install: pip install snakeviz
---> Basic example:
-----> (1) Code: Same code as above but instead of printing the stats, dump the stats.
-------> stats.dump_stats(filename='stats.prof')  # for collecting stats and using them in a graph (snakeviz)
-----> (2) call snakeviz in terminal
-------> Type in your terminal (make sure that youre in the correct directory):
---------> snakeviz ./stats.prof
-------> This automatically opens your default browser and show some nice graphs about the function.



-> JSON (JavaScript Object Notation)

---> Its a light weight data format that is used for data exchanges.
---> Its heavily used in web applications
---> Python has already have a built-in JSON module that makes working with JSON easy.

---> Python types to JSON types conversion
-----> dict (Python) <-> object (JSON)
-----> list, tuple (Python) <-> array (JSON)
-----> str (Python) <-> string (JSON)
-----> int, long, float (Python) <-> number (JSON)
-----> True (Python) <-> true (JSON)
-----> False (Python) <-> false (JSON)
-----> none (Python) <-> null (JSON)

---> Serialization/Encoding

-----> Converting python data into a JSON string
-------> import json
-------> python_data = {'name': 'John', 'age': 30, 'city': 'New York', 'hasChildren': False, 'titles': ['engineer', 'programmer']}
-------> json_data_string = json.dumps(python_data)  # the 's' in 'dumps' is for strings
-------> print(json_data_string)

-----> Converting python data into JSON and dumping it into a file
-------> import json
-------> with open('person.json', 'w') as file:
------->     json.dump(python_data, file, indent=4, sort_keys=True)

-----> Converting custom python class/object into JSON
-------> import json
-------> class User:
------->     def __init__(self, name, age):
------->         self.name = name
------->         self.age = age
-------> def encode_with_user(parameter):
------->     if isinstance (parameter, User):  # this checks if parameter is type User
------->         return {'name': parameter.name, 'age': parameter.age, parameter.__class__.__name__:True}
------->     else:
------->         return parameter
-------> # Use the specified encoder
-------> user = User('Max', 27)
-------> json_data_string = json.dumps(user, default=encode_with_user)
-------> print(json_data_string) 

---> Deserialization/Decoding

-----> Converting JSON string into python data 
-------> import json
-------> converted_data = json.loads(json_data_string)  # the 's' in 'loads' is for strings
-------> print(python_data)

-----> Reading JSON data from a file and converting it to python data 
-------> import json
-------> with open('person.json', 'r') as file:
------->     python_data = json.load(file)
-------> print(python_data)

-----> Converting from JSON string into a python class/object  
-------> import json
-------> class User:
------->     def __init__(self, name, age):
------->         self.name = name
------->         self.age = age
-------> def decode_with_user(parameter):
------->     if User.__name__  in parameter:  # this checks if the class name exists in the data
------->         return User(name=parameter['name'], age=parameter['age'])
------->     else:
------->         return parameter
-------> # Use the specified decoder
-------> python_data = json.loads(json_data_string, object_hook=decode_with_user)  # the 's' in 'loads' is for strings
-------> print(type(python_data), python_data.name, python_data.age)



-> YAML

---> Compared to JSON, YAML allows a much better human maintainability and gives ability to add comments. 
---> It is a convenient choice for configuration files where a human will have to edit.

---> There are two main libraries allowing to access to YAML files:=
-----> (1) PyYaml
-----> (2) Ruamel.yaml

---> Install them using pip install in your virtual environment.
---> The first one is easier to use but the second one, Ruamel, implements much better the YAML specification, and allow for example to modify a YAML content without altering comments.

---> Open a YAML file with:
-----> from ruamel.yaml import YAML
-----> with open('filename.yaml') as f:
----->     yaml=YAML()
----->     yaml.load(f)



-> Anyconfig

---> Anyconfig is a very handy package, allowing to abstract completely the underlying configuration file format. 
-----> It allows to load a Python dictionary from JSON, YAML, TOML, and so on.

---> Install it with: pip install anyconfig

---> Usage:
-----> import anyconfig
-----> conf1 = anyconfig.load('/path/to/foo/conf.d/a.yml')



-> Random Numbers

---> Using the python module 'random'
-----> You can seed and reseed the values so you can reproduce the random numbers.
-----> Because you can reproduce them, they are not recommended to be used on security applications.
-----> Example usages:
-------> import random
-------> seed_value = 100 
-------> random.seed(seed_value)  # so we can reproduce the same random numbers (without this it will random at each run)
-------> random_float = random.random()  # gives a random float on [0, 1)
-------> random_float_at_interval = random.uniform(-10.5, 10.5)  # gives a random float at interval
-------> random_int_at_interval1 = random.randint(-10, 10)  # gives a random integer (including both end points)
-------> random_int_at_interval2 = random.randrange(-10, 10)  # gives a random integer (half open at upper bound (so not included))
-------> random_at_normal_distribution = random.normalvariate(0, 1)  # gives a random float at normal distribution
-------> my_list = ['A', 'B', 'C', 'D', 'E', 'F']
-------> random_item = random.choice(my_list)  # picks a random element in a non-empty sequence
-------> random_items = random.sample(my_list, 3)  # picks multiple random elements (output is a list)
-------> random_items_multiple_times = random.choices(my_list, k=3)  # picks multiple random elements (output is a list, can be multiple times)
-------> random.shuffle(my_list)  # shuffle in place
-------> print(random_float)
-------> print(random_float_at_interval)
-------> print(random_int_at_interval1)
-------> print(random_int_at_interval2) 
-------> print(random_at_normal_distribution)
-------> print(random_item)
-------> print(random_items)
-------> print(random_items_multiple_times)
-------> print(my_list)

---> Using the python module 'secrets'
-----> This is used in security applications (passwords, security tokens, account authentication).
-------> import secrets
-------> random_int1 = secrets.randbelow(10)  # gives a random int in the range [0, n)
-------> random_int2 = secrets.randbits(8)  #  gives a random int with k random bits
-------> my_list = ['A', 'B', 'C', 'D', 'E', 'F']
-------> random_item = secrets.choice(my_list)  # picks a random element in a non-empty sequence
-------> print(random_int1)
-------> print(random_int2)
-------> print(random_item)

---> Using the python third party module 'numpy'
-----> This needs to be installed (preferably via pip)
-----> This can generate an array of random numbers.
-----> This uses different random generators from the standard library.
-------> import numpy as np
-------> seed_value = 100
-------> np.random.seed(seed_value)  # so we can reproduce the same random numbers (without this it will random at each run)
-------> random_floats = np.random.rand()  # gives a random float on [0, 1)
-------> random_floats_in_1d = np.random.rand(3)  # gives a random floats in a 1D list
-------> random_floats_in_2d = np.random.rand(3, 3)  # gives a random floats in a 2D list
-------> random_int = np.random.randint(0, 10)  # gives a random integer (half open at upper bound (so not included))
-------> random_ints_in_1d = np.random.randint(0, 10, 3)  # gives a random integer in a 1D list
-------> random_ints_in_2d = np.random.randint(0, 10, (3, 4))  # gives a random integer in a 2D list
-------> my_list_in_2d = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
-------> np.random.shuffle(my_list_in_2d)  # NOTE: this only shuffles in one dimension
-------> print(random_floats)
-------> print(random_floats_in_1d)
-------> print(random_floats_in_2d)
-------> print(random_int)
-------> print(random_ints_in_1d)
-------> print(random_ints_in_2d)
-------> print(my_list_in_2d)



-> Decorators

---> Functions in python are class objects:
-----> This means like any other objects they be defined inside another function.
-----> This means like any other objects they be pass as argument to another function.
-----> This means like any other objects they be returned from another function.
---> Typical use cases for decorators are:
-----> Timer decorator (to calculate the time inside the function)
-----> Debug decorator (print additional infomation about the called function)
-----> Check arguments decorator (to check if the arguments fulfill the additional requirements)
-----> Register functions (like plugins)
-----> Cache the return values, add information, update the state, etc

---> Function decorators
-----> Basic syntax:
-------> @first_decorator
-------> @second_decorator
-------> def do_something():
---------> pass

-----> Basic example:
-------> def my_decorator(function_to_decorate):
------->     def wrapper():  # can be renamed as something else (typically decorator_something)
------->         print('do something at the start')  # do something at the start
------->         function_to_decorate()
------->         print('do something at the end')  # do something at the end
------->     return wrapper
-------> @my_decorator  # decorator syntax
-------> def my_function():
------->     print('inside my_function')
-------> # my_function = my_decorator(my_function) # this is the same thing as above (without decorator syntax)
-------> my_function()

-----> Example usage (functions with arguments and return value):
-------> import functools
-------> def my_decorator(function_to_decorate):
------->     @functools.wraps(function_to_decorate)  # this preserves the identity as the passed function (without this it will recognized as 'wrapper')
------->     def wrapper(*args, **kwargs):  # can be renamed as something else (typically decorator_something)
------->         # '*args, **kwargs' means it can handle as much arguments and keyword arguments 
------->         print('do something at the start')  # do something at the start
------->         result = function_to_decorate(*args, **kwargs)
------->         print('do something at the end')  # do something at the end
------->         return result
------->     return wrapper
-------> @my_decorator  # decorator syntax
-------> def my_function(argument):
------->     print(f'inside my_function with value: {argument}')
------->     return argument
-------> # my_function = my_decorator(my_function) # this is the same thing as above (without decorator syntax)
-------> result = my_function(10)
-------> print(result)
-------> print('Help details: ')  # prints the function's identity (it should retain it)
-------> help(my_function)
-------> print(f'Function name: {my_function.__name__}')  # prints the function's name (it should retain it)

-----> Example usage (decorator with arguments):
-------> import functools
-------> def my_decorator_with_arguments(number_of_times_to_repeat):
------->     def sub_decorator(function_to_decorate):
------->         @functools.wraps(function_to_decorate)  # this preserves the identity as the passed function (without this it will recognized as wrapper)
------->         def wrapper(*args, **kwargs):  # this means it can handle as much arguments and keyword arguments 
------->             result = 0  # example usage
------->             for _ in range(number_of_times_to_repeat):  # example usage
------->                 result += function_to_decorate(*args, **kwargs)  # example usage
------->             return result
------->         return wrapper
------->     return sub_decorator
-------> @my_decorator_with_arguments(5)  # decorator syntax
-------> def my_function(argument):
------->     print(f'inside the function with value: {argument}')
------->     return argument
-------> # my_function = my_decorator(my_function) # this is the same thing as above (without decorator syntax)
-------> result = my_function(10)
-------> print(result)
-------> print('Help details: ')  # prints the function's identity (it should retain it)
-------> help(my_function)
-------> print(f'Function name: {my_function.__name__}')  # prints the function's name (it should retain it)


 
---> Class decorators
-----> class CountCalls:
----->     def __init__(self, function_to_decorate):
----->         self.function_to_decorate = function_to_decorate
----->         self.number_of_calls = 0
----->     def __call__(self, *args, **kwargs):
----->         self.number_of_calls += 1
----->         result = self.function_to_decorate(*args, **kwargs)
----->         print(f'{self.function_to_decorate.__name__} is executed {self.number_of_calls} times')
----->         return result
-----> @CountCalls
-----> def my_function():
----->     print('inside my_function')
-----> my_function()
-----> my_function()
-----> my_function()



-> Generators

---> They are like functions that return objects that can be iterated over (iterable).
---> They generate the items lazily, they generate it one at a time and only if you ask for it.
---> They are much more memory efficient than other sequence objects that deal with large data sets.
---> The syntax is just like a normal function but instead of the 'return' keyword they use the 'yield' keyword.
-----> It will give the next value at every yield.

---> Simple generator example:
-----> def my_generator():
----->     yield 1
----->     yield 2
----->     yield 3
-----> my_generator_object = my_generator()
-----> print(my_generator_object)  # prints generator object my_generator
-----> for item in my_generator_object:
----->     print(item)  # prints 1, 2, 3 at a time

---> 'next' function example:
-----> def my_generator():
----->     yield 1
----->     yield 2
----->     yield 3
-----> my_generator_object = my_generator()
-----> print(next(my_generator_object))  # prints 1
-----> print(next(my_generator_object))  # prints 2
-----> print(next(my_generator_object))  # prints 3
-----> # print(next(my_generator_object))  # StopOperation exception is raised because there is no yield left

---> You can pass generator objects as an iterable:
-----> def my_generator():
----->     yield 6
----->     yield 2
----->     yield 8
-----> my_generator_object = my_generator()
-----> print(sorted(my_generator_object))  # prints [2, 6, 8]
-----> # sorted expects an iterable also the output of sorted is a list

---> Generator objects consume less memory than actual structures:
-----> import sys
-----> actual_1_to_5 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
-----> def generator_from_1_to_10():
----->     for item in range(1, 10):
----->         yield item
-----> generator_object_from_1_to_5 = generator_from_1_to_5()
-----> print(sys.getsizeof(actual_1_to_5))  # prints 120
-----> print(sys.getsizeof(generator_object_from_1_to_5))  # prints 104

---> Fibonacci example:
-----> def fibonacci_generator(limitValue):
----->     # 0, 1, 1, 2, 3, 5, 8, 13
----->     current, next = 0, 1
----->     while current < limitValue:
----->         yield current
----->         current, next = next, current+next
-----> fibonacci_iterable = fibonacci_generator(30)
-----> for value in fibonacci_iterable:
----->     print(value)

---> Generator expression example (similar syntax to list comprehension):
-----> squared_numbers = [n*n for n in range(1, 10)]  # brackets mean list comprehension
-----> even_numbers = [n for n in range(1, 10) if n % 2 == 0]  # brackets mean list comprehension
-----> squared_numbers_generator_object = (n*n for n in range(1, 10))  # parentheses mean generator object
-----> even_numbers_generator_object = (n for n in range(1, 10) if n % 2 == 0)  # parentheses mean generator object
-----> print(squared_numbers)  # prints [1, 4, 9, 16, 25, 36, 49, 64, 81]
-----> print(even_numbers)  # prints [2, 4, 6, 8]
-----> for value in squared_numbers_generator_object: 
----->     print(value)
-----> for value in even_numbers_generator_object: 
----->     print(value)

---> Conversion to list (since its iterable it can be passed on its constructor)
-----> squared_numbers_generator_object = (n*n for n in range(1, 10))  # parentheses mean generator object
-----> even_numbers_generator_object = (n for n in range(1, 10) if n % 2 == 0)  # parentheses mean generator object
-----> print(list(squared_numbers_generator_object))  # prints [1, 4, 9, 16, 25, 36, 49, 64, 81]
-----> print(list(even_numbers_generator_object))  # prints [2, 4, 6, 8]



-> Multihtreading and multiprocessing

---> Process is an instance of a program
-----> Examples: the Python Interpreter, the firefox browser
-----> A thread on the other hand is an entity of a process (a process can have multiples threads inside).
-----> Pro: Takes advantage of multiple CPUs and cores
-----> Pro: Separate memory space -> memory is not shared between process
-----> Pro: Great for CPU-bound processing
-----> Pro: Processes are interruptable/killable
-----> Pro: One GIL (Global Interpreter Lock) for each process -> avoids GIL limitation
-----> Con: Heavyweight
-----> Con: Starting a process is slower than starting a thread.
-----> Con: More memory
-----> Con: IPC (inter-process communication) is more complicated
processes
---> Thread is an entity within a process that can be scheduled (also known as lightweight process)
-----> A process can spawn multiple threads.
-----> Pro: All thread within a process share the same memory
-----> Pro: Lightweight
-----> Pro: Starting a thread is faster than starting a process
-----> Pro: Great for I/O-bound tasks (can easily switch one thread (waiting for devices) to other threads)
-----> Con: Threading is limited by GIL: Only one thread at a time
-----> Con: No effect for CPU-bound tasks
-----> Con: Not interruptable/killable (be careful with resource leaks)
-----> Con: Careful with race conditions (two threads changing the same memory at the same time)

---> GIL is the Global Interpreter Lock
-----> This is a lock that allows only one thread at a time to execute in Python
-----> This is needed in CPython (the python implementation from python.org) because memory is not thread-safe
-------> The reference counting is not thread-safe (problems when the reference count is increased or decreased by different threads) 
-----> How to avoid the GIL?
-------> Use Multiprocessing
-------> Avoid CPython and use a different, free-threaded Python implementation (Jython, IronPython)
-------> Use python as wrapper for third-party libraries (C/C++) -> numpy, scipy

---> Multiprocessing simple example
-----> from multiprocessing import Process
-----> import os
-----> def my_function(argument1, argument2):
----->     print(f'inside my function with arguments: [{argument1, argument2}]')
-----> if __name__ == '__main__':  # needed on windows to avoid recursion (the processes other than main are creating their own process)
----->     processes = []  # create an empty list
----->     number_of_processes = os.cpu_count()  # its good to match the number of processes with the number of cores
----->     # create processes
----->     for _ in range(number_of_processes):
----->         process = Process(target=my_function, args=(10, 20))  # Note that args should be tuple here
----->         processes.append(process)
----->     # start processes
----->     for process in processes:
----->         process.start()
----->     # join or wait for all the processes to finish
----->     for process in processes:
----->         process.join()
----->     # program ends with all processes ended

---> Multithreading simple example
-----> from threading import Thread
-----> import os
-----> def my_function(argument1, argument2):
----->     print(f'inside my function with arguments: [{argument1, argument2}]')
-----> threads = []  # create an empty list
-----> number_of_threads = os.cpu_count()*2  # example number
-----> # create threads
-----> for _ in range(number_of_threads):
----->     thread = Thread(target=my_function, args=(10, 20))  # Note that args should be tuple here
----->     threads.append(thread)
-----> # start threads
-----> for thread in threads:
----->     thread.start()
-----> # join or wait for all the threads to finish
-----> for thread in threads:
----->     thread.join()
-----> # program ends with all threads ended

---> Multithreading: Sharing data between threads (common database example)
-----> from threading import Thread, Lock
-----> lock = Lock()
-----> database_value = 0
-----> def increase_value_in_database():
----->     global database_value
----->     global lock 
----->     with lock:  # need a lock to avoid race conditions
----->         local_copy = database_value  # similate a database access by getting a local copy
----->         local_copy += 1
----->         database_value = local_copy
-----> print('start value:', database_value)
-----> thread1 = Thread(target=increase_value_in_database)
-----> thread2 = Thread(target=increase_value_in_database)
-----> # start threads
-----> thread1.start()
-----> thread2.start()
-----> # join or wait for all the threads to finish
-----> thread1.join()
-----> thread2.join()
-----> print('end value:', database_value)
-----> # program ends with all threads ended

---> Multithreading: Use a common queue between threads (worker threads example)
-----> from threading import Thread, Lock, current_thread
-----> from queue import Queue  # for multiprocessing use this ('from multiprocessing import Queue') but usage is different
-----> def worker_function(jobs, lock):
----->     while True:  # infinite loop to get all values from the queue
----->         value = jobs.get()  # the get method will block the execution if the queue is empty
----->         # processing
----->         with lock:  # add a lock here to not have a jumbled print
----->             print(f'in {current_thread().name} got {value}')
----->         jobs.task_done() # For each get(), a call to task_done() tells the queue that the processing is finished
-----> jobs = Queue()
-----> lock = Lock()
-----> number_of_worker_threads = 10
-----> # start the workers
-----> for _ in range(number_of_worker_threads):
----->     worker_thread = Thread(target=worker_function, args=(jobs, lock))  # Note that args should be tuple here (hence the comma)
----->     worker_thread.daemon = True  # A daemon thread dies when the main thread dies (no cleanup needed)
----->     worker_thread.start()
-----> # fill in the jobs
-----> for i in range(1, 21):
----->     jobs.put(i)
-----> jobs.join()  # Blocks until all items in the Queue have been gotten and processed.

---> Multiprocessing: Use a shared value between processes 
-----> from multiprocessing import Process, Value, Lock
-----> def increase_shared_value(shared_value, increment, lock):
----->     with lock:  # need a lock to avoid race conditions
----->         for _ in range(increment):
----->             shared_value.value += 1
-----> if __name__ == '__main__':  # needed on windows to avoid recursion (the processes other than main are creating their own process)
----->     shared_value = Value('i', 0)
----->     lock = Lock()
----->     print('Number at beginning is', shared_value.value)
----->     process1 = Process(target=increase_shared_value, args=(shared_value, 100, lock))
----->     process2 = Process(target=increase_shared_value, args=(shared_value, 200, lock))
----->     process1.start()
----->     process2.start()
----->     process1.join()
----->     process2.join()
----->     print('Number at end is', shared_value.value)  # double check if value is correct (avoided race conditions)

---> Multiprocessing: Use a shared array between processes 
-----> from multiprocessing import Process, Array, Lock
-----> def increase_all_in_shared_array(shared_array, increment, lock):
----->     for _ in range(increment):
----->         for i in range(len(shared_array)):
----->             with lock:  # need a lock to avoid race conditions
----->                 shared_array[i] += 1
----->     
-----> if __name__ == '__main__':  # needed on windows to avoid recursion (the processes other than main are creating their own process)
----->     shared_array = Array('d', [0.0, 100.0, 200.0])
----->     lock = Lock()
----->     print('Array at beginning is', shared_array[:])
----->     process1 = Process(target=increase_all_in_shared_array, args=(shared_array, 100, lock))
----->     process2 = Process(target=increase_all_in_shared_array, args=(shared_array, 200, lock))
----->     process1.start()
----->     process2.start()
----->     process1.join()
----->     process2.join()
----->     print('Array at end is', shared_array[:])  # double check if value is correct (avoided race conditions)

---> Multiprocessing: Use a process pool
-----> A process pool can be used to manage multiple processes.
-----> A process pool object control a pool of worker processes to which jobs can be submitted.
-----> They manage the available process (split the data into smaller chunks, and feed it to different worker processes). 
-------> from multiprocessing import Pool
-------> def cube(number):
------->     return number * number * number
-------> if __name__ == '__main__':  # needed on windows to avoid recursion (the processes other than main are creating their own process)
------->     number = 54
------->     numbers = [1, 2, 3, 4, 5]
------->     pool = Pool()
------->     # The important functions in a process pool are map, apply join, close (please check documentation for more)
------->     apply_result = pool.apply(cube, args=(number,))  # apply can only process a single input
------->     map_result = pool.map(cube, numbers)  # map can process multiple inputs 
------->     pool.close()
------->     pool.join()
------->     print(numbers)  # prints [1, 2, 3, 4, 5]
------->     print(apply_result)  # prints 157464
------->     print(map_result)  # prints [1, 8, 27, 64, 125]
 


-> Function arguments and function parameters

---> The difference between arguments and parameters
-----> Arguments are the values passed while calling a function (so arguments are used when calling a function).
-----> Parameters are the variables inside the parentheses while defining a function (so arguments are used when defining a function).
-----> Example usage:
-------> def my_print_function(this_is_a_function_parameter):
------->     print(this_is_a_function_parameter)
-------> this_is_a_function_argument = 'SampleText'
-------> my_print_function(this_is_a_function_argument)

---> Positional and keyword arguments
-----> The difference is demonstrated in this example:
-------> def my_print_function(a, b, c):
------->     print(a, b, c)
-------> # Note: All of the prints below will show 1 2 3
-------> my_print_function(1, 2, 3)  # This call is using the 'position' to determine the arguments and parameters
-------> my_print_function(c=3, b=2, a=1)  # This call is using the 'keyword' to determine the arguments and parameters
-------> my_print_function(1, c=3, b=2)  # You can mix them up but with some limitations
-------> # my_print_function(1, c=3, 2)  # You cannot specify a position argument after a keyword argument
-------> # my_print_function(1, c=3, a=2)  # You cannot specify a keyword argument thats already been used as position argument

---> Default arguments
-----> This is demonstrated in this example:
-------> def my_print_function1(a, b, c, d=4):  # d has a default argument
------->     print(a, b, c, d)
-------> # def my_print_function2(a, b=2, c, d=4):  # default arguments should be at the last part of the definition
-------> #     print(a, b, c, d)
-------> my_print_function1(1, 2, 3)  # prints 1 2 3 4 (d has a default argument)

---> Variable-length arguments (*args and **kwargs)
-----> If you mark an parameter with one asterisk(*), then you can call it with any number of positional arguments.
-----> If you mark an parameter with two asterisks(**), then you can call it with any number of keyword arguments.
-----> The words *args and **kwargs are naming conventions.
-------> They are not imposed by the interpreter, but considered good practice by the Python community. 
-----> 'args' is a tuple 
-------> The position in the tuple determines the order of the positional arguments when it was called
-----> 'kwargs' is a dict
-------> The key of the dict is the keyword of that argument 
-------> The corresponding value of a key is the value of that argument
-----> This is demonstrated in this example:
-------> def my_print_function(a, b, *args, **kwargs):
------->     values = [str(a), str(b)]
------->     position = 1
------->     for positional_argument in args:
------->         values.append(f'position{position}={positional_argument}')
------->         position+=1
------->     for key in kwargs:
------->         values.append(f'{key}={kwargs[key]}')
------->     print(', '.join(values))
-------> my_print_function(1, 2, 3, 4)  # prints 1, 2, position1=3, position2=4
-------> my_print_function(1, 2, 3, 4, 5, six=6, seven=7)  # 1, 2, position1=3, position2=4, position3=5, six=6, seven=7

---> Force keywords arguments
-----> After the argument with one asterisk(*) or '*args', it needs to be a keyword arguments.
-----> This is demonstrated in this example:
-------> def my_print_function1(a, b, *, c, d):
------->     print(a, b, c, d)
-------> def my_print_function2(a, b, *args, c, d):
------->     print(a, b, c, d)
-------> # my_print_function1(1, 2, 3, 4)  # does not work because c and d needs to be keyword arguments
-------> my_print_function1(1, 2, c=3, d=4)  # prints 1 2 3 4
-------> # my_print_function2(1, 2, 3, 4)  # does not work because c and d needs to be keyword arguments
-------> my_print_function2(1, 2, c=3, d=4)  # prints 1 2 3 4

---> Container unpacking into function arguments
-----> The asterisk (*) can un pack container arguments.
-----> NOTE: The size of the container should match the number of parameters.
-----> This is demonstrated in this example:
-------> def my_print_function(a, b, c):
------->     print(a, b, c)
-------> my_print_function(*[1, 2, 3])  # prints 1 2 3 (asterisk(*) unpacks a list)
-------> my_print_function(*(1, 2, 3))  # prints 1 2 3 (asterisk(*) unpacks a tuple)
-------> my_print_function(*{1, 2, 3})  # prints 1 2 3 (asterisk(*) unpacks a set)
-------> # my_print_function(*[1, 2, 3, 4])  # TypeError (the number of parameters should match the size)
-------> my_print_function(*{'a':1, 'b':2, 'c':3})  # prints a b c (asterisk(*) unpacks the keys of a dict)
-------> my_print_function(**{'a':1, 'b':2, 'c':3})  # prints 1 2 3 (double asterisk(*) unpacks the values of a dict)
-------> # my_print_function(**{'e':1, 'f':2, 'g':3})  # TypeError (the keys should match the parameters names)

---> Local vs. Global arguments
-----> This is demonstrated in this example:
-------> def change_value_of_global_variable():
------->     global global_variable  # without this global declaration the next statement in this function will just create a local copy
------->     global_variable = 2
-------> global_variable = 1
-------> change_value_of_global_variable()
-------> print(global_variable)  # prints 2 if 'global' keyword is used (prints 1 (the value of the local copy) if there is no 'global' keyword used)

---> Parameter passing
-----> This is similar to 'pass by value' and 'pass by reference' in C++
-----> In python, its 'call by object' or 'call by object reference'. 
-----> The rules are different for mutable types(lists, dicts) and immutable types (ints, strings, tuples)
-----> For immutable types:
-------> def reassign_int(parameter_int):
------->     parameter_int = 2  # Due to reassignment, it rebinds now to a local variable unaffected the original argument.
-------> def reassign_str(parameter_str):
------->     parameter_str = 'Second'  # Due to reassignment, it rebinds now to a local variable unaffected the original argument.
-------> my_int = 1
-------> my_str = 'First'
-------> reassign_int(my_int)
-------> reassign_str(my_str)
-------> print(my_int)  # prints 1 (The value is NOT changed because its reassigned and int is immutable)
-------> print(my_str)  # prints First (The value is NOT changed because its reassigned and str is immutable)
-----> For mutable types:
-------> def reassign_list(parameter_list):
------->     parameter_list = [4, 5, 6]  # Due to reassignment, it rebinds now to a local variable unaffected the original argument.
-------> def mutate_list(parameter_list):
------->     parameter_list.append(4)  # This is a mutation and it mutated the original argument.
-------> my_list1 = [1, 2, 3]
-------> reassign_list(my_list1)
-------> print(my_list1)  # prints [1, 2, 3] (The value is NOT changed because its reassigned)
-------> my_list2 = [1, 2, 3]
-------> mutate_list(my_list2)
-------> print(my_list2)  # prints [1, 2, 3, 4] (The value is changed because its mutated and list is mutable)
-----> The operation(+=) for mutable types is a mutation.
-------> def reassign_list(parameter_list):
------->     parameter_list = parameter_list + [4, 5, 6]  # This still rebinds to a local variable.
-------> def mutate_list(parameter_list):
------->     parameter_list += [4, 5, 6]  # This is a mutation and it mutated the original argument.
-------> my_list1 = [1, 2, 3]
-------> reassign_list(my_list1)
-------> print(my_list1)  # prints [1, 2, 3] (The value is NOT changed because its reassigned)
-------> my_list2 = [1, 2, 3]
-------> mutate_list(my_list2)
-------> print(my_list2)  # prints [1, 2, 3, 4, 5, 6] (The value is changed because its mutated and list is mutable)



-> Asterisk/Star (*) operator
 
---> This has several meanings in python, here are some of the multiple different cases:

---> (1) The Asterisk/Star (*) operator is used in multiplication and power operations.
-----> For example:
-------> multiplication_result = 5*7
-------> power_result = 5**7
-------> print(multiplication_result)  # prints 35
-------> print(power_result)  # prints 78125

---> (2) The Asterisk/Star (*) operator is used creation of strings, list, tuples etc with repeated elements.
-----> See constructions in the sections for strings, lists and tuples.
-----> For example:
-------> my_str = 'XYZ' * 3
-------> my_list = [1, 2] * 3
-------> my_tuple = [4, 5, 6] * 3
-------> print(my_str)  # prints XYZXYZXYZ
-------> print(my_list)  # prints [1, 2, 1, 2, 1, 2]
-------> print(my_tuple)  # prints [4, 5, 6, 4, 5, 6, 4, 5, 6]

---> (3) The Asterisk/Star (*) operator is used for args kwargs and keyword only parameters
-----> See 'Variable-length arguments' and 'Force keywords arguments' subsections in the 'Function arguments and function parameters' section

---> (4) Its used for unpacking lists, tuples, sets, and dictionaries into function arguments.
-----> See 'Container unpacking into function arguments' subsection in the 'Function arguments and function parameters' section

---> (5) Its used for unpacking and merging containers.
-----> Take note that unpacking will always result to a list regardless of the structure used.
-----> Unpacking examples:
-------> my_tuple = (1, 2, 3, 4, 5, 6)
-------> start, *the_rest_at_end = my_tuple
-------> print(start, the_rest_at_end)  # prints 1 [2, 3, 4, 5, 6]
-------> *the_rest_at_start, end = my_tuple
-------> print(the_rest_at_start, end)  # prints [1, 2, 3, 4, 5] 6
-------> start, *the_rest_at_middle, end = my_tuple
-------> print(start, the_rest_at_middle, end)  # prints 1 [2, 3, 4, 5] 6
-------> first_start, second_start, *the_rest_at_middle, second_end, first_end = my_tuple
-------> print(first_start, second_start, the_rest_at_middle, second_end, first_end)  # prints 1 2 [3, 4] 5 6
-----> Merging examples (lists, tuples, sets):
-------> my_list = [1, 2, 3]
-------> my_tuple =(4, 5, 6)
-------> my_set = {7, 8, 9}
-------> new_list = [*my_list, *my_tuple, *my_set]
-------> new_tuple = (*my_list, *my_tuple, *my_set)
-------> new_set = {*my_list, *my_tuple, *my_set}
-------> print(new_list)  # prints [1, 2, 3, 4, 5, 6, 8, 9, 7]  (be careful with expecting the order on set)
-------> print(new_tuple)  # prints (1, 2, 3, 4, 5, 6, 8, 9, 7)  (be careful with expecting the order on set)
-------> print(new_set)  # prints {1, 2, 3, 4, 5, 6, 7, 8, 9}
-----> Merging examples (dictionaries):
-------> my_dict1 = {'a':1, 'b': 2}
-------> my_dict2 = {'c':3, 'd': 4}
-------> new_dict = {**my_dict1, **my_dict2}  # Use braces '{}' and double asterisk'**' for merging dictionaries
-------> print(new_dict)



-> Shallow copy vs Deep copy

---> Shallow copy: one level deep, only references of nested child objects
---> Deep copy: full independent copy

---> Copying on IMMUTABLE types is NOT a problem
-----> original = 5
-----> revised = original
-----> revised = 6
-----> print(original)  # prints 5
-----> print(revised)  # prints 6

---> Copying on MUTABLE types is NOT a problem if you reassign it
-----> original = [1, 2, 3]
-----> revised = original
-----> revised = [4, 5, 6]  # makes a new object
-----> print(original)  # prints [1, 2, 3]
-----> print(revised)  # prints [4, 5, 6]

---> Copying on MUTABLE types is a problem if you mutate it
-----> original = [1, 2, 3]
-----> revised = original
-----> revised.append(4)
-----> print(original)  # prints [1, 2, 3, 4]
-----> print(revised)  # prints [1, 2, 3, 4]

---> Copying on MUTABLE types can be done in various ways
-----> See the 'Copying' section of list, dictionaries, set etc

---> Copying on MUTABLE types can be done using the copy module
-----> Shallow copy example:
-------> import copy
-------> original = [1, 2, 3]
-------> revised = copy.copy(original)
-------> revised[2] = 4
-------> print(original)  # prints [1, 2, 3]
-------> print(revised)  # prints [1, 2, 4]
-----> Deep copy example:
-------> import copy
-------> original = [1, 2, 3]
-------> revised = copy.deepcopy(original)
-------> revised[2] = 4
-------> print(original)  # prints [1, 2, 3]
-------> print(revised)  # prints [1, 2, 4]
 
---> Copying on MUTABLE types with inner MUTABLE types needs to be deep copy
-----> 2D List example (shallow copy does NOT work):
-------> import copy
-------> original = [[1, 2, 3], 4, 5, 6], [7, 8, 9]]
-------> revised = copy.copy(original)
-------> revised[0][0] = 100
-------> print(original)  # prints [[100, 2, 3], [4, 5, 6], [7, 8, 9]]
-------> print(revised)  # prints [[100, 2, 3], [4, 5, 6], [7, 8, 9]]
-----> 2D List example (deep copy works):
-------> import copy
-------> original = [[1, 2, 3], 4, 5, 6], [7, 8, 9]]
-------> revised = copy.copy(original)
-------> revised[0][0] = 100
-------> print(original)  # prints [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
-------> print(revised)  # prints [[100, 2, 3], [4, 5, 6], [7, 8, 9]]
-----> Class/Object example:
-------> import copy
-------> class Person:
------->     def __init__(self, name, age):
------->         self.name = name
------->         self.age = age
-------> class Company:
------->     def __init__(self, boss, employee):
------->         self.boss = boss
------->         self.employee = employee
-------> p1 = Person('Alex', 55)
-------> p2 = Person('Joe', 27)
-------> company = Company(p1, p2)
-------> # company_clone = copy.copy(company)  # shallow copy does NOT work on the boss's age
-------> company_clone = copy.deepcopy(company)  # deep copy works
-------> company_clone.boss.age = 56
-------> print(company_clone.boss.age, company.boss.age)  # prints 56 55 if deep copy (56 56 if shallow copy)



-> Paths (file and directory handling)

---> There are two main modules in Python that deals with path manipulation. One is the os.path module and the other is the pathlib module.

---> os.path VS pathlib
-----> The `pathlib` module was added in Python 3.4, offering an object-oriented way to handle file system paths.

---> Linux and Windows Paths
-----> On Windows, paths are written using backslashes (\) as the separator between folder names. 
-----> On Unix based operating system such as macOS, Linux, and BSDs, the forward slash (/) is used as the path separator. 
-----> Joining paths can be a headache if your code needs to work on different platforms.
-----> Fortunately, Python provides easy ways to handle this. We will showcase how to deal with both, os.path.join and pathlib.Path.joinpath
-----> Using os.path.join on Windows:
-------> import os
-------> os.path.join('usr', 'bin', 'spam')  # 'usr\\bin\\spam'
-----> And using pathlib on *nix:
-------> from pathlib import Path
-------> print(Path('usr').joinpath('bin').joinpath('spam'))  # usr/bin/spam
-----> pathlib also provides a shortcut to joinpath using the / operator:
-------> from pathlib import Path
-------> print(Path('usr') / 'bin' / 'spam')  # usr/bin/spam
----> Notice the path separator is different between Windows and Unix based operating system, 
----> that’s why you want to use one of the above methods instead of adding strings together to join paths together.
----> Joining paths is helpful if you need to create different file paths under the same directory.
----> Using os.path.join on Windows:
-------> my_files = ['accounts.txt', 'details.csv', 'invite.docx']
-------> for filename in my_files:
------->     print(os.path.join('C:\\Users\\asweigart', filename))
-------> # C:\Users\asweigart\accounts.txt
-------> # C:\Users\asweigart\details.csv
-------> # C:\Users\asweigart\invite.docx
----> Using pathlib on *nix:
-------> my_files = ['accounts.txt', 'details.csv', 'invite.docx']
-------> home = Path.home()
-------> for filename in my_files:
------->     print(home / filename)
-------> # /home/asweigart/accounts.txt
-------> # /home/asweigart/details.csv
-------> # /home/asweigart/invite.docx

---> The current working directory
-----> Using os on Windows:
-------> import os
-------> os.getcwd()  # 'C:\\Python34'
-------> os.chdir('C:\\Windows\\System32')
-------> os.getcwd()  # 'C:\\Windows\\System32'
-----> Using pathlib on *nix:
-------> from pathlib import Path
-------> from os import chdir
-------> print(Path.cwd())  # /home/asweigart
-------> chdir('/usr/lib/python3.6')
-------> print(Path.cwd())  # /usr/lib/python3.6

---> Creating new folders
-----> Using os on Windows:
-------> import os
-------> os.makedirs('C:\\delicious\\walnut\\waffles')
-----> Using pathlib on *nix:
-------> from pathlib import Path
-------> cwd = Path.cwd()
-------> (cwd / 'delicious' / 'walnut' / 'waffles').mkdir()
-------> # Traceback (most recent call last):
-------> #   File "<stdin>", line 1, in <module>
-------> #   File "/usr/lib/python3.6/pathlib.py", line 1226, in mkdir
-------> #     self._accessor.mkdir(self, mode)
-------> #   File "/usr/lib/python3.6/pathlib.py", line 387, in wrapped
-------> #     return strfunc(str(pathobj), *args)
-------> # FileNotFoundError: [Errno 2] No such file or directory: '/home/asweigart/delicious/walnut/waffles'
-----> Oh no, we got a nasty error! The reason is that the ‘delicious’ directory does not exist, 
-----> so we cannot make the ‘walnut’ and the ‘waffles’ directories under it. To fix this, do:
-------> from pathlib import Path
-------> cwd = Path.cwd()
-------> (cwd / 'delicious' / 'walnut' / 'waffles').mkdir(parents=True)
-----> And all is good :)

---> Absolute vs. Relative paths
-----> There are two ways to specify a file path.
-------> (1) An absolute path, which always begins with the root folder
-------> (2) A relative path, which is relative to the program’s current working directory
-----> There are also the dot (.) and dot-dot (..) folders. These are not real folders, but special names that can be used in a path. 
-----> A single period (“dot”) for a folder name is shorthand for “this directory.” Two periods (“dot-dot”) means “the parent folder.”

---> Handling Absolute paths
-----> To see if a path is an absolute path:
-------> Using os.path on *nix:
---------> import os
---------> os.path.isabs('/')  # True
---------> os.path.isabs('..')  # False
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> Path('/').is_absolute()  # True
---------> Path('..').is_absolute()  # False
-----> You can extract an absolute path with both os.path and pathlib
-------> Using os.path on *nix:
---------> import os
---------> os.getcwd() '/home/asweigart'
---------> os.path.abspath('..') '/home'
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> print(Path.cwd())  # /home/asweigart
---------> print(Path('..').resolve()) # /home

---> Handling Relative paths
-----> You can get a relative path from a starting path to another path.
-------> Using os.path on *nix:
---------> import os
---------> os.path.relpath('/etc/passwd', '/')  # 'etc/passwd'
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> print(Path('/etc/passwd').relative_to('/'))  # etc/passwd

---> Path and File validity

-----> Checking if a file/directory exists
-------> Using os.path on *nix:
---------> import os
---------> os.path.exists('.')  # True
---------> os.path.exists('setup.py')  # True
---------> os.path.exists('/etc')  # True
---------> os.path.exists('nonexistentfile')  # False
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> Path('.').exists()  # True
---------> Path('setup.py').exists()  # True
---------> Path('/etc').exists()  # True
---------> Path('nonexistentfile').exists()  # False

-----> Checking if a path is a file
-------> Using os.path on *nix:
---------> import os
---------> os.path.isfile('setup.py')  # True
---------> os.path.isfile('/home')  # False
---------> os.path.isfile('nonexistentfile')  # False
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> Path('setup.py').is_file()  # True
---------> Path('/home').is_file()  # False
---------> Path('nonexistentfile').is_file()  # False

-----> Checking if a path is a directory
-------> Using os.path on *nix:
---------> import os
---------> os.path.isdir('/')  # True
---------> os.path.isdir('setup.py')  # False
---------> os.path.isdir('/spam')  # False
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> Path('/').is_dir()  # True
---------> Path('setup.py').is_dir()  # False
---------> Path('/spam').is_dir()  # False

-----> Getting a file’s size in bytes
-------> Using os.path on Windows:
---------> import os
---------> os.path.getsize('C:\\Windows\\System32\\calc.exe')  # 776192
-------> Using pathlib on *nix:
---------> from pathlib import Path
---------> stat = Path('/bin/python3.6').stat()
---------> print(stat) # stat contains some other information about the file as well
---------> # os.stat_result(st_mode=33261, st_ino=141087, st_dev=2051, st_nlink=2, st_uid=0,
---------> # --snip--
---------> # st_gid=0, st_size=10024, st_atime=1517725562, st_mtime=1515119809, st_ctime=1517261276)
---------> print(stat.st_size) # size in bytes  # 10024

---> Listing directories
-----> Listing directory contents using os.listdir on Windows:
-------> import os
-------> os.listdir('C:\\Windows\\System32')
-------> # ['0409', '12520437.cpx', '12520850.cpx', '5U877.ax', 'aaclient.dll',
-------> # --snip--
-------> # 'xwtpdui.dll', 'xwtpw32.dll', 'zh-CN', 'zh-HK', 'zh-TW', 'zipfldr.dll']
-----> Listing directory contents using pathlib on *nix:
-------> from pathlib import Path
-------> for f in Path('/usr/bin').iterdir():
-------> print(f)
-------> # ...
-------> # /usr/bin/tiff2rgba
-------> # /usr/bin/iconv
-------> # /usr/bin/ldd
-------> # /usr/bin/cache_restore
-------> # /usr/bin/udiskie
-------> # /usr/bin/unix2dos
-------> # /usr/bin/t1reencode
-------> # /usr/bin/epstopdf
-------> # /usr/bin/idle3
-------> # ...

---> Directory file sizes
-----> WARNING
-------> Directories themselves also have a size! 
-------> So, you might want to check for whether a path is a file or directory using the methods in the methods discussed in the above section.
-----> Using os.path.getsize() and os.listdir() together on Windows:
-------> import os
-------> total_size = 0
-------> for filename in os.listdir('C:\\Windows\\System32'):
------->     total_size = total_size + os.path.getsize(os.path.join('C:\\Windows\\System32', filename))
-------> print(total_size)  # 1117846456
-----> Using pathlib on *nix:
-------> from pathlib import Path
-------> total_size = 0
-------> for sub_path in Path('/usr/bin').iterdir():
------->   total_size += sub_path.stat().st_size
-------> print(total_size)  # 1903178911

---> Copying files and folders
-----> The shutil module provides functions for copying files, as well as entire folders.
-------> import shutil, os
-------> os.chdir('C:\\')
-------> shutil.copy('C:\\spam.txt', 'C:\\delicious')  # C:\\delicious\\spam.txt'
-------> shutil.copy('eggs.txt', 'C:\\delicious\\eggs2.txt')  # 'C:\\delicious\\eggs2.txt'
-----> While shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it:
-------> import shutil, os
-------> os.chdir('C:\\')
-------> shutil.copytree('C:\\bacon', 'C:\\bacon_backup')  # 'C:\\bacon_backup'

---> Moving and Renaming
-------> import shutil
-------> shutil.move('C:\\bacon.txt', 'C:\\eggs')  # 'C:\\eggs\\bacon.txt'
-----> The destination path can also specify a filename. In the following example, the source file is moved and renamed:
-------> shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')  # 'C:\\eggs\\new_bacon.txt'
-----> If there is no eggs folder, then move() will rename bacon.txt to a file named eggs:
-------> shutil.move('C:\\bacon.txt', 'C:\\eggs')  # 'C:\\eggs'

---> Deleting files and folders
-----> Calling os.unlink(path) or Path.unlink() will delete the file at path.
-----> Calling os.rmdir(path) or Path.rmdir() will delete the folder at path. This folder must be empty of any files or folders.
-----> Calling shutil.rmtree(path) will remove the folder at path, and all files and folders it contains will also be deleted.

---> Safe Deletes with the send2trash
-----> You can install this module by running pip install send2trash from a Terminal window.
-------> import send2trash
-------> with open('bacon.txt', 'a') as bacon_file: # creates the file
------->     bacon_file.write('Bacon is not a vegetable.')  # 25
-------> send2trash.send2trash('bacon.txt')

---> Walking a Directory Tree
-----> import os
-----> for folder_name, subfolders, filenames in os.walk('C:\\delicious'):
----->     print(f'The current folder is {folder_name}')
----->     for subfolder in subfolders:
----->         print('SUBFOLDER OF {folder_name}: {subfolder}')
----->     for filename in filenames:
----->         print('FILE INSIDE {folder_name}: filename{filename}')
----->     print('')
-----> # The current folder is C:\delicious
-----> # SUBFOLDER OF C:\delicious: cats
-----> # SUBFOLDER OF C:\delicious: walnut
-----> # FILE INSIDE C:\delicious: spam.txt
-----> # The current folder is C:\delicious\cats
-----> # FILE INSIDE C:\delicious\cats: catnames.txt
-----> # FILE INSIDE C:\delicious\cats: zophie.jpg
-----> # The current folder is C:\delicious\walnut
-----> # SUBFOLDER OF C:\delicious\walnut: waffles
-----> # The current folder is C:\delicious\walnut\waffles
-----> # FILE INSIDE C:\delicious\walnut\waffles: butter.txt

---> Pathlib vs Os Module
-----> 'pathlib' provides a lot more functionality than the ones listed above, like getting file name, getting file extension, reading/writing a file without manually opening it, etc. 
-----> See the official documentation if you intend to know more. 



-> Files (Reading and Writing Files)

---> The file Reading/Writing process
-----> To read/write to a file in Python, you will want to use the with statement, which will close the file for you after you are done, managing the available resources for you.

---> Opening and reading files with the open() function
-----> with open('C:\\Users\\your_home_folder\\hi.txt', 'r') as hello_file:
----->     # 'r' for read
----->     # 'w' for write
----->     # 'a' for append
----->     # 'r+' for read and write
----->     hello_content = hello_file.read()
-----> print(hello_content)  # prints 'Hello World!'

---> Reading from files:
-----> with open('sample.txt', 'r') as sample_file:
----->     print('Is readable:' + str(sample_file.readable()))  # This returns a boolean if the file can be read (files opened by write will return false)
----->     print('The entire contents:' + sample_file.read())  # This prints the entire contents of the file
----->     sample_file.seek(0)  # reset at the start of the file
----->     print('First line: ' + sample_file.readline())  # This prints one line of the file
----->     print('Second line: ' + sample_file.readline())  # This prints one line of the file
----->     print(sample_file.readline())  # This prints one line of the file
----->     sample_file.seek(0)  # reset at the start of the file
----->     for line in sample_file:
----->         print('Line at the loop:' + line.strip())
----->     sample_file.seek(0)  # reset at the start of the file
----->     print(sample_file.readlines())  # This prints all line in a list (readlines() put all lines in a list)
----->     sample_file.seek(0)  # reset at the start of the file
----->     for line in sample_file.readlines():
----->         print('Line at the loop:' + line.strip())

---> Writing to files:
-----> # appending to a file
-----> with open('sample.txt', 'a') as sample_file:
----->     sample_file.write('Toby - Human Resources\n') # This appends to the last line.
-----> # writing to a file
-----> with open('sample.txt', 'w') as sample_file:
----->     sample_file.write('Toby - Human Resources\n')  # This writes a line to the file (and erasing it previous contents).

---> Saving variables with the shelve module

-----> To save variables:
-------> import shelve
-------> cats = ['Zophie', 'Pooka', 'Simon']
-------> with shelve.open('mydata') as shelf_file:
------->     shelf_file['cats'] = cats

-----> To open and read variables:
-------> with shelve.open('mydata') as shelf_file:
------->     print(type(shelf_file))
------->     print(shelf_file['cats'])
-------> # <class 'shelve.DbfilenameShelf'>
-------> # ['Zophie', 'Pooka', 'Simon']

-----> Just like dictionaries, shelf values have keys() and values() methods that will return list-like values of the keys and values in the shelf. 
-----> Since these methods return list-like values instead of true lists, you should pass them to the list() function to get them in list form.
-------> with shelve.open('mydata') as shelf_file:
------->     print(list(shelf_file.keys()))
------->     print(list(shelf_file.values()))
-------> # ['cats']
-------> # [['Zophie', 'Pooka', 'Simon']]

---> Reading ZIP files
-----> import zipfile, os
-----> os.chdir('C:\\')    # move to the folder with example.zip
-----> with zipfile.ZipFile('example.zip') as example_zip:
----->     print(example_zip.namelist())
----->     spam_info = example_zip.getinfo('spam.txt')
----->     print(spam_info.file_size)
----->     print(spam_info.compress_size)
----->     print('Compressed file is %sx smaller!' % (round(spam_info.file_size / spam_info.compress_size, 2)))
-----> # ['spam.txt', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg']
-----> # 13908
-----> # 3828
-----> # 'Compressed file is 3.63x smaller!'

---> Extracting from ZIP Files
-----> The extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory.
-------> import zipfile, os
-------> os.chdir('C:\\')    # move to the folder with example.zip
-------> with zipfile.ZipFile('example.zip') as example_zip:
------->     example_zip.extractall()
-----> The extract() method for ZipFile objects will extract a single file from the ZIP file:
-------> with zipfile.ZipFile('example.zip') as example_zip:
------->     print(example_zip.extract('spam.txt'))
------->     print(example_zip.extract('spam.txt', 'C:\\some\\new\\folders'))
-------> # 'C:\\spam.txt'
-------> # 'C:\\some\\new\\folders\\spam.txt'

---> Creating and Adding to ZIP Files
-----> import zipfile
-----> with zipfile.ZipFile('new.zip', 'w') as new_zip:
----->     new_zip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED)
-----> # This code will create a new ZIP file named new.zip that has the compressed contents of spam.txt.



-> Regular Expressions

---> A regular expression (shortened as regex [...]) is a sequence of characters that specifies a search pattern in text. 
---> This is used by string-searching algorithms for 'find' or 'find and replace' operations on strings, or for input validation.

---> Steps on handling regexes
-----> (1) Import the regex match_objectdule with import re.
-----> (2) Create a Regex object with the re.compile() function. (Remember to use a raw string.)
-----> (3) Pass the string you want to search into the Regex object’s search() method. This returns a Match object.
-----> (4) Call the Match object’s group() method to return a string of the actual matched text.

---> Regex symbols
-----> Check RegexNotes.txt (for a better reference)

---> Matching regex objects
-----> import re
-----> phone_num_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
-----> match_object = phone_num_regex.search('My number is 415-555-4242.')
-----> print(f'Phone number found: {match_object.group()}')  # prints Phone number found: 415-555-4242

---> Grouping with parentheses
-----> import re
-----> phone_num_regex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
-----> print(match_object) = phone_num_regex.search('My number is 415-555-4242.')
-----> print(match_object.group(1))  # prints '415'
-----> print(match_object.group(2))  # prints '555-4242'
-----> print(match_object.group(0))  # prints '415-555-4242'
-----> print(match_object.group())  # prints '415-555-4242'
-----> print(match_object.groups())  # prints ('415', '555-4242')
-----> area_code, main_number = match_object.groups()
-----> print(area_code)  # prints 415
-----> print(main_number)  # prints 555-4242

---> Multiple groups with Pipe
-----> You can use the | character anywhere you want to match one of many expressions.
-------> import re
-------> hero_regex = re.compile (r'Batman|Tina Fey')
-------> match_object1 = hero_regex.search('Batman and Tina Fey.')
-------> print(match_object1.group())  # prints 'Batman'
-------> match_object2 = hero_regex.search('Tina Fey and Batman.')
-------> print(match_object2.group())  # prints 'Tina Fey'
-----> You can also use the pipe to match one of several patterns as part of your regex:
-------> import re
-------> bat_regex = re.compile(r'Bat(man|match_objectbile|copter|bat)')
-------> match_object = bat_regex.search('Batmatch_objectbile lost a wheel')
-------> print(match_object.group())  # prints 'Batmatch_objectbile'
-------> print(match_object.group(1))  # prints 'match_objectbile'

---> Optional matching with the Question Mark
-----> The ? character flags the group that precedes it as an optional part of the pattern.
-------> import re
-------> bat_regex = re.compile(r'Bat(wo)?man')
-------> match_object1 = bat_regex.search('The Adventures of Batman')
-------> print(match_object1.group())  # prints 'Batman'
-------> match_object2 = bat_regex.search('The Adventures of Batwoman')
-------> print(match_object2.group())  # prints 'Batwoman'

---> Matching zero or match_objectre with the Star
-----> The * (star or asterisk) means “match zero or match_objectre”. 
-----> The group that precedes the star can occur any number of times in the text.
-------> import re
-------> bat_regex = re.compile(r'Bat(wo)*man')
-------> match_object1 = bat_regex.search('The Adventures of Batman')
-------> print(match_object1.group())  # prints 'Batman'
-------> match_object2 = bat_regex.search('The Adventures of Batwoman')
-------> print(match_object2.group())  # prints 'Batwoman'
-------> match_object3 = bat_regex.search('The Adventures of Batwowowowoman')
-------> print(match_object3.group())  # prints 'Batwowowowoman'

---> Matching one or match_objectre with the Plus
-----> The + (or plus) means match one or match_objectre. 
-----> The group preceding a plus must appear at least once:
-------> import re
-------> bat_regex = re.compile(r'Bat(wo)+man')
-------> match_object1 = bat_regex.search('The Adventures of Batwoman')
-------> print(match_object1.group())  # prints # 'Batwoman'
-------> match_object2 = bat_regex.search('The Adventures of Batwowowowoman')
-------> print(match_object2.group())  # prints 'Batwowowowoman'
-------> match_object3 = bat_regex.search('The Adventures of Batman')
-------> print(match_object3 is None)  # prints True

---> Matching specific repetitions with Curly Brackets
-----> If you have a group that you want to repeat a specific number of times, 
-----> follow the group in your regex with a number in curly brackets:
-------> import re
-------> ha_regex = re.compile(r'(Ha){3}')
-------> match_object1 = ha_regex.search('HaHaHa')
-------> print(match_object1.group())  # prints 'HaHaHa'
-------> match_object2 = ha_regex.search('Ha')
-------> print(match_object2 is None)  # prints True
-----> Instead of one number, you can specify a range with minimum and a maximum in between the curly brackets. 
-----> For example, the regex (Ha){3,5} will match ‘HaHaHa’, ‘HaHaHaHa’, and ‘HaHaHaHaHa’.
-------> import re
-------> ha_regex = re.compile(r'(Ha){2,3}')
-------> match_object1 = ha_regex.search('HaHaHaHa')
-------> print(match_object1.group())  # prints 'HaHaHa'

---> Greedy and non-greedy matching
-----> Python’s regular expressions are greedy by default: 
-----> in ambiguous situations they will match the longest string possible. 
-----> The non-greedy version of the curly brackets, which matches the shortest string possible, 
-----> has the closing curly bracket followed by a question mark.
-------> import re
-------> greedy_ha_regex = re.compile(r'(Ha){3,5}')
-------> match_object1 = greedy_ha_regex.search('HaHaHaHaHa')
-------> print(match_object1.group())  # prints 'HaHaHaHaHa'
-------> non_greedy_ha_regex = re.compile(r'(Ha){3,5}?')
-------> match_object2 = non_greedy_ha_regex.search('HaHaHaHaHa')
-------> print(match_object2.group())  # prints 'HaHaHa'

---> The findall() method
-----> The findall() method will return the strings of every match in the searched string.
-------> import re
-------> phone_num_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups
-------> phone_num_regex.findall('Cell: 415-555-9999 Work: 212-555-0000')  # prints ['415-555-9999', '212-555-0000']

---> Making your own character classes
-----> You can define your own character class using square brackets. 
-----> For example, the character class [aeiouAEIOU] will match any vowel, both lowercase and uppercase.
-------> import re
-------> vowel_regex = re.compile(r'[aeiouAEIOU]')
-------> print(vowel_regex.findall('Robocop eats baby food. BABY FOOD.'))  
-------> # prints ['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']
-----> You can also include ranges of letters or numbers by using a hyphen. 
-----> For example, the character class [a-zA-Z0-9] will match all lowercase letters, uppercase letters, and numbers.
-----> By placing a caret character (^) just after the character class’s opening bracket, 
-----> you can make a negative character class that will match all the characters that are not in the character class:
-------> import re
-------> consonant_regex = re.compile(r'[^aeiouAEIOU]')
-------> print(consonant_regex.findall('Robocop eats baby food. BABY FOOD.'))
-------> # prints ['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']

---> The Caret and Dollar sign characters
-----> You can also use the caret symbol ^ at the start of a regex to indicate that a match must occur at the beginning of the searched text.
-----> Likewise, you can put a dollar sign $ at the end of the regex to indicate the string must end with this regex pattern.
-----> And you can use the ^ and $ together to indicate that the entire string must match the regex.
-----> The r'^Hello’ regular expression string matches strings that begin with ‘Hello’:
-------> import re
-------> begins_with_hello = re.compile(r'^Hello')
-------> print(begins_with_hello.search('Hello world!'))  # prints <_sre.SRE_Match object; span=(0, 5), match='Hello'>
-------> print(begins_with_hello.search('He said hello.')) is None  # prints True
-----> The r'\d\$' regular expression string matches strings that end with a numeric character from 0 to 9:
-------> import re
-------> whole_string_is_num = re.compile(r'^\d+$')
-------> print(whole_string_is_num.search('1234567890'))  # prints <_sre.SRE_Match object; span=(0, 10), match='1234567890'>
-------> print(whole_string_is_num.search('12345xyz67890') is None)  # prints True
-------> print(whole_string_is_num.search('12 34567890') is None)  # prints True

---> The Wildcard character
-----> The . (or dot) character in a regular expression will match any character except for a newline:
-------> import re
-------> at_regex = re.compile(r'.at')
-------> print(at_regex.findall('The cat in the hat sat on the flat mat.'))  # prints ['cat', 'hat', 'sat', 'lat', 'mat']

---> Matching everything with Dot-Star
-------> import re
-------> name_regex = re.compile(r'First Name: (.*) Last Name: (.*)')
-------> match_object = name_regex.search('First Name: Al Last Name: Sweigart')
-------> print(match_object.group(1))  # prints 'Al'
-------> print(match_object.group(2))  # prints 'Sweigart'
-----> The .* uses greedy match_object: It will always try to match as much text as possible. 
-----> To match any and all text in a non-greedy fashion, use the dot, star, and question mark (.*?).
-----> The question mark tells Python to match in a non-greedy way:
-------> import re
-------> non_greedy_regex = re.compile(r'<.*?>')
-------> match_object = non_greedy_regex.search('<To serve man> for dinner.>')
-------> print(match_object.group())  # prints '<To serve man>'
-------> greedy_regex = re.compile(r'<.*>')
-------> match_object = greedy_regex.search('<To serve man> for dinner.>')
-------> print(match_object.group())  # prints '<To serve man> for dinner.>'

---> Matching newlines with the Dot character
-----> The dot-star will match everything except a newline. 
-----> By passing re.DOTALL as the second argument to re.compile(), 
-----> you can make the dot character match all characters, including the newline character:
-------> import re
-------> no_newline_regex = re.compile('.*')
-------> print(no_newline_regex.search('Serve the public trust.\nProtect the innocent.\nUphold the law.').group())  
-------> # prints 'Serve the public trust.'
-------> newline_regex = re.compile('.*', re.DOTALL)
-------> print(newline_regex.search('Serve the public trust.\nProtect the innocent.\nUphold the law.').group())  
-------> # prints 'Serve the public trust.\nProtect the innocent.\nUphold the law.'

---> Case-Insensitive matching
-----> To make your regex case-insensitive, you can pass re.IGNORECASE or re.I as a second argument to re.compile():
-------> import re
-------> robocop = re.compile(r'robocop', re.IGNORECASE)
-------> print(robocop.search('Robocop is part man, part machine, all cop.').group())  # prints 'Robocop'
-------> print(robocop.search('ROBOCOP protects the innocent.').group())  # prints 'ROBOCOP'
-------> print(robocop.search('Al, why does your programming book talk about robocop so much?').group())  # prints 'robocop'

---> Substituting strings with the sub() method
-----> The sub() method for Regex objects is passed two arguments:
-------> (1) The first argument is a string to replace any matches.
-------> (2) The second is the string for the regular expression.
-----> The sub() method returns a string with the substitutions applied:
-------> import re
-------> names_regex = re.compile(r'Agent \w+')
-------> print(names_regex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.'))  
-------> # prints 'CENSORED gave the secret documents to CENSORED.'

---> Managing complex Regexes
-----> To tell the re.compile() function to ignore whitespace and comments inside the regular expression string,
-----> “verbose match_objectde” can be enabled by passing the variable re.VERBOSE as the second argument to re.compile().
-----> Now instead of a hard-to-read regular expression like this:
-------> import re
-------> phone_regex = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4}(\s*(ext|x|ext.)\s*\d{2,5})?)')
-----> you can spread the regular expression over multiple lines with comments like this:
-------> import re
-------> phone_regex = re.compile(r'''(
------->     (\d{3}|\(\d{3}\))?            # area code
------->     (\s|-|\.)?                    # separator
------->     \d{3}                         # first 3 digits
------->     (\s|-|\.)                     # separator
------->     \d{4}                         # last 4 digits
------->     (\s*(ext|x|ext.)\s*\d{2,5})?  # extension
------->     )''', re.VERBOSE)



-> Python setup.py

---> A 'controversial' opinion
-----> Using `setup.py` to pack and distribute your python packages can be quite challenging every so often. 
-----> Tools like Poetry make not only the packaging a lot easy, but also help you to manage your dependencies in a very convenient way.

---> Introduction
-----> The setup script is the center of all activity in building, distributing, and installing modules using the Distutils. 
-------> The main purpose of the setup script is to describe your module distribution to the Distutils, 
-------> so that the various commands that operate on your modules do the right thing.
-----> The setup.py file is at the heart of a Python project. It describes all the metadata about your project. 
-------> There are quite a few fields you can add to a project to give it a rich set of metadata describing the project. 
-------> However, there are only three required fields: name, version, and packages. 
-------> The name field must be unique if you wish to publish your package on the Python Package Index (PyPI).
-------> The version field keeps track of different releases of the project. 
-------> The package’s field describes where you’ve put the Python source code within your project.
-------> This allows you to easily install Python packages. Often it’s enough to write:
---------> python setup.py install
-------> and module will install itself.

-----> Example
-----> Our initial setup.py will also include information about the license and will re-use the README.txt file for the long_description field. 
-----> This will look like:
-------> from distutils.core import setup
-------> setup(
------->    name='pythonCheatsheet',
------->    version='0.1',
------->    packages=['pipenv',],
------->    license='MIT',
------->    long_description=open('README.txt').read(),
-------> )


