This notes are taken from C++ Primer


-> Notes on minimum sizes: 
The type "int" has minimum size of 16.
The difference between "long long" and "long long long" is the guarantee of the minimum size.
The floating types have a minimum number of significant digits.
-------------------------------------------------------------------
Table 2.1: C++: Arithmetic Types (taken from C++ Primer)
-------------------------------------------------------------------
Type           | Meaning                           | Minimum Size
-------------------------------------------------------------------
bool           | boolean                           | NA
char           | character                         | 8 bits
wchar_t        | wide character                    | 16 bits
char16_t       | Unicode character                 | 16 bits
char32_t       | Unicode character                 | 32 bits
short          | short integer                     | 16 bits
int            | integer                           | 16 bits
long long      | integer                           | 32 bits
long long long | integer                           | 64 bits
float          | single-precision floating-point   | 6 significant digits
double         | double-precision floating-point   | floating-point 10 significant digits
long double    | extended-precision floating-point | floating-point 10 significant digits
-------------------------------------------------------------------


-> NOTE: ADVICE: DECIDING WHICH TYPE TO USE (taken from C++ Primer)
C++, like C, is designed to let programs get close to the hardware when necessary.
The arithmetic types are defined to cater to the peculiarities of various kinds of hardware.
Accordingly, the number of arithmetic types in C++ can be bewildering. 
Most programmers can (and should) ignore these complexities by restricting the types they use. 
A few rules of thumb can be useful in deciding which type to use:

• Use an unsigned type when you know that the values cannot be negative.
• Use int for integer arithmetic. short is usually too small and, in practice, long often has the same size as int. 
If your data values are larger than the minimum guaranteed size of an int, then use long long.
• Do not use plain char or bool in arithmetic expressions.
Use them only to hold characters or truth values. 
Computations using char are especially problematic because char is signed on some machines and unsigned on others. 
If you need a tiny integer, explicitly specify either signed char or unsigned char.
• Use double for floating-point computations; float usually does not have enough precision, 
and the cost of double-precision calculations versus single precision is negligible. 
In fact, on some machines, double-precision operations are faster than single. 
The precision offered by long double usually is unnecessary and often entails considerable run-time cost.


-> NOTE: CAUTION: DON’T MIX SIGNED AND UNSIGNED TYPES (taken from C++ Primer) 
Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. 
It is essential to remember that signed values are automatically converted to unsigned. 
For example, in an expression like a * b, if a is -1 and b is 1, then if both a and b are ints, the value is, as expected -1. 
However, if a is int and b is an unsigned, then the value of this expression depends on how many bits an int has on the particular machine. 
On our machine, this expression yields 4294967295.


-> Note on Type Conversions:
Type Conversions
The type of an object defines the data that an object might contain and what operations that object can perform. 
Among the operations that many types support is the ability to convert objects of the given type to other, related types.
Type conversions happen automatically when we use an object of one type where an object of another type is expected. 
We’ll have more to say about conversions in § 4.11 (p. 159), but for now it is useful to understand what happens when we assign a value of one type to an object of another type.
When we assign one arithmetic type to another:
bool b = 42; // b is true
int i = b; // i has value 1
i = 3.14; // i has value 3
double pi = i; // pi has value 3.0
unsigned char c = -1; // assuming 8-bit chars, c has value 255
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined
what happens depends on the range of the values that the types permit:
• When we assign one of the nonbool arithmetic types to a bool object, the result is false if the value is 0 and true otherwise.
• When we assign a bool to one of the other arithmetic types, the resulting value is 1 if the bool is true and 0 if the bool is false.
• When we assign a floating-point value to an object of integral type, the value is truncated. 
The value that is stored is the part before the decimal point.
• When we assign an integral value to an object of floating-point type, the fractional part is zero. 
Precision may be lost if the integer has more bits than the floating-point object can accommodate.
• If we assign an out-of-range value to an object of unsigned type, 
the result is the remainder of the value modulo the number of values the target type can hold. 
For example, an 8-bit unsigned char can hold values from 0 through 255, inclusive. 
If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. 
Therefore, assigning –1 to an 8-bit unsigned char gives that object the value 255.
• If we assign an out-of-range value to an object of signed type, the result is undefined. 
The program might appear to work, it might crash, or it might produce garbage values.


-> NOTE: CAUTION: DON’T MIX SIGNED AND UNSIGNED TYPES
Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. 
It is essential to remember that signed values are automatically converted to unsigned. 
For example, in an expression like a * b, if a is -1 and b is 1, then if both a and b are ints, the value is, as expected -1. 
However, if a is int and b is an unsigned, then the value of this expression depends on how many bits an int has on the particular machine.
On our machine, this expression yields 4294967295.


-> Escape sequences:
Some characters, such as backspace or control characters, have no visible image.
Such characters are nonprintable. 
Other characters (single and double quotation marks, question mark, and backslash) have special meaning in the language. 
Our programs cannot use any of these characters directly. 
Instead, we use an escape sequence to represent such characters. 
An escape sequence begins with a backslash.
The language defines several escape sequences:
newline \n 
horizontal tab \t 
alert (bell) \a
vertical tab \v 
backspace \b 
double quote \"
backslash \\ 
question mark \? 
single quote \’
carriage return \r 
formfeed \f
We use an escape sequence as if it were a single character:
std::cout << ’\n’; // prints a newline
std::cout << "\tHi!\n"; // prints a tab followd by "Hi!" and a newline
We can also write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits. 
The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):
\7 (bell) 
\12 (newline) 
\40(blank)
\0 (null) 
\115 (’M’) 
\x4d (’M’)


-> Specifying the Type of a Literal
We can override the default type of an integer, floating- point, or character literal by supplying a suffix or prefix as listed in Table 2.2.

-------------------------------------------------------------------
Character and Character String Literals
-------------------------------------------------------------------
Prefix | Meaning | Type
-------------------------------------------------------------------
u      | Unicode 16 character         | char16_t
U      | Unicode 32 character         | char32_t
L      | wide character               | wchar_t
u8     | utf-8 (string literals only) | char
-------------------------------------------------------------------
Integer Literals
-------------------------------------------------------------------
Suffix   | Minimum Type 
-------------------------------------------------------------------
u or U   | unsigned 
l or L   | long 
ll or LL | long long
-------------------------------------------------------------------
Floating-Point Literals
-------------------------------------------------------------------
Suffix   | Type 
-------------------------------------------------------------------
f or F   | float
l or L   | long double

Examples:
L’a’ // wide character literal, type is wchar_t
u8"hi!" // utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
42ULL // unsigned integer literal, type is unsigned long long
1E-3F // single-precision floating-point literal, type is float
3.14159L // extended-precision floating-point literal, type is long double


-> NOTE: When you write a long literal, use the uppercase L; the lowercase letter l is too easily mistaken for the digit 1.


-> NOTE: Initializers
An object that is initialized gets the specified value at the moment it is created.
The values used to initialize a variable can be arbitrarily complicated expressions.
When a definition defines two or more variables, the name of each object becomes visible immediately. 
Thus, it is possible to initialize a variable to the value of one defined earlier in the same definition.
double price = 109.99, discount = price * 0.16; // ok: price is defined and initialized before it is used to initialize discount
double salePrice = applyDiscount(price, discount); // ok: call applyDiscount and use the return value to initialize salePrice

Initialization in C++ is a surprisingly complicated topic and one we will return to again and again. 
Many programmers are confused by the use of the = symbol to initialize a variable. 
It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. 
This concept is particularly confusing because in many languages the distinction is irrelevant and can be ignored. 
Moreover, even in C++ the distinction often doesn’t matter.
Nonetheless, it is a crucial concept and one we will reiterate throughout the text.

-> NOTE: Initialization is not assignment.
Initialization happens when a variable is given a value when it is created. 
Assignment obliterates an object’s current value and replaces that value with a new one.


-> NOTE: List Initialization
One way in which initialization is a complicated topic is that the language defines several different forms of initialization. 
For example, we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);

When used with variables of built-in type, this form of initialization has one important property: 
The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld; // ok: but value will be truncated


-> NOTE: Default Initialization
When we define a variable without an initializer, the variable is default initialized.
Such variables are given the “default” value. 
What that default value is depends on the type of the variable and may also depend on where the variable is defined.
The value of an object of built-in type that is not explicitly initialized depends on where it is defined.
Variables defined outside any function body are initialized to zero. 
With one exception, which we cover in § 6.1.1 (p. 205), variables of built-in type defined inside a function are uninitialized. 
The value of an uninitialized variable of built-in type is undefined (§ 2.1.2, p. 36). 
It is an error to copy or otherwise try to access the value of a variable whose value is undefined.

-> NOTE: Most classes let us define objects without explicit initializers. 
Such classes supply an appropriate default value for us. 
For example, aswe’ve just seen, the library string class says that if we do not supply an initializer, 
then the resulting string is the empty string:
std::string empty; // empty implicitly initialized to the empty string
Sales_item item; // default-initialized Sales_item object

-> NOTE: Uninitialized objects of built-in type defined inside a function body have undefined value. 
Objects of class type that we do not explicitly initialize have a value that is defined by the class.


-> Direct and Copy Forms of Initialization
In § 2.2.1 (p. 43) we saw that C++ has several different forms of initialization. 
Using strings, we can start to understand how these forms differ from one another.
When we initialize a variable using =,
we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. 
Otherwise, when we omit the =, we use direct initialization.
When we have a single initializer, we can use either the direct or copy form of initialization. 
When we initialize a variable from more than one value, such as in the initialization of s4 above, 
we must use the direct form of initialization:
string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, ’c’); // direct initialization; s7 is cccccccccc
When we want to use several values, 
we can indirectly use the copy form of initialization by explicitly creating a (temporary) object to copy:
string s8 = string(10, ’c’); // copy initialization; s8 is cccccccccc
The initializer of s8—string(10, ’c’) — creates a string of the given size and character value and then copies that value into s8. 
It is as if we had written:
string temp(10, ’c’); // temp is cccccccccc
string s8 = temp; // copy temp into s8
Although the code used to initialize s8 is legal, it is less readable and offers no compensating advantage over the way we initialized s7.


-> NOTE: Value Initialization
We can usually omit the value and supply only a size. 
In this case the library creates a value-initialized element initializer for us. 
This library-generated value is used to initialize each element in the container. 
The value of the element initializer depends on the type of the elements stored in the vector.
If the vector holds elements of a BUILT-IN TYPE, such as int, then the element initializer has a value of 0. 
If the elements are of a CLASS TYPE, such as string, then the element initializer is itself default initialized:
vector<int> ivec(10); // ten elements, each initialized to 0
vector<string> svec(10); // ten elements, each an empty string
There are two restrictions on this form of initialization: 
The first restriction is that some classes require that we always supply an explicit initializer (§ 2.2.1, p. 44). 
If our vector holds objects of a type that we cannot default initialize, 
then we must supply an initial element value; it is not possible to create vectors of such types by supplying only a size.
The second restriction is that when we supply an element count without also supplying an initial value, 
we must use the direct form of initialization


-> NOTE: CAUTION: UNINITIALIZED VARIABLES CAUSE RUN-TIME PROBLEMS
An uninitialized variable has an indeterminate value. 
Trying to use the value of an uninitialized variable is an error that is often hard to debug. 
Moreover, the compiler is not required to detect such errors, although most will warn about at least some uses of uninitialized variables.
What happens when we use an uninitialized variable is undefined. 
Sometimes, we’re lucky and our program crashes as soon as we access the object. 
Once we track down the location of the crash, it is usually easy to see that the variable was not properly initialized. 
Other times, the program completes but produces erroneous results.
Even worse, the results may appear correct on one run of our program but fail on a subsequent run. 
Moreover, adding code to the program in an unrelated location can cause what we thought was a correct program to start producing incorrect results.


-> NOTE: We recommend initializing every object of built-in type. 
It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.


-> NOTE: Variables must be defined exactly once but can be declared many times.


-> NOTE: KEY CONCEPT: STATIC TYPING
C++ is a statically typed language, which means that types are checked at compile time. 
The process by which types are checked is referred to as type checking.
As we’ve seen, the type of an object constrains the operations that the object can perform. 
In C++, the compiler checks whether the operations we write are supported by the types we use. 
If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.
As our programs get more complicated, we’ll see that static type checking can help find bugs. 
However, a consequence of static checking is that the type of every entity we use must be known to the compiler. 
As one example, we must declare the type of a variable before we can use that variable.


-> NOTE: ADVICE: DEFINE VARIABLES WHERE YOU FIRST USE THEM
It is usually a good idea to define an object near the point at which the object is first used. 
Doing so improves readability by making it easy to find the definition of the variable. 
More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used


-> NOTE: It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.


-> NOTE: References
A reference defines an alternative name for an object. 
A reference type “refers to” another type. 
We define a reference type by writing a declarator of the form &d, where d is the name being declared:
int ival = 1024;
int &refVal = ival; // refVal refers to (is another name for) ival
int &refVal2; // error: a reference must be initialized


-> NOTE: The new standard introduced a new kind of reference: an “rvalue reference,” which we’ll cover in § 13.6.1 (p. 532). These references are primarily
intended for use inside classes. Technically speaking, when we use the term reference, we mean “lvalue reference.”


-> NOTE: A Reference Is an Alias
A reference is not an object. Instead, a reference is just another name for an already existing object.


-> NOTE: Reference Definitions
We can define multiple references in a single definition. 
Each identifier that is a reference must be preceded by the & symbol:
int i = 1024, i2 = 2048; // i and i2 are both ints
int &r = i, r2 = i2; // r is a reference bound to i; r2 is an int
int i3 = 1024, &ri = i3; // i3 is an int; ri is a reference bound to i3
int &r3 = i3, &r4 = i2; // both r3 and r4 are references


-> NOTE: Pointers
A pointer is a compound type that “points to” another type. 
Like references, pointers are used for indirect access to other objects. 
Unlike a reference, a pointer is an object in its own right. 
Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. 
Unlike a reference, a pointer need not be initialized at the time it is defined. 
Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.


-> NOTE: Pointers are often hard to understand. Debugging problems due to pointer errors bedevil even experienced programmers.


-> NOTE: Taking the Address of an Object
A pointer holds the address of another object. 
We get the address of an object by using the address-of operator (the & operator):
int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
With two exceptions, which we cover in § 2.4.2 (p. 62) and § 15.2.3 (p. 601), 
the types of the pointer and the object to which it points must match:
double dval;
double *pd = &dval; // ok: initializer is the address of a double
double *pd2 = pd; // ok: initializer is a pointer to double
int *pi = pd; // error: types of pi and pd differ
pi = &dval; // error: assigning the address of a double to a pointer to int


-> NOTE: Pointer Value
The value (i.e., the address) stored in a pointer can be in one of four states:
1. It can point to an object.
2. It can point to the location just immediately past the end of an object.
3. It can be a null pointer, indicating that it is not bound to any object.
4. It can be invalid; values other than the preceding three are invalid.


-> NOTE: Using a Pointer to Access an Object
When a pointer points to an object, we can use the dereference operator (the * operator) to access that object:
int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
cout << *p; // * yields the object to which p points; prints 42
Dereferencing a pointer yields the object to which the pointer points. 
We can assign to that object by assigning to the result of the dereference:
*p = 0; // * yields the object; we assign a new value to ival through p
cout << *p; // prints 0
When we assign to *p, we are assigning to the object to which p points.


-> NOTE: We may dereference only a valid pointer that points to an object.


-> NOTE: KEY CONCEPT: SOME SYMBOLS HAVE MULTIPLE MEANINGS
Some symbols, such as & and *, are used as both an operator in an expression and as part of a declaration. 
The context in which a symbol is used determines what the symbol means:
int i = 42;
int &r = i; // & follows a type and is part of a declaration; r is a reference
int *p; // * follows a type and is part of a declaration; p is a pointer
p = &i; // & is used in an expression as the address-of operator
*p = i; // * is used in an expression as the dereference operator
int &r2 = *p; // & is part of the declaration; * is the dereference operator
In declarations, & and * are used to form compound types. 
In expressions, these same symbols are used to denote an operator. 
Because the same symbol is used with very different meanings, it can be helpful to ignore appearances 
and think of them as if they were different symbols.


-> NOTE: ADVICE: INITIALIZE ALL POINTERS
Uninitialized pointers are a common source of run-time errors.
As with any other uninitialized variable, what happens when we use an uninitialized pointer is undefined. 
Using an uninitialized pointer almost always results in a run-time crash. 
However, debugging the resulting crashes can be surprisingly hard.
Under most compilers, when we use an uninitialized pointer, the bits in the memory inwhich the pointer resides are used as an address. 
Using an uninitialized pointer is a request to access a supposed object at that supposed location. 
There is no way to distinguish a valid address from an invalid one formed from the bits that happen to be in the memory in which the pointer was allocated.
Our recommendation to initialize all variables is particularly important for pointers.
If possible, define a pointer only after the object to which it should point has been defined. 
If there is no object to bind to a pointer, then initialize the pointer to nullptr or zero. 
That way, the program can detect that the pointer does not point to an object.


-> NOTE: References to Pointers
A reference is not an object. 
Hence, we may not have a pointer to a reference.
However, because a pointer is an object, we can define a reference to a pointer:
int i = 42;
int *p; // p is a pointer to int
int *&r = p; // r is a reference to the pointer p
r = &i; // r refers to a pointer; assigning &i to r makes p point to i
*r = 0; // dereferencing r yields i, the object to which p points; changes i to 0


-> NOTE: To share a const object among multiple files, you must define the variable as extern.
To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):
// file_1.cc defines and initializes a const that is accessible to other files
extern const int bufSize = fcn();
// file_1.h
extern const int bufSize; // same bufSize as defined in file_1.cc
In this program, file_1.cc defines and initializes bufSize. 
Because this declaration includes an initializer, it is (as usual) a definition.
However, because bufSize is const, we must specify extern in order for bufSize to be used in other files.
The declaration in file_1.h is also extern. 
In this case, the extern signifies that bufSize is not local to this file and that its definition will occur elsewhere.


-> NOTE: void* Pointers
The type void* is a special pointer type that can hold the address of any object.
Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown


-> NOTE: Because we can’t change the value of a const object after we create it, it must be initialized. 
As usual, the initializer may be an arbitrarily complicated expression:
const int i = get_size(); // ok: initialized at run time
const int j = 42; // ok: initialized at compile time
const int k; // error
pointer examples:
int i, *const cp;       // error: cp is uninitialized const
int *p1, *const p2;     // error: p2 is uninitialized const
const int ic, &r = ic;  // error: ic is uninitialized const
const int *const p3;    // error: p3 is uninitialized const
const int *p;           // no error


-> NOTE: Objects of built-in type defined at global scope are initialized to 0;
those defined at local scope are uninitialized and have undefined values.


-> TERMINOLOGY: CONST REFERENCE IS A REFERENCE TO CONST (THIS IS IMPORTANT)
C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.”
This abbreviation makes sense—if you remember that it is an abbreviation.
Technically speaking, there are no const references. 
A reference is not an object, so we cannot make a reference itself const. 
Indeed, because there is no way to make a reference refer to a different object, in some sense all references are const. 
Whether a reference refers to a const or nonconst type affects what we can do with that reference, 
not whether we can alter the binding of the reference itself.


-> NOTE: Initialization and References to const
In § 2.3.1 (p. 51) we noted that there are two exceptions to the rule that the type of a reference must match the type of the object to which it refers. 
The first exception is that we can initialize a reference to const from any expression that can be converted (§ 2.1.2, p. 35) to the type of the reference. 
In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression:
int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object
const int &r2 = 42; // ok: r1 is a reference to const
const int &r3 = r1 * 2; // ok: r3 is a reference to const
int &r4 = r * 2; // error: r4 is a plain, nonconst reference
The easiest way to understand this difference in initialization rules is to consider what happens when we bind a reference to an object of a different type:
double dval = 3.14;
const int &ri = dval;
Here ri refers to an int. 
Operations on ri will be integer operations, but dval is a floating-point number, not an integer. 
To ensure that the object to which ri is bound is an int, the compiler transforms this code into something like
const int temp = dval; // create a temporary const int from the double
const int &ri = temp; // bind ri to that temporary
In this case, ri is bound to a temporary object. 
A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 
C++ programmers often use the word temporary as an abbreviation for temporary object. 


-> NOTE: ME: There is a lot of difference of "reference to const" to "pointer to const".
---> Mainly because "reference to const" can create a temporary so it can convert more types (Check entries before this).

-> NOTE: ME: A good rule of thumb is to check whats going on underneath and check if its possible, if its not its an error.


-> NOTE: A Reference to const May Refer to an Object That Is Not const (THIS IS IMPORTANT! THIS IS THE RULE THAT MESSES ME UP)
It is important to realize that a reference to const restricts only what we can do through that reference. 
Binding a reference to const to an object says nothing about whether the underlying object itself is const. 
Because the underlying object might be nonconst, it might be changed by other means:
int i = 42;
int &r1 = i; // r1 bound to i
const int &r2 = i; // r2 also bound to i; but cannot be used to change i
r1 = 0; // r1 is not const; i is now 0
r2 = 0; // error: r2 is a reference to const
Binding r2 to the (nonconst) int i is legal. 
However, we cannot use r2 to change i. 
Even so, the value in i still might change. 
We can change i by assigning to it directly, or by assigning to another reference bound to i, such as r1.
i = 43;


-> NOTE: Pointers and constexpr
It is important to understand that when we define a pointer in a constexpr declaration, 
the constexpr specifier applies to the pointer, not the type to which the pointer points:
const int *p = nullptr; // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int
Despite appearances, the types of p and q are quite different; p is a pointer to const, whereas q is a constant pointer. 
The difference is a consequence of the fact that constexpr imposes a top-level const (§ 2.4.3, p. 63) on the objects it defines.
Like any other constant pointer, a constexpr pointer may point to a const or a nonconst type:
constexpr int *np = nullptr; // np is a constant pointer to int that is null
int j = 0;
constexpr int i = 42; // type of i is const int
// i and j must be defined outside any function
constexpr const int *p = &i; // p is a constant pointer to the const int i
constexpr int *p1 = &j; // p1 is a constant pointer to the int j


-> NOTE: Pointers, const, and Type Aliases
Declarations that use type aliases that represent compound types and const can yield surprising results. 
For example, the following declarations use the type pstring, which is an alias for the the type char*:
typedef char *pstring;
const pstring cstr = 0; // cstr is a constant pointer to char
const pstring *ps; // ps is a pointer to a constant pointer to char
The base type in these declarations is const pstring. 
As usual, a const that appears in the base type modifies the given type. 
The type of pstring is “pointer to char.” 
So, const pstring is a constant pointer to char — not a pointer to const char.
It can be tempting, albeit incorrect, to interpret a declaration that uses a type alias by conceptually replacing the alias with its corresponding type:
const char *cstr = 0; // wrong interpretation of const pstring cstr
However, this interpretation is wrong. 
When we use pstring in a declaration, the base type of the declaration is a pointer type. 
When we rewrite the declaration using char*, the base type is char and the * is part of the declarator.
In this case, const char is the base type. 
This rewrite declares cstr as a pointer to const char rather than as a const pointer to char.


-> NOTE: As with any other type specifier, we can define multiple variables using auto.
Because a declaration can involve only a single base type, 
the initializers for all the variables in the declaration must have types that are consistent with each other:
auto i = 0, *p = &i; // ok: i is int and p is a pointer to int
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi


-> NOTE: The compiler uses that object’s type (base type?) for auto’s type deduction:
int i = 0, &r = i;
auto a = r; // a is an int (r is an alias for i, which has type int)


-> NOTE: Auto ordinarily ignores top-level consts (§ 2.4.3, p. 63). 
As usual in initializations, low-level consts, such as when an initializer is a pointer to const, are kept:
int i;
const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)
auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i; // d is an int* (& of an int object is int*)
auto e = &ci; // e is const int* (& of a const object is low-level const)
If we want the deduced type to have a top-level const, we must say so explicitly:
const auto f = ci; // deduced type of ci is int; f has type const int
We can also specify that we want a reference to the auto-deduced type. 
Normal initialization rules still apply:
auto &g = ci; // g is a const int& that is bound to ci
auto &h = 42; // error: we can’t bind a plain reference to a literal
const auto &j = 42; // ok: we can bind a const reference to a literal


-> NOTE: As usual, the initializers in auto must provide consistent auto-deduced types (ME: including the constness of the type):
int i;
const int ci;
auto k = ci, &l = i; // k is int; l is int&
auto &m = ci, *p = &ci; // m is a const int&; p is a pointer to const int
// error: type deduced from i is int; type deduced from &ci is const int
auto &n = i, *p2 = &ci;


-> NOTE: The way decltype handles top-level const and references differs subtly from the way auto does. 
When the expression to which we apply decltype is a variable, decltype returns the type of that variable, including top-level const and references
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z; // error: z is a reference and must be initialized
Because cj is a reference, decltype(cj) is a reference type. 
Like any other reference, z must be initialized.
It is worth noting that decltype is the only context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.


-> NOTE: decltype and References
When we apply decltype to an expression that is not a variable, we get the type that that expression yields. 
As we’ll see in § 4.1.1 (p. 135), some expressions will cause decltype to yield a reference type. 
Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment:
// decltype of an expression can be a reference type
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int
decltype(*p) c; // error: c is int& and must be initialized
Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 
What can be confusing is that enclosing the name of a variable in parentheses affects the type returned by decltype. 
When we apply decltype to a variable without any parentheses, we get the type of that variable. 
If we wrap the variable’s name in one or more sets of parentheses, the compiler will evaluate the operand as an expression.
A variable is an expression that can be the left-hand side of an assignment.
As a result, decltype on such an expression yields a reference:
// decltype of a parenthesized variable is always a reference
decltype((i)) d; // error: d is int& and must be initialized
decltype(i) e; // ok: e is an (uninitialized) int
ME: You can also use std::remove_cvref_t to remove the type.


-> NOTE: Remember that decltype((variable)) (note, double parentheses) is always a reference type, 
but decltype(variable) is a reference type only if variable is a reference.


-> NOTE: Value Initialization
We can usually omit the value and supply only a size. 
In this case the library creates a value-initialized element initializer for us. 
This library-generated value is used to initialize each element in the container. 
The value of the element initializer depends on the type of the elements stored in the vector.
If the vector holds elements of a built-in type, such as int, then the element initializer has a value of 0. 
If the elements are of a class type, such as string, then the element initializer is itself default initialized:
vector<int> ivec(10); // ten elements, each initialized to 0
vector<string> svec(10); // ten elements, each an empty string


-> NOTE: KEY CONCEPT: GENERIC PROGRAMMING on !=
Programmers coming to C++ from C or Javamight be surprised that we used != rather than < in our for loops such as the one above and in the one on page 94. 
C++ programmers use != as amatter of habit. 
They do so for the same reason that they use iterators rather than subscripts: 
This coding style applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among them, have the subscript operator. 
Similarly, all of the library containers have iterators that define the == and != operators.
Most of those iterators do not have the < operator.
By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.


-> Character Arrays Are Special
Character arrays have an additional form of initialization: We can initialize such arrays from a string literal (§ 2.1.3, p. 39). 
When we use this form of initialization, it is important to remember that string literals end with a null character. 
That null character is copied into the array along with the characters in the literal:
char a1[] = {’C’, ’+’, ’+’}; // list initialization, no null
char a2[] = {’C’, ’+’, ’+’, ’\0’}; // list initialization, explicit null
char a3[] = "C++"; // null terminator added automatically
const char a4[6] = "Daniel"; // error: no space for the null!
The dimension of a1 is 3; the dimensions of a2 and a3 are both 4. 
The definition of a4 is in error. 
Although the literal contains only six explicit characters, the array size must be at least seven—six to hold the literal and one for the null.


-> NOTE: Arrays cant be copied or assigned.
We cannot initialize an array as a copy of another array, nor is it legal to assign one
array to another:
int a[] = {0, 1, 2}; // array of three ints
int a2[] = a; // error: cannot initialize one array with another
a2 = a; // error: cannot assign one array to another
Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. Programs that
use such features, will not work with a different compiler.


-> NOTE: Lvalues and Rvalues
Every expression in C++ is either an rvalue (pronounced “are-value”) or an lvalue (pronounced “ell-value”). 
These names are inherited from C and originally had a simple mnemonic purpose: 
lvalues could stand on the left-hand side of an assignment whereas rvalues could not.
In C++, the distinction is less simple. 
In C++, an lvalue expression yields an object or a function. 
However, some lvalues, such as const objects, may not be the left-hand operand of an assignment. 
Moreover, some expressions yield objects but return them as rvalues, not lvalues. 
Roughly speaking, when we use an object as an rvalue, we use the object’s value (ITS CONTENTS). 
When we use an object as an lvalue, we use the object’s identity (ITS LOCATION ON MEMORY).
Operators differ as to whether they require lvalue or rvalue operands and as to whether they return lvalues or rvalues. 
The important point is that (with one exception that we’ll cover in § 13.6 (p. 531))
we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required.
When we use an lvalue in place of an rvalue, the object’s contents (its value) are used. 
Examples:
• Assignment requires a (nonconst) lvalue as its left-hand operand and yields its left-hand operand as an lvalue.
• The address-of operator (§ 2.3.2, p. 52) requires an lvalue operand and returns a pointer to its operand as an rvalue.
• The built-in dereference and subscript operators (§ 2.3.2, p. 53, and § 3.5.2, p. 116) 
and the iterator dereference and string and vector subscript operators (§ 3.4.1, p. 106, § 3.2.3, p. 93, and § 3.3.3, p. 102) all yield lvalues.
• The built-in and iterator increment and decrement operators (§ 1.4.1, p. 12, and § 3.4.1, p. 107) require lvalue operands 
and the prefix versions (which are the ones we have used so far) also yield lvalues.


-> NOTE: Order of Evaluation
Precedence specifies how the operands are grouped. 
It says nothing about the order in which the operands are evaluated. 
In most cases, the order is largely unspecified. 
In the following expression
int i = f1() * f2();
we know that f1 and f2 must be called before the multiplication can be done. 
After all, it is their results that are multiplied. 
However, we have no way of knowing whether f1 will be called before f2 or vice versa.
For operators that do not specify evaluation order, it is an error for an expression to refer to and change the same object. 
Expressions that do so have undefined behavior (§ 2.1.2, p. 36). 
As a simple example, the << operator makes no guarantees about when or how its operands are evaluated. 
As a result, the following output expression is undefined:
int i = 0;
cout << i << " " << ++i << endl; // undefined
Because this program is undefined, we cannot draw any conclusions about how it might behave. 
The compiler might evaluate ++i before evaluating i, in which case the output will be 1 1. 
Or the compiler might evaluate i first, in which case the output will be 0 1. 
Or the compiler might do something else entirely. 
Because this expression has undefined behavior, the program is in error, regardless of what code the compiler generates.
There are four operators that do guarantee the order in which operands are evaluated. 
We saw in § 3.2.3 (p. 94) that the logical AND (&&) operator guarantees that its left-hand operand is evaluated first. 
Moreover, we are also guaranteed that the right-hand operand is evaluated only if the left-hand operand is true. 
The only other operators that guarantee the order in which operands are evaluated are the logical OR (||) operator (§ 4.3, p. 141), 
the conditional (? :) operator (§ 4.7, p. 151), and the comma (,) operator (§ 4.10, p. 157).


-> NOTE: Order of Evaluation, Precedence, and Associativity
Order of operand evaluation is independent of precedence and associativity. 
In an expression such as f() + g() * h() + j():
• Precedence guarantees that the results of g() and h() are multiplied.
• Associativity guarantees that the result of f() is added to the product of g() and h() and that the result of that addition is added to the value of j().
• There are no guarantees as to the order in which these functions are called.
If f, g, h, and j are independent functions that do not affect the state of the same objects or perform IO, 
then the order in which the functions are called is irrelevant.
If any of these functions do affect the same object, then the expression is in error and has undefined behavior.


-> NOTE: Short-circuit evaluation can optimize your programs.
The logical AND and OR operators always evaluate their left operand before the right. 
Moreover, the right operand is evaluated if and only if the left operand does not determine the result. 
This strategy is known as short-circuit evaluation:
• The right side of an && is evaluated if and only if the left side is true.
• The right side of an || is evaluated if and only if the left side is false.


-> NOTE: Assignment Is Right Associative
Unlike the other binary operators, assignment is right associative:
int ival, jval;
ival = jval = 0; // ok: each assigned 0
Because assignment is right associative, the right-most assignment, jval = 0, is the right-hand operand of the left-most assignment operator. 
Because assignment returns its left-hand operand, the result of the right-most assignment (i.e., jval) is assigned to ival.
int i;
double d;
d = i = 3.5; // i : [3] d : [3]
i = d = 3.5; // i : [3] d : [3.5]


-> NOTE: ADVICE: USE POSTFIX OPERATORS ONLY WHEN NECESSARY
Readers from a C background might be surprised that we use the prefix increment in the programs we’ve written. 
The reason is simple: The prefix version avoids unnecessary work. 
It increments the value and returns the incremented version. 
The postfix operator must store the original value so that it can return the unincremented value as its result. 
If we don’t need the unincremented value, there’s no need for the extra work done by the postfix operator.
For ints and pointers, the compiler can optimize away this extra work. 
For more complicated iterator types, this extra work potentially might be more costly. 
By habitually using the prefix versions, we do not have to worry about whether the performance difference matters. 
Moreover—and perhaps more importantly—we can express the intent of our programs more directly.


-> NOTE: ADVICE: BREVITY CAN BE A VIRTUE (Combining Dereference and Increment in a Single Expression)
Expressions such as *pbeg++ can be bewildering—at first. 
However, it is a useful and widely used idiom. 
Once the notation is familiar, writing
cout << *iter++ << endl;
is easier and less error-prone than the more verbose equivalent
cout << *iter << endl;
++iter;
It is worthwhile to study examples of such code until their meanings are immediately clear. 
Most C++ programs use succinct expressions rather than more verbose equivalents.
Therefore, C++ programmers must be comfortable with such usages. 
Moreover, once these expressions are familiar, you will find them less error-prone.


-> NOTE: Remember That Operands Can Be Evaluated in Any Order
Most operators give no guarantee as to the order in which operands will be evaluated (§ 4.1.3, p. 137). 
This lack of guaranteed order often doesn’t matter. 
The cases where it does matter arewhen one subexpression changes the value of an operand that is used in another subexpression. 
Because the increment and decrement operators change their operands, it is easy to misuse these operators in compound expressions.


-> NOTE: Shift Operators (aka IO Operators) Are Left Associative
Although many programmers never use the bitwise operators directly, 
most programmers do use overloaded versions of these operators for IO. 
An overloaded operator has the same precedence and associativity as the built-in version of that operator. 
Therefore, programmers need to understand the precedence and associativity of the shift operators even if they never use them with their built-in meaning.
Because the shift operators are left associative, the expression
cout << "hi" << " there" << endl;
executes as
( (cout << "hi") << " there" ) << endl;
In this statement, the operand "hi" is grouped with the first << symbol. 
Its result is grouped with the second, and then that result is grouped with the third.
The shift operators have midlevel precedence: 
lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. 
These relative precedence levels mean we usually have to use parentheses to force the correct grouping of operators with lower precedence. 
cout << 42 + 10; // ok: + has higher precedence, so the sum is printed
cout << (10 < 42); // ok: parentheses force intended grouping; prints 1
cout << 10 < 42; // error: attempt to compare cout to 42!
The last cout is interpreted as
(cout << 10) < 42;
which says to “write 10 onto cout and then compare the result of that operation
(i.e., cout) to 42.”


-> NOTE: Comma Operator
The comma operator takes two operands,which it evaluates fromleft to right. 
Like the logical AND and logical OR and the conditional operator, the comma operator guarantees the order in which its operands are evaluated.
The left-hand expression is evaluated and its result is discarded. 
The result of a comma expression is the value of its right-hand expression. 
The result is an lvalue if the right-hand operand is an lvalue.
One common use for the comma operator is in a for loop:
vector<int>::size_type cnt = ivec.size();
// assign values from size . . . 1 to the elements in ivec
for(vector<int>::size_type ix = 0;
ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;


-> NOTE: When Implicit Conversions Occur
Implicit Conversions are carried out automatically without programmer intervention—and sometimes without programmer knowledge. 
The compiler automatically converts operands in the following circumstances:
• In most expressions, values of integral types smaller than int are first promoted to an appropriate larger integral type.
• In conditions, nonbool expressions are converted to bool.
• In initializations, the initializer is converted to the type of the variable; in assignments, the right-hand operand is converted to the type of the left-hand.
• In arithmetic and relational expressions with operands of mixed types, the types are converted to a common type.
• As we’ll see in Chapter 6, conversions also happen during function calls.
Examples are:
-> Integral Promotions
-> Operands of Unsigned Type
-> Array to Pointer Conversions
-> Conversions to bool
-> Conversion to const
-> Conversions Defined by Class Types


-> NOTE: On Explicit Conversions, ADVICE: AVOID CASTS
Casts interfere with normal type checking (§ 2.2.2, p. 46). 
As a result, we strongly recommend that programmers avoid casts. 
This advice is particularly applicable to reinterpret_casts. 
Such casts are always hazardous. 
A const_cast can be useful in the context of overloaded functions, which we’ll cover in § 6.4 (p. 232). 
Other uses of const_cast often indicate a design flaw. 
The other casts, static_cast and dynamic_cast, should be needed infrequently. 
Every time you write a cast, you should think hard about whether you can achieve the same result in a different way.
If the cast is unavoidable, errors can be mitigated by limiting the scope in which the cast value is used and by documenting all assumptions about the types involved.


-> NOTE: CAUTION: WRITING EXCEPTION SAFE CODE IS Hard
It is important to realize that exceptions interrupt the normal flow of a program. 
At the point where the exception occurs, some of the computations that the caller requested may have been done, while others remain undone. 
In general, bypassing part of the program might mean that an object is left in an invalid or incomplete state, or that a resource is not freed, and so on. 
Programs that properly “clean up” during exception handling are said to be exception safe. 
Writing exception safe code is surprisingly hard, and (largely) beyond the scope of this language Primer.
Some programs use exceptions simply to terminate the program when an exceptional condition occurs. 
Such programs generally don’t worry about exception safety.
Programs that do handle exceptions and continue processing generally must be constantly aware of whether an exception might occur 
and what the program must do to ensure that objects are valid, that resources don’t leak, and that the program is restored to an appropriate state.
We will occasionally point out particularly common techniques used to promote exception safety. 
However, readers whose programs require robust exception handling should be aware 
that the techniques we cover are insufficient by themselves to achieve exception safety.



-> NOTE: In C++, names have scope (§ 2.2.4, p. 48), and objects have lifetimes.
It is important to understand both of these concepts.
• The scope of a name is the part of the program’s text in which that name is visible.
• The lifetime of an object is the time during the program’s execution that the object exists.


-> NOTE: ME: In a function, "Parameters" are the ones in the function declaration, "Arguments" are the ones used in the function.


-> NOTE: Parameter initialization works the same way as variable initialization.


-> NOTE: For function parameters: Use Reference to const When Possible


-> NOTE: initializer_list Parameters
We can write a function that takes an unknown number of arguments of a single
type by using an initializer_list parameter.


-> NOTE: Failing to provide a return after a loop that contains a return is an error. 
However, many compilers will not detect such errors.


-> NOTE: How Values Are Returned
Values are returned in exactly the same way as variables and parameters are initialized:
The return value is used to initialize a temporary at the call site, and that temporary is the result of the function call.


-> NOTE: Reference Returns Are Lvalues
Whether a function call is an lvalue (§ 4.1.1, p. 135) depends on the return type of the function. 
Calls to functions that return references are lvalues; other return  types yield rvalues. 
A call to a function that returns a reference can be used in the same ways as any other lvalue.


-> NOTE: List Initializing the Return Value
Under the new standard, functions can return a braced list of values. 
As in any other return, the list is used to initialize the temporary that represents the function’s return. 
If the list is empty, that temporary is value initialized (§ 3.3.1, p. 98).
Otherwise, the value of the return depends on the function’s return type.


-> NOTE: The main function may not call itself.


-> NOTE: Its easier to return complicated types by using 
---> Using a type alias
using ArrayOfInts int(*)[10];
ArrayOfInts func(int i);
---> Using a Trailing Return Type
auto func(int i) -> int(*)[10];
---> Using decltype
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
return (i % 2) ? &odd : &even; // returns a pointer to the array
}


-> NOTE: The main function may not be overloaded.


-> Defining Overloaded Functions
Overloaded functions must differ in the NUMBER or the TYPE(s) of their parameters.
It is an error for two functions to differ ONLY in terms of their return types. 
If the parameter lists of two functions match but the return types differ, then the second declaration is an error.


-> NOTE: Overloading and const Parameters
As we saw in § 6.2.3 (p. 212), top-level const (§ 2.4.3, p. 63) has no effect on the objects that can be passed to the function. 
A parameter that has a top-level const is indistinguishable from one without a top-level const.


-> NOTE: const_cast and Overloading
In § 4.11.3 (p. 163) we noted that const_casts are most useful in the context of overloaded functions. 
As one example, recall our shorterString function from § 6.3.2 (p. 224):
// return a reference to the shorter of two strings
const string &shorterString(const string &s1, const string &s2)
{
return s1.size() <= s2.size() ? s1 : s2;
}
This function takes and returns references to const string.
We can call the function on a pair of nonconst string arguments, butw e’ll get a reference to a const string as the result. 
We might want to have a version of shorterString that, when given nonconst arguments, would yield a plain reference. 
We can write this version of our function using a const_cast:
string &shorterString(string &s1, string &s2)
{
auto &r = shorterString(const_cast<const string&>(s1),
const_cast<const string&>(s2));
return const_cast<string&>(r);
}
This version calls the const version of shorterString by casting its arguments to references to const. 
That function returns a reference to a const string, which we know is bound to one of our original, nonconst arguments. 
Therefore, we know it is safe to cast that string back to a plain string& in the return.


-> NOTE: Calling an Overloaded Function
Once we have defined a set of overloaded functions, we need to be able to call them with appropriate arguments. 
Function matching (also known as overload resolution) is the process by which 
a particular function call is associated with a specific function from a set of overloaded functions. 
The compiler determines which function to call by comparing the arguments in the call with the parameters offered by each function in the overload set.
In many—probably most—cases, it is straightforward for a programmer to determine whether a particular call is legal and, if so, which function will be called.
Often the functions in the overload set differ in terms of the number of arguments, or the types of the arguments are unrelated. 
In such cases, it is easy to determine which function is called. 
Determining which function is called when the overloaded functions have the same number of parameters 
and those parameters are related by conversions (§ 4.11, p. 159) can be less obvious. 
We’ll look at how the compiler resolves calls involving conversions in § 6.6 (p. 242).
For now, what’s important to realize is that for any given call to an overloaded function, there are three possible outcomes:
• The compiler finds exactly one function that is a best match for the actual arguments and generates code to call that function.
• There is no function with parameters that match the arguments in the call, in which case the compiler issues an error message that there was no match.
• There is more than one function that matches and none of the matches is clearly best. 
This case is also an error; it is an ambiguous call.


-> NOTE: In Function Overloading (or in other argument lookup), name lookup happens before type checking.


-> NOTE: inline Functions Avoid Function Call Overhead
A function specified as inline (usually) is expanded “in line” at each call. 


-> NOTE: The inline specification is only a request to the compiler. 
The compiler may choose to ignore this request.
In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. 
Many compilers will not inline a recursive function.
A 75-line function will almost surely not be expanded inline.


-> NOTE: constexpr Functions
A constexpr function is a function that can be used in a constant expression (§ 2.4.4, p. 65). 
A constexpr function is defined like any other function but must meet certain restrictions: 
---> The return type and the type of each parameter in a must be a literal type (§ 2.4.4, p. 66), 
---> and the function body must contain exactly one return statement


-> NOTE: A constexpr function is not required to return a constant expression.
A constexpr function body may contain other statements so long as those statements generate no actions at run time. 
For example, a constexpr function may contain null statements, type aliases (§ 2.5.1, p. 67), and using declarations.
A constexpr function is permitted to return a value that is not a constant.
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
If we call scale with an expression that is not a constant expression — such as on the int object i — then the return is not a constant expression. 
If we use scale in a context that requires a constant expression, the compiler checks that the result is a constant expression. 
If it is not, the compiler will produce an error message.


-> NOTE: Put inline and constexpr functions in Header Files
Unlike other functions, inline and constexpr functions may be defined multiple times in the program. 
After all, the compiler needs the definition, not just the declaration, in order to expand the code. 
However, all of the definitions of a given inline or constexpr must match exactly. 
As a result, inline and constexpr functions normally are defined in headers.


-> NOTE: Function Matching with Multiple Parameters
The compiler then determines, argument by argument, which function is (or functions are) the best match. 
There is an overall best match if there is one and only one function for which
• The match for each argument is no worse than the match required by any other viable function
• There is at least one argument for which the match is better than the match provided by any other viable function.
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6); // calls void f(double, double)
f(42, 2.56); // calls void f(int, int), Considering only the first argument, f(int, int) is a better match than f(double, double).


-> NOTE: Casts should not be needed to call an overloaded function. 
The need for a cast suggests that the parameter sets are designed poorly.


-> NOTE: Argument Type Conversions
In order to determine the bestmatch, the compiler ranks the conversions that could be used 
to convert each argument to the type of its corresponding parameter. 
Conversions are ranked as follows:
1. An exact match. 
An exact match happens when:
• The argument and parameter types are identical.
• The argument is converted from an array or function type to the corresponding pointer type. (§ 6.7 (p. 247) covers function pointers.)
• A top-level const is added to or discarded from the argument.
2. Match through a const conversion (§ 4.11.2, p. 162).
3. Match through a promotion (§ 4.11.1, p. 160).
4. Match through an arithmetic (§ 4.11.1, p. 159) or pointer conversion (§ 4.11.2, p. 161).
5. Match through a class-type conversion. (§ 14.9 (p. 579) covers these conversions.)
ME: So it goes:
1) Exact
2) Const
3) Primitive type promotion
4) Primitive type implicit conversions (arithmetic and pointers)
5) Class types conversions


-> NOTE: Functions defined in the class are implicitly inline (§ 6.5.2, p. 238).
ME: So avoid lengthy function definitions inside the class

-> NOTE: Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself.

-> NOTE: The only difference between using class and using struct to define a class is the default access level.

-> NOTE: Name Lookup and Class Scope
In the programs we’ve written so far, name lookup (the process of finding which declarations match the use of a name) has been relatively straightforward:
• First, look for a declaration of the name in the block in which the name was used. 
Only names declared before the use are considered.
• If the name isn’t found, look in the enclosing scope(s).
• If no declaration is found, then the program is in error.
The way names are resolved inside member functions defined inside the class may seem to behave differently than these lookup rules. 
However, in this case, appearances are deceiving. 
Class definitions are processed in two phases:
• First, the member declarations are compiled.
• Function bodies are compiled only after the entire class has been seen.


-> NOTE: Member function definitions are processed after the compiler processes all of the declarations in the class.


-> NOTE: Normal Block-Scope Name Lookup inside Member Definitions
A name used in the body of a member function is resolved as follows:
• First, look for a declaration of the name inside the member function. 
As usual, only declarations in the function body that precede the use of the name are considered.
• If the declaration is not found inside the member function, look for a declaration inside the class. 
All the members of the class are considered.
• If a declaration for the name is not found in the class, look for a declaration that is in scope before the member function definition.
ME: So it goes:
1) Function scope
2) Class scope
3) Outside function scope


-> NOTE: (ME: This is good when doing inheritance classes). 
Even though the class member is hidden, it is still possible to use that member 
by qualifying the member’s name with the name of its class or by using the this pointer explicitly.
Example:
// bad practice: names local to member functions shouldn’t hide member names
void Screen::dummy_fcn(pos height) {
cursor = width * this->height; // member height
// alternative way to indicate the member
cursor = width * Screen::height; // member height
}

-> NOTE: Even though the outer object is hidden, it is still possible to access that object by using the scope operator.
Example:
// bad practice: don’t hide names that are needed from surrounding scopes
void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one
}


-> NOTE: We must use the constructor initializer list to provide values for members 
that are const, reference, or of a class type that does not have a default constructor.
class ConstRef {
public:
ConstRef(int ii);
private:
int i;
const int ci;
int &ri;
};
// Instead of this:
ConstRef::ConstRef(int ii)
{ // assignments:
i = ii; // ok
ci = ii; // error: cannot assign to a const
ri = i; // error: ri was never initialized
}
// Do this:
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { } // ok: explicitly initialize reference and const members


-> NOTE: Delegating Constructors
The new standard extends the use of constructor initializers to let us define socalled delegating constructors. 
A delegating constructor uses another constructor from its own class to perform its initialization. 
It is said to “delegate” some (or all) of its work to this other constructor.


-> NOTE: 7.5.3 The Role of the Default Constructor
The default constructor is used automatically whenever an object is default or value initialized (value initialized to zero). 
Default initialization happens:
• When we define nonstatic variables (§ 2.2.1, p. 43) or arrays (§ 3.5.1, p. 114) at block scope without initializers
---> ME: non static variables without initializers
• When a class that itself has members of class type uses the synthesized default constructor (§ 7.1.4, p. 262)
---> ME: variables that has a class type with a default constructor
• When members of class type are not explicitly initialized in a constructor initializer list (§ 7.1.4, p. 265)
---> ME: member variables not specified in the constructor
Value initialization happens:
• During array initialization when we provide fewer initializers than the size of the array (§ 3.5.1, p. 114)
---> ME: incomplete array initialization
• When we define a local static object without an initializer (§ 6.1.1, p. 205)
---> ME: static varialbles/objects without value
• When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type 
(NOTE: The vector constructor that takes a single argument to specify the vector’s size (§ 3.3.1, p. 98) 
uses an argument of this kind to value initialize its element initializer.)
---> ME: variables declared in the form T()


-> NOTE: In practice, it is almost always right to provide a default constructor if other constructors are being defined.
---> ME: Either specify one, explicitly use the default or explicitly delete it. (Watch out for the rule of 5)


-> NOTE: Implicit Class-Type Conversions, Converting Constructors
A constructor that can be called with a single argument defines an implicit conversion from the constructor’s parameter type to the class type.


-> NOTE: When a constructor is declared explicit, it can be used only with the direct form of initialization (§ 3.2.1, p. 84). 
Moroever, the compiler will not use this constructor in an automatic conversion.


-> NOTE: Aggregate Classes (Plain old data)
An aggregate class gives users direct access to its members and has special initialization syntax. 
A class is an aggregate if:
• All of its data members are public
• It does not define any constructors
• It has no in-class initializers (§ 2.6.1, p. 73)
ME: Such as this:
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
• It has no base classes or virtual functions, which are class-related features that we’ll cover in Chapter 15
ME: So in short: Classes with public data members with no constructors, no inclass initializers, no base classes and virtual functions. 


-> NOTE: Literal Classes (for constexpr return types)
The parameters and return type of a constexpr function must be literal types.
Unlike other classes, classes that are literal types may have function members that are constexpr. 
Such members must meet all the requirements of a constexpr function. 
These member functions are implicitly const (§ 7.1.2, p. 258).
1) An aggregate class (§ 7.5.5, p. 298) whose data members are all of literal type is a literal class. 
2) A nonaggregate class, that meets the following restrictions, is also a literal class: 
• The data members all must have literal type.
• The class must have at least one constexpr constructor.
• If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression (§ 2.4.4, p. 65), 
or if the member has class type, the initializer must use the member’s own constexpr constructor.
• The class must use default definition for its destructor, which is the member that destroys objects of the class type (§ 7.1.5, p. 267).


-> NOTE: constexpr Constructors
Although constructors can’t be const (§ 7.1.4, p. 262), constructors in a literal class can be constexpr (§ 6.5.2, p. 239) functions. 
Indeed, a literal class must provide at least one constexpr constructor.
A constexpr constructor can be declared as = default.
Otherwise, a constexpr constructor must meet the requirements of a constructor—meaning it can have no return statement—
and of a constexpr function—meaning the only executable statement it can have is a return statement (§ 6.5.2, p. 239). 
As a result, the body of a constexpr constructor is typically empty.
A constexpr constructor must initialize every data member. 
The initializers must either use a constexpr constructor or be a constant expression


-> NOTE:  As with any class member, when we refer to a class static member outside the class body, we must specify the class in which the member is defined. 
The static keyword, however, is used only on the declaration inside the class body.


-> NOTE: The best way to ensure that the object is defined exactly once is to put the definition of static data members 
in the same file that contains the definitions of the class non inline member functions (ME: so in short the .cpp).


-> NOTE: Even if a const static data member is initialized in the class body, that member ordinarily should be defined outside the class definition. (DEFINITON INSIDE THE CLASS IS ALLOWED NOW)
static constexpr int period = 30;// period is a constant expression
constexpr int Account::period;


-> NOTE: A static data member can have incomplete type (§ 7.3.3, p. 278).
---> ME: One of the many advantages of being static.
In particular, a static data member can have the same type as the class type of which it is a member. 
A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:
class Bar {
public:
// . . .
private:
// inside bar, so bar is complete yet
static Bar mem1; // ok: static member can have incomplete type
Bar *mem2; // ok: pointer member can have incomplete type
Bar mem3; // error: data members must have complete type
};


-> NOTE: Another difference between static and ordinary members is that we can use a static member as a default argument (§ 6.5.1, p. 236):
---> ME: Another one of the many advantages of being static.
class Screen {
public:
// bkground refers to the static member
// declared later in the class definition
Screen& clear(char = bkground);
private:
static const char bkground;
};
A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member. 
Using a nonstatic data member as a default argument provides no object from which to obtain the member’s value and so is an error


-> NOTE: No Copy or Assign for IO Objects
ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects
ofstream print(ofstream); // error: can’t initialize the ofstream parameter
out2 = print(out2); // error: cannot copy stream objects


-> NOTE: Condition States
Inherent in doing IO is the fact that errors can occur. 
Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct.
As an example of an IO error, consider the following code:
int ival;
cin >> ival;
If we enter Boo on the standard input, the read will fail. 
The input operator expected to read an int but got the character B instead. 
As a result, cin will be put in an error state. 
Similarly, cin will be in an error state if we enter an end-of-file.


-> NOTE: Flushing the Output Buffer
Our programs have already used the endl manipulator, which ends the current line and flushes the buffer. 
There are two other similar manipulators: flush and ends. 
flush flushes the streambut adds no characters to the output; ends inserts a null character into the buffer and then flushes it:
cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer
cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data
cout << "hi!" << ends; // writes hi and a null, then flushes the buffer


-> NOTE: The unitbuf Manipulator
If we want to flush after every output, we can use the unitbuf manipulator.
This manipulator tells the stream to do a flush after every subsequent write.
The nounitbuf manipulator restores the stream to use normal, system-managed buffer flushing:
cout << unitbuf; // all writes will be flushed immediately
// any output is flushed immediately, no buffering
cout << nounitbuf; // returns to normal buffering


-> NOTE: CAUTION: BUFFERS ARE NOT FLUSHED IF THE PROGRAM CRASHES (ME: This is the reason why some logging is missing when there is a problem.)
Output buffers are not flushed if the programterminates abnormally. 
When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.
When you debug a program that has crashed, it is essential to make sure that any output you think should have been written was actually flushed. 
Countless hours of programmer time have been wasted tracking through code that appeared not to have executed 
when in fact the buffer had not been flushed and the output was pending when the program crashed.


-> NOTE: Tying Input and Output Streams Together (ME: this means do all output first before input)
When an input stream is tied to an output stream, any attempt to read the input stream will first flush the buffer associated with the output stream.
The library ties cout to cin, so the statement
cin >> ival;
causes the buffer associated with cout to be flushed.
Interactive systems usually should tie their input stream to their output stream. 
Doing so means that all output, which might include prompts to the user, will be written before attempting to read the input.


-> NOTE: Using an istringstream
An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line.
struct PersonInfo {
string name;
vector<string> phones;
};
string line, word; // will hold a line and word from input, respectively
vector<PersonInfo> people; // will hold all the records from the input
// read the input a line at a time until cin hits end-of-file (or another error)
while (getline(cin, line)) {
PersonInfo info; // create an object to hold this record’s data
istringstream record(line); // bind record to the line we just read
record >> info.name; // read the name
while (record >> word) // read the phone numbers
info.phones.push_back(word); // and store them
people.push_back(info); // append this record to people
}


-> NOTE: Using Using ostringstreams
An ostringstream is useful when we need to build up our output a little at a time but do not want to print the output until later.
for (const auto &entry : people) { // for each entry in people
ostringstream formatted, badNums; // objects created on each loop
for (const auto &nums : entry.phones) { // for each number
if (!valid(nums)) {
badNums << " " << nums; // string in badNums
} else
// ‘‘writes’’ to formatted’s string
formatted << " " << format(nums);
}
if (badNums.str().empty()) // there were no bad numbers
os << entry.name << " " // print the name
<< formatted.str() << endl; // and reformatted numbers
else // otherwise, print the name and bad numbers
cerr << "input error: " << entry.name
<< " invalid number(s) " << badNums.str() << endl;
}




-> NOTE: Overview of the Sequential Containers
---> The costs to add or delete elements to the container
---> The costs to perform nonsequential access to elements of the container
1) vector: Flexible-size array. Supports fast random access. Inserting or deleting elements other than at the back may be slow.
2) deque: Double-ended queue. Supports fast random access. Fast insert/delete at front or back.
3) list: Doubly linked list. Supports only bidirectional sequential access. Fast insert/delete at any point in the list.
4) forward_list: Singly linked list. Supports only sequential access in one direction. Fast insert/delete at any point in the list.
5) array: Fixed-size array. Supports fast random access. Cannot add or remove elements.
6) string: A specialized container, similar to vector, that contains characters. Fast random access. Fast insert/delete at the back.


-> NOTE: For reasons we’ll explain in § 13.6 (p. 531), the new library containers are dramatically faster than in previous releases. 
The library containers almost certainly perform as well as (and usually better than) even the most carefully crafted alternatives. 
Modern C++ programs should use the library containers rather than more primitive structures like arrays.


-> NOTE: Deciding Which Sequential Container to Use
Ordinarily, it is best to use vector unless there is a good reason to prefer another container.
There are a few rules of thumb that apply to selecting which container to use:
• Unless you have a reason to use another container, use a vector.
• If your program has lots of small elements and space overhead matters, don’t use list or forward_list.
• If the program requires random access to elements, use a vector or a deque.
• If the program needs to insert or delete elements in the middle of the container, use a list or forward_list.
• If the program needs to insert or delete elements at the front and the back, but not in the middle, use a deque.
• If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements:
---> First, decide whether you actually need to add elements in the middle of a container. 
---> It is often easier to append to a vector and then call the library sort function (which we shall cover in § 10.2.3 (p. 384)) to reorder the container when you’re done with input.
--->If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.


-> NOTE: If you’re not sure which container to use, write your code so that it uses only operations common to both vectors and lists: 
Use iterators, not subscripts, and avoid random access to elements. 
That way it will be easy to use either a vector or a list as necessary.


-> NOTE: Iterator Ranges
The concept of an iterator range is fundamental to the standard library.
This element range is called a left-inclusive interval. 
The standard mathematical notation for such a range is
[ begin, end )


-> NOTE: REQUIREMENTS ON ITERATORS FORMING AN ITERATOR RANGE
Two iterators, begin and end, form an iterator range, if
• They refer to elements of, or one past the end of, the same container, and
• It is possible to reach end by repeatedly incrementing begin. In other words, end must not precede begin.
The compiler cannot enforce these requirements. 
It is up to us to ensure that our programs follow these conventions.


-> NOTE: Container Type Members
---> iterator: Type of the iterator for this container type
---> const_iterator: Iterator type that can read but not change its elements
---> size_type: Unsigned integral type big enough to hold the size of the largest possible container of this container type
---> difference_type: Signed integral type big enough to hold the distance between two iterators
---> value_type: Element type
---> reference: Element’s lvalue type; synonym for value_type& (ME: I didnt know this)
---> const_reference: Element’s const lvalue type (i.e., const value_type&) (ME: I didnt know this)


-> NOTE: Best Practices: When write access is not needed, use cbegin and cend.


-> NOTE: Defining and Initializing Containers
1) Default constructor. 
C c;
If C is array, then the elements in c are default-initialized; otherwise c is empty.
2) Copy constructor. 
C c1(c2)
C c1 = c2 
c1 is a copy of c2. c1 and c2 must have the same type (i.e., they must be the same container type and hold the same element type; for array must also have the same size).
3) Constructor with initializer list.
C c{a,b,c...}
C c = {a,b,c...}
c is a copy of the elements in the initializer list. 
Type of elements in the list must be compatible with the element type of C. 
For array, the list must have same number or fewer elements than the size of the array, any missing elements are value-initialized (§ 3.3.1, p. 98).
4) Range constructor
C c(b, e) 
c is a copy of the elements in the range denoted by iterators b and e.
Type of the elements must be compatible with the element type of C. (Not valid for array.)
-----------------------------------------------------------------------------------------------
Constructors that take a size are valid for sequential containers only (not including array, ME: because array size is a template parameter) 
1) Fill constructor with default values
C seq(n) 
seq has n value-initialized elements; this constructor is explicit (§ 7.5.4, p. 296). (Not valid for string.)
1) Fill constructor wtih a value
C seq(n,t) 
seq has n elements with value t.


-> NOTE: When we initialize a container as a copy of another container, the container type and element type of both containers must be identical.


-> NOTE: Sequential Container Size-Related Constructors
vector<int> ivec(10, -1); // ten int elements, each initialized to -1
list<string> svec(10, "hi!"); // ten strings; each element is "hi!"
forward_list<int> ivec(10); // ten elements, each initialized to 0
deque<string> svec(10); // ten elements, each an empty string
The constructors that take a size are valid only for sequential containers; they are not supported for the associative containers.


-> NOTE: Just as the size of a built-in array is part of its type, 
the size of a library array is part of its type. When we define an array, 
in addition to specifying the element type, we also specify the container size:
array<int, 42> // type is: array that holds 42 ints
array<string, 10> // type is: array that holds 10 strings


-> NOTE: Container Assignment Operations
1) Assignment operator (with another object)
c1 = c2 
Replace the elements in c1 with copies of the elements in c2. c1 and c2 must be the same type.
2) Assignment operator (with initializer list)
c = {a,b,c. . . } 
Replace the elements in c1 with copies of the elements in the initializer list. (Not valid for array.)
3) Swap function (ME: These needs lvalues)
swap(c1, c2)
c1.swap(c2)
Exchanges elements in c1 with those in c2. 
c1 and c2 must be the same type. 
swap is usually much faster than copying elements from c2 to c1. (ME: Because underneath, its just exchanging memory locations)
-----------------------------------------------------------------------------------------------
assign operations not valid for associative containers or array 
-----------------------------------------------------------------------------------------------
1) assign function with range parameter
seq.assign(b,e) 
Replaces elements in seq with those in the range denoted by iterators b and e. 
The iterators b and e must not refer to elements in seq.
2) assign function with initializer list
seq.assign(il) Replaces the elements in seq with those in the initializer list il.
3) assign function with fill parameters
seq.assign(n,t) Replaces the elements in seq with n elements with value t.


-> NOTE: Assignment related operations invalidate iterators, references, and pointers into the left-hand container. 
Aside from string they remain valid after a swap, and (excepting arrays) the containers to which they refer are swapped.


-> NOTE: Because the existing elements are replaced, the iterators passed to assign must not refer to the container on which assign is called.


-> NOTE: Excepting array, swap() does not copy, delete, or insert any elements and is guaranteed to run in constant time.


-> NOTE: Relational Operators
Every container type supports the equality operators (== and !=); 
all the containers except the unordered associative containers also support the relational operators (>, >=, <, <=).
Comparing two containers performs a pairwise comparison of the elements.
These operators work similarly to the string relationals (§ 3.2.2, p. 88):
• If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.
• If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.
• If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.
---> ME: So it goes:
1) Size and content must be the same to be equal
2) If the smaller container is an exact subsequence, then the smaller container is less than the other.
3) If its the smaller is not a subsequence, the relationship depends on the first unequal elements.
---> Examples:
vector<int> v1 = { 1, 3, 5, 7, 9, 12 };
vector<int> v2 = { 1, 3, 9 };
vector<int> v3 = { 1, 3, 5, 7 };
vector<int> v4 = { 1, 3, 5, 7, 9, 12 };
v1 < v2 // true; v1 and v2 differ at element[2]: v1[2] is less than v2[2]
v1 < v3 // false; all elements are equal, but v3 has fewer of them;
v1 == v4 // true; each element is equal and v1 and v4 have the same size()
v1 == v2 // false; v2 has fewer elements than v1


-> NOTE: We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.


-> NOTE: Operations That Add Elements to a Sequential Container
These operations change the size of the container; they are not supported by array.
forward_list has special versions of insert and emplace; see § 9.3.4 (p. 350).
push_back and emplace_back not valid for forward_list.
push_front and emplace_front not valid for vector or string.
1) Back insertion
c.push_back(t)
c.emplace_back(args)
Creates an element with value t or constructed from args at the end of c. Returns void.
2) Front insertion
c.push_front(t)
c.emplace_front(args)
3) Insertion at specific location
c.insert(p,t)
c.emplace(p, args)
Creates an element with value t or constructed from args before the element denoted by iterator p. 
Returns an iterator referring to the element that was added.
4) Insertion using fill parameters
c.insert(p,n,t) 
Inserts n elements with value t before the element denoted by iterator p. 
Returns an iterator to the first element inserted; if n is zero, returns p.
5) Insertion using iterator range
c.insert(p,b,e) 
Inserts the elements from the range denoted by iterators b and e before the element denoted by iterator p. b and e may not refer
to elements in c. Returns an iterator to the first element inserted; if the range is empty, returns p.
6) Insertion using initializer_list
c.insert(p,il) 
il is a braced list of element values. 
Inserts the given values before the element denoted by the iterator p. 
Returns an iterator to the first inserted element; if the list is empty returns p.
-> NOTE: Adding elements to a vector, string, or deque potentially invalidates all existing iterators, references, and pointers into the container.


-> NOTE: It is legal to insert anywhere in a vector, deque, or string. However, doing so can be an expensive operation.


-> NOTE: It is important to understand how this loop operates—in particular, to understand why the loop is equivalent to calling push_front.
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
iter = lst.insert(iter, word); // same as calling push_front


-> NOTE: The emplace functions construct elements in the container. The arguments to these functions must match a constructor for the element type.


-> NOTE: Operations to Access Elements in a Sequential Container
at and subscript operator valid only for string, vector, deque, and array.
back not valid for forward_list.
1) Back access
c.back() 
Returns a reference to the last element in c. Undefined if c is empty.
2) Front access
c.front() Returns a reference to the first element in c. Undefined if c is empty.
3) Subscript (access a specified element)
c[n] Returns a reference to the element indexed by the unsigned integral value n.
Undefined if n >= c.size().
4) at() function (access specified element with bounds checking)
c.at(n) 
Returns a reference to the element indexed by n. If the index is out of range,
throws an out_of_range exception.


-> NOTE: Calling front or back on an empty container, like using a subscript that is out of range, is a serious programming error.


-> NOTE: Subscripting and Safe Random Access
If we want to ensure that our index is valid, we can use the at member instead.
The at member acts like the subscript operator, but if the index is invalid, at throws an out_of_range exception (§ 5.6, p. 193):
vector<string> svec; // empty vector
cout << svec[0]; // run-time error: there are no elements in svec!
cout << svec.at(0); // throws an out_of_range exception


-> NOTE: erase Operations on Sequential Containers
These operations change the size of the container and so are not supported by array.
forward_list has a special version of erase; see § 9.3.4 (p. 350).
pop_back not valid for forward_list; pop_front not valid for vector and string.
1) Removes last element
c.pop_back() 
Removes last element in c. Undefined if c is empty. Returns void.
2) Removes first element
c.pop_front() 
Removes first element in c. Undefined if c is empty. Returns void.
3) Removes an element indicated by an iterator
c.erase(p) 
Removes the element denoted by the iterator p and returns an iterator to the element 
after the one deleted or the off-the-end iterator if p denotes the last element. 
Undefined if p is the off-the-end iterator.
4) Remove elements indicated by an iterator range
c.erase(b,e) R
emoves the range of elements denoted by the iterators b and e. 
Returns an iterator to the element after the last one that was deleted, or an off-the-end iterator if e is itself an off-the-end iterator.
4) Remove all elements
c.clear() 
Removes all the elements in c. Returns void.


-> NOTE: The members that remove elements do not check their argument(s). The programmer must ensure that element(s) exist before removing them.


-> NOTE: Removing elements anywhere but the beginning or end of a deque invalidates all iterators, references, and pointers. 
Iterators, references, and pointers to elements after the erasure point in a vector or string are invalidated.


-> NOTE: Operations to Insert or Remove Elements in a forward_list
1) Begin Iterators
lst.before_begin()
lst.cbefore_begin()
Iterator denoting the nonexistent element just before the beginning of the list. 
This iterator may not be dereferenced.
cbefore_begin() returns a const_iterator.
2) Insert after
lst.insert_after(p,t)
lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)
Inserts element(s) after the one denoted by iterator p. t is an object, n is a count, 
b and e are iterators denoting a range (b and e must not refer to lst), and il is a braced list. 
Returns an iterator to the last inserted element.
If the range is empty, returns p. 
Undefined if p is the off-the-end iterator.
3) Emplace after
emplace_after(p, args) 
Uses args to construct an element after the one denoted by
iterator p. Returns an iterator to the new element.
Undefined if p is the off-the-end iterator.
4) Erase after
lst.erase_after(p)
lst.erase_after(b,e)
Removes the element after the one denoted by iterator p or the range of elements 
from the one after the iterator b up to but not including the one denoted by e. 
Returns an iterator to the element after the one deleted, or the off-the-end iterator if there is no such element. 
Undefined if p denotes the last element in lst or is the off-the-end iterator.


-> NOTE: Sequential Container Size Operations
resize not valid for array.
1) Resize with default element construction
c.resize(n) Resize c so that it has n elements. 
If n < c.size(), the excess elements are discarded. 
If new elements must be added, they are value initialized.
2) Resize with specified element value
c.resize(n,t) 
Resize c to have n elements. Any elements added have value t.
Example:
list<int> ilist(10, 42); // ten ints: each has value 42
ilist.resize(15); // adds five elements of value 0 to the back of ilist
ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist
ilist.resize(5); // erases 20 elements from the back of ilist


-> NOTE: If resize shrinks the container, then iterators, references, and pointers to the deleted elements are invalidated; 
resize on a vector, string, or deque potentially invalidates all iterators, pointers, and references.


-> NOTE: Container Operations May Invalidate Iterators (ME: And what happens underneath)
Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. 
An invalidated pointer, reference, or iterator is one that no longer denotes an element. 
Using an invalidated pointer, reference, or iterator is a serious programming error 
that is likely to lead to the same kinds of problems as using an uninitialized pointer (§ 2.3.2, p. 54).
1) After an operation that adds elements to a container:
• Iterators, pointers, and references to a vector or string are invalid if the container was reallocated. 
If no reallocation happens, indirect references to elements before the insertion remain valid; 
those to elements after the insertion are invalid.
• Iterators, pointers, and references to a deque are invalid if we add elements anywhere but at the front or back. 
If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not.
• Iterators, pointers, and references (including the off-the-end and the beforethe- beginning iterators) to a list or forward_list remain valid,
2) It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. 
After all, those elements have been destroyed. 
After we remove an element, 
• All other iterators, references, or pointers (including the off-the-end and the before-the-beginning iterators) 
to a list or forward_list remain valid.
• All other iterators, references, or pointers to a deque are invalidated if the removed elements are anywhere but the front or back. 
If we remove elements at the back of the deque, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; 
they are also unaffected if we remove from the front.
• All other iterators, references, or pointers to a vector or string remain valid for elements before the removal point. 
Note: The off-the-end iterator is always invalidated when we remove elements.
---> How about reallocation during deletion? Does that not happen? 

-> NOTE: It is a serious run-time error to use an iterator, pointer, or reference that has been invalidated.


-> NOTE: ADVICE: MANAGING ITERATORS
When you use an iterator (or a reference or pointer to a container element), 
it is a good idea to minimize the part of the program during which an iterator must stay valid.
Because code that adds or removes elements to a container can invalidate iterators, 
you need to ensure that the iterator is repositioned, as appropriate, 
after each operation that changes the container. 
This advice is especially important for vector, string, and deque.


-> NOTE: Avoid Storing the Iterator Returned from end


-> NOTE: Don’t cache the iterator returned from end() in loops that insert or delete elements in a deque, string, or vector.


-> NOTE: reserve()
A call to reserve changes the capacity of the vector only if the requested space exceeds the current capacity. 
If the requested size is greater than the current capacity, reserve allocates at least as much as (and may allocate more than) the requested amount.
If the requested size is less than or equal to the existing capacity, reserve does nothing. 
In particular, calling reserve with a size smaller than capacity does not cause the container to give back memory. 
Thus, after calling reserve, the capacity will be greater than or equal to the argument passed to reserve.
As a result, a call to reserve will never reduce the amount of space that the container uses. 
Similarly, the resize members (§ 9.3.5, p. 352) change only the number of elements in the container, not its capacity. 
We cannot use resize to reduce the memory a container holds in reserve.

-> NOTE: reserve does not change the number of elements in the container; it affects only how much memory the vector preallocates.


-> NOTE: shrink_to_fit()
Under the new library, we can call shrink_to_fit to ask a deque, vector,
or string to return unneeded memory. This function indicates that we no longer
need any excess capacity. However, the implementation is free to ignore this request.
There is no guarantee that a call to shrink_to_fit will return memory


-> NOTE: Container Size Management
shrink_to_fit valid only for vector, string, and deque.
capacity and reserve valid only for vector and string.
1) shrink_to_fit()
c.shrink_to_fit() 
Request to reduce capacity() to equal size().
2) capacity()
c.capacity() 
Number of elements c can have before reallocation is necessary.
3) reserve()
c.reserve(n) 
Allocate space for at least n elements.


-> NOTE: ME: The containers will reach the capacity first before reallocation. (so capacity and size will be equal)


-> NOTE: Each vector implementation can choose its own allocation strategy.
However, it must not allocate new memory until it is forced to do so. (ME: so it will reach it capacity first before reallocation)


-> NOTE: A vector may be reallocated only when the user performs an insert operation when the size equals capacity
or by a call to resize or reserve with a value that exceeds the current capacity. 
How much memory is allocated beyond the specified amount is up to the implementation.


-> NOTE: Additional Ways to Construct strings
n, len2 and pos2 are all unsigned values
1) Construction from char array
string s(cp, n); 
s is a copy of the first n characters in the array to which cp points. 
That array must have at least n characters.
2) Construction of a substring from existing string with position
string s(s2, pos2); s is a copy of the characters in the string s2 starting at the index pos2. 
Undefined if pos2 > s2.size().
2) Construction of a substring from existing string with position and length
string s(s2, pos2, len2); 
s is a copy of len2 characters from s2 starting at the index pos2. 
Undefined if pos2 > s2.size().
Regardless of the value of len2, copies at most s2.size() - pos2 characters


-> NOTE: Substring Operation
s.substr(pos, n) 
Return a string containing n characters from s starting at pos. 
pos defaults to 0. 
n defaults to a value that causes the library to copy all the characters in s starting from pos.


-> NOTE: Operations to Modify strings
1) s.insert(pos, args) 
Insert characters specified by args before pos. pos can be an index or an iterator. 
Versions taking an index return a reference to s; those taking an iterator return an iterator denoting the first inserted character.
2) s.erase(pos, len) 
Remove len characters starting at position pos. 
If len is omitted, removes characters from pos to the end of the s.
Returns a reference to s.
3) s.assign(args) 
Replace characters in s according to args (ME: same arguments with the constructor?). 
Returns a reference to s.
4) s.append(args) 
Append args to s. 
Returns a reference to s.
5) s.replace(range, args) 
Remove range of characters from s and replace them with the characters formed by args. 
range is either an index and a length or a pair of iterators into s. 
Returns a reference to s.
----------------------------------------------------------------------------------
args: can be one of the following; append and assign can use all forms:
1) str: must be distinct from s and the iterators b and e may not refer to s
2) str, pos, len: Up to len characters from str starting at pos.
3) cp, len: Up to len characters from the character array pointed to by cp.
4) cp: Null-terminated array pointed to by pointer cp.
5) n, c: n copies of character c.
6) b, e: Characters in the range formed by iterators b and e.
7) initializer_list: Comma-separated list of characters enclosed in braces.


-> NOTE: string Search Operations
Search operations return the index of the desired character or npos if not found
1) s.find(args) 
Find the first occurrence of args in s.
2) s.rfind(args) 
Find the last occurrence of args in s.
3) s.find_first_of(args) 
Find the first occurrence of any character from args in s.
4) s.find_last_of(args) 
Find the last occurrence of any character from args in s.
5) s.find_first_not_of(args) 
Find the first character in s that is not in args.
6) s.find_last_not_of(args) 
Find the last character in s that is not in args.
----------------------------------------------------------------------------------
args must be one of
1) c, pos:  Look for the character c starting at position pos in s. pos defaults to 0.
2) s2, pos:  Look for the string s2 starting at position pos in s. pos defaults to 0.
3) cp, pos Look for the C-style null-terminated string pointed to by the pointer cp. 
Start looking at position pos in s. pos defaults to 0.
4) cp, pos, n Look for the first n characters in the array pointed to by the pointer cp. 
Start looking at position pos in s. No default for pos or n.


-> NOTE: The string search functions return string::size_type, which is an unsigned type. 
As a result, it is a bad idea to use an int, or other signed type, to hold the return from these functions (§ 2.1.2, p. 36).


-> NOTE: Specifying Where to Start the Search
We can pass an optional starting position to the find operations. 
This optional argument indicates the position from which to start the search. 
By default, that position is set to zero.
ME: This is useful when doing continuous searching on the same string.


-> NOTE: Searching Backward
The find operations we’ve used so far execute left to right. 
The library provides analogous operations that search from right to left. 
The rfind member searches for the last—that is, right-most—occurrence of the indicated substring:
string river("Mississippi");
auto first_pos = river.find("is"); // returns 1
auto last_pos = river.rfind("is"); // returns 4



-> NOTE: Numeric Conversions
1) number to string conversion
to_string(val); 
Overloaded functions returning the string representation of val.
val can be any arithmetic type (§ 2.1.1, p. 32). 
There are versions of to_string for each floating-point type and integral type that is int or larger. 
Small integral types are promoted (§ 4.11.1, p. 160) as usual.
2) string to integer conversion
stoi(s, p, b)
stol(s, p, b)
stoul(s, p, b)
stoll(s, p, b)
stoull(s, p, b)
Return the initial substring of s that has numeric content as an int, long, unsigned long, long long, unsigned long long, respectively.
b indicates the numeric base to use for the conversion; b defaults to 10. 
p is a pointer to a size_t in which to put the index of the first nonnumeric character in s; 
p defaults to 0, in which case the function does not store the index.
3) string to floating point conversion
stof(s, p)
stod(s, p)
stold(s, p)
Return the initial numeric substring in s as a float, double, or long double, respectively.
p has the same behavior as described for the integer conversions.


-> NOTE: If the string can’t be converted to a number, These functions throw an invalid_argument exception (§ 5.6, p. 193). 
If the conversion generates a value that can’t be represented, they throw out_of_range.



-> NOTE: Container Adaptors
In addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue.
An adaptor is a general concept in the library. 
There are container, iterator, and function adaptors.


-> NOTE: Operations and Types Common to the Container Adaptors
1) size_type: Type large enough to hold the size of the largest object of this type.
2) value_type: Element type.
3) container_type: Type of the underlying container on which the adaptor is implemented.
4) A a;
Create a new empty adaptor named a.
5) A a(c); 
Create a new adaptor named a with a copy of the container c.
6) relational operators: 
Each adaptor supports all the relational operators: ==, !=, <, <=, >, >=.
These operators return the result of comparing the underlying containers.
7) a.empty() 
false if a has any elements, true otherwise.
8) a.size() 
Number of elements in a.
9) swap(a, b) or a.swap(b)
Swaps the contents of a and b; a and b must have the same type, 
including the type of the container on which they are implemented.


-> NOTE: Defining an Adaptor
By default both STACK and QUEUE are implemented in terms of DEQUE, and a PRIORITY_QUEUE is implemented on a VECTOR. 
We can override the default container type by naming a sequential container as a second type argument when we create the adaptor
stack<int> stk(deq); // copies elements from deq into stk
stack<string, vector<string>> str_stk; // empty stack implemented on top of vector
stack<string, vector<string>> str_stk2(svec); // str_stk2 is implemented on top of vector and initially holds a copy of svec


-> NOTE: Stack Operations in Addition to Those in Table 9.17
Uses deque by default; can be implemented on a list or vector as well.
1) s.pop() 
Removes, but does not return, the top element from the stack.
2) s.push(item)
s.emplace(args)
Creates a new top element on the stack by copying ormoving item, or by constructing the element from args.
3) s.top() 
Returns, but does not remove, the top element on the stack.


-> NOTE: queue, priority_queue Operations in Addition to Table 9.17
By default queue uses deque and priority_queue uses vector;
queue can use a list or vector as well, priority_queue can use a deque.
1) q.pop() 
Removes, but does not return, the front element or highest-priority element from the queue or priority_queue, respectively.
2) q.front() and q.back()
Returns, but does not remove, the front or back element of q. Valid only for queue
3) q.top() 
Returns, but does not remove, the highest-priority element. Valid only for priority_queue.
4) q.push(item) and q.emplace(args)
Create an element with value item or constructed from args at the end of the queue or in its appropriate position in priority_queue.


KEY CONCEPT: ALGORITHMS NEVER EXECUTE CONTAINER OPERATIONS
The generic algorithms do not themselves execute container operations. 
They operate solely in terms of iterators and iterator operations. 
The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: 
Algorithms never change the size of the underlying container.
Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. 
They do not, however, ever add or remove elements directly.
As we’ll see in § 10.4.1 (p. 401), there is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. 
When we assign to these iterators, they execute insert operations on the underlying container. 
When an algorithm operates on one of these iterators, the iterator may have the effect of adding elements to the container. 
The algorithm itself, however, never does so.


-> NOTE: The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.
int sum = accumulate(vec.cbegin(), vec.cend(), 0); // sum the elements in vec starting the summation with the value 0


-> NOTE: Ordinarily it is best to use cbegin() and cend() (§ 9.2.3, p. 334) with algorithms that read, but do not write, the elements. 
However, if you plan to use the iterator returned by the algorithm to change an element’s value, then you need to pass begin() and end().


-> NOTE: Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.


-> NOTE: KEY CONCEPT: ITERATOR ARGUMENTS
Some algorithms read elements from two sequences. 
The elements that constitute these sequences can be stored in different kinds of containers. 
For example, the first sequence might be stored in a vector and the second might be in a list, a deque, a built-in array, or some other sequence. 
Moreover, the element types in the two sequences are not required to match exactly. 
What is required is that we be able to compare elements from the two sequences. 
For example, in the equal algorithm, the element types need not be identical, 
but we do have to be able to use == to compare elements from the two sequences.
Algorithms that operate on two sequences differ as to how we pass the second sequence.
Some algorithms, such as equal, take three iterators: 
The first two denote the range of the first sequence, and the third iterator denotes the first element in the second sequence. 
Others take four iterators: The first two denote the range of elements in the first sequence, 
and the second two denote the range for the second sequence.
Algorithms that use a single iterator to denote the second sequence assume that the second sequence is at least as large as the first. 
It is up to us to ensure that the algorithm will not attempt to access a nonexistent element in the second sequence.
For example, the equal algorithm potentially compares every element from its first sequence to an element in the second. 
If the second sequence is a subset of the first, then our program has a serious error—equal will attempt to access elements beyond the end of the second sequence.


-> NOTE: Algorithms that write to a destination iterator assume the destination is large enough to hold the number of elements being written.


-> NOTE: Introducing the back_inserter
One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator.
An insert iterator is an iterator that adds elements to a container. 
Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. 
When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.


-> NOTE: The library algorithms operate on iterators, not containers. 
Therefore, an algorithm cannot (directly) add or remove elements.



-> NOTE: Introducing Lambdas
We can pass any kind of callable object to an algorithm. 
An object or expression is callable if we can apply the call operator (§ 1.5.2, p. 23) to it. 
That is, if e is a callable expression, we can write e(args) where args is a comma-separated list of zero or more arguments.
Some other callables are functions and function pointers (§ 6.7,p. 247).
And there are two other kinds of callables: classes that overload the function call operator, which we’ll cover in § 14.8 (p. 571), and lambda expressions.
A lamba expression has the form:
[capture list](parameter list) -> return type { function body }


-> NOTE: Omitting the parentheses and the parameter list in a lambda is equivalent to specifying an empty parameter list.
auto f = [] { return 42; };


-> NOTE: Lambda return type:
If we omit the return type, the lambda has an inferred return type that depends on the code in the function body.
If the function body is just a return statement, the return type is inferred from the type of the expression that is returned.
Otherwise, the return type is void.


-> NOTE: Lambdas with function bodies that contain anything other than a single return statement that do not specify a return type return void.


-> NOTE: A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.


-> NOTE: The capture list is used for local nonstatic variables only; lambdas can use local statics and variables declared outside the function directly.


-> NOTE: Similar to function parameters, lambda capture can be "Capture by Value" or "Capture by Reference"
auto f = [v1] { return v1; }; // capture by value
auto f2 = [&v1] { return v1; }; //capture by reference


-> NOTE: When we capture a variable by reference, we must ensure that the variable exists at the time that the lambda executes.


-> NOTE: ADVICE: KEEP YOUR LAMBDA CAPTURES SIMPLE
A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) 
and the time (or times) the lambda itself is executed. It is the programmer’s responsibility to ensure that whatever information
is captured has the intended meaning each time the lambda is executed.
Capturing an ordinary variable—an int, a string, or other nonpointer type— by value is usually straightforward. 
In this case, we only need to care whether the variable has the value we need when we capture it.
If we capture a pointer or iterator, or capture a variable by reference, 
we must ensure that the object bound to that iterator, pointer, or reference still exists, 
whenever the lambda executes. 
Moreover, we need to ensure that the object has the intended value. 
Code that executes between when the lambda is created and when it executes might change 
the value of the object to which the lambda capture points (or refers).
The value of the object at the time the pointer (or reference) was captured might have been what we wanted. 
The value of that object when the lambda executes might be quite different.
As a rule, we can avoid potential problems with captures by minimizing the data we capture. 
Moreover, if possible, avoid capturing pointers or references.


-> NOTE: Implicit Captures
Rather than explicitly listing the variables we want to use from the enclosing function,
we can let the compiler infer which variables we use from the code in the lambda’s body.
To direct the compiler to infer the capture list, we use an & or = in the capture list. 
The & tells the compiler to capture by reference, and the = says the values are captured by value.
wc = find_if(words.begin(), words.end(), [=](const string &s) { return s.size() >= sz; }); // capture by value
wc = find_if(words.begin(), words.end(), [&](const string &s) { return s.size() >= sz; }); // capture by reference


-> NOTE: Lambda Capture List
1) Empty capture list. 
[] 
The lambda may not use variables from the enclosing function. 
A lamba may use local variables only if it captures them.
2) Capture list with names
[names] 
names is a comma-separated list of names local to the enclosing function.
By default, variables in the capture list are copied. 
A name preceded by & is captured by reference.
3) Implicit reference capture list
[&] 
Implicit by reference capture list. 
Entities from the enclosing function used in the lambda body are used by reference.
4) Implicit value capture list
[=] 
Implicit by value capture list. 
Entities from the enclosing function used in the lambda body are copied into the lambda body.
5) Implicit reference capture list with explicitly names list with value.
[&, identifier_list] 
identifier_list is a comma-separated list of zero or more variables from the enclosing function. 
These variables are captured by value; any implicitly captured variables are captured by reference. 
The names in identifier_list must not be preceded by an &.
6) Implicit value capture list with explicitly names list with reference.
[=, reference_list] 
Variables included in the reference_list are captured by reference; any
implicitly captured variables are captured by value. The names in
reference_list may not include this and must be preceded by an &.


-> NOTE: Mutable Lambdas
By default, a lambda may not change the value of a variable that it copies by value.
If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword mutable.
auto f = [v1] () mutable { return ++v1; };


-> NOTE: Specifying the Lambda Return Type
When we need to define a return type for a lambda, we must use a trailing return type (§ 6.3.3, p. 229):
transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int { if (i < 0) return -i; else return i; });



-> NOTE: Binding Arguments
Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. 
If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. 
Similarly, if an operation requires many statements, it is ordinarily better to use a function.


-> NOTE: '’Effective Modern C++’’, Item 34: Prefer lambdas to std::bind.


-> NOTE: The Library bind Function
We can solve the problem of passing a size argument to check_size by using a new library function named bind, which is defined in the functional header.
The bind function can be thought of as a general-purpose function adaptor (§ 9.6, p. 368). 
It takes a callable object and generates a new callable that “adapts” the parameter list of the original object.


-> NOTE: bind() function form:
The general form of a call to bind is:
auto newCallable = bind(callable, arg_list);
where newCallable is itself a callable object and arg_list is a comma-separated list of arguments that correspond to the parameters of the given callable. 
That is, when we call new Callable, newCallable calls callable, passing the arguments in arg_list.
The arguments in arg_list may include names of the form _n, where n is an integer. 
These arguments are “placeholders” representing the parameters of new-Callable. 
They stand “in place of” the arguments that will be passed to newCallable.
The number n is the position of the parameter in the generated callable: _1 is the first parameter in newCallable, _2 is the second, and so forth.
Example:
auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));



-> NOTE: Using placeholders Names
The _n names are defined in a namespace named placeholders. 
That namespace is itself defined inside the std namespace (§ 3.1, p. 82). 
To use these names, we must supply the names of both namespaces. 
As with our other examples, our calls to bind assume the existence of appropriate using declarations. 
For example, the using declaration for _1 is using std::placeholders::_1;


-> NOTE: Arguments to bind
As we’ve seen, we can use bind to fix the value of a parameter. 
More generally, we can use bind to bind or rearrange the parameters in the given callable. 
For example, assuming f is a callable object that has five parameters, the following call to bind:
// g is a callable object that takes two arguments
auto g = bind(f, a, b, _2, c, _1);
This generates a new callable that takes two arguments, represented by the placeholders _2 and _1. 
The new callable will pass its own arguments as the third and fifth arguments to f. 
The first, second, and fourth arguments to f are bound to the given values, a, b, and c, respectively.
In effect, this call to bind maps:
g(X, Y)
to
f(a, b, Y, c, X)


-> NOTE: Using to bind to Reorder Parameters
As a more concrete example of using bind to reorder arguments, we can use bind to invert the meaning of isShorter by writing
sort(words.begin(), words.end(), isShorter); // sort on word length, shortest to longest
sort(words.begin(), words.end(), bind(isShorter, _2, _1)); // sort on word length, longest to shortest


-> NOTE: Binding Reference Parameters
By default, the arguments to bind that are not placeholders are copied into the callable object that bind returns. 
However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference 
or we might want to bind an argument that has a type that we cannot copy.
for_each(words.begin(), words.end(), bind(print, os, _1, ’ ’)); // error: cannot copy os
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ’ ’)); // using ref function
The ref function returns an object that contains the given reference and that is itself copyable.
There is also a cref function that generates a class that holds a reference to const.
Like bind, the ref and cref functions are defined in the functional header.


-> NOTE: BACKWARD COMPATIBILITY: BINDING ARGUMENTS
Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. 
The library defined two functions named bind1st and bind2nd. 
Like bind, these functions take a function and generate a new callable object that calls 
the given function with one of its parameters bound to a given value. 
However, these functions can bind only the first or second parameter, respectively. 
Because they are ofmuch more limited utility, they have been deprecated in the new standard. 
A deprecated feature is one that may not be supported in future releases. 
Modern C++ programs should use bind.



-> NOTE: Revisiting Iterators
In addition to the iterators that are defined for each of the containers, 
the library defines several additional kinds of iterators in the iterator header. 
These iterators include
• Insert iterators: 
These iterators are bound to a container and can be used to insert elements into the container.
• Stream iterators: 
These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.
• Reverse iterators: 
These iterators move backward, rather than forward. 
The library containers, other than forward_list, have reverse iterators.
• Move iterators: 
These special-purpose iterators move rather than copy their elements. 
We’ll cover move iterators in § 13.6.2 (p. 543).


-> NOTE: Insert Iterators
An inserter is an iterator adaptor (§ 9.6, p. 368) that takes a container and yields
an iterator that adds elements to the specified container. When we assign a value
through an insert iterator, the iterator calls a container operation to add an element
at a specified position in the given container. The operations these iterators support
are listed in Table 10.2 (overleaf).
There are three kinds of inserters. Each differs from the others as to where
elements are inserted:
• back_inserter (§ 10.2.2, p. 382) creates an iterator that uses push_back.
• front_inserter creates an iterator that uses push_front.
• inserter creates an iterator that uses insert. This function takes a second
argument, which must be an iterator into the given container. Elements are
inserted ahead of the element denoted by the given iterator.


-> NOTE: We can use front_inserter only if the container has push_front.
Similarly, we can use back_inserter only if it has push_back.


-> NOTE: Insert Iterator Operations
1) it = t 
Inserts the value t at the current position denoted by it. 
Depending on the kind of insert iterator, and assuming c is the container to which it is bound, 
calls c.push_back(t), c.push_front(t), or c.insert(t, p), where p is the iterator position given to inserter.
2) *it, ++it, it++ 
These operations exist but do nothing to it. Each operator returns it.


-> NOTE: It is important to understand that when we call inserter(c, iter), we get an iterator that, when used successively, 
inserts elements ahead of the element originally denoted by iter. 
That is, if it is an iterator generated by inserter, then an assignment such as:
*it = val;
behaves as:
it = c.insert(it, val); // it points to the newly added element
++it; // increment it so that it denotes the same element as before


-> NOTE: iostream Iterators
When we create a stream iterator, we must specify the type of objects that the iterator will read or write. 
An istream_iterator uses >> to read a stream.
Therefore, the type that an istream_iterator reads must have an input operator defined. 
When we create an istream_iterator, we can bind it to a stream.
Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value.
istream_iterator<int> int_it(cin); // reads ints from cin
istream_iterator<int> int_eof; // end iterator value
ifstream in("afile");
istream_iterator<string> str_it(in); // reads strings from" afile"
As an example, we can use an istream_iterator to read the standard input into a vector:
istream_iterator<int> in_iter(cin); // read ints fro mcin
istream_iterator<int> eof; // istream ‘‘end’’ iterator
while (in_iter != eof) // while there’s valid input to read
// postfix increment reads the stream and returns the old value of the iterator
// we dereference that iterator to get the previous value read fromthe stream
vec.push_back(*in_iter++);


-> NOTE: istream_iterator Operations
1) istream_iterator<T> in(is); 
in reads values of type T from input stream is.
2) istream_iterator<T> end; 
Off-the-end iterator for an istream_iterator that reads values of type T.
3) in1 == in2 or in1 != in2
in1 and in2 must read the same type. They are equal if they are both the
end value or are bound to the same input stream.
4) *in 
Returns the value read from the stream.
5) in->mem 
Synonym for (*in).mem.
6) ++in, in++ 
Reads the next value from the input stream using the >> operator for the element type. 
As usual, the prefix version returns a reference to the incremented iterator. 
The postfix version returns the old value.


-> NOTE: istream_iterators Are Permitted to Use Lazy Evaluation
When we bind an istream_iterator to a stream, we are not guaranteed that it will read the stream immediately. 
The implementation is permitted to delay reading the stream until we use the iterator. 
We are guaranteed that before we dereference the iterator for the first time, the stream will have been read. 
For most programs, whether the read is immediate or delayed makes no difference. 
However, if we create an istream_iterator that we destroy without using 
or if we are synchronizing reads to the same stream from two different objects, 
then we might care a great deal when the read happens.


-> NOTE: Operations on ostream_iterators
An ostream_iterator can be defined for any type that has an output operator (the << operator). 
When we create an ostream_iterator, we may (optionally) provide a second argument that specifies a character string 
to print following each element. That string must be a C-style character string (i.e., a string literal or a pointer to a null-terminated array). 
We must bind an ostream_iterator to a specific stream.
There is no empty or off-the-end ostream_iterator


-> NOTE: ostream_iterator Operations
1) ostream_iterator<T> out(os); 
out writes values of type T to output stream os.
2) ostream_iterator<T> out(os, d); 
out writes values of type T followed by d to output stream os. 
d points to a null-terminated character array.
3) out = val 
Writes val to the ostream to which out is bound using the << operator.
val must have a type that is compatible with the type that out can write.
4) *out, ++out, out++
These operations exist but do nothing to out. 
Each operator returns out.


-> NOTE: The * and ++ operators do nothing on an ostream_iterator, so omitting them has no effect. 
However, we prefer to write the loop as first presented.
That loop uses the iterator consistently with how we use other iterator types. 
We can easily change this loop to execute on another iterator type.
Moreover, the behavior of this loop will be clearer to readers of our code.


-> NOTE: Reverse Iterators
A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. 
A reverse iterator inverts the meaning of increment (and decrement). 
Incrementing (++it) a reverse iterator moves the iterator to the previous element; derementing (--it) moves the iterator to the next element.


-> NOTE: Reverse Iterators Require Decrement Operators
Not surprisingly, we can define a reverse iterator only from an iterator that supports -- as well as ++. 
After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. 
Aside from forward_list, the iterators on the standard containers all support decrement as well as increment.
However, the stream iterators do not, because it is not possible to move backward through a stream. 
Therefore, it is not possible to create a reverse iterator from a forward_list or a stream iterator.


-> NOTE: The fact that reverse iterators are intended to represent ranges 
and that these ranges are asymmetric has an important consequence: 
When we initialize or assign a reverse iterator from a plain iterator, 
the resulting iterator does not refer to the same element as the original.


-> NOTE: The Five Iterator Categories
1) Input iterators: can read elements in a sequence. 
An input iterator must provide:
• Equality and inequality operators (==, !=) to compare two iterators
• Prefix and postfix increment (++) to advance the iterator
• Dereference operator (*) to read an element; dereference may appear only on the right-hand side of an assignment
• The arrow operator (->) as a synonym for (*it).member—that is, dereference the iterator and fetch a member from the underlying object
2) Output iterators: can be thought of as having complementary functionality to input iterators; they write rather than read elements. 
Output iterators must provide
• Prefix and postfix increment (++) to advance the iterator
• Dereference (*), which may appear only as the left-hand side of an assignment 
(Assigning to a dereferenced output iterator writes to the underlying element.)
3) Forward iterators: can read and write a given sequence. 
They move in only one direction through the sequence. 
Forward iterators support all the operations of both input iterators and output iterators. 
Moreover, they can read or write the same element multiple times. 
Therefore, we can use the saved state of a forward iterator.
Hence, algorithms that use forward iterators may make multiple passes through the sequence. 
The replace algorithm requires a forward iterator; iterators on forward_list are forward iterators.
4) Bidirectional iterators: can read and write a sequence forward or backward. 
In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (--) operators. 
The reverse algorithm requires bidirectional iterators, and aside from forward_list, 
the library containers supply iterators that meet the requirements for a bidirectional iterator.
5)  Random-access iterators: provide constant-time access to any position in the sequence.
These iterators support all the functionality of bidirectional iterators. 
In addition, random-access iterators support the operations from Table 3.7 (p. 111):
• The relational operators (<, <=, >, and >=) to compare the relative positions of two iterators.
• Addition and subtraction operators (+, +=, -, and -=) on an iterator and an integral value. 
The result is the iterator advanced (or retreated) the integral number of elements within the sequence.
• The subtraction operator (-) when applied to two iterators, which yields the distance between two iterators.
• The subscript operator (iter[n]) as a synonym for *(iter + n).



-> NOTE: Associative containers support efficient lookup and retrieval by a key. 
The two primary associative-container types are map and set. 
The elements in a map are key–value pairs: 
The key serves as an index into the map, and the value represents the data associated with that index.


-> NOTE: Associative Container Types
----------------------------------------------------------------------------
Elements Ordered by Key
----------------------------------------------------------------------------
map Associative array; holds key–value pairs
set Container in which the key is the value
multimap map in which a key can appear multiple times
multiset set in which a key can appear multiple times
----------------------------------------------------------------------------
Unordered Collections
----------------------------------------------------------------------------
unordered_map map organized by a hash function
unordered_set set organized by a hash function
unordered_multimap Hashed map; keys can appear multiple times
unordered_multiset Hashed set; keys can appear multiple times


-> NOTE: Callable objects passed to a sort algorithm (§ 10.3.1, p. 386) must meet the same requirements as do the keys in an associative container.


-> NOTE: Key Types for Ordered Containers
Just as we can provide our own comparison operation to an algorithm (§ 10.3, p. 385), 
we can also supply our own operation to use in place of the < operator on keys. 
The specified operation must define a strict weak ordering over the key type. 
We can think of a strict weak ordering as “less than,” 
although our function might use a more complicated procedure. 
However we define it, the comparison function must have the following properties:
• Two keys cannot both be “less than” each other; if k1 is “less than” k2, then k2 must never be “less than” k1.
• If k1 is “less than” k2 and k2 is “less than” k3, then k1 must be “less than” k3.
• If there are two keys, and neither key is “less than” the other, then we’ll say that those keys are “equivalent.” 
If k1 is “equivalent” to k2 and k2 is “equivalent” to k3, then k1 must be “equivalent” to k3.
If two keys are equivalent (i.e., if neither is “less than” the other), 
the container treats them as equal. 
When used as a key to a map, there will be only one element associated with those keys, 
and either key can be used to access the corresponding value.


-> NOTE: In practice, what’s important is that a type that defines a < operator that “behaves normally” can be used as a key.


-> NOTE: The pair Type
A pair holds two data members. 
Like the containers, pair is a template from which we generate specific types. 
We must supply two type names when we create a pair. 
The data members of the pair have the corresponding types. 
There is no requirement that the two types be the same: 
pair<string, string> anon; // holds two strings
pair<string, size_t> word_count; // holds a string and an size_t
pair<string, vector<int>> line; // holds string and vector<int>


-> NOTE: Operations on pairs
1) pair<T1, T2> p; 
p is a pair with value initialized (§ 3.3.1, p. 98) members of types T1 and T2, respectively.
2) pair<T1, T2> p(v1, v2); 
p is a pair with types T1 and T2; the first and second members are initialized from v1 and v2, respectively.
3) pair<T1, T2> p = {v1, v2}; 
Equivalent to p(v1, v2).
4) make_pair(v1, v2) 
Returns a pair initialized from v1 and v2. 
The type of the pair is inferred from the types of v1 and v2.
5) p.first 
Returns the (public) data member of p named first.
6) p.second Returns the (public) data member of p named second.
7) p1 relop p2 
Relational operators (<, >, <=, >=). 
Relational operators are defined as dictionary ordering: 
For example, p1 < p2 is true if p1.first < p2.first or if !(p2.first < p1.first) && p1.second < p2.second. 
Uses the element’s < operator.
8) p1 == p2 or p1 != p2
Two pairs are equal if their first and second members are respectively equal. 
Uses the element’s == operator.


-> NOTE: Associative Container Iterators Are Different
When we dereference an iterator, we get a reference to a value of the container’s value_type. 
In the case of map, the value_type is a pair in which first holds the const key and second holds the value.


-> NOTE: It is essential to remember that the value_type of a map is a pair and that we can change the value but not the key member of that pair.


-> NOTE: Iterators for sets Are const
Although the set types define both the iterator and const_iterator types, both types of iterators give us read-only access to the elements in the set. 
Just as we cannot change the key part of a map element, the keys in a set are also const.


-> NOTE: Iterating across an Associative Container
The output of this program is in alphabetical order. 
When we use an iterator to traverse a map, multimap, set, or multiset, the iterators  yield elements in ascending key order.


-> NOTE: Associative Containers and Algorithms
In general, we do not use the generic algorithms (Chapter 10) with the associative containers. 
The fact that the keys are constmeans that we cannot pass associative container iterators to algorithms that write to or reorder container elements. 
Such algorithms need towrite to the elements. 
The elements in the set types are const, and those in maps are pairs whose first element is const.
Associative containers can be used with the algorithms that read elements.
However, many of these algorithms search the sequence. 
Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. 
For example, as we’ll see in § 11.3.5 (p. 436), the associative containers define a member named find, which directly fetches the element with a given key. 
We could use the generic find algorithm to look for an element, but that algorithm does a sequential search. 
It is much faster to use the find member defined by the container than to call the generic version.
In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. 
For example, we might use the generic copy algorithm to copy the elements froman associative container into another sequence. 
Similarly, we can call inserter to bind an insert iterator (§ 10.4.1, p. 401) to an associative container. 
Using inserter,we can use the associative container as a destination for another algorithm.


-> NOTE: Associative Container insert Operations
1) c.insert(v) or c.emplace(args)
v value_type object; args are used to construct an element.
For map and set, the element is inserted (or constructed) only if an element with the given key is not already in c. 
Returns a pair containing an iterator referring to the element with the given key and a bool indicating whether the element was inserted.
For multimap and multiset, inserts (or constructs) the given element and returns an iterator to the new element.
2) c.insert(b, e) c.insert(il) (ME: YOU CAN HAVE INITIALIZER LIST IN INSERT)
b and e are iterators that denote a range of c::value_type values;
il is a braced list of such values. 
Returns void.
For map and set, inserts the elements with keys that are not already in c. 
For multimap and multiset inserts, each element in the range.
3) c.insert(p, v) or c.emplace(p, args)
Like insert(v) (or emplace(args)), but uses iterator p as a hint for where to begin the search for where the new element should be stored. 
Returns an iterator to the element with the given key.


-> NOTE: Testing the Return from insert
The value returned by insert (or emplace) depends on the container type and the parameters. 
For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. 
The first member of the pair is an iterator to the element with the given key; 
the second is a bool indicating whether that element was inserted, or was already there. 
If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. 
If the key isn’t present, then the element is inserted and the bool is true.


-> NOTE: Removing Elements from an Associative Container
1) c.erase(k) 
Removes every element with key k from c. Returns size_type
indicating the number of elements removed.
2) c.erase(p) 
Removes the element denoted by the iterator p from c. p must refer to an
actual element in c; it must not be equal to c.end(). Returns an iterator
to the element after p or c.end() if p denotes the last element in c.
3) c.erase(b, e) 
Removes the elements in the range denoted by the iterator pair b, e.
Returns e.


-> NOTE: Subscripting a map behaves quite differently from subscripting an array or vector: 
Using a key that is not already present adds an element with that key to the map.


-> NOTE: Using the Value Returned from a Subscript Operation
Another way in which the map subscript differs from other subscript operators we’ve used is its return type. 
Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. 
Not so for maps: when we subscript a map, we get a mapped_type object; when we dereference a map iterator, we get a value_type object.


-> NOTE: Unlike vector or string, the type returned by the map subscript operator differs from the type obtained by dereferencing a map iterator.


-> NOTE: Accessing Elements
The associative containers provide variousways to find a given element, which are described in Table 11.7 (p. 438). 
Which operation to use depends on what problem we are trying to solve. 
If all we care about is whether a particular element is in the container, it is probably best to use find. 
For the containers that can hold only unique keys, it probably doesn’t matterwhether we use find or count. 
However, for the containers with multiple keys, count has to do more work: 
If the element is present, it still has to count how many elements have the same key. 
If we don’t need the count, it’s best to use find:
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
iset.find(1); // returns an iterator that refers to the element with key == 1
iset.find(11); // returns the iterator == iset.end()
iset.count(1); // returns 1
iset.count(11); // returns 0


-> NOTE: Using find Instead of Subscript for maps
For the map and unordered_map types, the subscript operator provides the simplest method of retrieving a value. 
However, as we’ve just seen, using a subscript has an important side effect: 
If that key is not already in the map, then subscript inserts an element with that key. 
Whether this behavior is correct depends on our expectations. 
Our word-counting programs relied on the fact that using a nonexistent key as a subscript inserts an element with that key and value 0.
Sometimes, we want to know if an element with a given key is present without changing the map. 
We cannot use the subscript operator to determine whether an element is present, 
because the subscript operator inserts a new element if the key is not already there. 
In such cases, we should use find: 
if (word_count.find("foobar") == word_count.end())
cout << "foobar is not in the map" << endl;


-> NOTE: Finding Elements in a multimap or multiset
Finding an element in an associative container that requires unique keys is a simple matter—the element is or is not in the container. 
For the containers that allow multiple keys, the process is more complicated: 
There may be many elements with the given key. 
When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container.


-> NOTE: Operations to Find Elements in an Associative Container
lower_bound and upper_bound not valid for the unordered containers.
Subscript and at operations only for map and unordered_map that are not const.
1) c.find(k) 
Returns an iterator to the (first) element with key k, or the off-the-end iterator if k is not in the container.
2) c.count(k) 
Returns the number of elements with key k. For the containers with
unique keys, the result is always zero or one.
3) c.lower_bound(k) 
Returns an iterator to the first element with key NOT less than k.
4) c.upper_bound(k) 
Returns an iterator to the first element with key greater than k.
5) c.equal_range(k) 
Returns a pair of iterators denoting the elements with key k. 
If k is not present, both members are c.end().


-> NOTE: We are guaranteed that iterating across a multimap or multiset returns all the elements with a given key in sequence.


-> NOTE: A Different, Iterator-Oriented Solution
Alternatively, we can solve our problem using lower_bound and upper_bound.
Each of these operations take a key and returns an iterator. 
If the key is in the container, the iterator returned from lower_bound will refer to the FIRST INSTANCE of that key 
and the iterator returned by upper_bound will refer just AFTER the LAST INSTANCE of the key.


-> NOTE: If the element is not in the multimap, then lower_bound and upper_bound will return equal iterators; 
both will refer to the point at which the key can be inserted without disrupting the order. 
Thus, calling lower_bound and upper_bound on the same key yields an iterator range (§ 9.2.1, p. 331) that denotes ALL the elements with that key.


-> NOTE: Of course, the iterator returned from these operations might be the off-the-end iterator for the container itself.
If the element we’re looking for has the largest key in the container, then upper_bound on that key returns the off-the-end iterator. 
If the key is not present and is larger than any key in the container, then the return from lower_bound will also be the off-the-end iterator.


-> NOTE: The iterator returned from lower_bound may or may not refer to an element with the given key. 
If the key is not in the container, then lower_bound REFERS TO THE FIRST POINT 
at which this key can be inserted WHILE PRESERVING THE ELEMENT ORDER within the container.


-> NOTE: If lower_bound and upper_bound return the same iterator, then the given key is not in the container.


-> NOTE: The equal_range Function
The remaining way to solve this problemis the most direct of the three approaches:
Instead of calling upper_bound and lower_bound, we can call equal_range.
This function takes a key and returns a pair of iterators. 
If the key is present, then the first iterator refers to the first instance of the key 
and the second iterator refers one past the last instance of the key. 
If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.


-> NOTE: Print each item
// definitions of authors and search_item as above
// beg and end denote the range of elements for this author
for (auto beg = authors.lower_bound(search_item),
end = authors.upper_bound(search_item);
beg != end; ++beg)
cout << beg->second << endl; // print each title
// definitions of authors and search_item as above
// pos holds iterators that denote the range of elements for this key
for (auto pos = authors.equal_range(search_item);
pos.first != pos.second; ++pos.first)
cout << pos.first->second << endl; // print each title


-> NOTE: The Unordered Containers
The new standard defines four unordered associative containers. 
Rather than using a comparison operation to organize their elements, 
these containers use a hash function and the key type’s == operator. 
An unordered container is most usefulwhenwe have a key type forwhich there is no obvious ordering relationship among the elements. 
These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive.


-> NOTE: Although hashing gives better average case performance in principle, 
achieving good results in practice often requires a fair bit of performance testing and tweaking. 
As a result, it is usually easier (and often yields better performance) to use an ordered container.


-> NOTE: Use an unordered container if the key type is inherently unordered or if performance testing reveals problems that hashing might solve.


-> NOTE: Using an Unordered Container
Aside fromoperations that manage the hashing, 
the unordered containers provide the same operations (find, insert, and so on) as the ordered containers. 
That means that the operations we’ve used on map and set apply to unordered_map and unordered_set as well. 
Similarly for the unordered versions of the containers that allow multiple keys.


-> NOTE: Managing the Buckets
The unordered containers are organized as a collection of buckets, each of which holds zero ormore elements. 
These containers use a hash function to map elements to buckets. 
To access an element, the container first computes the element’s hash code, which tells which bucket to search. 
The container puts all of its elements with a given hash value into the same bucket. 
If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. 
As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.


-> NOTE: Unordered Container Management Operations
-------------------------------------------------------------------------------------
Bucket Interface
-------------------------------------------------------------------------------------
1) c.bucket_count() 
Number of buckets in use.
2) c.max_bucket_count() 
Largest number of buckets this container can hold.
3) c.bucket_size(n) 
Number of elements in the nth bucket.
4) c.bucket(k) 
Bucket in which elements with key k would be found.
-------------------------------------------------------------------------------------
Bucket Iteration
-------------------------------------------------------------------------------------
5) local_iterator 
Iterator type that can access elements in a bucket.
6) const_local_iterator 
const version of the bucket iterator.
7) c.begin(n), c.end(n) 
Iterator to the first, one past the last element in bucket n.
8) c.cbegin(n), c.cend(n) 
Returns const_local_iterator.
-------------------------------------------------------------------------------------
Hash Policy
-------------------------------------------------------------------------------------
9) c.load_factor() 
Average number of elements per bucket. Returns float.
10) c.max_load_factor() 
Average bucket size that c tries to maintain. 
c adds buckets to keep load_factor <= max_load_factor. 
Returns float.
11) c.rehash(n) 
Reorganize storage so that bucket_count >= n and and bucket_count > size/max_load_factor.
12) c.reserve(n) 
Reorganize so that c can hold n elements without a rehash.


-> NOTE: Requirements on Key Type for Unordered Containers
By default, the unordered containers use the == operator on the key type to compare elements. 
They also use an object of type hash<key_type> to generate the hash code for each element. 
The library supplies versions of the hash template for the built-in types, including pointers. 
It also defines hash for some of the library types, including strings and the smart pointer types that we will describe in Chapter 12. 
Thus, we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer.
However,we cannot directly define an unordered container that uses a our own class types for its key type. 
Unlike the containers, we cannot use the hash template directly. 
Instead, we must supply our own version of the hash template.


-> NOTE: Dynamic Memory
Our programs have used only static or stack memory. 
Static memory is used for local static objects (§ 6.1.1, p. 205), for class static data members (§ 7.6, p. 300), 
and for variables defined outside any function. 
Stack memory is used for nonstatic objects defined inside functions. 
Objects allocated in static or stack memory are automatically created and destroyed by the compiler. 
Stack objects exist only while the block in which they are defined is executing; 
static objects are allocated before they are used, and they are destroyed when the program ends.
In addition to static or stack memory, every programalso has a pool of memory that it can use. 
This memory is referred to as the free store or heap. 
Programs use the heap for objects that they dynamically allocate—that is, 
for objects that the program allocates at run time. 
The program controls the lifetime of dynamic objects; 
our code must explicitly destroy such objects when they are no longer needed.

-> NOTE: Although necessary at times, dynamic memory is notoriously tricky to manage correctly.


-> NOTE: To make using dynamic memory easier (and safer), the new library provides two smart pointer types that manage dynamic objects. 
A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points.


-> NOTE: The shared_ptr Class
Like vectors, smart pointers are templates (§ 3.3, p. 96). 
Therefore, when we create a smart pointer, we must supply additional information—in this case, 
the type to which the pointer can point. 
As with vector, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining:
shared_ptr<string> p1; // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints


-> NOTE: The make_shared Function
The safest way to allocate and use dynamic memory is to call a library function named make_shared. 
This function allocates and initializes an object in dynamic memory and returns a shared_ptr that points to that object. 
Like the smart pointers, make_shared is defined in the memory header.
shared_ptr<int> p3 = make_shared<int>(42); // shared_ptr that points to an int with value 42
shared_ptr<string> p4 = make_shared<string>(10, ’9’); // p4 points to a string with value 9999999999
shared_ptr<int> p5 = make_shared<int>(); // p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0


-> NOTE: If we do not pass any arguments, then the object is value initialized (§ 3.3.1, p. 98).


-> NOTE: Operations Common to shared_ptr and unique_ptr
1) shared_ptr<T> sp or unique_ptr<T> up
Null smart pointer that can point to objects of type T.
2) p 
Use p as a condition; true if p points to an object.
3) *p 
Dereference p to get the object to which p points.
4) p->mem 
Synonym for (*p).mem.
5) p.get() 
Returns the pointer in p. 
Use with caution; the object to which the returned pointer points will disappear when the smart pointer deletes it.
6) swap(p, q) or p.swap(q)
Swaps the pointers in p and q.


-> NOTE: Reference count
We can think of a shared_ptr as if it has an associated counter, usually referred to as a reference count. 
Whenever we copy a shared_ptr, the count is incremented.
For example, the counter associated with a shared_ptr is incremented when we use it to initialize another shared_ptr, 
when we use it as the right-hand operand of an assignment, 
or when we pass it to (§ 6.2.1, p. 209) 
or return it from a function by value (§ 6.3.2, p. 224).
The counter is decremented when we assign a new value to the shared_ptr and when the shared_ptr itself is destroyed, 
such as when a local shared_ptr goes out of scope (§ 6.1.1, p. 204).
auto r = make_shared<int>(42); // int to which r points has one user
r = q; // assign to r, making it point to a different address
// increase the use count for the object to which q points
// reduce the use count of the object to which r had pointed
// the object r had pointed to has no users; that object is automatically freed


-> NOTE: It is up to the implementation whether to use a counter 
or another data structure to keep track of how many pointers share state. 
The key point is that the class keeps track of how many shared_ptrs point to the same object 
and automatically frees that object when appropriate.


-> NOTE: shared_ptrs Automatically Destroy Their Objects ...
When the last shared_ptr pointing to an object is destroyed, 
the shared_ptr class automatically destroys the object to which that shared_ptr points. 
It does so through another special member function known as a destructor.


-> NOTE: The destructor for shared_ptr decrements the reference count of the object to which that shared_ptr points. 
If the count goes to zero, the shared_ptr destructor destroys the object to which the shared_ptr points 
and frees the memory used by that object.


-> NOTE: Operations Specific to shared_ptr
1) make_shared<T>(args) 
Returns a shared_ptr pointing to a dynamically allocated object of type T. 
Uses args to initialize that object.
2) shared_ptr<T> 
p(q) p is a copy of the shared_ptr q; increments the count in q. 
The pointer in q must be convertible to T* (§ 4.11.2, p. 161).
3) p = q 
p and q are shared_ptrs holding pointers that can be converted to one another. 
Decrements p’s reference count and increments q’s count; 
deletes p’s existing memory if p’s count goes to 0.
4) p.unique() 
Returns true if p.use_count() is one; false otherwise.
5) p.use_count() 
Returns the number of objects sharing with p; may be a slow operation, intended primarily for debugging purposes.


-> NOTE: ... and Automatically Free the Associated Memory
The fact that the shared_ptr class automatically frees dynamic objects 
when they are no longer needed makes it fairly easy to use dynamic memory. 
For example, we might have a function that returns a shared_ptr 
to a dynamically allocated object of a type named Foo that can be initialized by an argument of type T.


-> NOTE: If you put shared_ptrs in a container, and you subsequently need to use some, 
but not all, of the elements, remember to erase the elements you no longer need.


-> NOTE: Classes with Resources That Have Dynamic Lifetime
Programs tend to use dynamic memory for one of three purposes:
1. They don’t know how many objects they’ll need
2. They don’t know the precise type of the objects they need
3. They want to share data between several objects


-> NOTE: One common reason to use dynamic memory is to allow multiple objects to share the same state.


-> NOTE: Managing Memory Directly
The language itself defines two operators that allocate and free dynamic memory.
The new operator allocates memory, and delete frees memory allocated by new.
For reasons that will become clear as we describe how these operators work, 
using these operators to manage memory is considerably more error-prone than using a smart pointer. 
Moreover, classes that do manage their own memory—
unlike those that use smart pointers—cannot rely on the default definitions for the members that copy, assign, and destroy class objects (§ 7.1.4, p. 264). 
As a result, programs that use smart pointers are likely to be easier to write and debug.


-> NOTE: Recommendation: Your classes should allocate dynamic memory only if they use smart pointers to manage that memory.


-> NOTE:  Using new to Dynamically Allocate and Initialize Objects

Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. 
Instead, new returns a pointer to the object it allocates: 
int *pi = new int; // pi points to a dynamically allocated, unnamed, uninitialized int

This new expression constructs an object of type int on the free store and returns a pointer to that object.
By default, dynamically allocated objects are default initialized (§ 2.2.1, p. 43),
which means that objects of built-in or compound type have undefined value; 
objects of class type are initialized by their default constructor:
string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

We can initialize a dynamically allocated object using direct initialization (§ 3.2.1, p. 84). 
We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, ’9’); // *ps is "9999999999"
// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
We can also value initialize (§ 3.3.1, p. 98) a dynamically allocated object by following the type name with a pair of empty parentheses:
string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

For class types (such as string) that define their own constructors (§ 7.1.4, p. 262),
requesting value initialization is of no consequence; 
regardless of form, the object is initialized by the default constructor. 
In the case of built-in types the difference is SIGNIFICANT; 
a value-initialized object of built-in type has a well-defined value but a default-initialized object does not. 
Similarly, members of built-in type in classes that rely on the synthesized default constructor 
will also be uninitialized if those members are not initialized in the class body (§ 7.1.4, p. 263).


-> NOTE: For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.


-> NOTE: When we provide an initializer inside parentheses, 
we can use auto (§ 2.5.2, p. 68) to deduce the type of the object we want to allocate from that initializer.
However, because the compiler uses the initializer’s type to deduce the type to
allocate, we can use auto only with a single initializer inside parentheses:
auto p1 = new auto(obj); // p points to an object of the type of obj
// that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer


-> NOTE: Dynamically Allocated const Objects
It is legal to use new to allocate const objects:
// allocate and initialize a const int
const int *pci = new const int(1024);
// allocate a default-initialized const empty string
const string *pcs = new const string;
Like any other const, a dynamically allocated const object must be initialized.
A const dynamic object of a class type that defines a default constructor (§ 7.1.4, p. 263) 
may be initialized implicitly. Objects of other types must be explicitly initialized.
Because the allocated object is const, the pointer returned by new is a pointer to const (§ 2.4.2, p. 62).


-> NOTE: Memory Exhaustion
Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. 
Once a program has used all of its available memory, new expressions will fail. 
By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc (§ 5.6, p. 193). 
We can prevent new from throwing an exception by using a different form of new:
// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

For reasons we’ll explain in § 19.1.2 (p. 824) this form of new is referred to as placement new. 
A placement new expression lets us pass additional arguments to new.
In this case,we pass an object named nothrow that is defined by the library.
When we pass nothrow to new, we tell new that it must not throw an exception. 
If this form of new is unable to allocate the requested storage, it will return a null pointer.
Both bad_alloc and nothrow are defined in the new header.


-> NOTE: Freeing Dynamic Memory
In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. 
We return memory through a delete expression. 
A delete expression takes a pointer to the object we want to free:
delete p; // p must point to a dynamically allocated object or be null
Like new, a delete expression performs two actions: 
It destroys the object to which its given pointer points, and it frees the corresponding memory.


-> NOTE: Pointer Values and delete
The pointer we pass to delete must either point to dynamically allocated memory or be a null pointer (§ 2.3.2, p. 53). 
Deleting a pointer to memory that was not allocated by new, or deleting the same pointer value more than once, is undefined:
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd; // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer
Although the value of a const object cannot be modified, the object itself can be destroyed. 
As with any other dynamic object, a const dynamic object is freed by executing delete on a pointer that points to that object:
const int *pci = new const int(1024);
delete pci; // ok: deletes a const object


-> NOTE: Dynamically Allocated Objects Exist until They Are Freed
As we saw in § 12.1.1 (p. 452), memory that is managed through a shared_ptr is automatically deleted when the last shared_ptr is destroyed. 
The same is not true for memory we manage using built-in pointers. 
A dynamic object managed through a built-in pointer exists until it is explicitly deleted.
Functions that return pointers (rather than smart pointers) to dynamic memory put a burden 
on their callers—the caller must remember to delete the memory:
// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg)
{
// process arg as appropriate
return new Foo(arg); // caller is responsible for deleting this memory
}
Unlike class types, nothing happens when objects of built-in type are destroyed.
In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. 
If that pointer points to dynamic memory, that memory is not automatically freed.


-> NOTE: Dynamic memory managed through built-in pointers (rather than smart pointers) exists until it is explicitly freed.


-> NOTE: CAUTION: MANAGING DYNAMIC MEMORY IS ERROR-PRONE
There are three common problems with using new and delete to manage dynamic memory:
1. Forgetting to delete memory. 
Neglecting to delete dynamic memory is known as a “memory leak,” because the memory is never returned to the free store.
Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually exhaust memory.
2. Using an object after it has been deleted. 
This error can sometimes be detected by making the pointer null after the delete.
3. Deleting the same memory twice. This error can happen when two pointers address the same dynamically allocated object. 
If delete is applied to one of the pointers, then the object’s memory is returned to the free store.
If we subsequently delete the second pointer, then the free store may be corrupted.
These kinds of errors are considerably easier to make than they are to find and fix.
You can avoid all of these problems by using smart pointers exclusively.
The smart pointer will take care of deleting the memory only when there are no remaining smart pointers pointing to that memory.


-> NOTE: Resetting the Value of a Pointer after a delete ...
When we delete a pointer, that pointer becomes invalid. 
Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. 
After the delete, the pointer becomes what is referred to as a dangling pointer. 
A dangling pointer is one that refers to memory that once held an object but no longer does so.


-> NOTE: Dangling pointers have all the problems of uninitialized pointers (§ 2.3.2, p. 54).
We can avoid the problems with dangling pointers by deleting the memory associated with a pointer 
just before the pointer itself goes out of scope. 
That way there is no chance to use the pointer after the memory associated with the pointer is freed.
If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. 
Doing so makes it clear that the pointer points to no object.


-> NOTE: ... Provides Only Limited Protection
A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. 
Resetting the pointer we use to delete that memory lets us check that particular pointer 
but has no effect on any of the other pointers that still point at the (freed) memory. 
For example:
int *p(new int(42)); // p points to dynamic memory
auto q = p; // p and q point to the same memory
delete p; // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object
Here both p and q point at the same dynamically allocated object. 
We delete that memory and set p to nullptr, indicating that the pointer no longer points to an object. 
However, resetting p has no effect on q, which became invalid when we deleted the memory to which p (and q!) pointed. 
In real systems, finding all the pointers that point to the same memory is surprisingly difficult.


-> NOTE: Using shared_ptrs with new
As we’ve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. 
As described in Table 12.3, we can also initialize a smart pointer from a pointer returned by new:
shared_ptr<double> p1; // shared_ptr that can point at a double
shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42
The smart pointer constructors that take pointers are explicit (§ 7.5.4, p. 296).
Hence, we cannot implicitly convert a built-in pointer to a smart pointer; 
we must use the direct form of initialization (§ 3.2.1, p. 84) to initialize a smart pointer:
shared_ptr<int> p1 = new int(1024); // error: must use direct initialization
shared_ptr<int> p2(new int(1024)); // ok: uses direct initialization
The initialization of p1 implicitly asks the compiler to create a shared_ptr from the int* returned by new. 
Because we can’t implicitly convert a pointer to a smart pointer, this initialization is an error. 
For the same reason, a function that returns a shared_ptr cannot implicitly convert a plain pointer in its return statement:
shared_ptr<int> clone(int p) {
return new int(p); // error: implicit conversion to shared_ptr<int>
}
We must explicitly bind a shared_ptr to the pointer we want to return:
shared_ptr<int> clone(int p) {
// ok: explicitly create a shared_ptr<int> from int*
return shared_ptr<int>(new int(p));
}
By default, a pointer used to initialize a smart pointer must point to dynamic memory because, 
by default, smart pointers use delete to free the associated object.
We can bind smart pointers to pointers to other kinds of resources. 
However, to do so, we must supply our own operation to use in place of delete. 
We’ll see how to supply our own deletion code in § 12.1.4 (p. 468).


-> NOTE: Don’t Mix Ordinary Pointers and Smart Pointers ...
A shared_ptr can coordinate destruction only with other shared_ptrs that are copies of itself.
Indeed, this fact is one of the reasons we recommend using make_shared rather than new. 
That way, we bind a shared_ptr to the object at the same time that we allocate it. 
There is no way to inadvertently bind the same memory to more than one independently created shared_ptr.
Consider the following function that operates on a shared_ptr:
// ptr is created and initialized when process is called
void process(shared_ptr<int> ptr)
{
// use ptr
} // ptr goes out of scope and is destroyed
The parameter to process is passed by value, so the argument to process is copied into ptr.
Copying a shared_ptr increments its reference count. 
Thus, inside process the count is at least 2. 
When process completes, the reference count of ptr is decremented but cannot go to zero. 
Therefore, when the local variable ptr is destroyed, the memory to which ptr points will not be deleted.
The right way to use this function is to pass it a shared_ptr:
shared_ptr<int> p(new int(42)); // reference count is 1
process(p); // copying p increments its count; in process the reference count is 2
int i = *p; // ok: reference count is 1
Although we cannot pass a built-in pointer to process, 
we can pass process a (temporary) shared_ptr that we explicitly construct from a built-in pointer.
However, doing so is likely to be an error:
int *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointer
process(x); // error: cannot convert int* to shared_ptr<int>
process(shared_ptr<int>(x)); // legal, but the memory will be deleted!
int j = *x; // undefined: x is a dangling pointer!
In this call, we passed a temporary shared_ptr to process. 
That temporary is destroyed when the expression in which the call appears finishes. 
Destroying the temporary decrements the reference count, which goes to zero. 
The memory to which the temporary points is freed when the temporary is destroyed.
But x continues to point to that (freed) memory; x is now a dangling pointer.
Attempting to use the value of x is undefined.
When we bind a shared_ptr to a plain pointer, we give responsibility for that memory to that shared_ptr. 
Once we give shared_ptr responsibility for a pointer, 
we should no longer use a built-in pointer to access the memory to which the shared_ptr now points.


-> NOTE: Other Ways to Define and Change shared_ptrs
1) shared_ptr<T> p(q) 
p manages the object to which the built-in pointer q points;
q must point to memory allocated by new and must be convertible to T*.
2) shared_ptr<T> p(u) 
p assumes ownership from the unique_ptr u; makes u null.
3) shared_ptr<T> p(q, d) 
p assumes ownership for the object to which the built-in pointer q points. 
q must be convertible to T* (§ 4.11.2, p. 161).
p will use the callable object d (§ 10.3.2, p. 388) in place of delete to free q.
4) shared_ptr<T> p(p2, d) 
p is a copy of the shared_ptr p2 as described in Table 12.2 except that p uses the callable object d in place of delete.
5) p.reset() or p.reset(q) or p.reset(q, d)
If p is the only shared_ptr pointing at its object, reset frees p’s existing object. 
If the optional built-in pointer q is passed, makes p point to q, otherwise makes p null. 
If d is supplied, will call d to free q otherwise uses delete to free q.


-> NOTE: ... and Don’t Use get to Initialize or Assign Another Smart Pointer
The smart pointer types define a function named get (described in Table 12.1 (p. 452)) 
that returns a built-in pointer to the object that the smart pointer is managing.
This function is intended for cases when we need to pass a built-in pointer to code that can’t use a smart pointer. 
The code that uses the return from get must not delete that pointer.
Although the compiler will not complain, it is an error to bind another smart pointer to the pointer returned by get:
shared_ptr<int> p(new int(42)); // reference count is 1
int *q = p.get(); // ok: but don’t use q in any way that might delete its pointer
{ // new block
// undefined: two independent shared_ptrs point to the same memory
shared_ptr<int>(q);
} // block ends, q is destroyed, and the memory to which q points is freed
int foo = *p; // undefined; the memory to which p points was freed
In this case, both p and q point to the same memory. 
Because they were created independently from each other, each has a reference count of 1. 
When the block in which q was defined ends, q is destroyed. 
Destroying q frees the memory to which q points. 
That makes p into a dangling pointer, meaning that what happens when we attempt to use p is undefined. 
Moreover, when p is destroyed, the pointer to that memory will be deleted a second time.


-> NOTE: Use get only to pass access to the pointer to code that you know will not delete the pointer. 
In particular, never use get to initialize or assign to another smart pointer.


-> NOTE: Other shared_ptr Operations
The shared_ptr class gives us a few other operations, which are listed in Table 12.2 (p. 453) and Table 12.3 (on the previous page). 
We can use reset to assign a newpointer to a shared_ptr:
p = new int(1024); // error: cannot assign a pointer to a shared_ptr
p.reset(new int(1024)); // ok: p points to a new object
Like assignment, reset updates the reference counts and, if appropriate, deletes the object to which p points. 
The reset member is often used together with unique to control changes to the object shared among several shared_ptrs. 
Before changing the underlying object, we check whether we’re the only user. 
If not, we make a new copy before making the change:
if (!p.unique()){
p.reset(new string(*p)); // we aren’t alone; allocate a new copy
}
*p += newVal; // now that we know we’re the only pointer, okay to change this object


-> NOTE: Smart Pointers and Exceptions
In § 5.6.2 (p. 196) we noted that programs that use exception handling to continue processing 
after an exception occurs need to ensure that resources are properly freed if an exception occurs. 
One easy way to make sure resources are freed is to use smart pointers.
When we use a smart pointer, the smart pointer class ensures that memory is freed 
when it is no longer needed even if the block is exited prematurely:
void f()
{
shared_ptr<int> sp(new int(42)); // allocate a new object
// code that throws an exception that is not caught inside f
} // shared_ptr freed automatically when the function ends
When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. 
In this case, sp is a shared_ptr, so destroying sp checks its reference count. 
Here, sp is the only pointer to the memory it manages; 
that memory will be freed as part of destroying sp.
In contrast, memory that we manage directly is not automatically freed when an exception occurs. 
If we use built-in pointers to manage memory and an exception occurs after a new but before the corresponding delete, then that memory won’t be freed:
void f()
{
int *ip = new int(42); // dynamically allocate a new object
// code that throws an exception that is not caught inside f
delete ip; // free the memory before exiting
}
If an exception happens between the new and the delete, and is not caught inside f, then this memory can never be freed. 
There is no pointer to this memory outside the function f. 
Thus, there is no way to free this memory.


-> NOTE: Smart Pointers and Dumb Classes
Many C++ classes, including all the library classes, define destructors (§ 12.1.1, p. 452) 
that take care of cleaning up the resources used by that object. 
However, not all classes are so well behaved. 
In particular, classes that are designed to be used by both C and C++ 
generally require the user to specifically free any resources that are used.

When we create a shared_ptr, we can pass an optional argument that points to a deleter function (§ 6.7, p. 247):
void f(destination &d /* other parameters */)
{
connection c = connect(&d);
shared_ptr<connection> p(&c, end_connection);
// use the connection
// when f exits, even if by an exception, the connection will be properly closed
}
When p is destroyed, it won’t execute delete on its stored pointer. 
Instead, p will call end_connection on that pointer. 
In turn, end_connection will call disconnect, thus ensuring that the connection is closed. 
If f exits normally, then p will be destroyed as part of the return. 
Moreover, p will also be destroyed, and the connection will be closed, if an exception occurs.


-> NOTE: CAUTION: SMART POINTER PITFALLS
Smart pointers can provide safety and convenience for handling dynamically allocated memory only when they are used properly. 
To use smart pointers correctly, we must adhere to a set of conventions:
• Don’t use the same built-in pointer value to initialize (or reset) more than one smart pointer.
• Don’t delete the pointer returned from get().
• Don’t use get() to initialize or reset another smart pointer.
• If you use a pointer returned by get(), remember that the pointer will become invalid when the last corresponding smart pointer goes away.
• If you use a smart pointer to manage a resource other than memory allocated by new, remember to pass a deleter (§ 12.1.4, p. 468, and § 12.1.5, p. 471).


-> NOTE: unique_ptr
A unique_ptr “owns” the object to which it points. 
Unlike shared_ptr, only one unique_ptr at a time can point to a given object. 
The object to which a unique_ptr points is destroyed when the unique_ptr is destroyed. 
Table 12.4 lists the operations specific to unique_ptrs. 
The operations common to both were covered in Table 12.1 (p. 452).


-> NOTE: Unlike shared_ptr, there is no library function comparable to make_shared that returns a unique_ptr. (ME: THERES MAKE_UNIQUE)
Instead, when we define a unique_ptr, we bind it to a pointer returned by new. 
As with shared_ptrs, we must use the direct form of initialization:
unique_ptr<double> p1; // unique_ptr that can point at a double
unique_ptr<int> p2(new int(42)); // p2 points to int with value 42
Because a unique_ptr owns the object to which it points, 
unique_ptr does not support ordinary copy or assignment:
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1); // error: no copy for unique_ptr
unique_ptr<string> p3;
p3 = p2;


-> NOTE: Although we can’t copy or assign a unique_ptr,
we can transfer ownership from one (nonconst) unique_ptr to another by calling release or reset:
// transfers ownership from p1 (which points to the string Stegosaurus) to p2
unique_ptr<string> p2(p1.release()); // release makes p1 null
unique_ptr<string> p3(new string("Trex"));
// transfers ownership from p3 to p2
p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed
The release member returns the pointer currently stored in the unique_ptr and makes that unique_ptr null. 
Thus, p2 is initialized from the pointer value that had been stored in p1 and p1 becomes null.



-> NOTE: unique_ptr Operations (See Also Table 12.1 (p. 452))
1) unique_ptr<T> u1 or unique_ptr<T, D> u2
Null unique_ptrs that can point to objects of type T. 
u1 will use delete to free its pointer; 
u2 will use a callable object of type D to free its pointer.
2) unique_ptr<T, D> u(d) 
Null unique_ptr that point to objects of type T that uses d,
which must be an object of type D in place of delete.
u = nullptr Deletes the object to which u points; makes u null.
3) u.release() 
Relinquishes control of the pointer u had held; returns the pointer u had held and makes u null.
4) u.reset() or u.reset(q) u.reset(nullptr)
Deletes the object to which u points;
If the built-in pointer q is supplied, makes u point to that object.
Otherwise makes u null.


-> NOTE: Passing and Returning unique_ptrs
There is one exception to the rule that we cannot copy a unique_ptr: 
We can copy or assign a unique_ptr that is about to be destroyed. 
The most common example is when we return a unique_ptr from a function:
unique_ptr<int> clone(int p) {
// ok: explicitly create a unique_ptr<int> from int*
return unique_ptr<int>(new int(p));
}
Alternatively, we can also return a copy of a local object:
unique_ptr<int> clone(int p) {
unique_ptr<int> ret(new int (p));
// . . .
return ret;
}
In both cases, the compiler knows that the object being returned is about to be destroyed. 
In such cases, the compiler does a special kind of “copy” which we’ll discuss in § 13.6.2 (p. 534).


-> NOTE: BACKWARD COMPATIBILITY: AUTO_PTR
Earlier versions of the library included a class named auto_ptr that had some, but not all, of the properties of unique_ptr. 
In particular, it was not possible to store an auto_ptr in a container, nor could we return one from a function.
Although auto_ptr is still part of the standard library, programs should use unique_ptr instead.


-> NOTE: Passing a Deleter to unique_ptr (ME: decltype can be used here)
Like shared_ptr, by default, unique_ptr uses delete to free the object to which a unique_ptr points. 
As with shared_ptr, we can override the default deleter in a unique_ptr (§ 12.1.4, p. 468). 
However, for reasons we’ll describe in § 16.1.6 (p. 676), the way unique_ptr manages its deleter is differs from the way shared_ptr does.
Overridding the deleter in a unique_ptr affects the unique_ptr type as well as how we construct (or reset) objects of that type. 
Similar to overriding the comparison operation of an associative container (§ 11.2.2, p. 425), 
we must supply the deleter type inside the angle brackets along with the type to which the unique_ptr can point. 
We supply a callable object of the specified type when we create or reset an object of this type:
// p points to an object of type objT and uses an object of type delT to free that object
// it will call an object named fcn of type delT
unique_ptr<objT, delT> p (new objT, fcn);
As a somewhat more concrete example, we’ll rewrite our connection program to use a unique_ptr in place of a shared_ptr as follows:
void f(destination &d /* other needed parameters */)
{
connection c = connect(&d); // open the connection
// when p is destroyed, the connection will be closed
unique_ptr<connection, decltype(end_connection)*> // decltype can be used here
p(&c, end_connection);
// use the connection
// when f exits, even if by an exception, the connection will be properly closed
}
Here we use decltype (§ 2.5.3, p. 70) to specify the function pointer type. 
Because decltype(end_connection) returns a function type, 
we must remember to add a * to indicate that we’re using a pointer to that type (§ 6.7, p. 250).



-> NOTE: weak_ptr
A weak_ptr (Table 12.5) is a smart pointer that does not control the lifetime of the object to which it points. 
Instead, a weak_ptr points to an object that is managed by a shared_ptr. 
Binding a weak_ptr to a shared_ptr does not change the reference count of that shared_ptr. 
Once the last shared_ptr pointing to the object goes away, the object itself will be deleted. 
That object will be deleted even if there are weak_ptrs pointing to it—hence the name weak_ptr, 
which captures the idea that a weak_ptr shares its object “weakly.”


-> NOTE: When we create a weak_ptr, we initialize it from a shared_ptr:
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); // wp weakly shares with p; use count in p is unchanged
Here both wp and p point to the same object. 
Because the sharing is weak, creating wp doesn’t change the reference count of p; 
it is possible that the object to which wp points might be deleted.


-> NOTE: Because the object might no longer exist, we cannot use a weak_ptr to access its object directly. 
To access that object, we must call lock. 
The lock function checks whether the object to which the weak_ptr points still exists. 
If so, lock returns a shared_ptr to the shared object. 
As with any other shared_ptr, we are guaranteed that the underlying object to which that 
shared_ptr points continues to exist at least as long as that shared_ptr exists. 
For example:
if (shared_ptr<int> np = wp.lock()) { // true if np is not null
// inside the if, np shares its object with p
}
Here we enter the body of the if only if the call to lock succeeds. 
Inside the if, it is safe to use np to access that object.


-> NOTE: weak_ptrs
1) weak_ptr<T> 
w Null weak_ptr that can point at objects of type T.
2) weak_ptr<T> w(sp) 
weak_ptr that points to the same object as the shared_ptr sp.
T must be convertible to the type to which sp points.
3) w = p 
p can be a shared_ptr or a weak_ptr. After the assignment w
shares ownership with p.
4) w.reset() 
Makes w null.
5) w.use_count() 
The number of shared_ptrs that share ownership with w.
6) w.expired() 
Returns true if w.use_count() is zero, false otherwise.
7) w.lock() 
If expired is true, returns a null shared_ptr; otherwise returns a shared_ptr to the object to which w points.


-> NOTE: Dynamic Arrays
The new and delete operators allocate objects one at a time. 
Some applications, need the ability to allocate storage for many objects at once. 
For example, vectors and strings store their elements in contiguous memory 
and must allocate several elements at once whenever the container has to be reallocated (§ 9.4, p. 355).

To support such usage, the language and library provide two ways to allocate an array of objects at once. 
The language defines a second kind of new expression that allocates and initializes an array of objects. 
The library includes a template class named allocator that lets us separate allocation from initialization. 
For reasons we’ll explain in § 12.2.2 (p. 481), using an allocator generally provides better performance and more flexible memory management.

Many, perhaps even most, applications have no direct need for dynamic arrays.
When an application needs a varying number of objects, it is almost always easier, faster, and safer to use a vector (or other library container). 
For reasons we’ll explain in § 13.6 (p. 531), the advantages of using a library container are even more pronounced under the new standard. 
Libraries that support the new standard tend to be dramatically faster than previous releases.


-> NOTE: new and Arrays
We ask new to allocate an array of objects by specifying the number of objects to allocate in a pair of square brackets after a type name. 
In this case, new allocates the requested number of objects and (assuming the allocation succeeds) returns a pointer to the first one:
// call get_size to determine how many ints to allocate
int *pia = new int[get_size()]; // pia points to the first of these ints
The size inside the brackets must have integral type but need not be a constant.
We can also allocate an array by using a type alias (§ 2.5.1, p. 67) to represent an array type. 
In this case, we omit the brackets:
typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first one
Here, new allocates an array of ints and returns a pointer to the first one. 
Even though there are no brackets in our code, the compiler executes this expression using new[].
That is, the compiler executes this expression as if we had written 
int *p = new int[42];


-> NOTE: Allocating an Array Yields a Pointer to the Element Type
Although it is common to refer to memory allocated by new T[] as a “dynamic array,” this usage is somewhat misleading.
When we use new to allocate an array, we do not get an object with an array type. 
Instead, we get a pointer to the element type of the array. 
Even if we use a type alias to define an array type, new does not allocate an object of array type. 
In this case, the fact that we’re allocating an array is not even visible; there is no [num]. 
Even so, new returns a pointer to the element type.
Because the allocated memory does not have an array type, we cannot call begin or end (§ 3.5.3, p. 118) on a dynamic array. 
These functions use the array dimension (which is part of an array’s type) 
to return pointers to the first and one past the last elements, respectively. 
For the same reasons, we also cannot use a range for to process the elements in a (so-called) dynamic array.


-> NOTE: It is important to remember that what we call a dynamic array does not have an array type.


-> NOTE: Initializing an Array of Dynamically Allocated Objects
By default, objects allocated by new—whether allocated as a single object or in an array—are default initialized. 
We can value initialize (§ 3.3.1, p. 98) the elements in an array by following the size with an empty pair of parentheses.
int *pia = new int[10]; // block of ten uninitialized ints
int *pia2 = new int[10](); // block of ten ints value initialized to 0
string *psa = new string[10]; // block of ten empty strings
string *psa2 = new string[10](); // block of ten empty strings
Under the new standard, we can also provide a braced list of element initializers:
// block of ten ints each initialized from the corresponding initializer
int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9}; // ME: WOW, this is new!
// block of ten strings; the first four are initialized from the given initializers
// remaining elements are value initialized
string *psa3 = new string[10]{"a", "an", "the", string(3,’x’)};


-> NOTE: It Is Legal to Dynamically Allocate an Empty Array
We can use an arbitrary expression to determine the number of objects to allocate:
size_t n = get_size(); // get_size returns the number of elements needed
int* p = new int[n]; // allocate an array to hold the elements
for (int* q = p; q != p + n; ++q)
/* process the array */ ;
An interesting question arises: 
What happens if get_size returns 0? 
The answer is that our code works fine. 
Calling new[n] with n equal to 0 is legal even though we cannot create an array variable of size 0:
char arr[0]; // error: cannot define a zero-length array
char *cp = new char[0]; // ok: but cp can’t be dereferenced


-> NOTE: Freeing Dynamic Arrays
To free a dynamic array, we use a special form of delete that includes an empty pair of square brackets:
delete p; // p must point to a dynamically allocated object or be null
delete [] pa; // pa must point to a dynamically allocated array or be null
The second statement destroys the elements in the array to which pa points and frees the corresponding memory. 
Elements in an array are destroyed in reverse order. (ME: This is important!)
That is, the last element is destroyed first, then the second to last, and so on.
When we delete a pointer to an array, the empty bracket pair is essential: 
It indicates to the compiler that the pointer addresses the first element of an array of objects. 
If we omit the brackets when we delete a pointer to an array (or provide them when we delete a pointer to an object), the behavior is undefined.
Recall that when we use a type alias that defines an array type, 
we can allocate an array without using [] with new. 
Even so, we must use brackets when we delete a pointer to that array:
typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first one
delete [] p; // brackets are necessary because we allocated an array
Despite appearances, p points to the first element of an array of objects, not to a single object of type arrT.
Thus, we must use [] when we delete p.


-> NOTE: The compiler is unlikely to warn us if we forget the brackets when we delete a pointer to an array 
or if we use them when we delete a pointer to an object. 
Instead, our program is apt to misbehave without warning during execution.


-> NOTE: Smart Pointers and Dynamic Arrays
The library provides a version of unique_ptr that can manage arrays allocated by new. 
To use a unique_ptr to manage a dynamic array, we must include a pair of empty brackets after the object type:
// up points to an array of ten uninitialized ints
unique_ptr<int[]> up(new int[10]);
up.release(); // automatically uses delete[] to destroy its pointer


-> NOTE: When a unique_ptr points to an array, we cannot use the dot and arrow member access operators.


-> NOTE: unique_ptrs to Arrays
Member access operators (dot and arrow) are NOT supported for unique_ptrs to arrays.
Other unique_ptr operations unchanged.
1) unique_ptr<T[]> u
u can point to a dynamically allocated array of type T.
2) unique_ptr<T[]> u(p) 
u points to the dynamically allocated array to which the built-in pointer p points. 
p must be convertible to T* (§ 4.11.2, p. 161).
3) u[i] 
Returns the object at position i in the array that u owns. 
u must point to an array.


-> NOTE: Unlike unique_ptr, shared_ptrs provide no direct support for managing a dynamic array. 
If we want to use a shared_ptr to manage a dynamic array, we must provide our own deleter:
// to use a shared_ptr we must supply a deleter
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
sp.reset(); // uses the lambda we supplied that uses delete[] to free the array
Here we pass a lambda (§ 10.3.2, p. 388) that uses delete[] as the deleter.
Had we neglected to supply a deleter, this code would be undefined. 
By default, shared_ptr uses delete to destroy the object to which it points. 
If that object is a dynamic array, using delete has the same kinds of problems 
that arise if we forget to use [] when we delete a pointer to a dynamic array (§ 12.2.1, p. 479).


-> NOTE: The fact that shared_ptr does not directly support managing arrays affects how we access the elements in the array:
// shared_ptrs don’t have subscript operator and don’t support pointer arithmetic
for (size_t i = 0; i != 10; ++i)
*(sp.get() + i) = i; // use get to get a built-in pointer



-> NOTE: The allocator Class
The library allocator class, which is defined in the memory header, lets us separate allocation from construction. 
It provides type-aware allocation of raw, unconstructed, memory. 
Table 12.7 (overleaf) outlines the operations that allocator supports. 
In this section, we’ll describe the allocator operations. 
In § 13.5 (p. 524), we’ll see an example of how this class is typically used.
Like vector, allocator is a template (§ 3.3, p. 96). 
To define an allocator we must specify the type of objects that a particular allocator can allocate.
When an allocator object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type:
allocator<string> alloc; // object that can allocate strings
auto const p = alloc.allocate(n); // allocate n unconstructed strings
This call to allocate allocates memory for n strings.


-> NOTE: allocators Allocate Unconstructed Memory
The memory an allocator allocates is unconstructed. 
We use this memory by constructing objects in that memory. 
In the new library the construct member takes a pointer and zero or more additional arguments; 
it constructs an element at the given location. 
The additional arguments are used to initialize the object being constructed. 
Like the arguments to make_shared (§ 12.1.1, p. 451), these additional arguments 
must be valid initializers for an object of the type being constructed.
In particular, if the , object is a class type, these arguments must match a constructor for that class:
auto q = p; // q will point to one past the last constructed element
alloc.construct(q++); // *q is the empty string
alloc.construct(q++, 10, ’c’); // *q is cccccccccc
alloc.construct(q++, "hi"); // *q is hi!
In earlier versions of the library, construct took only two arguments: 
the pointer at which to construct an object and a value of the element type. 
As a result, we could only copy an element into unconstructed space, we could not use any other constructor for the element type.
It is an error to use raw memory in which an object has not been constructed:
cout << *p << endl; // ok: uses the string output operator
cout << *q << endl; // disaster: q points to unconstructed memory!


-> NOTE: Standard allocator Class and Customized Algorithms
1) allocator<T> a 
Defines an allocator object named a that can allocate memory for objects of type T.
2) a.allocate(n) 
Allocates raw, unconstructed memory to hold n objects of type T.
3) a.deallocate(p, n) 
Deallocates memory that held n objects of type T starting at the address in the T* pointer p; 
p must be a pointer previously returned by allocate, and n must be the size requested when p was created. 
The user must run destroy on any objects that were constructed in this memory before calling deallocate.
4) a.construct(p, args) 
pmust be a pointer to type T that points to raw memory; 
args are passed to a constructor for type T, which is used to construct an object in the memory pointed to by p.
5) a.destroy(p) 
Runs the destructor (§ 12.1.1, p. 452) on the object pointed to by the T* pointer p.


-> NOTE: allocators Allocate Unconstructed Memory
The memory an allocator allocates is unconstructed.
We use this memory by constructing objects in that memory. 
In the new library the construct member takes a pointer and zero or more additional arguments; 
it constructs an element at the given location. 
The additional arguments are used to initialize the object being constructed. 
Like the arguments to make_shared (§ 12.1.1, p. 451), these additional arguments must be valid initializers for an object of the type being constructed.
In particular, if the , object is a class type, these arguments must match a constructor for that class:
auto q = p; // q will point to one past the last constructed element
alloc.construct(q++); // *q is the empty string
alloc.construct(q++, 10, ’c’); // *q is cccccccccc
alloc.construct(q++, "hi"); // *q is hi!


-> NOTE: We must construct objects in order to use memory returned by allocate. 
Using unconstructed memory in other ways is undefined.


-> NOTE: When we’re finished using the objects, we must destroy the elements we constructed, which we do by calling destroy on each constructed element. 
The destroy function takes a pointer and runs the destructor (§ 12.1.1, p. 452) on the pointed-to object:
while (q != p)
alloc.destroy(--q); // free the strings we actually allocated
At the beginning of our loop, q points one past the last constructed element. 
We decrement q before calling destroy. 
Thus, on the first call to destroy, q points to the last constructed element. 
We destroy the first element in the last iteration, after which q will equal p and the loop ends.


-> NOTE: Once the elements have been destroyed, we can either reuse the memory to hold other strings or return the memory to the system. 
We free the memory by calling deallocate:
alloc.deallocate(p, n);
The pointer we pass to deallocate cannot be null; it must point to memory allocated by allocate. 
Moreover, the size argument passed to deallocate must be the same size as used in the call to allocate that obtained the memory to which the pointer points.


-> NOTE: Algorithms to Copy and Fill Uninitialized Memory
As a companion to the allocator class, the library also defines two algorithms that can construct objects in uninitialized memory. 
These functions, described in Table 12.8, are defined in the memory header.
As an example, assume we have a vector of ints that we want to copy into dynamic memory. 
We’ll allocate memory for twice as many ints as are in the vector. 
We’ll construct the first half of the newly allocated memory by copying elements from the original vector. 
We’ll construct elements in the second half by filling them with a given value:
// allocate twice as many elements as vi holds
auto p = alloc.allocate(vi.size() * 2);
// construct elements starting at p as copies of elements in vi
auto q = uninitialized_copy(vi.begin(), vi.end(), p);
// initialize the remaining elements to 42
uninitialized_fill_n(q, vi.size(), 42);
Like the copy algorithm (§ 10.2.2, p. 382), uninitialized_copy takes three iterators. 
The first two denote an input sequence and the third denotes the destination into which those elements will be copied. 
The destination iterator passed to uninitialized_copy must denote unconstructed memory. 
Unlike copy, uninitialized_copy constructs elements in its destination.
Like copy, uninitialized_copy returns its (incremented) destination iterator.
Thus, a call to uninitialized_copy returns a pointer positioned one element past the last constructed element. 
In this example, we store that pointer in q, which we pass to uninitialized_fill_n. 
This function, like fill_n (§ 10.2.2, p. 380), takes a pointer to a destination, a count, and a value. 
It will construct the given number of objects from the given value at locations starting at the given destination.


-> NOTE: allocator Algorithms
These functions construct elements in the destination, rather than assigning to them.
) uninitialized_copy(b, e, b2)
Copies elements from the input range denoted by iterators b and e into unconstructed, raw memory denoted by the iterator b2. 
The memory denoted by b2 must be large enough to hold a copy of the elements in the input range.
) uninitialized_copy_n(b, n, b2)
Copies n elements starting from the one denoted by the iterator b into raw memory starting at b2.
) uninitialized_fill(b, e, t)
Constructs objects in the range of raw memory denoted by iterators b and e as a copy of t.
) uninitialized_fill_n(b, n, t)
Constructs an unsigned number n objects starting at b. b must denote unconstructed, 
raw memory large enough to hold the given number of objects.


-> NOTE: ME: uninitialized_copy vs copy
uninitialized_copy constructs an object "in-place", using placement-new expression, 
means that there is an existing span of storage into which the object is constructed. 
This is in contrast with allocating-new, which allocates a new piece of dynamic storage into which the object is created.
Note that in contrast, std::copy does not create any objects. 
It calls the assignment operator on existing objects whose lifetime is not affected by the operation. 
(Although, an overloaded assignment operator may indirectly result in creation of objects).
A case where std::uninitialized_copy is useful is reusal of raw memory, such as in the implementation of std::vector.


-> NOTE: Copy Control
When we define a class, we specify—explicitly or implicitly—what happens 
when objects of that class type are copied, moved, assigned, and destroyed.
A class controls these operations by defining five special member functions: 
copy constructor, copy-assignment operator, move constructor, move-assignment operator, and destructor.


-> NOTE: Copy control is an essential part of defining any C++ class. 
Programmers new to C++ are often confused by having to define 
what happens when objects are copied, moved, assigned, or destroyed. 
This confusion is compounded because if we do not explicitly define these operations,
the compiler defines them for us—although the compiler-defined versions might not behave as we intend.


-> NOTE: The Copy Constructor
A constructor is the copy constructor if its first parameter is a reference to the class type and any additional parameters have default values:
class Foo {
public:
Foo(); // default constructor
Foo(const Foo&); // copy constructor
// . . .
};
For reasons we’ll explain shortly, the first parameter must be a reference type. 
That parameter is almost always a reference to const, although we can define the copy constructor to take a reference to nonconst. 
The copy constructor is used implicitly in several circumstances. 
Hence, the copy constructor usually should not be explicit (§ 7.5.4, p. 296).


-> NOTE: The Synthesized Copy Constructor
When we do not define a copy constructor for a class, the compiler synthesizes one for us. 
Unlike the synthesized default constructor (§ 7.1.4, p. 262), a copy constructor is synthesized even if we define other constructors.
As we’ll see in § 13.1.6 (p. 508), the synthesized copy constructor for some classes prevents us from copying objects of that class type. 
Otherwise, the synthesized copy constructor memberwise copies the members of its argument into the object being created (§ 7.1.5, p. 267). 
The compiler copies each nonstatic member in turn from the given object into the one being created.


-> NOTE: Copy Initialization
We are now in a position to fully understand the differences between direct initialization and copy initialization (§ 3.2.1, p. 84):
string dots(10, ’.’); // direct initialization
string s(dots); // direct initialization
string s2 = dots; // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, ’9’); // copy initialization
When we use direct initialization, we are asking the compiler to use ordinary function matching (§ 6.4, p. 233) 
to select the constructor that best matches the arguments we provide. 
When we use copy initialization, we are asking the compiler to copy the right-hand operand into the object being created, 
converting that operand if necessary (§ 7.5.4, p. 294).


-> NOTE: Copy initialization ordinarily uses the copy constructor. 
However, as we’ll see in § 13.6.2 (p. 534), if a class has a move constructor, 
then copy initialization sometimes uses the move constructor instead of the copy constructor. 
For now, what’s useful to know is when copy initialization happens 
and that copy initialization requires either the copy constructor or the move constructor.
Copy initialization happens NOT only when we define variables using an =, but also when we
• Pass an object as an argument to a parameter of nonreference type
• Return an object from a function that has a nonreference return type
• Brace initialize the elements in an array or the members of an aggregate class (§ 7.5.5, p. 298)
Some class types also use copy initialization for the objects they allocate. 
For example, the library containers copy initialize their elements when we initialize the container,
or when we call an insert or push member (§ 9.3.1, p. 342). 
By contrast, elements created by an emplace member are direct initialized (§ 9.3.1, p. 345).


-> NOTE: Parameters and Return Values
During a function call, parameters that have a nonreference type are copy initialized (§ 6.2.1, p. 209). 
Similarly, when a function has a nonreference return type, 
the return value is used to copy initialize the result of the call operator at the call site (§ 6.3.2, p. 224).
The fact that the copy constructor is used to initialize nonreference parameters of class type 
explains why the copy constructor’s own parameter must be a reference.
If that parameter were not a reference, then the call would never succeed—to call the copy constructor, 
we’d need to use the copy constructor to copy the argument,
but to copy the argument, we’d need to call the copy constructor, and so on indefinitely.


-> NOTE: Constraints on Copy Initialization
As we’ve seen, whether we use copy or direct initialization matters 
if we use an initializer that requires conversion by an explicit constructor (§ 7.5.4, p. 296):
vector<int> v1(10); // ok: direct initialization
vector<int> v2 = 10; // error: constructor that takes a size is explicit
void f(vector<int>); // f’s parameter is copy initialized
f(10); // error: can’t use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
Directly initializing v1 is fine, but the seemingly equivalent copy initialization of v2 is an error, 
because the vector constructor that takes a single size parameter is explicit. 
For the same reasons that we cannot copy initialize v2, 
we cannot implicitly use an explicit constructor when we pass an argument or return a value from a function. 
If we want to use an explicit constructor, we must do so explicitly, as in the last line of the example above.


-> NOTE: The Compiler Can Bypass the Copy Constructor
During copy initialization, the compiler is permitted (but not obligated) 
to skip the copy/move constructor and create the object directly. 
That is, the compiler is permitted to rewrite
string null_book = "9-999-99999-9"; // copy initialization
into
string null_book("9-999-99999-9"); // compiler omits the copy constructor
However, even if the compiler omits the call to the copy/move constructor, 
the copy/move constructor must exist and must be accessible (e.g., not private) at that point in the program.


-> NOTE: The Copy-Assignment Operator
Just as a class controls how objects of that class are initialized, 
it also controls how objects of its class are assigned:
Sales_data trans, accum;
trans = accum; // uses the Sales_data copy-assignment operator
As with the copy constructor, the compiler synthesizes a copy-assignment operator if the class does not define its own.


-> NOTE: Introducing Overloaded Assignment
Before we look at the synthesized assignment operator, 
we need to know a bit about overloaded operators, which we cover in detail in Chapter 14.
Overloaded operators are functions that have the name operator followed by the symbol for the operator being defined. 
Hence, the assignment operator is a function named operator=. 
Like any other function, an operator function has a return type and a parameter list.


-> NOTE: Assignment operators ordinarily should return a reference to their left hand operand.


-> NOTE: The Synthesized Copy-Assignment Operator
Just as it does for the copy constructor, the compiler generates 
a synthesized copy assignment operator for a class if the class does not define its own. 
Analogously to the copy constructor, for some classes the synthesized copy-assignment operator disallows assignment (§ 13.1.6, p. 508).
Otherwise, it assigns each nonstatic member of the right-hand object 
to the corresponding member of the left-hand object using the copy-assignment operator for the type of that member. 
Array members are assigned by assigning each element of the array. 
The synthesized copy-assignment operator returns a reference to its left-hand object.


-> NOTE: The Destructor
The destructor operates inversely to the constructors: 
Constructors initialize the nonstatic data members of an object and may do other work; 
destructors do whatever work is needed to free the resources used by an object and destroy the nonstatic data members of the object.
The destructor is a member function with the name of the class prefixed by a tilde (~). 
It has no return value and takes no parameters:
class Foo {
public:
~Foo(); // destructor
// . . .
};
Because it takes no parameters, it cannot be overloaded. 
There is always only one destructor for a given class.


-> NOTE: What a Destructor Does
Just as a constructor has an initialization part and a function body (§ 7.5.1, p. 288), 
a destructor has a function body and a destruction part. 
In a constructor, members are initialized before the function body is executed, 
and members are initialized in the same order as they appear in the class. 
In a destructor, the function body is executed first and then the members are destroyed. 
Members are destroyed in reverse order from the order in which they were initialized.


-> In a destructor, there is nothing akin to the constructor initializer list 
to control how members are destroyed; the destruction part is implicit. 
What happens whena member is destroyed depends on the type of the member. 
Members of class type are destroyed by running the member’s own destructor. 
The built-in types do NOT have destructors, so nothing is done to destroy members of built-in type.


-> NOTE: The implicit destruction of a member of built-in pointer type does not delete the object to which that pointer points.


-> NOTE: When a Destructor Is Called
The destructor is used automatically whenever an object of its type is destroyed:
• Variables are destroyed when they go out of scope.
• Members of an object are destroyed when the object ofwhich they are a part is destroyed.
• Elements in a container—whether a library container or an array—are destroyed when the container is destroyed.
• Dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object (§ 12.1.2, p. 460).
• Temporary objects are destroyed at the end of the full expression in which the temporary was created.
Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.


-> NOTE: The destructor is not run when a reference or a pointer to an object goes out of scope.


-> NOTE: The Synthesized Destructor
The compiler defines a synthesized destructor for any class that does not define its own destructor. 
As with the copy constructor and the copy-assignment operator, for some classes, 
the synthesized destructor is defined to disallow objects of the type from being destroyed (§ 13.1.6, p. 508). 
Otherwise, the synthesized destructor has an empty function body.
The members are automatically destroyed after the (empty) destructor body is run.
It is important to realize that the destructor body does not directly destroy the members themselves. 
Members are destroyed as part of the implicit destruction phase that follows the destructor body. 
A destructor body executes in addition to the memberwise destruction that takes place as part of destroying an object.


-> NOTE: The Rule of Three/Five
Aswe’ve seen, there are three basic operations to control copies of class objects: 
the copy constructor, copy-assignment operator, and destructor. 
Moreover, as we’ll see in § 13.6 (p. 531), under the new standard, a class can also define a move constructor and move-assignment operator
There is no requirement that we define all of these operations: 
We can define one or two of them without having to define all of them. 
However, ordinarily these operations should be thought of as a unit. 
In general, it is unusual to need one without needing to define them all.


-> NOTE: Classes That Need Destructors Need Copy and Assignment
One rule of thumb to use when you decide whether a class needs to define its own versions 
of the copy-control members is to decide first whether the class needs a destructor. 
Often, the need for a destructor is more obvious than the need for the copy constructor or assignment operator. 
If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.
ME: This is for classes that has a specialized destructor (so it mean something needs to be done during destruction -> then its mean something needs to be done on assign ment) 


-> NOTE: If a class needs a destructor, it almost surely also needs the copy assignment operator and a copy constructor.


-> NOTE: Classes That Need Copy Need Assignment, and Vice Versa
Although many classes need to define all of (or none of) the copy-control members, 
some classes have work that needs to be done to copy or assign objects but has no need for the destructor.


-> NOTE: If a class needs a copy constructor, it almost surely needs a copy-assignment operator. 
And vice versa if the class needs an assignment operator, it almost surely needs a copy constructor as well. 
Nevertheless, needing either the copy constructor or the copy-assignment operator does not (necessarily) indicate the need for a destructor.


-> NOTE: Using = default
We can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as = default (§ 7.1.4, p. 264):
class Sales_data {
public:
// copy control; use defaults
Sales_data() = default;
Sales_data(const Sales_data&) = default;
Sales_data& operator=(const Sales_data &);
~Sales_data() = default;
// other members as before
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
When we specify = default on the declaration of the member inside the class body, 
the synthesized function is implicitly inline (just as is any other member function defined in the body of the class). 
If we do not want the synthesized member to be an inline function, 
we can specify = default on themember’s definition,
as we do in the definition of the copy-assignment operator.


-> NOTE: We can use = default only on member functions that have a synthesized version (i.e., the default constructor or a copy-control member).


-> NOTE: Preventing Copies
Although most classes should (and generally do) define a copy constructor and a copy-assignment operator, 
for some classes, there really is no sensible meaning for these operations. 
In such cases, the class must be defined so as to prevent copies or assignments from being made. 
For example, the iostream classes prevent copying to avoid letting multiple objects write to or read from the same IO buffer. 
It might seem that we could prevent copies by not defining the copy-control members.
However, this strategy doesn’t work: If our class doesn’t define these operations, the compiler will synthesize them.


-> NOTE: Most classes should define—either implicitly or explicitly—the default and copy constructors and the copy-assignment operator.


-> NOTE: Defining a Function as Deleted
Under the new standard, we can prevent copies by defining the copy constructor and copy-assignment operator as deleted functions. 
A deleted function is one that is declared but may not be used in any other way. 
We indicate that we want to define a function as deleted by following its parameter list with = delete:
struct NoCopy {
NoCopy() = default; // use the synthesized default constructor
NoCopy(const NoCopy&) = delete; // no copy
NoCopy &operator=(const NoCopy&) = delete; // no assignment
~NoCopy() = default; // use the synthesized destructor
// other members
};


-> NOTE: The = delete signals to the compiler (and to readers of our code) that we are intentionally not defining these members.


-> NOTE: Unlike = default, = delete must appear on the first declaration of a deleted function. 
This difference follows logically from the meaning of these declarations. 
A defaulted member affects only what code the compiler generates; 
hence the = default is not needed until the compiler generates code. 
On the other hand, the compiler needs to know that a function is deleted in order to prohibit operations that attempt to use it.


-> NOTE: Also unlike = default, we can specify = delete on any function 
(we can use = default only on the default constructor or a copy-control member that the compiler can synthesize). 
Although the primary use of deleted functions is to suppress the copy-control members, 
deleted functions are sometimes also useful when we want to guide the function-matching process.


-> NOTE: The Destructor Should Not be a Deleted Member
It is worth noting that we did not delete the destructor. 
If the destructor is deleted, then there is no way to destroy objects of that type. 
The compiler will not let us define variables or create temporaries of a type that has a deleted destructor.
Moreover, we cannot define variables or temporaries of a class that has a member whose type has a deleted destructor. 
If a member has a deleted destructor, then that member cannot be destroyed. 
If a member can’t be destroyed, the object as a whole can’t be destroyed.


-> NOTE: Although we cannot define variables or members of such types, we can dynamically allocate objects with a deleted destructor. 
However, we cannot free them:
struct NoDtor {
NoDtor() = default; // use the synthesized default constructor
~NoDtor() = delete; // we can’t destroy objects of type NoDtor
};
NoDtor nd; // error: NoDtor destructor is deleted
NoDtor *p = new NoDtor(); // ok: but we can’t delete p
delete p; // error: NoDtor destructor is deleted


-> NOTE: It is not possible to define an object or delete a pointer to a dynamically allocated object of a type with a deleted destructor.


-> NOTE: The Copy-Control Members May Be Synthesized as Deleted
As we’ve seen, if we do not define the copy-control members, the compiler defines them for us. 
Similarly, if a class defines no constructors, the compiler synthesizes a default constructor for that class (§ 7.1.4, p. 262). 
For some classes, the compiler defines these synthesized members as deleted functions:
• The synthesized destructor is defined as deleted if the class has a member whose own destructor is deleted or is inaccessible (e.g., private).
• The synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. 
It is also deleted if the class has a member with a deleted or inaccessible destructor.
• The synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, 
or if the class has a const or reference member.
• The synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; 
or has a reference member that does not have an in-class initializer (§ 2.6.1, p. 73); 
or has a const member whose type does not explicitly define a default constructor and that member does not have an in-class initializer.


-> NOTE: In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, 
then the corresponding member will be a deleted function.
It may be surprising that a member that has a deleted or inaccessible destructor 
causes the synthesized default and copy constructors to be defined as deleted. 
The reason for this rule is that without it, we could create objects that we could not destroy.


-> NOTE: In essence, the copy-control members are synthesized as deleted when it is impossible to copy, assign, or destroy a member of the class.


-> NOTE: private Copy Control
Prior to the new standard, classes prevented copies by declaring their copy constructor
and copy-assignment operator as private:
class PrivateCopy {
// no access specifier; following members are private by default; see § 7.2 (p. 268)
// copy control is private and so is inaccessible to ordinary user code
PrivateCopy(const PrivateCopy&);
PrivateCopy &operator=(const PrivateCopy&);
// other members
public:
PrivateCopy() = default; // use the synthesized default constructor
~PrivateCopy(); // users can define objects of this type but not copy them
};
Because the destructor is public, users will be able to define PrivateCopy objects.
However, because the copy constructor and copy-assignment operator are private, user code will not be able to copy such objects. 
However, friends and members of the class can still make copies. 
To prevent copies by friends and members, we declare these members as private but do not define them.
With one exception, which we’ll cover in § 15.2.1 (p. 594), it is legal to declare,
but not define, a member function (§ 6.1.2, p. 206). 
An attempt to use an undefined member results in a link-time failure. 
By declaring (but not defining) a private copy constructor, 
we can forestall any attempt to copy an object of the class type:
User code that tries to make a copy will be flagged as an error at compile time;
copies made in member functions or friends will result in an error at link time.


-> NOTE: Classes that want to prevent copying should define their copy constructor 
and copy-assignment operators using = delete rather than making those members private.


-> NOTE: Copy Control and Resource Management
Ordinarily, classes thatmanage resources that do not reside in the class must define the copy-control members. 
As we saw in § 13.1.4 (p. 504), such classes will need destructors to free the resources allocated by the object. 
Once a class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.
In order to define these members, we first have to decide what copying an object of our type will mean. 
In general, we have two choices: 
We can define the copy operations to make the class behave like a value or like a pointer.


-> NOTE: Classes that behave like values have their own state. 
When we copy a valuelike object, the copy and the original are independent of each other. 
Changes made to the copy have no effect on the original, and vice versa.


-> NOTE: Classes that act like pointers share state. 
When we copy objects of such classes, the copy and the original use the same underlying data. 
Changes made to the copy also change the original, and vice versa.


-> NOTE: Classes That Act Like Values
To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. 
That means each HasPtr object must have its own copy of the string to which ps points. 
To implement valuelike behavior HasPtr needs
• A copy constructor that copies the string, not just the pointer
• A destructor to free the string
• A copy-assignment operator to free the object’s existing string and copy
the string from its right-hand operand


-> NOTE: Valuelike Copy-Assignment Operator
Assignment operators typically combine the actions of the destructor and the copy constructor. 
Like the destructor, assignment destroys the left-hand operand’s resources.
Like the copy constructor, assignment copies data from the right-hand operand. 
However, it is crucially important that these actions be done in a sequence that is correct even if an object is assigned to itself. 
Moreover, when possible, we should also write our assignment operators so that 
they will leave the left-hand operand in a sensible state should an exception occur (§ 5.6.2, p. 196).
In this case, we can handle SELF-ASSIGNMENT and make our code safe should an exception happen—by first copying the right-hand side. 
After the copy is made, we’ll free the left-hand side and update the pointer to point to the newly allocated
string:
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
auto newp = new string(*rhs.ps); // copy the underlying string
delete ps; // free the old memory
ps = newp; // copy data from rhs into this object
i = rhs.i;
return *this; // return this object
}
In this assignment operator, we quite clearly first do the work of the constructor:
The initializer of newp is identical to the initializer of ps in HasPtr’s copy constructor.
As in the destructor, we next delete the string to which ps currently points. 
What remains is to copy the pointer to the newly allocated string and the int value from rhs into this object.


-> NOTE: KEY CONCEPT: ASSIGNMENT OPERATORS
There are two points to keep in mind when you write an assignment operator:
• Assignment operators must work correctly if an object is assigned to itself.
• Most assignment operators share work with the destructor and copy constructor.
A good pattern to use when you write an assignment operator is to first copy the righthand operand into a local temporary. 
After the copy is done, it is safe to destroy the existing members of the left-hand operand. 
Once the left-hand operand is destroyed, copy the data from the temporary into the members of the left-hand operand.


-> NOTE: It is crucially important for assignment operators to work correctly, even when an object is assigned to itself. 
A good way to do so is to copy the right-hand operand before destroying the left-hand operand.


-> NOTE: Defining Classes That Act Like Pointers
For our HasPtr class to act like a pointer, we need the copy constructor 
and copy assignment operator to copy the pointer member, not the string to which that pointer points. 
Our class will still need its own destructor to free the memory allocated by the constructor that takes a string (§ 13.1.4, p. 504). 
In this case, though, the destructor cannot unilaterally free its associated string. 
It can do so only when the last HasPtr pointing to that string goes away.
The easiest way to make a class act like a pointer is to use shared_ptrs to manage the resources in the class. 
Copying (or assigning) a shared_ptr copies (assigns) the pointer to which the shared_ptr points. 
The shared_ptr class itself keeps track of how many users are sharing the pointed-to object. 
When there are no more users, the shared_ptr class takes care of freeing the resource.
However, sometimes we want to manage a resource directly. 
In such cases, it can be useful to use a reference count (§ 12.1.1, p. 452). 
To show how reference counting works, we’ll redefine HasPtr to provide pointerlike behavior, but we will do our own reference counting.


-> NOTE: Reference Counts
Reference counting works as follows:
• In addition to initializing the object, each constructor (other than the copy constructor) creates a counter. 
This counter will keep track of how many objects share state with the object we are creating. 
When we create an object, there is only one such object, so we initialize the counter to 1. 
• The copy constructor does not allocate a new counter; 
instead, it copies the data members of its given object, including the counter. 
The copy constructor increments this shared counter, indicating that there is another user of that object’s state.
• The destructor decrements the counter, indicating that there is one less user of the shared state. 
If the count goes to zero, the destructor deletes that state.
• The copy-assignment operator increments the right-hand operand’s counter and decrements the counter of the left-hand operand. 
If the counter for the left-hand operand goes to zero, there are no more users. 
In this case, the copy-assignment operator must destroy the state of the left-hand operand.
The only wrinkle is deciding where to put the reference count. 
The counter cannot be a directmember of a HasPtr object. 
To see why, consider what happens in the following example:
HasPtr p1("Hiya!");
HasPtr p2(p1); // p1 and p2 point to the same string
HasPtr p3(p1); // p1, p2, and p3 all point to the same string
If the reference count is stored in each object, how can we update it correctly when p3 is created? 
We could increment the count in p1 and copy that count into p3, but how wouldwe update the counter in p2?
One way to solve this problem is to store the counter in dynamic memory.
When we create an object, we’ll also allocate a new counter. 
When we copy or assign an object, we’ll copy the pointer to the counter. 
That way the copy and the original will point to the same counter.


-> NOTE: Pointerlike CopyMembers “Fiddle” the Reference Count
When we copy or assign a HasPtr object, we want the copy and the original to point to the same string. 
That is, when we copy a HasPtr, we’ll copy ps itself, not the string to which ps points. 
When we make a copy, we also increment the counter associated with that string.
The copy constructor (which we defined inside the class) copies all three members from its given HasPtr. 
This constructor also increments the use member, indicating that there is another user for the string to which ps and p.ps point.
The destructor cannot unconditionally delete ps—there might be other objects pointing to that memory. 
Instead, the destructor decrements the reference count, indicating that one less object shares the string. 
If the counter goes to zero, then the destructor frees the memory to which both ps and use point:
HasPtr::~HasPtr()
{
if (--*use == 0) { // if the reference count goes to 0
delete ps; // delete the string
delete use; // and the counter
}
}


-> NOTE: Swap function
In addition to defining the copy-control members, classes that manage resources often also define a function named swap (§ 9.2.5, p. 339). 
Defining swap is particularly important for classes that we plan to use with algorithms that reorder elements (§ 10.2.3, p. 383). 
Such algorithms call swap whenever they need to exchange two elements.


-> NOTE: Writing Our Own swap Function
We can override the default behavior of swap by defining a version of swap that operates on our class. 
The typical implementation of swap is:
class HasPtr {
friend void swap(HasPtr&, HasPtr&);
// other members as in § 13.2.1 (p. 511)
};
inline
void swap(HasPtr &lhs, HasPtr &rhs)
{
using std::swap;
swap(lhs.ps, rhs.ps); // swap the pointers, not the string data
swap(lhs.i, rhs.i); // swap the int members
}
We start by declaring swap as a friend to give it access to HasPtr’s (private) data members. 
Because swap exists to optimize our code, we’ve defined swap as an inline function (§ 6.5.2, p. 238). 
The body of swap calls swap on each of the data members of the given object. 
In this case, we first swap the pointers and then the int members of the objects bound to rhs and lhs.


-> NOTE: Unlike the copy-control members, swap is never necessary. 
However, defining swap can be an important optimization for classes that allocate resources.


-> NOTE: swap Functions Should Call swap, Not std::swap
There is one important subtlety in this code: 
Although it doesn’t matter in this particular case, it is essential that swap functions call swap and not std::swap.
In the HasPtr function, the data members have built-in types. 
There is no type specific version of swap for the built-in types. 
In this case, these calls will invoke the library std::swap.
However, if a class has a member that has its own type-specific swap function, calling std::swap would be a mistake. 
For example, assume we had another class named Foo that has a member named h, which has type HasPtr. 
If we did not write a Foo version of swap, then the library version of swap would be used.
As we’ve already seen, the LIBRARY SWAP makes unnecessary copies of the strings managed by HasPtr.
We can avoid these copies by writing a swap function for Foo. 
However, if we wrote the Foo version of swap as:
void swap(Foo &lhs, Foo &rhs)
{
// WRONG: this function uses the library version of swap, not the HasPtr version
std::swap(lhs.h, rhs.h);
// swap other members of type Foo
}
this code would compile and execute. 
However, there would be no performance difference between this code and simply using the default version of swap. 
The problem is that we’ve explicitly requested the library version of swap. 
However, we don’t want the version in std; we want the one defined for HasPtr objects.
The right way to write this swap function is:
void swap(Foo &lhs, Foo &rhs)
{
using std::swap;
swap(lhs.h, rhs.h); // uses the HasPtr version of swap (ME: HOW?)
// swap other members of type Foo
}


-> NOTE: Using swap in Assignment Operators
Classes that define swap often use swap to define their assignment operator. 
These operators use a technique known as copy and swap.
This technique swaps the lefthand
operand with a copy of the right-hand operand:
// note rhs is passed by value, which means the HasPtr copy constructor
// copies the string in the right-hand operand into rhs
HasPtr& HasPtr::operator=(HasPtr rhs)
{
// swap the contents of the left-hand operand with the local variable rhs
swap(*this, rhs); // rhs now points to the memory this object had used
return *this; // rhs is destroyed, which deletes the pointer in rhs
}

In this version of the assignment operator, the parameter is not a reference. 
Instead, we pass the right-hand operand by value. 
Thus, rhs is a copy of the right-hand operand. 
Copying a HasPtr allocates a new copy of that object’s string.
In the body of the assignment operator, we call swap, which swaps the data members of rhs with those in *this. 
This call puts the pointer that had been in the left-hand operand into rhs, and puts the pointer that was in rhs into *this.
Thus, after the swap, the pointer member in *this points to the newly allocated string that is a copy of the right-hand operand.
When the assignment operator finishes, rhs is destroyed and the HasPtr destructor is run. 
That destructor deletes the memory to which rhs now points,
thus freeing the memory to which the left-hand operand had pointed.
The interesting thing about this technique is that it automatically handles self assignment and is automatically exception safe. 
By copying the right-hand operand before changing the left-hand operand, 
it handles self assignment in the same was as we did in our original assignment operator (§ 13.2.1, p. 512). 
It manages exception safety in the same way as the original definition as well. 
The only code that might throw is the new expression inside the copy constructor. 
If an exception occurs, it will happen before we have changed the left-hand operand.


-> NOTE: Assignment operators that use copy and swap are automatically exception safe and correctly handle self-assignment.


-> NOTE: The copy-assignment operator often does the same work as is needed in the copy constructor and destructor. 
In such cases, the common work should be put in private utility functions.


-> NOTE: Classes That Manage Dynamic Memory
Some classes need to allocate a varying amount of storage at run time. 
Such classes often can (and if they can, generally should) use a library container to hold their data. 
For example, our StrBlob class uses a vector to manage the underlying storage for its elements.
However, this strategy does not work for every class; some classes need to do their own allocation. 
Such classes generally must define their own copy-control members to manage the memory they allocate.


-> NOTE: Check C++ Primer to see an example of StringVector class that uses allocators and Uninitialized Memory


-> NOTE: Moving Objects
One of the major features in the new standard is the ability to move rather than copy an object. 
In some of these circumstances, an object is immediately destroyed after it is copied. 
In those cases, moving, rather than copying, the object can provide a significant performance boost.
As we’ve just seen, our StrVec class is a good example of this kind of superfluous copy. 
During reallocation, there is no need to copy—rather than move—the elements from the old memory to the new. 
A second reason to move rather than copy occurs in classes such as the IO or unique_ptr classes. 
These classes have a resource (such as a pointer or an IO buffer) that may not be shared. 
Hence, objects of these types can’t be copied but can be moved.
Under earlier versions of the language, there was no direct way to move an object. 
We had to make a copy even if there was no need for the copy. 
If the objects are large, or if the objects themselves require memory allocation (e.g., strings), making a needless copy can be expensive. 
Similarly, in previous versions of the library, classes stored in a container had to be copyable. 
Under the new standard, we can use containers on types that cannot be copied so long as they can be moved.
The library containers, string, and shared_ptr classes support move as well as copy. 
The IO and unique_ptr classes can be moved but not copied.


-> NOTE: Rvalue References
To support move operations, the newstandard introduced a newkind of reference, an rvalue reference. 
An rvalue reference is a reference that must be bound to an rvalue. 
An rvalue reference is obtained by using && rather than &. 
As we’ll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. 
As a result, we are free to “move” resources from an rvalue reference to another object.
Recall that lvalue and rvalue are properties of an expression (§ 4.1.1, p. 135).
Some expressions yield or require lvalues; others yield or require rvalues. 
Generally speaking, an lvalue expression refers to an object’s identity whereas an rvalue expression refers to an object’s value.


-> NOTE:  Functions that return lvalue references, along with the assignment, subscript, dereference, 
and prefix increment/decrement operators, are all examples of expressions that return lvalues. 
We can bind an lvalue reference to the result of any of these expressions.


-> NOTE: Functions that return a nonreference type, along with the arithmetic, 
relational, bitwise, and postfix increment/decrement operators, all yield rvalues. 
We cannot bind an lvalue reference to these expressions, 
but we can bind either an lvalue reference to const or an rvalue reference to such expressions.


-> NOTE: Lvalues Persist; Rvalues Are Ephemeral
Looking at the list of lvalue and rvalue expressions, 
it should be clear that lvalues and rvalues differ from each other in an important manner: 
Lvalues have persistent state, whereas rvalues are either literals 
or temporary objects created in the course of evaluating expressions.
Because rvalue references can only be bound to temporaries, we know that
• The referred-to object is about to be destroyed
• There can be no other users of that object
These facts together mean that code that uses an rvalue reference 
is free to take over resources from the object to which the reference refers.


-> NOTE: Rvalue references refer to objects that are about to be destroyed. 
Hence, we can “steal” state from an object bound to an rvalue reference.


-> NOTE: Variables Are Lvalues
Although we rarely think about it this way, a variable is an expression with one operand and no operator. 
Like any other expression, a variable expression has the lvalue/rvalue property. 
Variable expressions are lvalues. It may be surprising, but as a consequence, 
we cannot bind an rvalue reference to a variable defined as an rvalue reference type:
int &&rr1 = 42; // ok: literals are rvalues
int &&rr2 = rr1; // error: the expression rr1 is an lvalue!
Given our previous observation that rvalues represent ephemeral objects, it should not be surprising that a variable is an lvalue. 
After all, a variable persists until it goes out of scope.


-> NOTE: A variable is an lvalue; we cannot directly bind an rvalue reference to a variable even if that variable was defined as an rvalue reference type.


-> NOTE: The Library move Function
Although we cannot directly bind an rvalue reference to an lvalue, 
we can explicitly cast an lvalue to its corresponding rvalue reference type. 
We can also obtain an rvalue reference bound to an lvalue by calling a new library function named move, which is defined in the utility header. 
The move function uses facilities that we’ll describe in § 16.2.6 (p. 690) to return an rvalue reference to its given object.
int &&rr3 = std::move(rr1); // ok
Calling move tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. 
It is essential to realize that the call to move promises that we do not intend to use rr1 again except to assign to it or to destroy it. 
After a call to move, we cannot make any assumptions about the value of the moved-from object.


-> NOTE: We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.


-> NOTE: As we’ve seen, differently from how we use most names from the library, 
we do not provide a using declaration (§ 3.1, p. 82) for move (§ 13.5, p. 530). 
We call std::move not move. 
We’ll explain the reasons for this usage in § 18.2.3 (p. 798).


-> NOTE: Code that uses move should use std::move, not move. Doing so avoids potential name collisions.


-> NOTE: Move Constructor and Move Assignment
Like the string class (and other library classes), our own classes can benefit from being able to be moved as well as copied. 
To enable move operations for our own types, we define a move constructor and amove-assignment operator. 
These members are similar to the corresponding copy operations, but they “steal” resources from their given object rather than copy them.
Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. 
Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. 
As in the copy constructor, any additional parameters must all have default arguments.
In addition to moving resources, the move constructor must ensure 
that the moved-from object is left in a state such that destroying that object will be harmless.
In particular, once its resources are moved, the original object must no longer point to those 
moved resources—responsibility for those resources has been assumed by the newly created object.


-> NOTE: Unlike the copy constructor, the move constructor does not allocate any new memory


-> NOTE: Move Operations, Library Containers, and Exceptions
Because a move operation executes by “stealing” resources, it ordinarily does not itself allocate any resources. 
As a result, move operations ordinarily will not throw any exceptions. 
When we write a move operation that cannot throw, we should inform the library of that fact. 
As we’ll see, unless the library knows that our move constructor won’t throw, 
it will do extra work to cater to the possibliity that moving an object of our class type might throw.


-> NOTE: One way inform the library is to specify noexcept on our constructor. 
We’ll cover noexcept, which was introduced by the new standard, in more detail in § 18.1.4 (p. 779). 
For now what’s important to know is that noexcept is a way for us to promise that a function does not throw any exceptions.


-> NOTE: Move constructors and move assignment operators that cannot throw exceptions should be marked as noexcept.


-> NOTE: What is the need for noexcept?
Understanding why noexcept is needed can help deepen our understanding of how the library interacts with objects of the types we write. 
We need to indicate that a move operation doesn’t throw because of two interrelated facts: 
First, although move operations usually don’t throw exceptions, they are permitted to do so. 
Second, the library containers provide guarantees as to what they do if an exception happens. 
As one example, vector guarantees that if an exception happens when we call push_back, the vector itself will be left unchanged.

As we’ve just seen moving an object generally changes the value of the moved from object. 
If reallocation uses a move constructor and that constructor throws an exception after moving some but not all of the elements, there would be a problem.
The moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. 
In this case, vector would be unable to meet its requirement that the vector is left unchanged.

On the other hand, if vector uses the copy constructor and an exception happens, it can easily meet this requirement. 
In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. 
If an exception happens, vector can free the space it allocated (but could not successfully construct) and return. 
The original vector elements still exist.

To avoid this potential problem, vector must use a copy constructor instead of a move constructor 
during reallocation unless it knows that the element type’s move constructor cannot throw an exception. 
If we want objects of our type to be moved rather than copied in circumstances such as vector reallocation, 
we must explicity tell the library that our move constructor is safe to use. 
We do so by marking the move constructor (and move-assignment operator) noexcept.


-> NOTE: Move-Assignment Operator
The move-assignment operator does the same work as the destructor and the move constructor. 
As with the move constructor, if our move-assignment operator won’t throw any exceptions, we should make it noexcept. 
Like a copy-assignment operator, a move-assignment operator must guard against self-assignment.
In this case we check directly whether the this pointer and the address of rhs are the same. 
If they are, the right- and left-hand operands refer to the same object and there is no work to do. 
Otherwise, we free the memory that the left-hand operand had used, and then take over the memory from the given object. 
As in the move constructor, we set the pointers in rhs to nullptr.
It may seem surprising that we bother to check for self-assignment. 
After all, move assignment requires an rvalue for the right-hand operand. 
We do the check because that rvalue could be the result of calling move. 
As in any other assignment operator, it is crucial that we not free the left-hand resources 
before using those (possibly same) resources from the right-hand operand.


-> NOTE: A Moved-from Object Must Be Destructible
Moving from an object does not destroy that object: 
Sometime after the move operation completes, the moved-from object will be destroyed. 
Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in which the destructor can be run. 
Our StrVec move operations meet this requirement by setting the pointer members of the moved-from object to nullptr.
In addition to leaving the moved-from object in a state that is safe to destroy,
move operations must guarantee that the object remains valid. 
In general, a valid object is one that can safely be given a new value or used in other ways that do not depend on its current value. 
On the other hand, move operations have no requirements as to the value that remains in the moved-from object. 
As a result, our programs should never depend on the value of a moved-from object.

-> NOTE: After a move operation, the “moved-from” object must remain a valid, destructible object but users may make no assumptions about its value.


-> NOTE: The Synthesized Move Operations
As it does for the copy constructor and copy-assignment operator, 
the compiler will synthesize the move constructor and move-assignment operator. 
However, the conditions under which it synthesizes a move operation 
are quite different from those in which it synthesizes a copy operation.
Recall that if we do not declare our own copy constructor or copy-assignment operator 
the compiler always synthesizes these operations (§ 13.1.1, p. 497 and § 13.1.2, p. 500). 
The copy operations are defined either to memberwise copy or assign the object or they are defined as deleted functions.

Differently from the copy operations, for some classes the compiler does not synthesize the move operations at all. 
In particular, if a class defines its own copy constructor, copy-assignment operator, or destructor, the move constructor and move-assignment operator are not synthesized. 
As a result, some classes do not have a move constructor or a move-assignment operator. 
As we’ll see on page 540, when a class doesn’t have a move operation, 
the corresponding copy operation is used in place of move through normal function matching.

The compiler will synthesize a move constructor or a move-assignment operator 
only if the class doesn’t define any of its own copy-control members 
and if every nonstatic data member of the class can bemoved. 
The compiler can move members of built-in type. 
It can alsomovemembers of a class type if themember’s class has the corresponding move operation


-> NOTE: The compiler synthesizes the move constructor and move assignment only if a class 
does not define any of its own copy-control members 
and only if all the data members can be moved constructed and move assigned, respectively.


-> NOTE: Unlike the copy operations, a move operation is never implicitly defined as a deleted function. 
However, if we explicitly ask the compiler to generate a move operation by using = default (§ 7.1.4, p. 264), 
and the compiler is unable to move all the members, then the move operation will be defined as deleted. 
With one important exception, the rules for when a synthesized move operation is defined as deleted 
are analogous to those for the copy operations (§ 13.1.6, p. 508):
• Unlike the copy constructor, the move constructor is defined as deleted 
if the class has a member that defines its own copy constructor but does not also define a move constructor, 
or if the class has a member that doesn’t define its own copy operations 
and for which the compiler is unable to synthesize a move constructor. 
Similarly for move-assignment.
• The move constructor or move-assignment operator is defined as deleted if the class has a member 
whose own move constructor or move-assignment operator is deleted or inaccessible.
• Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.
• Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a const or reference member.


-> NOTE: Classes that define a move constructor or move-assignment operator must also define their own copy operations. 
Otherwise, those members are deleted by default.


-> NOTE: Rvalues Are Moved, Lvalues Are Copied ...
When a class has both a move constructor and a copy constructor, 
the compiler uses ordinary function matching to determine which constructor to use (§ 6.4, p. 233). 
Similarly for assignment.


-> NOTE: ... But Rvalues Are Copied If There Is No Move Constructor
What if a class has a copy constructor but does not define a move constructor?
In this case, the compiler will not synthesize the move constructor, which means the class has a copy constructor but no move constructor. 
If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling move.


-> NOTE: If a class has a usable copy constructor and no move constructor, objects will be “moved” by the copy constructor. 
Similarly for the copy assignment operator and move-assignment.


-> NOTE: Copy-and-Swap Assignment Operators and Move
The version of our HasPtr class that defined a copy-and-swap assignment operator (§ 13.3, p. 518) 
is a good illustration of the interaction between function matching and move operations. 
If we add a move constructor to this class, it will effectively get a move assignment operator as well.
class HasPtr {
public:
// added move constructor
HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
// assignment operator is both the move- and copy-assignment operator (ME: I've seen this example.)
HasPtr& operator=(HasPtr rhs)
{ swap(*this, rhs); return *this; }
// other members as in § 13.2.1 (p. 511)
};
In this version of the class, we’ve added a move constructor that takes over the values from its given argument. 
The constructor body sets the pointer member of the given HasPtr to zero to ensure that it is safe to destroy the moved-from object.
Nothing this function does can throw an exception so we mark it as noexcept (§ 13.6.2, p. 535).


-> NOTE: ADVICE: UPDATING THE RULE OF THREE
All five copy-control members should be thought of as a unit: 
Ordinarily, if a class defines any of these operations, it usually should define themall. 
Aswe’ve seen, some classes must define the copy constructor, copy-assignment operator, and destructor to work correctly (§ 13.1.4, p. 504). 
Such classes typically have a resource that the copy members must copy. 
Ordinarily, copying a resource entails some amount of overhead.
Classes that define the move constructor andmove-assignment operator can avoid this overhead in those circumstances where a copy isn’t necessary.


-> NOTE: ADVICE: DON’T BE TOO QUICK TO MOVE
Because amoved-from object has indeterminate state, calling std::move on an object is a dangerous operation. 
When we call move, wemust be absolutely certain that there can be no other users of the moved-from object.
Judiciously used inside class code, move can offer significant performance benefits.
Casually used in ordinary user code (as opposed to class implementation code),
moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.
Outside of class implementation code such as move constructors or move assignment operators, 
use std::move only when you are certain that you need to do a move and that the move is guaranteed to be safe.


-> NOTE: Rvalue References and Member Functions
Member functions other than constructors and assignment can benefit from providing both copy and move versions. 
Such move-enabled members typically use the same parameter pattern as the copy/move constructor 
and the assignment operators—one version takes an lvalue reference to const, 
and the second takes an rvalue reference to nonconst.
For example, the library containers that define push_back provide two versions:
one that has an rvalue reference parameter and the other a const lvalue reference. 
Assuming X is the element type, these containers define:
void push_back(const X&); // copy: binds to any kind of X
void push_back(X&&); // move: binds only to modifiable rvalues of type X
We can pass any object that can be converted to type X to the first version of push_back. 
This version copies data from its parameter. 
We can pass only an rvalue that is not const to the second version. 
This version is an exactmatch (and a better match) for nonconst rvalues 
and will be run when we pass a modifiable rvalue (§ 13.6.2, p. 539). 
This version is free to steal resources from its parameter.


-> NOTE: Ordinarily, there is no need to define versions of the operation that take a const X&& or a (plain) X&. 
Usually, we pass an rvalue reference when we want to “steal” from the argument. 
In order to do so, the argument must not be const.
Similarly, copying from an object should not change the object being copied. 
As a result, there is usually no need to define a version that take a (plain) X& parameter.


-> NOTE: Overloaded functions that distinguish between moving and copying a parameter 
typically have one version that takes a const T& and one that takes a T&&.


-> NOTE: ME: Reference functions are C++11 feature.


-> NOTE: Rvalue and Lvalue Reference Member Functions (ME: WTF? This is the first time i've heard of this!)
Ordinarily, we can call a member function on an object, regardless of whether that object is an lvalue or an rvalue. 
For example:
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find(’a’);
Here, we called the find member (§ 9.5.3, p. 364) on the string rvalue that results from adding two strings. 
Sometimes such usage can be surprising:
s1 + s2 = "wow!";
Here we assign to the rvalue result of concatentating these strings.
Prior to the new standard, there was no way to prevent such usage. 
In order to maintain backward compatability, the library classes continue to allow assignment to rvalues.
However, we might want to prevent such usage in our own classes. 
In this case, we’d like to force the left-hand operand (i.e., the object to which this points) to be an lvalue.
We indicate the lvalue/rvalue property of this in the sameway that we define const member functions (§ 7.1.2, p. 258); w
e place a reference qualifier after the parameter list:
class Foo {
public:
Foo &operator=(const Foo&) &; // may assign only to modifiable lvalues
// other members of Foo
};
Foo &Foo::operator=(const Foo &rhs) &
{
// do whatever is needed to assign rhs to this object
return *this;
}
The reference qualifier can be either & or &&, indicating that this may point to an rvalue or lvalue, respectively. 
Like the const qualifier, a reference qualifier may appear only on a (nonstatic) member function 
and must appear in both the declaration and definition of the function.
We may run a function qualified by & only on an lvalue andmay run a function qualified by && only on an rvalue.
Foo &retFoo(); // returns a reference; a call to retFoo is an lvalue
Foo retVal(); // returns by value; a call to retVal is an rvalue
Foo i, j; // i and j are lvalues
i = j; // ok: i is an lvalue
retFoo() = j; // ok: retFoo() returns an lvalue
retVal() = j; // error: retVal() returns an rvalue
i = retVal(); // ok: we can pass an rvalue as the right-hand operand to assignment
A function can be both const and reference qualified. 
In such cases, the reference qualifier must follow the const qualifier:
class Foo {
public:
Foo someMem() & const; // error: const qualifier must come first
Foo anotherMem() const &; // ok: const qualifier comes first
};


-> NOTE: Overloading and Reference Functions
Just as we can overload a member function based on whether it is const (§ 7.3.2, p. 276), 
we can also overload a function based on its reference qualifier. 
Moreover, we may overload a function by its reference qualifier and by whether it is a const member. 
As an example, we’ll give Foo a vector member and a function named sorted 
that returns a copy of the Foo object in which the vector is sorted:
class Foo {
public:
Foo sorted() &&; // may run on modifiable rvalues
Foo sorted() const &; // may run on any kind of Foo
// other members of Foo
private:
vector<int> data;
};
// this object is an rvalue, so we can sort in place
Foo Foo::sorted() &&
{
sort(data.begin(), data.end());
return *this;
}
// this object is either const or it is an lvalue; either way we can’t sort in place
Foo Foo::sorted() const & {
Foo ret(*this); // make a copy
sort(ret.data.begin(), ret.data.end()); // sort the copy
return ret; // return the copy
}
When we run sorted on an rvalue, it is safe to sort the data member directly.
The object is an rvalue, which means it has no other users, so we can change the object itself. 
When we run sorted on a const rvalue or on an lvalue, we can’t change this object, so we copy data before sorting it.
Overload resolution uses the lvalue/rvalue property of the object 
that calls sorted to determine which version is used:
retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &&
retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &
When we define const memeber functions, we can define two versions that differ only in that one is const qualified and the other is not. 
There is no similar default for reference qualified functions. 
When we define two or more members that have the same name and the same parameter list, 
we must provide a reference qualifier on all or none of those functions:
class Foo {
public:
Foo sorted() &&;
Foo sorted() const; // error: must have reference qualifier
// Comp is type alias for the function type (see § 6.7 (p. 249))
// that can be used to compare int values
using Comp = bool(const int&, const int&);
Foo sorted(Comp*); // ok: different parameter list
Foo sorted(Comp*) const; // ok: neither version is reference qualified
};
Here the declaration of the const version of sorted that has no parameters is an error. 
There is a second version of sorted that has no parameters and that function has a reference qualifier, 
so the const version of that function must have a reference qualifier as well. 
On the other hand, the versions of sorted that take a pointer to a comparison operation are fine, because neither function has a qualifier.


-> NOTE: If a member function has a reference qualifier, all the versions of that member with the same parameter list must have reference qualifiers.





