

This notes are taken from C++ Primer



-> Notes on minimum sizes: 
The type "int" has minimum size of 16.
The difference between "long long" and "long long long" is the guarantee of the minimum size.
The floating types have a minimum number of significant digits.
-------------------------------------------------------------------
Table 2.1: C++: Arithmetic Types (taken from C++ Primer)
-------------------------------------------------------------------
Type           | Meaning                           | Minimum Size
-------------------------------------------------------------------
bool           | boolean                           | NA
char           | character                         | 8 bits
wchar_t        | wide character                    | 16 bits
char16_t       | Unicode character                 | 16 bits
char32_t       | Unicode character                 | 32 bits
short          | short integer                     | 16 bits
int            | integer                           | 16 bits
long long      | integer                           | 32 bits
long long long | integer                           | 64 bits
float          | single-precision floating-point   | 6 significant digits
double         | double-precision floating-point   | floating-point 10 significant digits
long double    | extended-precision floating-point | floating-point 10 significant digits
-------------------------------------------------------------------



-> NOTE: ADVICE: DECIDING WHICH TYPE TO USE (taken from C++ Primer)
C++, like C, is designed to let programs get close to the hardware when necessary.
The arithmetic types are defined to cater to the peculiarities of various kinds of hardware.
Accordingly, the number of arithmetic types in C++ can be bewildering. 
Most programmers can (and should) ignore these complexities by restricting the types they use. 
A few rules of thumb can be useful in deciding which type to use:
• Use an unsigned type when you know that the values cannot be negative.
• Use int for integer arithmetic. short is usually too small and, in practice, long often has the same size as int. 
If your data values are larger than the minimum guaranteed size of an int, then use long long.
• Do not use plain char or bool in arithmetic expressions.
Use them only to hold characters or truth values. 
Computations using char are especially problematic because char is signed on some machines and unsigned on others. 
If you need a tiny integer, explicitly specify either signed char or unsigned char.
• Use double for floating-point computations; float usually does not have enough precision, 
and the cost of double-precision calculations versus single precision is negligible. 
In fact, on some machines, double-precision operations are faster than single. 
The precision offered by long double usually is unnecessary and often entails considerable run-time cost.



-> Note on Type Conversions:
Type Conversions
The type of an object defines the data that an object might contain and what operations that object can perform. 
Among the operations that many types support is the ability to convert objects of the given type to other, related types.
Type conversions happen automatically when we use an object of one type where an object of another type is expected. 
We’ll have more to say about conversions in § 4.11 (p. 159), but for now it is useful to understand what happens when we assign a value of one type to an object of another type.
When we assign one arithmetic type to another:
bool b = 42; // b is true
int i = b; // i has value 1
i = 3.14; // i has value 3
double pi = i; // pi has value 3.0
unsigned char c = -1; // assuming 8-bit chars, c has value 255
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined
what happens depends on the range of the values that the types permit:
• When we assign one of the nonbool arithmetic types to a bool object, the result is false if the value is 0 and true otherwise.
• When we assign a bool to one of the other arithmetic types, the resulting value is 1 if the bool is true and 0 if the bool is false.
• When we assign a floating-point value to an object of integral type, the value is truncated. 
The value that is stored is the part before the decimal point.
• When we assign an integral value to an object of floating-point type, the fractional part is zero. 
Precision may be lost if the integer has more bits than the floating-point object can accommodate.
• If we assign an out-of-range value to an object of unsigned type, 
the result is the remainder of the value modulo the number of values the target type can hold. 
For example, an 8-bit unsigned char can hold values from 0 through 255, inclusive. 
If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. 
Therefore, assigning –1 to an 8-bit unsigned char gives that object the value 255.
• If we assign an out-of-range value to an object of signed type, the result is undefined. 
The program might appear to work, it might crash, or it might produce garbage values.



-> NOTE: CAUTION: DON’T MIX SIGNED AND UNSIGNED TYPES
Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. 
It is essential to remember that signed values are automatically converted to unsigned. 
For example, in an expression like a * b, if a is -1 and b is 1, then if both a and b are ints, the value is, as expected -1. 
However, if a is int and b is an unsigned, then the value of this expression depends on how many bits an int has on the particular machine.
On our machine, this expression yields 4294967295.



-> Escape sequences:
Some characters, such as backspace or control characters, have no visible image.
Such characters are nonprintable. 
Other characters (single and double quotation marks, question mark, and backslash) have special meaning in the language. 
Our programs cannot use any of these characters directly. 
Instead, we use an escape sequence to represent such characters. 
An escape sequence begins with a backslash.
The language defines several escape sequences:
newline \n 
horizontal tab \t 
alert (bell) \a
vertical tab \v 
backspace \b 
double quote \"
backslash \\ 
question mark \? 
single quote \’
carriage return \r 
formfeed \f
We use an escape sequence as if it were a single character:
std::cout << ’\n’; // prints a newline
std::cout << "\tHi!\n"; // prints a tab followd by "Hi!" and a newline
We can also write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits. 
The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):
\7 (bell) 
\12 (newline) 
\40(blank)
\0 (null) 
\115 (’M’) 
\x4d (’M’)



-> Specifying the Type of a Literal
We can override the default type of an integer, floating- point, or character literal by supplying a suffix or prefix as listed in Table 2.2.

-------------------------------------------------------------------
Character and Character String Literals
-------------------------------------------------------------------
Prefix | Meaning | Type
-------------------------------------------------------------------
u      | Unicode 16 character         | char16_t
U      | Unicode 32 character         | char32_t
L      | wide character               | wchar_t
u8     | utf-8 (string literals only) | char
-------------------------------------------------------------------
Integer Literals
-------------------------------------------------------------------
Suffix   | Minimum Type 
-------------------------------------------------------------------
u or U   | unsigned 
l or L   | long 
ll or LL | long long
-------------------------------------------------------------------
Floating-Point Literals
-------------------------------------------------------------------
Suffix   | Type 
-------------------------------------------------------------------
f or F   | float
l or L   | long double

Examples:
L’a’ // wide character literal, type is wchar_t
u8"hi!" // utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
42ULL // unsigned integer literal, type is unsigned long long
1E-3F // single-precision floating-point literal, type is float
3.14159L // extended-precision floating-point literal, type is long double



-> NOTE: When you write a long literal, use the uppercase L; the lowercase letter l is too easily mistaken for the digit 1.



-> NOTE: Initializers
An object that is initialized gets the specified value at the moment it is created.
The values used to initialize a variable can be arbitrarily complicated expressions.
When a definition defines two or more variables, the name of each object becomes visible immediately. 
Thus, it is possible to initialize a variable to the value of one defined earlier in the same definition.
double price = 109.99, discount = price * 0.16; // ok: price is defined and initialized before it is used to initialize discount
double salePrice = applyDiscount(price, discount); // ok: call applyDiscount and use the return value to initialize salePrice

Initialization in C++ is a surprisingly complicated topic and one we will return to again and again. 
Many programmers are confused by the use of the = symbol to initialize a variable. 
It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. 
This concept is particularly confusing because in many languages the distinction is irrelevant and can be ignored. 
Moreover, even in C++ the distinction often doesn’t matter.
Nonetheless, it is a crucial concept and one we will reiterate throughout the text.



-> NOTE: Initialization is not assignment.
Initialization happens when a variable is given a value when it is created. 
Assignment obliterates an object’s current value and replaces that value with a new one.



-> NOTE: List Initialization
One way in which initialization is a complicated topic is that the language defines several different forms of initialization. 
For example, we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);

When used with variables of built-in type, this form of initialization has one important property: 
The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld; // ok: but value will be truncated



-> NOTE: Default Initialization
When we define a variable without an initializer, the variable is default initialized.
Such variables are given the “default” value. 
What that default value is depends on the type of the variable and may also depend on where the variable is defined.
The value of an object of built-in type that is not explicitly initialized depends on where it is defined.
Variables defined outside any function body are initialized to zero. 
With one exception, which we cover in § 6.1.1 (p. 205), variables of built-in type defined inside a function are uninitialized. 
The value of an uninitialized variable of built-in type is undefined (§ 2.1.2, p. 36). 
It is an error to copy or otherwise try to access the value of a variable whose value is undefined.



-> NOTE: Most classes let us define objects without explicit initializers. 
Such classes supply an appropriate default value for us. 
For example, aswe’ve just seen, the library string class says that if we do not supply an initializer, 
then the resulting string is the empty string:
std::string empty; // empty implicitly initialized to the empty string
Sales_item item; // default-initialized Sales_item object



-> NOTE: Uninitialized objects of built-in type defined inside a function body have undefined value. 
Objects of class type that we do not explicitly initialize have a value that is defined by the class.



-> Direct and Copy Forms of Initialization
In § 2.2.1 (p. 43) we saw that C++ has several different forms of initialization. 
Using strings, we can start to understand how these forms differ from one another.
When we initialize a variable using =,
we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. 
Otherwise, when we omit the =, we use direct initialization.
When we have a single initializer, we can use either the direct or copy form of initialization. 
When we initialize a variable from more than one value, such as in the initialization of s4 above, 
we must use the direct form of initialization:
string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, ’c’); // direct initialization; s7 is cccccccccc
When we want to use several values, 
we can indirectly use the copy form of initialization by explicitly creating a (temporary) object to copy:
string s8 = string(10, ’c’); // copy initialization; s8 is cccccccccc
The initializer of s8—string(10, ’c’) — creates a string of the given size and character value and then copies that value into s8. 
It is as if we had written:
string temp(10, ’c’); // temp is cccccccccc
string s8 = temp; // copy temp into s8
Although the code used to initialize s8 is legal, it is less readable and offers no compensating advantage over the way we initialized s7.



-> NOTE: Value Initialization
We can usually omit the value and supply only a size. 
In this case the library creates a value-initialized element initializer for us. 
This library-generated value is used to initialize each element in the container. 
The value of the element initializer depends on the type of the elements stored in the vector.
If the vector holds elements of a BUILT-IN TYPE, such as int, then the element initializer has a value of 0. 
If the elements are of a CLASS TYPE, such as string, then the element initializer is itself default initialized:
vector<int> ivec(10); // ten elements, each initialized to 0
vector<string> svec(10); // ten elements, each an empty string
There are two restrictions on this form of initialization: 
The first restriction is that some classes require that we always supply an explicit initializer (§ 2.2.1, p. 44). 
If our vector holds objects of a type that we cannot default initialize, 
then we must supply an initial element value; it is not possible to create vectors of such types by supplying only a size.
The second restriction is that when we supply an element count without also supplying an initial value, 
we must use the direct form of initialization



-> NOTE: CAUTION: UNINITIALIZED VARIABLES CAUSE RUN-TIME PROBLEMS
An uninitialized variable has an indeterminate value. 
Trying to use the value of an uninitialized variable is an error that is often hard to debug. 
Moreover, the compiler is not required to detect such errors, although most will warn about at least some uses of uninitialized variables.
What happens when we use an uninitialized variable is undefined. 
Sometimes, we’re lucky and our program crashes as soon as we access the object. 
Once we track down the location of the crash, it is usually easy to see that the variable was not properly initialized. 
Other times, the program completes but produces erroneous results.
Even worse, the results may appear correct on one run of our program but fail on a subsequent run. 
Moreover, adding code to the program in an unrelated location can cause what we thought was a correct program to start producing incorrect results.



-> NOTE: We recommend initializing every object of built-in type. 
It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.



-> NOTE: Variables must be defined exactly once but can be declared many times.



-> NOTE: KEY CONCEPT: STATIC TYPING
C++ is a statically typed language, which means that types are checked at compile time. 
The process by which types are checked is referred to as type checking.
As we’ve seen, the type of an object constrains the operations that the object can perform. 
In C++, the compiler checks whether the operations we write are supported by the types we use. 
If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.
As our programs get more complicated, we’ll see that static type checking can help find bugs. 
However, a consequence of static checking is that the type of every entity we use must be known to the compiler. 
As one example, we must declare the type of a variable before we can use that variable.



-> NOTE: ADVICE: DEFINE VARIABLES WHERE YOU FIRST USE THEM
It is usually a good idea to define an object near the point at which the object is first used. 
Doing so improves readability by making it easy to find the definition of the variable. 
More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used



-> NOTE: It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.



-> NOTE: References
A reference defines an alternative name for an object. 
A reference type “refers to” another type. 
We define a reference type by writing a declarator of the form &d, where d is the name being declared:
int ival = 1024;
int &refVal = ival; // refVal refers to (is another name for) ival
int &refVal2; // error: a reference must be initialized



-> NOTE: The new standard introduced a new kind of reference: an “rvalue reference,” which we’ll cover in § 13.6.1 (p. 532). 
These references are primarily intended for use inside classes. 
Technically speaking, when we use the term reference, we mean “lvalue reference.”



-> NOTE: A Reference Is an Alias
A reference is not an object. Instead, a reference is just another name for an already existing object.



-> NOTE: Reference Definitions
We can define multiple references in a single definition. 
Each identifier that is a reference must be preceded by the & symbol:
int i = 1024, i2 = 2048; // i and i2 are both ints
int &r = i, r2 = i2; // r is a reference bound to i; r2 is an int
int i3 = 1024, &ri = i3; // i3 is an int; ri is a reference bound to i3
int &r3 = i3, &r4 = i2; // both r3 and r4 are references


-> NOTE: ME: A reference should always be initialized (thus it cannot be untilitialized). 


-> NOTE: ME: A reference cannot be initialized with a constant value (except when its a const reference).



-> NOTE: Pointers
A pointer is a compound type that “points to” another type. 
Like references, pointers are used for indirect access to other objects. 
Unlike a reference, a pointer is an object in its own right. 
Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. 
Unlike a reference, a pointer need not be initialized at the time it is defined. 
Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.



-> NOTE: Pointers are often hard to understand. 
Debugging problems due to pointer errors bedevil even experienced programmers.



-> NOTE: Taking the Address of an Object
A pointer holds the address of another object. 
We get the address of an object by using the address-of operator (the & operator):
int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
With two exceptions, which we cover in § 2.4.2 (p. 62) and § 15.2.3 (p. 601), 
the types of the pointer and the object to which it points must match:
double dval;
double *pd = &dval; // ok: initializer is the address of a double
double *pd2 = pd; // ok: initializer is a pointer to double
int *pi = pd; // error: types of pi and pd differ
pi = &dval; // error: assigning the address of a double to a pointer to int



-> NOTE: Pointer Value
The value (i.e., the address) stored in a pointer can be in one of four states:
1. It can point to an object.
2. It can point to the location just immediately past the end of an object.
3. It can be a null pointer, indicating that it is not bound to any object.
4. It can be invalid; values other than the preceding three are invalid.



-> NOTE: Using a Pointer to Access an Object
When a pointer points to an object, we can use the dereference operator (the * operator) to access that object:
int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
cout << *p; // * yields the object to which p points; prints 42
Dereferencing a pointer yields the object to which the pointer points. 
We can assign to that object by assigning to the result of the dereference:
*p = 0; // * yields the object; we assign a new value to ival through p
cout << *p; // prints 0
When we assign to *p, we are assigning to the object to which p points.



-> NOTE: We may dereference only a valid pointer that points to an object.



-> NOTE: KEY CONCEPT: SOME SYMBOLS HAVE MULTIPLE MEANINGS
Some symbols, such as & and *, are used as both an operator in an expression and as part of a declaration. 
The context in which a symbol is used determines what the symbol means:
int i = 42;
int &r = i; // & follows a type and is part of a declaration; r is a reference
int *p; // * follows a type and is part of a declaration; p is a pointer
p = &i; // & is used in an expression as the address-of operator
*p = i; // * is used in an expression as the dereference operator
int &r2 = *p; // & is part of the declaration; * is the dereference operator
In declarations, & and * are used to form compound types. 
In expressions, these same symbols are used to denote an operator. 
Because the same symbol is used with very different meanings, it can be helpful to ignore appearances 
and think of them as if they were different symbols.



-> NOTE: ADVICE: INITIALIZE ALL POINTERS
Uninitialized pointers are a common source of run-time errors.
As with any other uninitialized variable, what happens when we use an uninitialized pointer is undefined. 
Using an uninitialized pointer almost always results in a run-time crash. 
However, debugging the resulting crashes can be surprisingly hard.
Under most compilers, when we use an uninitialized pointer, the bits in the memory in which the pointer resides are used as an address. 
Using an uninitialized pointer is a request to access a supposed object at that supposed location. 
There is no way to distinguish a valid address from an invalid one formed from the bits that happen to be in the memory in which the pointer was allocated.
Our recommendation to initialize all variables is particularly important for pointers.
If possible, define a pointer only after the object to which it should point has been defined. 
If there is no object to bind to a pointer, then initialize the pointer to nullptr or zero. 
That way, the program can detect that the pointer does not point to an object.



-> NOTE: References to Pointers
A reference is not an object. 
Hence, we may not have a pointer to a reference.
However, because a pointer is an object, we can define a reference to a pointer:
int i = 42;
int *p; // p is a pointer to int
int *&r = p; // r is a reference to the pointer p
r = &i; // r refers to a pointer; assigning &i to r makes p point to i
*r = 0; // dereferencing r yields i, the object to which p points; changes i to 0



-> NOTE: To share a const object among multiple files, you must define the variable as extern.
To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):
// file_1.cc defines and initializes a const that is accessible to other files
extern const int bufSize = fcn();
// file_1.h
extern const int bufSize; // same bufSize as defined in file_1.cc
In this program, file_1.cc defines and initializes bufSize. 
Because this declaration includes an initializer, it is (as usual) a definition.
However, because bufSize is const, we must specify extern in order for bufSize to be used in other files.
The declaration in file_1.h is also extern. 
In this case, the extern signifies that bufSize is not local to this file and that its definition will occur elsewhere.



-> NOTE: void* Pointers
The type void* is a special pointer type that can hold the address of any object.
Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown



-> NOTE: Because we can’t change the value of a const object after we create it, it must be initialized. 
As usual, the initializer may be an arbitrarily complicated expression:
const int i = get_size(); // ok: initialized at run time
const int j = 42; // ok: initialized at compile time
const int k; // error
pointer examples:
int i, *const cp;       // error: cp is uninitialized const
int *p1, *const p2;     // error: p2 is uninitialized const
const int ic, &r = ic;  // error: ic is uninitialized const
const int *const p3;    // error: p3 is uninitialized const
const int *p;           // no error



-> NOTE: Objects of built-in type defined at global scope are initialized to 0;
those defined at local scope are uninitialized and have undefined values.



-> TERMINOLOGY: CONST REFERENCE IS A REFERENCE TO CONST (THIS IS IMPORTANT)
C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.”
This abbreviation makes sense—if you remember that it is an abbreviation.
Technically speaking, there are no const references. 
A reference is not an object, so we cannot make a reference itself const. 
Indeed, because there is no way to make a reference refer to a different object, in some sense all references are const. 
Whether a reference refers to a const or nonconst type affects what we can do with that reference, 
not whether we can alter the binding of the reference itself.



-> NOTE: Initialization and References to const
In § 2.3.1 (p. 51) we noted that there are two exceptions to the rule that the type of a reference must match the type of the object to which it refers. 
The first exception is that we can initialize a reference to const from any expression that can be converted (§ 2.1.2, p. 35) to the type of the reference. 
In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression:
int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object
const int &r2 = 42; // ok: r1 is a reference to const
const int &r3 = r1 * 2; // ok: r3 is a reference to const
int &r4 = r * 2; // error: r4 is a plain, nonconst reference
The easiest way to understand this difference in initialization rules is to consider what happens when we bind a reference to an object of a different type:
double dval = 3.14;
const int &ri = dval;
Here ri refers to an int. 
Operations on ri will be integer operations, but dval is a floating-point number, not an integer. 
To ensure that the object to which ri is bound is an int, the compiler transforms this code into something like
const int temp = dval; // create a temporary const int from the double
const int &ri = temp; // bind ri to that temporary
In this case, ri is bound to a temporary object. 
A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 
C++ programmers often use the word temporary as an abbreviation for temporary object. 



-> NOTE: ME: There is a lot of difference of "reference to const" to "pointer to const".
---> Mainly because "reference to const" can create a temporary so it can convert more types (Check entries before this).


-> NOTE: ME: A good rule of thumb is to check whats going on underneath and check if its possible, if its not its an error.



-> NOTE: A Reference to const May Refer to an Object That Is Not const (THIS IS IMPORTANT! THIS IS THE RULE THAT MESSES ME UP)
It is important to realize that a reference to const restricts only what we can do through that reference. 
Binding a reference to const to an object says nothing about whether the underlying object itself is const. 
Because the underlying object might be nonconst, it might be changed by other means:
int i = 42;
int &r1 = i; // r1 bound to i
const int &r2 = i; // r2 also bound to i; but cannot be used to change i
r1 = 0; // r1 is not const; i is now 0
r2 = 0; // error: r2 is a reference to const
Binding r2 to the (nonconst) int i is legal. 
However, we cannot use r2 to change i. 
Even so, the value in i still might change. 
We can change i by assigning to it directly, or by assigning to another reference bound to i, such as r1.
i = 43;



-> NOTE: Pointers and constexpr
It is important to understand that when we define a pointer in a constexpr declaration, 
the constexpr specifier applies to the pointer, not the type to which the pointer points:
const int *p = nullptr; // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int
Despite appearances, the types of p and q are quite different; p is a pointer to const, whereas q is a constant pointer. 
The difference is a consequence of the fact that constexpr imposes a top-level const (§ 2.4.3, p. 63) on the objects it defines.
Like any other constant pointer, a constexpr pointer may point to a const or a nonconst type:
constexpr int *np = nullptr; // np is a constant pointer to int that is null
int j = 0;
constexpr int i = 42; // type of i is const int
// i and j must be defined outside any function
constexpr const int *p = &i; // p is a constant pointer to the const int i
constexpr int *p1 = &j; // p1 is a constant pointer to the int j



-> NOTE: Pointers, const, and Type Aliases
Declarations that use type aliases that represent compound types and const can yield surprising results. 
For example, the following declarations use the type pstring, which is an alias for the the type char*:
typedef char *pstring;
const pstring cstr = 0; // cstr is a constant pointer to char
const pstring *ps; // ps is a pointer to a constant pointer to char
The base type in these declarations is const pstring. 
As usual, a const that appears in the base type modifies the given type. 
The type of pstring is “pointer to char.” 
So, const pstring is a constant pointer to char — not a pointer to const char.
It can be tempting, albeit incorrect, to interpret a declaration that uses a type alias by conceptually replacing the alias with its corresponding type:
const char *cstr = 0; // wrong interpretation of const pstring cstr
However, this interpretation is wrong. 
When we use pstring in a declaration, the base type of the declaration is a pointer type. 
When we rewrite the declaration using char*, the base type is char and the * is part of the declarator.
In this case, const char is the base type. 
This rewrite declares cstr as a pointer to const char rather than as a const pointer to char.



-> NOTE: As with any other type specifier, we can define multiple variables using auto.
Because a declaration can involve only a single base type, 
the initializers for all the variables in the declaration must have types that are consistent with each other:
auto i = 0, *p = &i; // ok: i is int and p is a pointer to int
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi



-> NOTE: ME: Auto drops top level const and gets the objects base type (without the references)


-> NOTE: The compiler uses that object’s type (base type?) for auto’s type deduction:
int i = 0, &r = i;
auto a = r; // a is an int (r is an alias for i, which has type int)



-> NOTE: Auto ordinarily ignores top-level consts (§ 2.4.3, p. 63). 
As usual in initializations, low-level consts, such as when an initializer is a pointer to const, are kept:
int i;
const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)
auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i; // d is an int* (& of an int object is int*)
auto e = &ci; // e is const int* (& of a const object is low-level const)
If we want the deduced type to have a top-level const, we must say so explicitly:
const auto f = ci; // deduced type of ci is int; f has type const int
We can also specify that we want a reference to the auto-deduced type. 
Normal initialization rules still apply:
auto &g = ci; // g is a const int& that is bound to ci
auto &h = 42; // error: we can’t bind a plain reference to a literal
const auto &j = 42; // ok: we can bind a const reference to a literal



-> NOTE: As usual, the initializers in auto must provide consistent auto-deduced types (ME: including the constness of the type):
int i;
const int ci;
auto k = ci, &l = i; // k is int; l is int&
auto &m = ci, *p = &ci; // m is a const int&; p is a pointer to const int
auto &n = i, *p2 = &ci; // error: type deduced from i is int; type deduced from &ci is const int



-> NOTE: The way decltype handles top-level const and references differs subtly from the way auto does. 
When the expression to which we apply decltype is a variable, decltype returns the type of that variable, including top-level const and references
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z; // error: z is a reference and must be initialized
Because cj is a reference, decltype(cj) is a reference type. 
Like any other reference, z must be initialized.



-> NOTE: It is worth noting that decltype is the only context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.



-> NOTE: decltype and References
When we apply decltype to an expression that is not a variable, we get the type that that expression yields. 
As we’ll see in § 4.1.1 (p. 135), some expressions will cause decltype to yield a reference type. 
Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment:
// decltype of an expression can be a reference type
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int
decltype(*p) c; // error: c is int& and must be initialized
Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 
What can be confusing is that enclosing the name of a variable in parentheses affects the type returned by decltype. 
When we apply decltype to a variable without any parentheses, we get the type of that variable. 
If we wrap the variable’s name in one or more sets of parentheses, the compiler will evaluate the operand as an expression.
A variable is an expression that can be the left-hand side of an assignment.
As a result, decltype on such an expression yields a reference:
// decltype of a parenthesized variable is always a reference
decltype((i)) d; // error: d is int& and must be initialized
decltype(i) e; // ok: e is an (uninitialized) int
ME: You can also use std::remove_cvref_t to remove the type.



-> NOTE: Remember that decltype((variable)) (note, double parentheses) is always a reference type, 
but decltype(variable) is a reference type only if variable is a reference.



-> NOTE: Value Initialization
We can usually omit the value and supply only a size. 
In this case the library creates a value-initialized element initializer for us. 
This library-generated value is used to initialize each element in the container. 
The value of the element initializer depends on the type of the elements stored in the vector.
If the vector holds elements of a built-in type, such as int, then the element initializer has a value of 0. 
If the elements are of a class type, such as string, then the element initializer is itself default initialized:
vector<int> ivec(10); // ten elements, each initialized to 0
vector<string> svec(10); // ten elements, each an empty string



-> NOTE: KEY CONCEPT: GENERIC PROGRAMMING on !=
Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops such as the one above and in the one on page 94. 
C++ programmers use != as amatter of habit. 
They do so for the same reason that they use iterators rather than subscripts: 
This coding style applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among them, have the subscript operator. 
Similarly, all of the library containers have iterators that define the == and != operators.
Most of those iterators do not have the < operator.
By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.



-> Character Arrays Are Special
Character arrays have an additional form of initialization: 
We can initialize such arrays from a string literal (§ 2.1.3, p. 39). 
When we use this form of initialization, it is important to remember that string literals end with a null character. 
That null character is copied into the array along with the characters in the literal:
char a1[] = {’C’, ’+’, ’+’}; // list initialization, no null
char a2[] = {’C’, ’+’, ’+’, ’\0’}; // list initialization, explicit null
char a3[] = "C++"; // null terminator added automatically
const char a4[6] = "Daniel"; // error: no space for the null!
The dimension of a1 is 3; the dimensions of a2 and a3 are both 4. 
The definition of a4 is in error. 
Although the literal contains only six explicit characters, the array size must be at least seven—six to hold the literal and one for the null.



-> NOTE: Arrays cant be copied or assigned.
We cannot initialize an array as a copy of another array, nor is it legal to assign one array to another:
int a[] = {0, 1, 2}; // array of three ints
int a2[] = a; // error: cannot initialize one array with another
a2 = a; // error: cannot assign one array to another
Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. 
Programs that use such features, will not work with a different compiler.



-> NOTE: Lvalues and Rvalues
Every expression in C++ is either an rvalue (pronounced “are-value”) or an lvalue (pronounced “ell-value”). 
These names are inherited from C and originally had a simple mnemonic purpose: 
lvalues could stand on the left-hand side of an assignment whereas rvalues could not.
In C++, the distinction is less simple. 
In C++, an lvalue expression yields an object or a function. 
However, some lvalues, such as const objects, may not be the left-hand operand of an assignment. 
Moreover, some expressions yield objects but return them as rvalues, not lvalues. 
Roughly speaking, when we use an object as an rvalue, we use the object’s value (ITS CONTENTS). 
When we use an object as an lvalue, we use the object’s identity (ITS LOCATION ON MEMORY).
Operators differ as to whether they require lvalue or rvalue operands and as to whether they return lvalues or rvalues. 
The important point is that (with one exception that we’ll cover in § 13.6 (p. 531))
we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required.
When we use an lvalue in place of an rvalue, the object’s contents (its value) are used. 
Examples:
• Assignment requires a (nonconst) lvalue as its left-hand operand and yields its left-hand operand as an lvalue.
• The address-of operator (§ 2.3.2, p. 52) requires an lvalue operand and returns a pointer to its operand as an rvalue.
• The built-in dereference and subscript operators (§ 2.3.2, p. 53, and § 3.5.2, p. 116) 
and the iterator dereference and string and vector subscript operators (§ 3.4.1, p. 106, § 3.2.3, p. 93, and § 3.3.3, p. 102) all yield lvalues.
• The built-in and iterator increment and decrement operators (§ 1.4.1, p. 12, and § 3.4.1, p. 107) require lvalue operands 
and the prefix versions (which are the ones we have used so far) also yield lvalues.



-> NOTE: Order of Evaluation
Precedence specifies how the operands are grouped. 
It says nothing about the order in which the operands are evaluated. 
In most cases, the order is largely unspecified. 
In the following expression
int i = f1() * f2();
we know that f1 and f2 must be called before the multiplication can be done. 
After all, it is their results that are multiplied. 
However, we have no way of knowing whether f1 will be called before f2 or vice versa.
For operators that do not specify evaluation order, it is an error for an expression to refer to and change the same object. 
Expressions that do so have undefined behavior (§ 2.1.2, p. 36). 
As a simple example, the << operator makes no guarantees about when or how its operands are evaluated. 
As a result, the following output expression is undefined:
int i = 0;
cout << i << " " << ++i << endl; // undefined
Because this program is undefined, we cannot draw any conclusions about how it might behave. 
The compiler might evaluate ++i before evaluating i, in which case the output will be 1 1. 
Or the compiler might evaluate i first, in which case the output will be 0 1. 
Or the compiler might do something else entirely. 
Because this expression has undefined behavior, the program is in error, regardless of what code the compiler generates.
There are four operators that do guarantee the order in which operands are evaluated. 
We saw in § 3.2.3 (p. 94) that the logical AND (&&) operator guarantees that its left-hand operand is evaluated first. 
Moreover, we are also guaranteed that the right-hand operand is evaluated only if the left-hand operand is true. 
The only other operators that guarantee the order in which operands are evaluated are the logical OR (||) operator (§ 4.3, p. 141), 
the conditional (? :) operator (§ 4.7, p. 151), and the comma (,) operator (§ 4.10, p. 157).



-> NOTE: Order of Evaluation, Precedence, and Associativity
Order of operand evaluation is independent of precedence and associativity. 
In an expression such as f() + g() * h() + j():
• Precedence guarantees that the results of g() and h() are multiplied.
• Associativity guarantees that the result of f() is added to the product of g() and h() and that the result of that addition is added to the value of j().
• There are no guarantees as to the order in which these functions are called.
If f, g, h, and j are independent functions that do not affect the state of the same objects or perform IO, 
then the order in which the functions are called is irrelevant.
If any of these functions do affect the same object, then the expression is in error and has undefined behavior.



-> NOTE: Short-circuit evaluation can optimize your programs.
The logical AND and OR operators always evaluate their left operand before the right. 
Moreover, the right operand is evaluated if and only if the left operand does not determine the result. 
This strategy is known as short-circuit evaluation:
• The right side of an && is evaluated if and only if the left side is true.
• The right side of an || is evaluated if and only if the left side is false.



-> NOTE: Assignment Is Right Associative
Unlike the other binary operators, assignment is right associative:
int ival, jval;
ival = jval = 0; // ok: each assigned 0
Because assignment is right associative, the right-most assignment, jval = 0, is the right-hand operand of the left-most assignment operator. 
Because assignment returns its left-hand operand, the result of the right-most assignment (i.e., jval) is assigned to ival.
int i;
double d;
d = i = 3.5; // i : [3] d : [3]
i = d = 3.5; // i : [3] d : [3.5]



-> NOTE: ADVICE: USE POSTFIX OPERATORS ONLY WHEN NECESSARY
Readers from a C background might be surprised that we use the prefix increment in the programs we’ve written. 
The reason is simple: The prefix version avoids unnecessary work. 
It increments the value and returns the incremented version. 
The postfix operator must store the original value so that it can return the unincremented value as its result. 
If we don’t need the unincremented value, there’s no need for the extra work done by the postfix operator.
For ints and pointers, the compiler can optimize away this extra work. 
For more complicated iterator types, this extra work potentially might be more costly. 
By habitually using the prefix versions, we do not have to worry about whether the performance difference matters. 
Moreover—and perhaps more importantly—we can express the intent of our programs more directly.



-> NOTE: ADVICE: BREVITY CAN BE A VIRTUE (Combining Dereference and Increment in a Single Expression)
Expressions such as *pbeg++ can be bewildering—at first. 
However, it is a useful and widely used idiom. 
Once the notation is familiar, writing
cout << *iter++ << endl;
is easier and less error-prone than the more verbose equivalent
cout << *iter << endl;
++iter;
It is worthwhile to study examples of such code until their meanings are immediately clear. 
Most C++ programs use succinct expressions rather than more verbose equivalents.
Therefore, C++ programmers must be comfortable with such usages. 
Moreover, once these expressions are familiar, you will find them less error-prone.



-> NOTE: Remember That Operands Can Be Evaluated in Any Order
Most operators give no guarantee as to the order in which operands will be evaluated (§ 4.1.3, p. 137). 
This lack of guaranteed order often doesn’t matter. 
The cases where it does matter arewhen one subexpression changes the value of an operand that is used in another subexpression. 
Because the increment and decrement operators change their operands, it is easy to misuse these operators in compound expressions.



-> NOTE: Shift Operators (aka IO Operators) Are Left Associative
Although many programmers never use the bitwise operators directly, 
most programmers do use overloaded versions of these operators for IO. 
An overloaded operator has the same precedence and associativity as the built-in version of that operator. 
Therefore, programmers need to understand the precedence and associativity of the shift operators even if they never use them with their built-in meaning.
Because the shift operators are left associative, the expression
cout << "hi" << " there" << endl;
executes as
( (cout << "hi") << " there" ) << endl;
In this statement, the operand "hi" is grouped with the first << symbol. 
Its result is grouped with the second, and then that result is grouped with the third.
The shift operators have midlevel precedence: 
lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. 
These relative precedence levels mean we usually have to use parentheses to force the correct grouping of operators with lower precedence. 
cout << 42 + 10; // ok: + has higher precedence, so the sum is printed
cout << (10 < 42); // ok: parentheses force intended grouping; prints 1
cout << 10 < 42; // error: attempt to compare cout to 42!
The last cout is interpreted as
(cout << 10) < 42;
which says to “write 10 onto cout and then compare the result of that operation
(i.e., cout) to 42.”



-> NOTE: Comma Operator
The comma operator takes two operands,which it evaluates from left to right. 
Like the logical AND and logical OR and the conditional operator, the comma operator guarantees the order in which its operands are evaluated.
The left-hand expression is evaluated and its result is discarded. 
The result of a comma expression is the value of its right-hand expression. 
The result is an lvalue if the right-hand operand is an lvalue.
One common use for the comma operator is in a for loop:
vector<int>::size_type cnt = ivec.size();
// assign values from size . . . 1 to the elements in ivec
for(vector<int>::size_type ix = 0;
ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;



-> NOTE: When Implicit Conversions Occur
Implicit Conversions are carried out automatically without programmer intervention—and sometimes without programmer knowledge. 
The compiler automatically converts operands in the following circumstances:
• In most expressions, values of integral types smaller than int are first promoted to an appropriate larger integral type.
• In conditions, nonbool expressions are converted to bool.
• In initializations, the initializer is converted to the type of the variable; 
in assignments, the right-hand operand is converted to the type of the left-hand.
• In arithmetic and relational expressions with operands of mixed types, the types are converted to a common type.
• As we’ll see in Chapter 6, conversions also happen during function calls.
Examples are:
-> Integral Promotions
-> Operands of Unsigned Type
-> Array to Pointer Conversions
-> Conversions to bool
-> Conversion to const
-> Conversions Defined by Class Types



-> NOTE: On Explicit Conversions, ADVICE: AVOID CASTS
Casts interfere with normal type checking (§ 2.2.2, p. 46). 
As a result, we strongly recommend that programmers avoid casts. 
This advice is particularly applicable to reinterpret_casts. 
Such casts are always hazardous. 
A const_cast can be useful in the context of overloaded functions, which we’ll cover in § 6.4 (p. 232). 
Other uses of const_cast often indicate a design flaw. 
The other casts, static_cast and dynamic_cast, should be needed infrequently. 
Every time you write a cast, you should think hard about whether you can achieve the same result in a different way.
If the cast is unavoidable, errors can be mitigated by limiting the scope in which the cast value is used and by documenting all assumptions about the types involved.



-> NOTE: CAUTION: WRITING EXCEPTION SAFE CODE IS Hard
It is important to realize that exceptions interrupt the normal flow of a program. 
At the point where the exception occurs, some of the computations that the caller requested may have been done, while others remain undone. 
In general, bypassing part of the program might mean that an object is left in an invalid or incomplete state, or that a resource is not freed, and so on. 
Programs that properly “clean up” during exception handling are said to be exception safe. 
Writing exception safe code is surprisingly hard, and (largely) beyond the scope of this language Primer.
Some programs use exceptions simply to terminate the program when an exceptional condition occurs. 
Such programs generally don’t worry about exception safety.
Programs that do handle exceptions and continue processing generally must be constantly aware of whether an exception might occur 
and what the program must do to ensure that objects are valid, that resources don’t leak, and that the program is restored to an appropriate state.
We will occasionally point out particularly common techniques used to promote exception safety. 
However, readers whose programs require robust exception handling should be aware 
that the techniques we cover are insufficient by themselves to achieve exception safety.



-> NOTE: In C++, names have scope (§ 2.2.4, p. 48), and objects have lifetimes.
It is important to understand both of these concepts.
• The scope of a name is the part of the program’s text in which that name is visible.
• The lifetime of an object is the time during the program’s execution that the object exists.



-> NOTE: ME: In a function, "Parameters" are the ones in the function declaration, "Arguments" are the ones used in the function.



-> NOTE: Parameter initialization works the same way as variable initialization.



-> NOTE: For function parameters: Use Reference to const When Possible



-> NOTE: initializer_list Parameters
We can write a function that takes an unknown number of arguments of a single
type by using an initializer_list parameter.



-> NOTE: Failing to provide a return after a loop that contains a return is an error. 
However, many compilers will not detect such errors.



-> NOTE: How Values Are Returned (ME: THIS IS IMPORTANT)
Values are returned in exactly the same way as variables and parameters are initialized:
The return value is used to initialize a temporary at the call site, and that temporary is the result of the function call.



-> NOTE: Reference Returns Are Lvalues
Whether a function call is an lvalue (§ 4.1.1, p. 135) depends on the return type of the function. 
Calls to functions that return references are lvalues; other return types yield rvalues. 
A call to a function that returns a reference can be used in the same ways as any other lvalue.



-> NOTE: List Initializing the Return Value
Under the new standard, functions can return a braced list of values. 
As in any other return, the list is used to initialize the temporary that represents the function’s return. 
If the list is empty, that temporary is value initialized (§ 3.3.1, p. 98).
Otherwise, the value of the return depends on the function’s return type.



-> NOTE: The main function may not call itself.



-> NOTE: Its easier to return complicated types by using 
---> Using a type alias
using ArrayOfInts int(*)[10];
ArrayOfInts func(int i);
---> Using a Trailing Return Type
auto func(int i) -> int(*)[10];
---> Using decltype
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
return (i % 2) ? &odd : &even; // returns a pointer to the array
}



-> NOTE: The main function may not be overloaded.



-> Defining Overloaded Functions
Overloaded functions must differ in the NUMBER or the TYPE(s) of their parameters.
It is an error for two functions to differ ONLY in terms of their return types. 
If the parameter lists of two functions match but the return types differ, then the second declaration is an error.



-> NOTE: Overloading and const Parameters
As we saw in § 6.2.3 (p. 212), top-level const (§ 2.4.3, p. 63) has no effect on the objects that can be passed to the function. 
A parameter that has a top-level const is indistinguishable from one without a top-level const.



-> NOTE: const_cast and Overloading
In § 4.11.3 (p. 163) we noted that const_casts are most useful in the context of overloaded functions. 
As one example, recall our shorterString function from § 6.3.2 (p. 224):
// return a reference to the shorter of two strings
const string &shorterString(const string &s1, const string &s2)
{
return s1.size() <= s2.size() ? s1 : s2;
}
This function takes and returns references to const string.
We can call the function on a pair of nonconst string arguments, but we’ll get a reference to a const string as the result. 
We might want to have a version of shorterString that, when given nonconst arguments, would yield a plain reference. 
We can write this version of our function using a const_cast:
string &shorterString(string &s1, string &s2)
{
auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
return const_cast<string&>(r);
}
This version calls the const version of shorterString by casting its arguments to references to const. 
That function returns a reference to a const string, which we know is bound to one of our original, nonconst arguments. 
Therefore, we know it is safe to cast that string back to a plain string& in the return.



-> NOTE: Calling an Overloaded Function
Once we have defined a set of overloaded functions, we need to be able to call them with appropriate arguments. 
Function matching (also known as overload resolution) is the process by which 
a particular function call is associated with a specific function from a set of overloaded functions. 
The compiler determines which function to call by comparing the arguments in the call with the parameters offered by each function in the overload set.
In many—probably most—cases, it is straightforward for a programmer to determine whether a particular call is legal and, if so, which function will be called.
Often the functions in the overload set differ in terms of the number of arguments, or the types of the arguments are unrelated. 
In such cases, it is easy to determine which function is called. 
Determining which function is called when the overloaded functions have the same number of parameters 
and those parameters are related by conversions (§ 4.11, p. 159) can be less obvious. 
We’ll look at how the compiler resolves calls involving conversions in § 6.6 (p. 242).
For now, what’s important to realize is that for any given call to an overloaded function, there are three possible outcomes:
• The compiler finds exactly one function that is a best match for the actual arguments and generates code to call that function.
• There is no function with parameters that match the arguments in the call, in which case the compiler issues an error message that there was no match.
• There is more than one function that matches and none of the matches is clearly best. 
This case is also an error; it is an ambiguous call.


-> NOTE: In Function Overloading (or in other argument lookup), name lookup happens before type checking.


-> NOTE: inline Functions Avoid Function Call Overhead
A function specified as inline (usually) is expanded “in line” at each call. 


-> NOTE: The inline specification is only a request to the compiler. 
The compiler may choose to ignore this request.
In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. 
Many compilers will not inline a recursive function.
A 75-line function will almost surely not be expanded inline.


-> NOTE: constexpr Functions
A constexpr function is a function that can be used in a constant expression (§ 2.4.4, p. 65). 
A constexpr function is defined like any other function but must meet certain restrictions: 
---> The return type and the type of each parameter in a must be a literal type (§ 2.4.4, p. 66), 
---> and the function body must contain exactly one return statement


-> NOTE: A constexpr function is not required to return a constant expression.
A constexpr function body may contain other statements so long as those statements generate no actions at run time. 
For example, a constexpr function may contain null statements, type aliases (§ 2.5.1, p. 67), and using declarations.
A constexpr function is permitted to return a value that is not a constant.
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
If we call scale with an expression that is not a constant expression — such as on the int object i — then the return is not a constant expression. 
If we use scale in a context that requires a constant expression, the compiler checks that the result is a constant expression. 
If it is not, the compiler will produce an error message.


-> NOTE: Put inline and constexpr functions in Header Files
Unlike other functions, inline and constexpr functions may be defined multiple times in the program. 
After all, the compiler needs the definition, not just the declaration, in order to expand the code. 
However, all of the definitions of a given inline or constexpr must match exactly. 
As a result, inline and constexpr functions normally are defined in headers.


-> NOTE: Function Matching with Multiple Parameters
The compiler then determines, argument by argument, which function is (or functions are) the best match. 
There is an overall best match if there is one and only one function for which
• The match for each argument is no worse than the match required by any other viable function
• There is at least one argument for which the match is better than the match provided by any other viable function.
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6); // calls void f(double, double)
f(42, 2.56); // calls void f(int, int), Considering only the first argument, f(int, int) is a better match than f(double, double).


-> NOTE: Casts should not be needed to call an overloaded function. 
The need for a cast suggests that the parameter sets are designed poorly.


-> NOTE: Argument Type Conversions
In order to determine the bestmatch, the compiler ranks the conversions that could be used 
to convert each argument to the type of its corresponding parameter. 
Conversions are ranked as follows:
1. An exact match. 
An exact match happens when:
• The argument and parameter types are identical.
• The argument is converted from an array or function type to the corresponding pointer type. (§ 6.7 (p. 247) covers function pointers.)
• A top-level const is added to or discarded from the argument.
2. Match through a const conversion (§ 4.11.2, p. 162).
3. Match through a promotion (§ 4.11.1, p. 160).
4. Match through an arithmetic (§ 4.11.1, p. 159) or pointer conversion (§ 4.11.2, p. 161).
5. Match through a class-type conversion. (§ 14.9 (p. 579) covers these conversions.)
ME: So it goes:
1) Exact
2) Const
3) Primitive type promotion
4) Primitive type implicit conversions (arithmetic and pointers)
5) Class types conversions


-> NOTE: Functions defined in the class are implicitly inline (§ 6.5.2, p. 238).
ME: So avoid lengthy function definitions inside the class

-> NOTE: Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself.

-> NOTE: The only difference between using class and using struct to define a class is the default access level.

-> NOTE: Name Lookup and Class Scope
In the programs we’ve written so far, name lookup (the process of finding which declarations match the use of a name) has been relatively straightforward:
• First, look for a declaration of the name in the block in which the name was used. 
Only names declared before the use are considered.
• If the name isn’t found, look in the enclosing scope(s).
• If no declaration is found, then the program is in error.
The way names are resolved inside member functions defined inside the class may seem to behave differently than these lookup rules. 
However, in this case, appearances are deceiving. 
Class definitions are processed in two phases:
• First, the member declarations are compiled.
• Function bodies are compiled only after the entire class has been seen.


-> NOTE: Member function definitions are processed after the compiler processes all of the declarations in the class.


-> NOTE: Normal Block-Scope Name Lookup inside Member Definitions
A name used in the body of a member function is resolved as follows:
• First, look for a declaration of the name inside the member function. 
As usual, only declarations in the function body that precede the use of the name are considered.
• If the declaration is not found inside the member function, look for a declaration inside the class. 
All the members of the class are considered.
• If a declaration for the name is not found in the class, look for a declaration that is in scope before the member function definition.
ME: So it goes:
1) Function scope
2) Class scope
3) Outside function scope


-> NOTE: (ME: This is good when doing inheritance classes). 
Even though the class member is hidden, it is still possible to use that member 
by qualifying the member’s name with the name of its class or by using the this pointer explicitly.
Example:
// bad practice: names local to member functions shouldn’t hide member names
void Screen::dummy_fcn(pos height) {
cursor = width * this->height; // member height
// alternative way to indicate the member
cursor = width * Screen::height; // member height
}


-> NOTE: Even though the outer object is hidden, it is still possible to access that object by using the scope operator.
Example:
// bad practice: don’t hide names that are needed from surrounding scopes
void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one
}


-> NOTE: We must use the constructor initializer list to provide values for members 
that are const, reference, or of a class type that does not have a default constructor.
class ConstRef {
public:
ConstRef(int ii);
private:
int i;
const int ci;
int &ri;
};
// Instead of this:
ConstRef::ConstRef(int ii)
{ // assignments:
i = ii; // ok
ci = ii; // error: cannot assign to a const
ri = i; // error: ri was never initialized
}
// Do this:
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { } // ok: explicitly initialize reference and const members


-> NOTE: Delegating Constructors
The new standard extends the use of constructor initializers to let us define socalled delegating constructors. 
A delegating constructor uses another constructor from its own class to perform its initialization. 
It is said to “delegate” some (or all) of its work to this other constructor.


-> NOTE: 7.5.3 The Role of the Default Constructor
The default constructor is used automatically whenever an object is default or value initialized (value initialized to zero). 
Default initialization happens:
• When we define nonstatic variables (§ 2.2.1, p. 43) or arrays (§ 3.5.1, p. 114) at block scope without initializers
---> ME: non static variables without initializers
• When a class that itself has members of class type uses the synthesized default constructor (§ 7.1.4, p. 262)
---> ME: variables that has a class type with a default constructor
• When members of class type are not explicitly initialized in a constructor initializer list (§ 7.1.4, p. 265)
---> ME: member variables not specified in the constructor
Value initialization happens:
• During array initialization when we provide fewer initializers than the size of the array (§ 3.5.1, p. 114)
---> ME: incomplete array initialization
• When we define a local static object without an initializer (§ 6.1.1, p. 205)
---> ME: static varialbles/objects without value
• When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type 
(NOTE: The vector constructor that takes a single argument to specify the vector’s size (§ 3.3.1, p. 98) 
uses an argument of this kind to value initialize its element initializer.)
---> ME: variables declared in the form T()


-> NOTE: In practice, it is almost always right to provide a default constructor if other constructors are being defined.
---> ME: Either specify one, explicitly use the default or explicitly delete it. (Watch out for the rule of 5)


-> NOTE: Implicit Class-Type Conversions, Converting Constructors
A constructor that can be called with a single argument defines an implicit conversion from the constructor’s parameter type to the class type.


-> NOTE: When a constructor is declared explicit, it can be used only with the direct form of initialization (§ 3.2.1, p. 84). 
Moroever, the compiler will not use this constructor in an automatic conversion.


-> NOTE: Aggregate Classes (Plain old data)
An aggregate class gives users direct access to its members and has special initialization syntax. 
A class is an aggregate if:
• All of its data members are public
• It does not define any constructors
• It has no in-class initializers (§ 2.6.1, p. 73)
ME: Such as this:
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
• It has no base classes or virtual functions, which are class-related features that we’ll cover in Chapter 15
ME: So in short: Classes with public data members with no constructors, no inclass initializers, no base classes and virtual functions. 


-> NOTE: Literal Classes (for constexpr return types)
The parameters and return type of a constexpr function must be literal types.
Unlike other classes, classes that are literal types may have function members that are constexpr. 
Such members must meet all the requirements of a constexpr function. 
These member functions are implicitly const (§ 7.1.2, p. 258).
1) An aggregate class (§ 7.5.5, p. 298) whose data members are all of literal type is a literal class. 
2) A nonaggregate class, that meets the following restrictions, is also a literal class: 
• The data members all must have literal type.
• The class must have at least one constexpr constructor.
• If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression (§ 2.4.4, p. 65), 
or if the member has class type, the initializer must use the member’s own constexpr constructor.
• The class must use default definition for its destructor, which is the member that destroys objects of the class type (§ 7.1.5, p. 267).


-> NOTE: constexpr Constructors
Although constructors can’t be const (§ 7.1.4, p. 262), constructors in a literal class can be constexpr (§ 6.5.2, p. 239) functions. 
Indeed, a literal class must provide at least one constexpr constructor.
A constexpr constructor can be declared as = default.
Otherwise, a constexpr constructor must meet the requirements of a constructor—meaning it can have no return statement—
and of a constexpr function—meaning the only executable statement it can have is a return statement (§ 6.5.2, p. 239). 
As a result, the body of a constexpr constructor is typically empty.
A constexpr constructor must initialize every data member. 
The initializers must either use a constexpr constructor or be a constant expression


-> NOTE:  As with any class member, when we refer to a class static member outside the class body, we must specify the class in which the member is defined. 
The static keyword, however, is used only on the declaration inside the class body.


-> NOTE: The best way to ensure that the object is defined exactly once is to put the definition of static data members 
in the same file that contains the definitions of the class non inline member functions (ME: so in short the .cpp).


-> NOTE: Even if a const static data member is initialized in the class body, 
that member ordinarily should be defined outside the class definition. (DEFINITON INSIDE THE CLASS IS ALLOWED NOW)
static constexpr int period = 30;// period is a constant expression
constexpr int Account::period;


-> NOTE: A static data member can have incomplete type (§ 7.3.3, p. 278).
---> ME: One of the many advantages of being static.
In particular, a static data member can have the same type as the class type of which it is a member. 
A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:
class Bar {
public:
// . . .
private:
// inside bar, so bar is complete yet
static Bar mem1; // ok: static member can have incomplete type
Bar *mem2; // ok: pointer member can have incomplete type
Bar mem3; // error: data members must have complete type
};


-> NOTE: Another difference between static and ordinary members is that we can use a static member as a default argument (§ 6.5.1, p. 236):
---> ME: Another one of the many advantages of being static.
class Screen {
public:
// bkground refers to the static member
// declared later in the class definition
Screen& clear(char = bkground);
private:
static const char bkground;
};
A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member. 
Using a nonstatic data member as a default argument provides no object from which to obtain the member’s value and so is an error


-> NOTE: No Copy or Assign for IO Objects
ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects
ofstream print(ofstream); // error: can’t initialize the ofstream parameter
out2 = print(out2); // error: cannot copy stream objects


-> NOTE: Condition States
Inherent in doing IO is the fact that errors can occur. 
Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct.
As an example of an IO error, consider the following code:
int ival;
cin >> ival;
If we enter Boo on the standard input, the read will fail. 
The input operator expected to read an int but got the character B instead. 
As a result, cin will be put in an error state. 
Similarly, cin will be in an error state if we enter an end-of-file.


-> NOTE: Flushing the Output Buffer
Our programs have already used the endl manipulator, which ends the current line and flushes the buffer. 
There are two other similar manipulators: flush and ends. 
flush flushes the streambut adds no characters to the output; ends inserts a null character into the buffer and then flushes it:
cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer
cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data
cout << "hi!" << ends; // writes hi and a null, then flushes the buffer


-> NOTE: The unitbuf Manipulator
If we want to flush after every output, we can use the unitbuf manipulator.
This manipulator tells the stream to do a flush after every subsequent write.
The nounitbuf manipulator restores the stream to use normal, system-managed buffer flushing:
cout << unitbuf; // all writes will be flushed immediately
// any output is flushed immediately, no buffering
cout << nounitbuf; // returns to normal buffering


-> NOTE: CAUTION: BUFFERS ARE NOT FLUSHED IF THE PROGRAM CRASHES (ME: This is the reason why some logging is missing when there is a problem.)
Output buffers are not flushed if the programterminates abnormally. 
When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.
When you debug a program that has crashed, it is essential to make sure that any output you think should have been written was actually flushed. 
Countless hours of programmer time have been wasted tracking through code that appeared not to have executed 
when in fact the buffer had not been flushed and the output was pending when the program crashed.


-> NOTE: Tying Input and Output Streams Together (ME: this means do all output first before input)
When an input stream is tied to an output stream, any attempt to read the input stream will first flush the buffer associated with the output stream.
The library ties cout to cin, so the statement
cin >> ival;
causes the buffer associated with cout to be flushed.
Interactive systems usually should tie their input stream to their output stream. 
Doing so means that all output, which might include prompts to the user, will be written before attempting to read the input.


-> NOTE: Using an istringstream
An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line.
struct PersonInfo {
string name;
vector<string> phones;
};
string line, word; // will hold a line and word from input, respectively
vector<PersonInfo> people; // will hold all the records from the input
// read the input a line at a time until cin hits end-of-file (or another error)
while (getline(cin, line)) {
PersonInfo info; // create an object to hold this record’s data
istringstream record(line); // bind record to the line we just read
record >> info.name; // read the name
while (record >> word) // read the phone numbers
info.phones.push_back(word); // and store them
people.push_back(info); // append this record to people
}


-> NOTE: Using Using ostringstreams
An ostringstream is useful when we need to build up our output a little at a time but do not want to print the output until later.
for (const auto &entry : people) { // for each entry in people
ostringstream formatted, badNums; // objects created on each loop
for (const auto &nums : entry.phones) { // for each number
if (!valid(nums)) {
badNums << " " << nums; // string in badNums
} else
// ‘‘writes’’ to formatted’s string
formatted << " " << format(nums);
}
if (badNums.str().empty()) // there were no bad numbers
os << entry.name << " " // print the name
<< formatted.str() << endl; // and reformatted numbers
else // otherwise, print the name and bad numbers
cerr << "input error: " << entry.name
<< " invalid number(s) " << badNums.str() << endl;
}




-> NOTE: Overview of the Sequential Containers
---> The costs to add or delete elements to the container
---> The costs to perform nonsequential access to elements of the container
1) vector: Flexible-size array. Supports fast random access. Inserting or deleting elements other than at the back may be slow.
2) deque: Double-ended queue. Supports fast random access. Fast insert/delete at front or back.
3) list: Doubly linked list. Supports only bidirectional sequential access. Fast insert/delete at any point in the list.
4) forward_list: Singly linked list. Supports only sequential access in one direction. Fast insert/delete at any point in the list.
5) array: Fixed-size array. Supports fast random access. Cannot add or remove elements.
6) string: A specialized container, similar to vector, that contains characters. Fast random access. Fast insert/delete at the back.


-> NOTE: For reasons we’ll explain in § 13.6 (p. 531), the new library containers are dramatically faster than in previous releases. 
The library containers almost certainly perform as well as (and usually better than) even the most carefully crafted alternatives. 
Modern C++ programs should use the library containers rather than more primitive structures like arrays.


-> NOTE: Deciding Which Sequential Container to Use
Ordinarily, it is best to use vector unless there is a good reason to prefer another container.
There are a few rules of thumb that apply to selecting which container to use:
• Unless you have a reason to use another container, use a vector.
• If your program has lots of small elements and space overhead matters, don’t use list or forward_list.
• If the program requires random access to elements, use a vector or a deque.
• If the program needs to insert or delete elements in the middle of the container, use a list or forward_list.
• If the program needs to insert or delete elements at the front and the back, but not in the middle, use a deque.
• If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements:
---> First, decide whether you actually need to add elements in the middle of a container. 
---> It is often easier to append to a vector and then call the library sort function (which we shall cover in § 10.2.3 (p. 384)) to reorder the container when you’re done with input.
---> If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.


-> NOTE: If you’re not sure which container to use, write your code so that it uses only operations common to both vectors and lists: 
Use iterators, not subscripts, and avoid random access to elements. 
That way it will be easy to use either a vector or a list as necessary.


-> NOTE: Iterator Ranges
The concept of an iterator range is fundamental to the standard library.
This element range is called a left-inclusive interval. 
The standard mathematical notation for such a range is
[ begin, end )


-> NOTE: REQUIREMENTS ON ITERATORS FORMING AN ITERATOR RANGE
Two iterators, begin and end, form an iterator range, if
• They refer to elements of, or one past the end of, the same container, and
• It is possible to reach end by repeatedly incrementing begin. In other words, end must not precede begin.
The compiler cannot enforce these requirements. 
It is up to us to ensure that our programs follow these conventions.


-> NOTE: Container Type Members
---> iterator: Type of the iterator for this container type
---> const_iterator: Iterator type that can read but not change its elements
---> size_type: Unsigned integral type big enough to hold the size of the largest possible container of this container type
---> difference_type: Signed integral type big enough to hold the distance between two iterators
---> value_type: Element type
---> reference: Element’s lvalue type; synonym for value_type& (ME: I didnt know this)
---> const_reference: Element’s const lvalue type (i.e., const value_type&) (ME: I didnt know this)


-> NOTE: Best Practices: When write access is not needed, use cbegin and cend.


-> NOTE: Defining and Initializing Containers
1) Default constructor. 
C c;
If C is array, then the elements in c are default-initialized; otherwise c is empty.
2) Copy constructor. 
C c1(c2)
C c1 = c2 
c1 is a copy of c2. c1 and c2 must have the same type (i.e., they must be the same container type and hold the same element type; for array must also have the same size).
3) Constructor with initializer list.
C c{a,b,c...}
C c = {a,b,c...}
c is a copy of the elements in the initializer list. 
Type of elements in the list must be compatible with the element type of C. 
For array, the list must have same number or fewer elements than the size of the array, any missing elements are value-initialized (§ 3.3.1, p. 98).
4) Range constructor
C c(b, e) 
c is a copy of the elements in the range denoted by iterators b and e.
Type of the elements must be compatible with the element type of C. (Not valid for array.)
-----------------------------------------------------------------------------------------------
Constructors that take a size are valid for sequential containers only (not including array, ME: because array size is a template parameter) 
1) Fill constructor with default values
C seq(n) 
seq has n value-initialized elements; this constructor is explicit (§ 7.5.4, p. 296). (Not valid for string.)
1) Fill constructor wtih a value
C seq(n,t) 
seq has n elements with value t.


-> NOTE: When we initialize a container as a copy of another container, the container type and element type of both containers must be identical.


-> NOTE: Sequential Container Size-Related Constructors
vector<int> ivec(10, -1); // ten int elements, each initialized to -1
list<string> svec(10, "hi!"); // ten strings; each element is "hi!"
forward_list<int> ivec(10); // ten elements, each initialized to 0
deque<string> svec(10); // ten elements, each an empty string
The constructors that take a size are valid only for sequential containers; they are not supported for the associative containers.


-> NOTE: Just as the size of a built-in array is part of its type, 
the size of a library array is part of its type. When we define an array, 
in addition to specifying the element type, we also specify the container size:
array<int, 42> // type is: array that holds 42 ints
array<string, 10> // type is: array that holds 10 strings


-> NOTE: Container Assignment Operations
1) Assignment operator (with another object)
c1 = c2 
Replace the elements in c1 with copies of the elements in c2. c1 and c2 must be the same type.
2) Assignment operator (with initializer list)
c = {a,b,c. . . } 
Replace the elements in c1 with copies of the elements in the initializer list. (Not valid for array.)
3) Swap function (ME: These needs lvalues)
swap(c1, c2)
c1.swap(c2)
Exchanges elements in c1 with those in c2. 
c1 and c2 must be the same type. 
swap is usually much faster than copying elements from c2 to c1. (ME: Because underneath, its just exchanging memory locations)
-----------------------------------------------------------------------------------------------
assign operations not valid for associative containers or array 
-----------------------------------------------------------------------------------------------
1) assign function with range parameter
seq.assign(b,e) 
Replaces elements in seq with those in the range denoted by iterators b and e. 
The iterators b and e must not refer to elements in seq.
2) assign function with initializer list
seq.assign(il) Replaces the elements in seq with those in the initializer list il.
3) assign function with fill parameters
seq.assign(n,t) Replaces the elements in seq with n elements with value t.


-> NOTE: Assignment related operations invalidate iterators, references, and pointers into the left-hand container. 
Aside from string they remain valid after a swap, and (excepting arrays) the containers to which they refer are swapped.


-> NOTE: Because the existing elements are replaced, the iterators passed to assign must not refer to the container on which assign is called.


-> NOTE: Excepting array, swap() does not copy, delete, or insert any elements and is guaranteed to run in constant time.


-> NOTE: Relational Operators
Every container type supports the equality operators (== and !=); 
all the containers except the unordered associative containers also support the relational operators (>, >=, <, <=).
Comparing two containers performs a pairwise comparison of the elements.
These operators work similarly to the string relationals (§ 3.2.2, p. 88):
• If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.
• If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.
• If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.
---> ME: So it goes:
1) Size and content must be the same to be equal
2) If the smaller container is an exact subsequence, then the smaller container is less than the other.
3) If its the smaller is not a subsequence, the relationship depends on the first unequal elements.
---> Examples:
vector<int> v1 = { 1, 3, 5, 7, 9, 12 };
vector<int> v2 = { 1, 3, 9 };
vector<int> v3 = { 1, 3, 5, 7 };
vector<int> v4 = { 1, 3, 5, 7, 9, 12 };
v1 < v2 // true; v1 and v2 differ at element[2]: v1[2] is less than v2[2]
v1 < v3 // false; all elements are equal, but v3 has fewer of them;
v1 == v4 // true; each element is equal and v1 and v4 have the same size()
v1 == v2 // false; v2 has fewer elements than v1


-> NOTE: We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.


-> NOTE: Operations That Add Elements to a Sequential Container
These operations change the size of the container; they are not supported by array.
forward_list has special versions of insert and emplace; see § 9.3.4 (p. 350).
push_back and emplace_back not valid for forward_list.
push_front and emplace_front not valid for vector or string.
1) Back insertion
c.push_back(t)
c.emplace_back(args)
Creates an element with value t or constructed from args at the end of c. Returns void.
2) Front insertion
c.push_front(t)
c.emplace_front(args)
3) Insertion at specific location
c.insert(p,t)
c.emplace(p, args)
Creates an element with value t or constructed from args before the element denoted by iterator p. 
Returns an iterator referring to the element that was added.
4) Insertion using fill parameters
c.insert(p,n,t) 
Inserts n elements with value t before the element denoted by iterator p. 
Returns an iterator to the first element inserted; if n is zero, returns p.
5) Insertion using iterator range
c.insert(p,b,e) 
Inserts the elements from the range denoted by iterators b and e before the element denoted by iterator p. b and e may not refer
to elements in c. Returns an iterator to the first element inserted; if the range is empty, returns p.
6) Insertion using initializer_list
c.insert(p,il) 
il is a braced list of element values. 
Inserts the given values before the element denoted by the iterator p. 
Returns an iterator to the first inserted element; if the list is empty returns p.
-> NOTE: Adding elements to a vector, string, or deque potentially invalidates all existing iterators, references, and pointers into the container.


-> NOTE: It is legal to insert anywhere in a vector, deque, or string. However, doing so can be an expensive operation.


-> NOTE: It is important to understand how this loop operates—in particular, to understand why the loop is equivalent to calling push_front.
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
iter = lst.insert(iter, word); // same as calling push_front


-> NOTE: The emplace functions construct elements in the container. The arguments to these functions must match a constructor for the element type.


-> NOTE: Operations to Access Elements in a Sequential Container
at and subscript operator valid only for string, vector, deque, and array.
back not valid for forward_list.
1) Back access
c.back() 
Returns a reference to the last element in c. Undefined if c is empty.
2) Front access
c.front() Returns a reference to the first element in c. Undefined if c is empty.
3) Subscript (access a specified element)
c[n] Returns a reference to the element indexed by the unsigned integral value n.
Undefined if n >= c.size().
4) at() function (access specified element with bounds checking)
c.at(n) 
Returns a reference to the element indexed by n. If the index is out of range,
throws an out_of_range exception.


-> NOTE: Calling front or back on an empty container, like using a subscript that is out of range, is a serious programming error.


-> NOTE: Subscripting and Safe Random Access
If we want to ensure that our index is valid, we can use the at member instead.
The at member acts like the subscript operator, but if the index is invalid, at throws an out_of_range exception (§ 5.6, p. 193):
vector<string> svec; // empty vector
cout << svec[0]; // run-time error: there are no elements in svec!
cout << svec.at(0); // throws an out_of_range exception


-> NOTE: erase Operations on Sequential Containers
These operations change the size of the container and so are not supported by array.
forward_list has a special version of erase; see § 9.3.4 (p. 350).
pop_back not valid for forward_list; pop_front not valid for vector and string.
1) Removes last element
c.pop_back() 
Removes last element in c. Undefined if c is empty. Returns void.
2) Removes first element
c.pop_front() 
Removes first element in c. Undefined if c is empty. Returns void.
3) Removes an element indicated by an iterator
c.erase(p) 
Removes the element denoted by the iterator p and returns an iterator to the element 
after the one deleted or the off-the-end iterator if p denotes the last element. 
Undefined if p is the off-the-end iterator.
4) Remove elements indicated by an iterator range
c.erase(b,e) R
emoves the range of elements denoted by the iterators b and e. 
Returns an iterator to the element after the last one that was deleted, or an off-the-end iterator if e is itself an off-the-end iterator.
4) Remove all elements
c.clear() 
Removes all the elements in c. Returns void.


-> NOTE: The members that remove elements do not check their argument(s). The programmer must ensure that element(s) exist before removing them.


-> NOTE: Removing elements anywhere but the beginning or end of a deque invalidates all iterators, references, and pointers. 
Iterators, references, and pointers to elements after the erasure point in a vector or string are invalidated.


-> NOTE: Operations to Insert or Remove Elements in a forward_list
1) Begin Iterators
lst.before_begin()
lst.cbefore_begin()
Iterator denoting the nonexistent element just before the beginning of the list. 
This iterator may not be dereferenced.
cbefore_begin() returns a const_iterator.
2) Insert after
lst.insert_after(p,t)
lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)
Inserts element(s) after the one denoted by iterator p. t is an object, n is a count, 
b and e are iterators denoting a range (b and e must not refer to lst), and il is a braced list. 
Returns an iterator to the last inserted element.
If the range is empty, returns p. 
Undefined if p is the off-the-end iterator.
3) Emplace after
emplace_after(p, args) 
Uses args to construct an element after the one denoted by
iterator p. Returns an iterator to the new element.
Undefined if p is the off-the-end iterator.
4) Erase after
lst.erase_after(p)
lst.erase_after(b,e)
Removes the element after the one denoted by iterator p or the range of elements 
from the one after the iterator b up to but not including the one denoted by e. 
Returns an iterator to the element after the one deleted, or the off-the-end iterator if there is no such element. 
Undefined if p denotes the last element in lst or is the off-the-end iterator.


-> NOTE: Sequential Container Size Operations
resize not valid for array.
1) Resize with default element construction
c.resize(n) Resize c so that it has n elements. 
If n < c.size(), the excess elements are discarded. 
If new elements must be added, they are value initialized.
2) Resize with specified element value
c.resize(n,t) 
Resize c to have n elements. Any elements added have value t.
Example:
list<int> ilist(10, 42); // ten ints: each has value 42
ilist.resize(15); // adds five elements of value 0 to the back of ilist
ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist
ilist.resize(5); // erases 20 elements from the back of ilist


-> NOTE: If resize shrinks the container, then iterators, references, and pointers to the deleted elements are invalidated; 
resize on a vector, string, or deque potentially invalidates all iterators, pointers, and references.


-> NOTE: Container Operations May Invalidate Iterators (ME: And what happens underneath)
Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. 
An invalidated pointer, reference, or iterator is one that no longer denotes an element. 
Using an invalidated pointer, reference, or iterator is a serious programming error 
that is likely to lead to the same kinds of problems as using an uninitialized pointer (§ 2.3.2, p. 54).
1) After an operation that adds elements to a container:
• Iterators, pointers, and references to a vector or string are invalid if the container was reallocated. 
If no reallocation happens, indirect references to elements before the insertion remain valid; 
those to elements after the insertion are invalid.
• Iterators, pointers, and references to a deque are invalid if we add elements anywhere but at the front or back. 
If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not.
• Iterators, pointers, and references (including the off-the-end and the beforethe- beginning iterators) to a list or forward_list remain valid,
2) It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. 
After all, those elements have been destroyed. 
After we remove an element, 
• All other iterators, references, or pointers (including the off-the-end and the before-the-beginning iterators) 
to a list or forward_list remain valid.
• All other iterators, references, or pointers to a deque are invalidated if the removed elements are anywhere but the front or back. 
If we remove elements at the back of the deque, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; 
they are also unaffected if we remove from the front.
• All other iterators, references, or pointers to a vector or string remain valid for elements before the removal point. 
Note: The off-the-end iterator is always invalidated when we remove elements.
---> How about reallocation during deletion? Does that not happen? 
From Bard: Iterators that point to elements before the removal point will still be valid. 
This is because the elements before the removal point are not moved when the vector is reallocated.


-> NOTE: It is a serious run-time error to use an iterator, pointer, or reference that has been invalidated.


-> NOTE: ADVICE: MANAGING ITERATORS
When you use an iterator (or a reference or pointer to a container element), 
it is a good idea to minimize the part of the program during which an iterator must stay valid.
Because code that adds or removes elements to a container can invalidate iterators, 
you need to ensure that the iterator is repositioned, as appropriate, 
after each operation that changes the container. 
This advice is especially important for vector, string, and deque.


-> NOTE: Avoid Storing the Iterator Returned from end


-> NOTE: Don’t cache the iterator returned from end() in loops that insert or delete elements in a deque, string, or vector.


-> NOTE: reserve()
A call to reserve changes the capacity of the vector only if the requested space exceeds the current capacity. 
If the requested size is greater than the current capacity, reserve allocates at least as much as (and may allocate more than) the requested amount.
If the requested size is less than or equal to the existing capacity, reserve does nothing. 
In particular, calling reserve with a size smaller than capacity does not cause the container to give back memory. 
Thus, after calling reserve, the capacity will be greater than or equal to the argument passed to reserve.
As a result, a call to reserve will never reduce the amount of space that the container uses. 
Similarly, the resize members (§ 9.3.5, p. 352) change only the number of elements in the container, not its capacity. 
We cannot use resize to reduce the memory a container holds in reserve.

-> NOTE: reserve does not change the number of elements in the container; it affects only how much memory the vector preallocates.


-> NOTE: shrink_to_fit()
Under the new library, we can call shrink_to_fit to ask a deque, vector,
or string to return unneeded memory. This function indicates that we no longer need any excess capacity. 
However, the implementation is free to ignore this request.
There is no guarantee that a call to shrink_to_fit will return memory.


-> NOTE: Container Size Management
shrink_to_fit valid only for vector, string, and deque.
capacity and reserve valid only for vector and string.
1) shrink_to_fit()
c.shrink_to_fit() 
Request to reduce capacity() to equal size().
2) capacity()
c.capacity() 
Number of elements c can have before reallocation is necessary.
3) reserve()
c.reserve(n) 
Allocate space for at least n elements.


-> NOTE: ME: The containers will reach the capacity first before reallocation. (so capacity and size will be equal)


-> NOTE: Each vector implementation can choose its own allocation strategy.
However, it must not allocate new memory until it is forced to do so. (ME: so it will reach it capacity first before reallocation)


-> NOTE: A vector may be reallocated only when the user performs an insert operation when the size equals capacity
or by a call to resize or reserve with a value that exceeds the current capacity. 
How much memory is allocated beyond the specified amount is up to the implementation.


-> NOTE: Additional Ways to Construct strings
n, len2 and pos2 are all unsigned values
1) Construction from char array
string s(cp, n); 
s is a copy of the first n characters in the array to which cp points. 
That array must have at least n characters.
2) Construction of a substring from existing string with position
string s(s2, pos2); s is a copy of the characters in the string s2 starting at the index pos2. 
Undefined if pos2 > s2.size().
2) Construction of a substring from existing string with position and length
string s(s2, pos2, len2); 
s is a copy of len2 characters from s2 starting at the index pos2. 
Undefined if pos2 > s2.size().
Regardless of the value of len2, copies at most s2.size() - pos2 characters


-> NOTE: Substring Operation
s.substr(pos, n) 
Return a string containing n characters from s starting at pos. 
pos defaults to 0. 
n defaults to a value that causes the library to copy all the characters in s starting from pos.


-> NOTE: Operations to Modify strings
1) s.insert(pos, args) 
Insert characters specified by args before pos. pos can be an index or an iterator. 
Versions taking an index return a reference to s; those taking an iterator return an iterator denoting the first inserted character.
2) s.erase(pos, len) 
Remove len characters starting at position pos. 
If len is omitted, removes characters from pos to the end of the s.
Returns a reference to s.
3) s.assign(args) 
Replace characters in s according to args (ME: same arguments with the constructor?). 
Returns a reference to s.
4) s.append(args) 
Append args to s. 
Returns a reference to s.
5) s.replace(range, args) 
Remove range of characters from s and replace them with the characters formed by args. 
range is either an index and a length or a pair of iterators into s. 
Returns a reference to s.
----------------------------------------------------------------------------------
args: can be one of the following; append and assign can use all forms:
1) str: must be distinct from s and the iterators b and e may not refer to s
2) str, pos, len: Up to len characters from str starting at pos.
3) cp, len: Up to len characters from the character array pointed to by cp.
4) cp: Null-terminated array pointed to by pointer cp.
5) n, c: n copies of character c.
6) b, e: Characters in the range formed by iterators b and e.
7) initializer_list: Comma-separated list of characters enclosed in braces.


-> NOTE: string Search Operations
Search operations return the index of the desired character or npos if not found
1) s.find(args) 
Find the first occurrence of args in s.
2) s.rfind(args) 
Find the last occurrence of args in s.
3) s.find_first_of(args) 
Find the first occurrence of any character from args in s.
4) s.find_last_of(args) 
Find the last occurrence of any character from args in s.
5) s.find_first_not_of(args) 
Find the first character in s that is not in args.
6) s.find_last_not_of(args) 
Find the last character in s that is not in args.
----------------------------------------------------------------------------------
args must be one of
1) c, pos:  Look for the character c starting at position pos in s. pos defaults to 0.
2) s2, pos:  Look for the string s2 starting at position pos in s. pos defaults to 0.
3) cp, pos Look for the C-style null-terminated string pointed to by the pointer cp. 
Start looking at position pos in s. pos defaults to 0.
4) cp, pos, n Look for the first n characters in the array pointed to by the pointer cp. 
Start looking at position pos in s. No default for pos or n.


-> NOTE: The string search functions return string::size_type, which is an unsigned type. 
As a result, it is a bad idea to use an int, or other signed type, to hold the return from these functions (§ 2.1.2, p. 36).


-> NOTE: Specifying Where to Start the Search
We can pass an optional starting position to the find operations. 
This optional argument indicates the position from which to start the search. 
By default, that position is set to zero.
ME: This is useful when doing continuous searching on the same string.


-> NOTE: Searching Backward
The find operations we’ve used so far execute left to right. 
The library provides analogous operations that search from right to left. 
The rfind member searches for the last—that is, right-most—occurrence of the indicated substring:
string river("Mississippi");
auto first_pos = river.find("is"); // returns 1
auto last_pos = river.rfind("is"); // returns 4



-> NOTE: Numeric Conversions
1) number to string conversion
to_string(val); 
Overloaded functions returning the string representation of val.
val can be any arithmetic type (§ 2.1.1, p. 32). 
There are versions of to_string for each floating-point type and integral type that is int or larger. 
Small integral types are promoted (§ 4.11.1, p. 160) as usual.
2) string to integer conversion
stoi(s, p, b)
stol(s, p, b)
stoul(s, p, b)
stoll(s, p, b)
stoull(s, p, b)
Return the initial substring of s that has numeric content as an int, long, unsigned long, long long, unsigned long long, respectively.
b indicates the numeric base to use for the conversion; b defaults to 10. 
p is a pointer to a size_t in which to put the index of the first nonnumeric character in s; 
p defaults to 0, in which case the function does not store the index.
3) string to floating point conversion
stof(s, p)
stod(s, p)
stold(s, p)
Return the initial numeric substring in s as a float, double, or long double, respectively.
p has the same behavior as described for the integer conversions.


-> NOTE: If the string can’t be converted to a number, These functions throw an invalid_argument exception (§ 5.6, p. 193). 
If the conversion generates a value that can’t be represented, they throw out_of_range.



-> NOTE: Container Adaptors
In addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue.
An adaptor is a general concept in the library. 
There are container, iterator, and function adaptors.


-> NOTE: Operations and Types Common to the Container Adaptors
1) size_type: Type large enough to hold the size of the largest object of this type.
2) value_type: Element type.
3) container_type: Type of the underlying container on which the adaptor is implemented.
4) A a;
Create a new empty adaptor named a.
5) A a(c); 
Create a new adaptor named a with a copy of the container c.
6) relational operators: 
Each adaptor supports all the relational operators: ==, !=, <, <=, >, >=.
These operators return the result of comparing the underlying containers.
7) a.empty() 
false if a has any elements, true otherwise.
8) a.size() 
Number of elements in a.
9) swap(a, b) or a.swap(b)
Swaps the contents of a and b; a and b must have the same type, 
including the type of the container on which they are implemented.


-> NOTE: Defining an Adaptor
By default both STACK and QUEUE are implemented in terms of DEQUE, and a PRIORITY_QUEUE is implemented on a VECTOR. 
We can override the default container type by naming a sequential container as a second type argument when we create the adaptor
stack<int> stk(deq); // copies elements from deq into stk
stack<string, vector<string>> str_stk; // empty stack implemented on top of vector
stack<string, vector<string>> str_stk2(svec); // str_stk2 is implemented on top of vector and initially holds a copy of svec


-> NOTE: Stack Operations in Addition to Those in Table 9.17
Uses deque by default; can be implemented on a list or vector as well.
1) s.pop() 
Removes, but does not return, the top element from the stack.
2) s.push(item) and s.emplace(args)
Creates a new top element on the stack by copying ormoving item, or by constructing the element from args.
3) s.top() 
Returns, but does not remove, the top element on the stack.


-> NOTE: queue, priority_queue Operations in Addition to Table 9.17
By default queue uses deque and priority_queue uses vector;
queue can use a list or vector as well, priority_queue can use a deque.
1) q.pop() 
Removes, but does not return, the front element or highest-priority element from the queue or priority_queue, respectively.
2) q.front() and q.back()
Returns, but does not remove, the front or back element of q. Valid only for queue
3) q.top() 
Returns, but does not remove, the highest-priority element. Valid only for priority_queue.
4) q.push(item) and q.emplace(args)
Create an element with value item or constructed from args at the end of the queue or in its appropriate position in priority_queue.


KEY CONCEPT: ALGORITHMS NEVER EXECUTE CONTAINER OPERATIONS
The generic algorithms do not themselves execute container operations. 
They operate solely in terms of iterators and iterator operations. 
The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: 
Algorithms never change the size of the underlying container.
Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. 
They do not, however, ever add or remove elements directly.
As we’ll see in § 10.4.1 (p. 401), there is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. 
When we assign to these iterators, they execute insert operations on the unde rlying container. 
When an algorithm operates on one of these iterators, the iterator may have the effect of adding elements to the container. 
The algorithm itself, however, never does so.


-> NOTE: The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.
int sum = accumulate(vec.cbegin(), vec.cend(), 0); // sum the elements in vec starting the summation with the value 0


-> NOTE: Ordinarily it is best to use cbegin() and cend() (§ 9.2.3, p. 334) with algorithms that read, but do not write, the elements. 
However, if you plan to use the iterator returned by the algorithm to change an element’s value, then you need to pass begin() and end().


-> NOTE: Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.


-> NOTE: KEY CONCEPT: ITERATOR ARGUMENTS
Some algorithms read elements from two sequences. 
The elements that constitute these sequences can be stored in different kinds of containers. 
For example, the first sequence might be stored in a vector and the second might be in a list, a deque, a built-in array, or some other sequence. 
Moreover, the element types in the two sequences are not required to match exactly. 
What is required is that we be able to compare elements from the two sequences. 
For example, in the equal algorithm, the element types need not be identical, 
but we do have to be able to use == to compare elements from the two sequences.
Algorithms that operate on two sequences differ as to how we pass the second sequence.
Some algorithms, such as equal, take three iterators: 
The first two denote the range of the first sequence, and the third iterator denotes the first element in the second sequence. 
Others take four iterators: The first two denote the range of elements in the first sequence, 
and the second two denote the range for the second sequence.
Algorithms that use a single iterator to denote the second sequence assume that the second sequence is at least as large as the first. 
It is up to us to ensure that the algorithm will not attempt to access a nonexistent element in the second sequence.
For example, the equal algorithm potentially compares every element from its first sequence to an element in the second. 
If the second sequence is a subset of the first, then our program has a serious error—equal will attempt to access elements beyond the end of the second sequence.


-> NOTE: Algorithms that write to a destination iterator assume the destination is large enough to hold the number of elements being written.


-> NOTE: Introducing the back_inserter
One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator.
An insert iterator is an iterator that adds elements to a container. 
Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. 
When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.


-> NOTE: The library algorithms operate on iterators, not containers. 
Therefore, an algorithm cannot (directly) add or remove elements.



-> NOTE: Introducing Lambdas
We can pass any kind of callable object to an algorithm. 
An object or expression is callable if we can apply the call operator (§ 1.5.2, p. 23) to it. 
That is, if e is a callable expression, we can write e(args) where args is a comma-separated list of zero or more arguments.
Some other callables are functions and function pointers (§ 6.7,p. 247).
And there are two other kinds of callables: classes that overload the function call operator, which we’ll cover in § 14.8 (p. 571), and lambda expressions.
A lamba expression has the form:
[capture list](parameter list) -> return type { function body }


-> NOTE: Omitting the parentheses and the parameter list in a lambda is equivalent to specifying an empty parameter list.
auto f = [] { return 42; };


-> NOTE: Lambda return type:
If we omit the return type, the lambda has an inferred return type that depends on the code in the function body.
If the function body is just a return statement, the return type is inferred from the type of the expression that is returned.
Otherwise, the return type is void.


-> NOTE: Lambdas with function bodies that contain anything other than a single return statement that do not specify a return type return void.


-> NOTE: A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.


-> NOTE: The capture list is used for local nonstatic variables only; lambdas can use local statics and variables declared outside the function directly.


-> NOTE: Similar to function parameters, lambda capture can be "Capture by Value" or "Capture by Reference"
auto f = [v1] { return v1; }; // capture by value
auto f2 = [&v1] { return v1; }; //capture by reference


-> NOTE: When we capture a variable by reference, we must ensure that the variable exists at the time that the lambda executes.


-> NOTE: ADVICE: KEEP YOUR LAMBDA CAPTURES SIMPLE
A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) 
and the time (or times) the lambda itself is executed.
It is the programmer’s responsibility to ensure that whatever information
is captured has the intended meaning each time the lambda is executed.
Capturing an ordinary variable—an int, a string, or other nonpointer type— by value is usually straightforward. 
In this case, we only need to care whether the variable has the value we need when we capture it.
If we capture a pointer or iterator, or capture a variable by reference, 
we must ensure that the object bound to that iterator, pointer, or reference still exists, 
whenever the lambda executes. 
Moreover, we need to ensure that the object has the intended value. 
Code that executes between when the lambda is created and when it executes might change 
the value of the object to which the lambda capture points (or refers).
The value of the object at the time the pointer (or reference) was captured might have been what we wanted. 
The value of that object when the lambda executes might be quite different.
As a rule, we can avoid potential problems with captures by minimizing the data we capture. 
Moreover, if possible, avoid capturing pointers or references.


-> NOTE: Implicit Captures
Rather than explicitly listing the variables we want to use from the enclosing function,
we can let the compiler infer which variables we use from the code in the lambda’s body.
To direct the compiler to infer the capture list, we use an & or = in the capture list. 
The & tells the compiler to capture by reference, and the = says the values are captured by value.
wc = find_if(words.begin(), words.end(), [=](const string &s) { return s.size() >= sz; }); // capture by value
wc = find_if(words.begin(), words.end(), [&](const string &s) { return s.size() >= sz; }); // capture by reference


-> NOTE: Lambda Capture List
1) Empty capture list. 
[] 
The lambda may not use variables from the enclosing function. 
A lamba may use local variables only if it captures them.
2) Capture list with names
[names] 
names is a comma-separated list of names local to the enclosing function.
By default, variables in the capture list are copied. 
A name preceded by & is captured by reference.
3) Implicit reference capture list
[&] 
Implicit by reference capture list. 
Entities from the enclosing function used in the lambda body are used by reference.
4) Implicit value capture list
[=] 
Implicit by value capture list. 
Entities from the enclosing function used in the lambda body are copied into the lambda body.
5) Implicit reference capture list with explicitly names list with value.
[&, identifier_list] 
identifier_list is a comma-separated list of zero or more variables from the enclosing function. 
These variables are captured by value; any implicitly captured variables are captured by reference. 
The names in identifier_list must not be preceded by an &.
6) Implicit value capture list with explicitly names list with reference.
[=, reference_list] 
Variables included in the reference_list are captured by reference; any
implicitly captured variables are captured by value. The names in
reference_list may not include this and must be preceded by an &.


-> NOTE: Mutable Lambdas
By default, a lambda may not change the value of a variable that it copies by value.
If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword mutable.
auto f = [v1] () mutable { return ++v1; };


-> NOTE: Specifying the Lambda Return Type
When we need to define a return type for a lambda, we must use a trailing return type (§ 6.3.3, p. 229):
transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int { if (i < 0) return -i; else return i; });



-> NOTE: Binding Arguments
Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. 
If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. 
Similarly, if an operation requires many statements, it is ordinarily better to use a function.


-> NOTE: '’Effective Modern C++’’, Item 34: Prefer lambdas to std::bind.


-> NOTE: The Library bind Function
We can solve the problem of passing a size argument to check_size by using a new library function named bind, which is defined in the functional header.
The bind function can be thought of as a general-purpose function adaptor (§ 9.6, p. 368). 
It takes a callable object and generates a new callable that “adapts” the parameter list of the original object.


-> NOTE: bind() function form:
The general form of a call to bind is:
auto newCallable = bind(callable, arg_list);
where newCallable is itself a callable object and arg_list is a comma-separated list of arguments that correspond to the parameters of the given callable. 
That is, when we call new Callable, newCallable calls callable, passing the arguments in arg_list.
The arguments in arg_list may include names of the form _n, where n is an integer. 
These arguments are “placeholders” representing the parameters of new-Callable. 
They stand “in place of” the arguments that will be passed to newCallable.
The number n is the position of the parameter in the generated callable: _1 is the first parameter in newCallable, _2 is the second, and so forth.
Example:
auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));



-> NOTE: Using placeholders Names
The _n names are defined in a namespace named placeholders. 
That namespace is itself defined inside the std namespace (§ 3.1, p. 82). 
To use these names, we must supply the names of both namespaces. 
As with our other examples, our calls to bind assume the existence of appropriate using declarations. 
For example, the using declaration for _1 is using std::placeholders::_1;


-> NOTE: Arguments to bind
As we’ve seen, we can use bind to fix the value of a parameter. 
More generally, we can use bind to bind or rearrange the parameters in the given callable. 
For example, assuming f is a callable object that has five parameters, the following call to bind:
// g is a callable object that takes two arguments
auto g = bind(f, a, b, _2, c, _1);
This generates a new callable that takes two arguments, represented by the placeholders _2 and _1. 
The new callable will pass its own arguments as the third and fifth arguments to f. 
The first, second, and fourth arguments to f are bound to the given values, a, b, and c, respectively.
In effect, this call to bind maps:
g(X, Y)
to
f(a, b, Y, c, X)


-> NOTE: Using to bind to Reorder Parameters
As a more concrete example of using bind to reorder arguments, we can use bind to invert the meaning of isShorter by writing
sort(words.begin(), words.end(), isShorter); // sort on word length, shortest to longest
sort(words.begin(), words.end(), bind(isShorter, _2, _1)); // sort on word length, longest to shortest


-> NOTE: Binding Reference Parameters
By default, the arguments to bind that are not placeholders are copied into the callable object that bind returns. 
However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference 
or we might want to bind an argument that has a type that we cannot copy.
for_each(words.begin(), words.end(), bind(print, os, _1, ’ ’)); // error: cannot copy os
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ’ ’)); // using ref function
The ref function returns an object that contains the given reference and that is itself copyable.
There is also a cref function that generates a class that holds a reference to const.
Like bind, the ref and cref functions are defined in the functional header.


-> NOTE: BACKWARD COMPATIBILITY: BINDING ARGUMENTS
Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. 
The library defined two functions named bind1st and bind2nd. 
Like bind, these functions take a function and generate a new callable object that calls 
the given function with one of its parameters bound to a given value. 
However, these functions can bind only the first or second parameter, respectively. 
Because they are ofmuch more limited utility, they have been deprecated in the new standard. 
A deprecated feature is one that may not be supported in future releases. 
Modern C++ programs should use bind.



-> NOTE: Revisiting Iterators
In addition to the iterators that are defined for each of the containers, 
the library defines several additional kinds of iterators in the iterator header. 
These iterators include
• Insert iterators: 
These iterators are bound to a container and can be used to insert elements into the container.
• Stream iterators: 
These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.
• Reverse iterators: 
These iterators move backward, rather than forward. 
The library containers, other than forward_list, have reverse iterators.
• Move iterators: 
These special-purpose iterators move rather than copy their elements. 
We’ll cover move iterators in § 13.6.2 (p. 543).


-> NOTE: Insert Iterators
An inserter is an iterator adaptor (§ 9.6, p. 368) that takes a container and yields an iterator that adds elements to the specified container. 
When we assign a value through an insert iterator, the iterator calls a container operation to add an element at a specified position in the given container. 
The operations these iterators support are listed in Table 10.2 (overleaf).
There are three kinds of inserters. Each differs from the others as to where elements are inserted:
• back_inserter (§ 10.2.2, p. 382) creates an iterator that uses push_back.
• front_inserter creates an iterator that uses push_front.
• inserter creates an iterator that uses insert. This function takes a second argument, which must be an iterator into the given container. 
Elements are inserted ahead of the element denoted by the given iterator.


-> NOTE: We can use front_inserter only if the container has push_front.
Similarly, we can use back_inserter only if it has push_back.


-> NOTE: Insert Iterator Operations
1) it = t 
Inserts the value t at the current position denoted by it. 
Depending on the kind of insert iterator, and assuming c is the container to which it is bound, 
calls c.push_back(t), c.push_front(t), or c.insert(t, p), where p is the iterator position given to inserter.
2) *it, ++it, it++ 
These operations exist but do nothing to it. Each operator returns it.


-> NOTE: It is important to understand that when we call inserter(c, iter), we get an iterator that, when used successively, 
inserts elements ahead of the element originally denoted by iter. 
That is, if it is an iterator generated by inserter, then an assignment such as:
*it = val;
behaves as:
it = c.insert(it, val); // it points to the newly added element
++it; // increment it so that it denotes the same element as before


-> NOTE: iostream Iterators
When we create a stream iterator, we must specify the type of objects that the iterator will read or write. 
An istream_iterator uses >> to read a stream.
Therefore, the type that an istream_iterator reads must have an input operator defined. 
When we create an istream_iterator, we can bind it to a stream.
Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value.
istream_iterator<int> int_it(cin); // reads ints from cin
istream_iterator<int> int_eof; // end iterator value
ifstream in("afile");
istream_iterator<string> str_it(in); // reads strings from" afile"
As an example, we can use an istream_iterator to read the standard input into a vector:
istream_iterator<int> in_iter(cin); // read ints fro mcin
istream_iterator<int> eof; // istream ‘‘end’’ iterator
while (in_iter != eof) // while there’s valid input to read
// postfix increment reads the stream and returns the old value of the iterator
// we dereference that iterator to get the previous value read fromthe stream
vec.push_back(*in_iter++);


-> NOTE: istream_iterator Operations
1) istream_iterator<T> in(is); 
in reads values of type T from input stream is.
2) istream_iterator<T> end; 
Off-the-end iterator for an istream_iterator that reads values of type T.
3) in1 == in2 or in1 != in2
in1 and in2 must read the same type. 
They are equal if they are both the end value or are bound to the same input stream.
4) *in 
Returns the value read from the stream.
5) in->mem 
Synonym for (*in).mem.
6) ++in, in++ 
Reads the next value from the input stream using the >> operator for the element type. 
As usual, the prefix version returns a reference to the incremented iterator. 
The postfix version returns the old value.


-> NOTE: istream_iterators Are Permitted to Use Lazy Evaluation
When we bind an istream_iterator to a stream, we are not guaranteed that it will read the stream immediately. 
The implementation is permitted to delay reading the stream until we use the iterator. 
We are guaranteed that before we dereference the iterator for the first time, the stream will have been read. 
For most programs, whether the read is immediate or delayed makes no difference. 
However, if we create an istream_iterator that we destroy without using 
or if we are synchronizing reads to the same stream from two different objects, 
then we might care a great deal when the read happens.


-> NOTE: Operations on ostream_iterators
An ostream_iterator can be defined for any type that has an output operator (the << operator). 
When we create an ostream_iterator, we may (optionally) provide a second argument that specifies a character string 
to print following each element. That string must be a C-style character string (i.e., a string literal or a pointer to a null-terminated array). 
We must bind an ostream_iterator to a specific stream.
There is no empty or off-the-end ostream_iterator


-> NOTE: ostream_iterator Operations
1) ostream_iterator<T> out(os); 
out writes values of type T to output stream os.
2) ostream_iterator<T> out(os, d); 
out writes values of type T followed by d to output stream os. 
d points to a null-terminated character array.
3) out = val 
Writes val to the ostream to which out is bound using the << operator.
val must have a type that is compatible with the type that out can write.
4) *out, ++out, out++
These operations exist but do nothing to out. 
Each operator returns out.


-> NOTE: The * and ++ operators do nothing on an ostream_iterator, so omitting them has no effect. 
However, we prefer to write the loop as first presented.
That loop uses the iterator consistently with how we use other iterator types. 
We can easily change this loop to execute on another iterator type.
Moreover, the behavior of this loop will be clearer to readers of our code.


-> NOTE: Reverse Iterators
A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. 
A reverse iterator inverts the meaning of increment (and decrement). 
Incrementing (++it) a reverse iterator moves the iterator to the previous element; derementing (--it) moves the iterator to the next element.


-> NOTE: Reverse Iterators Require Decrement Operators
Not surprisingly, we can define a reverse iterator only from an iterator that supports -- as well as ++. 
After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. 
Aside from forward_list, the iterators on the standard containers all support decrement as well as increment.
However, the stream iterators do not, because it is not possible to move backward through a stream. 
Therefore, it is not possible to create a reverse iterator from a forward_list or a stream iterator.


-> NOTE: The fact that reverse iterators are intended to represent ranges 
and that these ranges are asymmetric has an important consequence: 
When we initialize or assign a reverse iterator from a plain iterator, 
the resulting iterator does not refer to the same element as the original.


-> NOTE: The Five Iterator Categories
1) Input iterators: can read elements in a sequence. 
An input iterator must provide:
• Equality and inequality operators (==, !=) to compare two iterators
• Prefix and postfix increment (++) to advance the iterator
• Dereference operator (*) to read an element; dereference may appear only on the right-hand side of an assignment
• The arrow operator (->) as a synonym for (*it).member—that is, dereference the iterator and fetch a member from the underlying object
2) Output iterators: can be thought of as having complementary functionality to input iterators; they write rather than read elements. 
Output iterators must provide
• Prefix and postfix increment (++) to advance the iterator
• Dereference (*), which may appear only as the left-hand side of an assignment 
(Assigning to a dereferenced output iterator writes to the underlying element.)
3) Forward iterators: can read and write a given sequence. 
They move in only one direction through the sequence. 
Forward iterators support all the operations of both input iterators and output iterators. 
Moreover, they can read or write the same element multiple times. 
Therefore, we can use the saved state of a forward iterator.
Hence, algorithms that use forward iterators may make multiple passes through the sequence. 
The replace algorithm requires a forward iterator; iterators on forward_list are forward iterators.
4) Bidirectional iterators: can read and write a sequence forward or backward. 
In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (--) operators. 
The reverse algorithm requires bidirectional iterators, and aside from forward_list, 
the library containers supply iterators that meet the requirements for a bidirectional iterator.
5)  Random-access iterators: provide constant-time access to any position in the sequence.
These iterators support all the functionality of bidirectional iterators. 
In addition, random-access iterators support the operations from Table 3.7 (p. 111):
• The relational operators (<, <=, >, and >=) to compare the relative positions of two iterators.
• Addition and subtraction operators (+, +=, -, and -=) on an iterator and an integral value. 
The result is the iterator advanced (or retreated) the integral number of elements within the sequence.
• The subtraction operator (-) when applied to two iterators, which yields the distance between two iterators.
• The subscript operator (iter[n]) as a synonym for *(iter + n).



-> NOTE: Associative containers support efficient lookup and retrieval by a key. 
The two primary associative-container types are map and set. 
The elements in a map are key–value pairs: 
The key serves as an index into the map, and the value represents the data associated with that index.


-> NOTE: Associative Container Types
----------------------------------------------------------------------------
Elements Ordered by Key
----------------------------------------------------------------------------
map Associative array; holds key–value pairs
set Container in which the key is the value
multimap map in which a key can appear multiple times
multiset set in which a key can appear multiple times
----------------------------------------------------------------------------
Unordered Collections
----------------------------------------------------------------------------
unordered_map map organized by a hash function
unordered_set set organized by a hash function
unordered_multimap Hashed map; keys can appear multiple times
unordered_multiset Hashed set; keys can appear multiple times


-> NOTE: Callable objects passed to a sort algorithm (§ 10.3.1, p. 386) must meet the same requirements as do the keys in an associative container.


-> NOTE: Key Types for Ordered Containers
Just as we can provide our own comparison operation to an algorithm (§ 10.3, p. 385), 
we can also supply our own operation to use in place of the < operator on keys. 
The specified operation must define a strict weak ordering over the key type. 
We can think of a strict weak ordering as “less than,” 
although our function might use a more complicated procedure. 
However we define it, the comparison function must have the following properties:
• Two keys cannot both be “less than” each other; if k1 is “less than” k2, then k2 must never be “less than” k1.
• If k1 is “less than” k2 and k2 is “less than” k3, then k1 must be “less than” k3.
• If there are two keys, and neither key is “less than” the other, then we’ll say that those keys are “equivalent.” 
If k1 is “equivalent” to k2 and k2 is “equivalent” to k3, then k1 must be “equivalent” to k3.
If two keys are equivalent (i.e., if neither is “less than” the other), 
the container treats them as equal. 
When used as a key to a map, there will be only one element associated with those keys, 
and either key can be used to access the corresponding value.


-> NOTE: In practice, what’s important is that a type that defines a < operator that “behaves normally” can be used as a key.


-> NOTE: The pair Type
A pair holds two data members. 
Like the containers, pair is a template from which we generate specific types. 
We must supply two type names when we create a pair. 
The data members of the pair have the corresponding types. 
There is no requirement that the two types be the same: 
pair<string, string> anon; // holds two strings
pair<string, size_t> word_count; // holds a string and an size_t
pair<string, vector<int>> line; // holds string and vector<int>


-> NOTE: Operations on pairs
1) pair<T1, T2> p; 
p is a pair with value initialized (§ 3.3.1, p. 98) members of types T1 and T2, respectively.
2) pair<T1, T2> p(v1, v2); 
p is a pair with types T1 and T2; the first and second members are initialized from v1 and v2, respectively.
3) pair<T1, T2> p = {v1, v2}; 
Equivalent to p(v1, v2).
4) make_pair(v1, v2) 
Returns a pair initialized from v1 and v2. 
The type of the pair is inferred from the types of v1 and v2.
5) p.first 
Returns the (public) data member of p named first.
6) p.second Returns the (public) data member of p named second.
7) p1 relop p2 
Relational operators (<, >, <=, >=). 
Relational operators are defined as dictionary ordering: 
For example, p1 < p2 is true if p1.first < p2.first or if !(p2.first < p1.first) && p1.second < p2.second. 
Uses the element’s < operator.
8) p1 == p2 or p1 != p2
Two pairs are equal if their first and second members are respectively equal. 
Uses the element’s == operator.


-> NOTE: Associative Container Iterators Are Different
When we dereference an iterator, we get a reference to a value of the container’s value_type. 
In the case of map, the value_type is a pair in which first holds the const key and second holds the value.


-> NOTE: It is essential to remember that the value_type of a map is a pair and that we can change the value but not the key member of that pair.


-> NOTE: Iterators for sets Are const
Although the set types define both the iterator and const_iterator types, both types of iterators give us read-only access to the elements in the set. 
Just as we cannot change the key part of a map element, the keys in a set are also const.


-> NOTE: Iterating across an Associative Container
The output of this program is in alphabetical order. 
When we use an iterator to traverse a map, multimap, set, or multiset, the iterators  yield elements in ascending key order.


-> NOTE: Associative Containers and Algorithms
In general, we do not use the generic algorithms (Chapter 10) with the associative containers. 
The fact that the keys are const means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. 
Such algorithms need to write to the elements. 
The elements in the set types are const, and those in maps are pairs whose first element is const.
Associative containers can be used with the algorithms that read elements.
However, many of these algorithms search the sequence. 
Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. 
For example, as we’ll see in § 11.3.5 (p. 436), the associative containers define a member named find, which directly fetches the element with a given key. 
We could use the generic find algorithm to look for an element, but that algorithm does a sequential search. 
It is much faster to use the find member defined by the container than to call the generic version.
In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. 
For example, we might use the generic copy algorithm to copy the elements froman associative container into another sequence. 
Similarly, we can call inserter to bind an insert iterator (§ 10.4.1, p. 401) to an associative container. 
Using inserter, we can use the associative container as a destination for another algorithm.


-> NOTE: Associative Container insert Operations
1) c.insert(v) or c.emplace(args)
v value_type object; args are used to construct an element.
For map and set, the element is inserted (or constructed) only if an element with the given key is not already in c. 
Returns a pair containing an iterator referring to the element with the given key and a bool indicating whether the element was inserted.
For multimap and multiset, inserts (or constructs) the given element and returns an iterator to the new element.
2) c.insert(b, e) c.insert(il) (ME: YOU CAN HAVE INITIALIZER LIST IN INSERT)
b and e are iterators that denote a range of c::value_type values;
il is a braced list of such values. 
Returns void.
For map and set, inserts the elements with keys that are not already in c. 
For multimap and multiset inserts, each element in the range.
3) c.insert(p, v) or c.emplace(p, args)
Like insert(v) (or emplace(args)), but uses iterator p as a hint for where to begin the search for where the new element should be stored. 
Returns an iterator to the element with the given key.


-> NOTE: Testing the Return from insert
The value returned by insert (or emplace) depends on the container type and the parameters. 
For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. 
The first member of the pair is an iterator to the element with the given key; 
the second is a bool indicating whether that element was inserted, or was already there. 
If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. 
If the key isn’t present, then the element is inserted and the bool is true.


-> NOTE: Removing Elements from an Associative Container
1) c.erase(k) 
Removes every element with key k from c. Returns size_type
indicating the number of elements removed.
2) c.erase(p) 
Removes the element denoted by the iterator p from c. p must refer to an
actual element in c; it must not be equal to c.end(). Returns an iterator
to the element after p or c.end() if p denotes the last element in c.
3) c.erase(b, e) 
Removes the elements in the range denoted by the iterator pair b, e.
Returns e.


-> NOTE: Subscripting a map behaves quite differently from subscripting an array or vector: 
Using a key that is not already present adds an element with that key to the map.


-> NOTE: Using the Value Returned from a Subscript Operation
Another way in which the map subscript differs from other subscript operators we’ve used is its return type. 
Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. 
Not so for maps: when we subscript a map, we get a mapped_type object; when we dereference a map iterator, we get a value_type object.


-> NOTE: Unlike vector or string, the type returned by the map subscript operator differs from the type obtained by dereferencing a map iterator.


-> NOTE: Accessing Elements
The associative containers provide variousways to find a given element, which are described in Table 11.7 (p. 438). 
Which operation to use depends on what problem we are trying to solve. 
If all we care about is whether a particular element is in the container, it is probably best to use find. 
For the containers that can hold only unique keys, it probably doesn’t matterwhether we use find or count. 
However, for the containers with multiple keys, count has to do more work: 
If the element is present, it still has to count how many elements have the same key. 
If we don’t need the count, it’s best to use find:
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
iset.find(1); // returns an iterator that refers to the element with key == 1
iset.find(11); // returns the iterator == iset.end()
iset.count(1); // returns 1
iset.count(11); // returns 0


-> NOTE: Using find Instead of Subscript for maps
For the map and unordered_map types, the subscript operator provides the simplest method of retrieving a value. 
However, as we’ve just seen, using a subscript has an important side effect: 
If that key is not already in the map, then subscript inserts an element with that key. 
Whether this behavior is correct depends on our expectations. 
Our word-counting programs relied on the fact that using a nonexistent key as a subscript inserts an element with that key and value 0.
Sometimes, we want to know if an element with a given key is present without changing the map. 
We cannot use the subscript operator to determine whether an element is present, 
because the subscript operator inserts a new element if the key is not already there. 
In such cases, we should use find: 
if (word_count.find("foobar") == word_count.end())
cout << "foobar is not in the map" << endl;


-> NOTE: Finding Elements in a multimap or multiset
Finding an element in an associative container that requires unique keys is a simple matter—the element is or is not in the container. 
For the containers that allow multiple keys, the process is more complicated: 
There may be many elements with the given key. 
When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container.


-> NOTE: Operations to Find Elements in an Associative Container
lower_bound and upper_bound not valid for the unordered containers.
Subscript and at operations only for map and unordered_map that are not const.
1) c.find(k) 
Returns an iterator to the (first) element with key k, or the off-the-end iterator if k is not in the container.
2) c.count(k) 
Returns the number of elements with key k. 
For the containers with unique keys, the result is always zero or one.
3) c.lower_bound(k) 
Returns an iterator to the first element with key NOT less than k.
4) c.upper_bound(k) 
Returns an iterator to the first element with key greater than k.
5) c.equal_range(k) 
Returns a pair of iterators denoting the elements with key k. 
If k is not present, both members are c.end().


-> NOTE: We are guaranteed that iterating across a multimap or multiset returns all the elements with a given key in sequence.


-> NOTE: A Different, Iterator-Oriented Solution
Alternatively, we can solve our problem using lower_bound and upper_bound.
Each of these operations take a key and returns an iterator. 
If the key is in the container, the iterator returned from lower_bound will refer to the FIRST INSTANCE of that key 
and the iterator returned by upper_bound will refer just AFTER the LAST INSTANCE of the key.


-> NOTE: If the element is not in the multimap, then lower_bound and upper_bound will return equal iterators; 
both will refer to the point at which the key can be inserted without disrupting the order. 
Thus, calling lower_bound and upper_bound on the same key yields an iterator range (§ 9.2.1, p. 331) that denotes ALL the elements with that key.


-> NOTE: Of course, the iterator returned from these operations might be the off-the-end iterator for the container itself.
If the element we’re looking for has the largest key in the container, then upper_bound on that key returns the off-the-end iterator. 
If the key is not present and is larger than any key in the container, then the return from lower_bound will also be the off-the-end iterator.


-> NOTE: The iterator returned from lower_bound may or may not refer to an element with the given key. 
If the key is not in the container, then lower_bound REFERS TO THE FIRST POINT 
at which this key can be inserted WHILE PRESERVING THE ELEMENT ORDER within the container.


-> NOTE: If lower_bound and upper_bound return the same iterator, then the given key is not in the container.


-> NOTE: The equal_range Function
The remaining way to solve this problemis the most direct of the three approaches:
Instead of calling upper_bound and lower_bound, we can call equal_range.
This function takes a key and returns a pair of iterators. 
If the key is present, then the first iterator refers to the first instance of the key 
and the second iterator refers one past the last instance of the key. 
If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.


-> NOTE: Print each item
// definitions of authors and search_item as above
// beg and end denote the range of elements for this author
for (auto beg = authors.lower_bound(search_item),
end = authors.upper_bound(search_item);
beg != end; ++beg)
cout << beg->second << endl; // print each title
// definitions of authors and search_item as above
// pos holds iterators that denote the range of elements for this key
for (auto pos = authors.equal_range(search_item);
pos.first != pos.second; ++pos.first)
cout << pos.first->second << endl; // print each title



-> NOTE: The Unordered Containers
The new standard defines four unordered associative containers. 
Rather than using a comparison operation to organize their elements, 
these containers use a hash function and the key type’s == operator. 
An unordered container is most usefulwhenwe have a key type forwhich there is no obvious ordering relationship among the elements. 
These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive.


-> NOTE: Although hashing gives better average case performance in principle, 
achieving good results in practice often requires a fair bit of performance testing and tweaking. 
As a result, it is usually easier (and often yields better performance) to use an ordered container.


-> NOTE: Use an unordered container if the key type is inherently unordered or if performance testing reveals problems that hashing might solve.


-> NOTE: Using an Unordered Container
Aside fromoperations that manage the hashing, 
the unordered containers provide the same operations (find, insert, and so on) as the ordered containers. 
That means that the operations we’ve used on map and set apply to unordered_map and unordered_set as well. 
Similarly for the unordered versions of the containers that allow multiple keys.


-> NOTE: Managing the Buckets
The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. 
These containers use a hash function to map elements to buckets. 
To access an element, the container first computes the element’s hash code, which tells which bucket to search. 
The container puts all of its elements with a given hash value into the same bucket. 
If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. 
As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.


-> NOTE: Unordered Container Management Operations
-------------------------------------------------------------------------------------
Bucket Interface
-------------------------------------------------------------------------------------
1) c.bucket_count() 
Number of buckets in use.
2) c.max_bucket_count() 
Largest number of buckets this container can hold.
3) c.bucket_size(n) 
Number of elements in the nth bucket.
4) c.bucket(k) 
Bucket in which elements with key k would be found.
-------------------------------------------------------------------------------------
Bucket Iteration
-------------------------------------------------------------------------------------
5) local_iterator 
Iterator type that can access elements in a bucket.
6) const_local_iterator 
const version of the bucket iterator.
7) c.begin(n), c.end(n) 
Iterator to the first, one past the last element in bucket n.
8) c.cbegin(n), c.cend(n) 
Returns const_local_iterator.
-------------------------------------------------------------------------------------
Hash Policy
-------------------------------------------------------------------------------------
9) c.load_factor() 
Average number of elements per bucket. Returns float.
10) c.max_load_factor() 
Average bucket size that c tries to maintain. 
c adds buckets to keep load_factor <= max_load_factor. 
Returns float.
11) c.rehash(n) 
Reorganize storage so that bucket_count >= n and and bucket_count > size/max_load_factor.
12) c.reserve(n) 
Reorganize so that c can hold n elements without a rehash.


-> NOTE: Requirements on Key Type for Unordered Containers
By default, the unordered containers use the == operator on the key type to compare elements. 
They also use an object of type hash<key_type> to generate the hash code for each element. 
The library supplies versions of the hash template for the built-in types, including pointers. 
It also defines hash for some of the library types, including strings and the smart pointer types that we will describe in Chapter 12. 
Thus, we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer.
However, we cannot directly define an unordered container that uses a our own class types for its key type. 
Unlike the containers, we cannot use the hash template directly. 
Instead, we must supply our own version of the hash template.



-> NOTE: Dynamic Memory
Our programs have used only static or stack memory. 
Static memory is used for local static objects (§ 6.1.1, p. 205), for class static data members (§ 7.6, p. 300), 
and for variables defined outside any function. 
Stack memory is used for nonstatic objects defined inside functions. 
Objects allocated in static or stack memory are automatically created and destroyed by the compiler. 
Stack objects exist only while the block in which they are defined is executing; 
static objects are allocated before they are used, and they are destroyed when the program ends.
In addition to static or stack memory, every programalso has a pool of memory that it can use. 
This memory is referred to as the free store or heap. 
Programs use the heap for objects that they dynamically allocate—that is, 
for objects that the program allocates at run time. 
The program controls the lifetime of dynamic objects; 
our code must explicitly destroy such objects when they are no longer needed.


-> NOTE: Although necessary at times, dynamic memory is notoriously tricky to manage correctly.


-> NOTE: To make using dynamic memory easier (and safer), the new library provides two smart pointer types that manage dynamic objects. 
A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points.


-> NOTE: The shared_ptr Class
Like vectors, smart pointers are templates (§ 3.3, p. 96). 
Therefore, when we create a smart pointer, we must supply additional information—in this case, 
the type to which the pointer can point. 
As with vector, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining:
shared_ptr<string> p1; // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints


-> NOTE: The make_shared Function
The safest way to allocate and use dynamic memory is to call a library function named make_shared. 
This function allocates and initializes an object in dynamic memory and returns a shared_ptr that points to that object. 
Like the smart pointers, make_shared is defined in the memory header.
shared_ptr<int> p3 = make_shared<int>(42); // shared_ptr that points to an int with value 42
shared_ptr<string> p4 = make_shared<string>(10, ’9’); // p4 points to a string with value 9999999999
shared_ptr<int> p5 = make_shared<int>(); // p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0


-> NOTE: If we do not pass any arguments, then the object is value initialized (§ 3.3.1, p. 98).


-> NOTE: Operations Common to shared_ptr and unique_ptr
1) shared_ptr<T> sp or unique_ptr<T> up
Null smart pointer that can point to objects of type T.
2) p 
Use p as a condition; true if p points to an object.
3) *p 
Dereference p to get the object to which p points.
4) p->mem 
Synonym for (*p).mem.
5) p.get() 
Returns the pointer in p. 
Use with caution; the object to which the returned pointer points will disappear when the smart pointer deletes it.
6) swap(p, q) or p.swap(q)
Swaps the pointers in p and q.


-> NOTE: Reference count
We can think of a shared_ptr as if it has an associated counter, usually referred to as a reference count. 
Whenever we copy a shared_ptr, the count is incremented.
For example, the counter associated with a shared_ptr is incremented when we use it to initialize another shared_ptr, 
when we use it as the right-hand operand of an assignment, 
or when we pass it to (§ 6.2.1, p. 209) 
or return it from a function by value (§ 6.3.2, p. 224).
The counter is decremented when we assign a new value to the shared_ptr and when the shared_ptr itself is destroyed, 
such as when a local shared_ptr goes out of scope (§ 6.1.1, p. 204).
auto r = make_shared<int>(42); // int to which r points has one user
r = q; // assign to r, making it point to a different address
// increase the use count for the object to which q points
// reduce the use count of the object to which r had pointed
// the object r had pointed to has no users; that object is automatically freed


-> NOTE: It is up to the implementation whether to use a counter 
or another data structure to keep track of how many pointers share state. 
The key point is that the class keeps track of how many shared_ptrs point to the same object 
and automatically frees that object when appropriate.


-> NOTE: shared_ptrs Automatically Destroy Their Objects ...
When the last shared_ptr pointing to an object is destroyed, 
the shared_ptr class automatically destroys the object to which that shared_ptr points. 
It does so through another special member function known as a destructor.


-> NOTE: The destructor for shared_ptr decrements the reference count of the object to which that shared_ptr points. 
If the count goes to zero, the shared_ptr destructor destroys the object to which the shared_ptr points 
and frees the memory used by that object.


-> NOTE: Operations Specific to shared_ptr
1) make_shared<T>(args) 
Returns a shared_ptr pointing to a dynamically allocated object of type T. 
Uses args to initialize that object.
2) shared_ptr<T> 
p(q) p is a copy of the shared_ptr q; increments the count in q. 
The pointer in q must be convertible to T* (§ 4.11.2, p. 161).
3) p = q 
p and q are shared_ptrs holding pointers that can be converted to one another. 
Decrements p’s reference count and increments q’s count; 
deletes p’s existing memory if p’s count goes to 0.
4) p.unique() 
Returns true if p.use_count() is one; false otherwise.
5) p.use_count() 
Returns the number of objects sharing with p; may be a slow operation, intended primarily for debugging purposes.


-> NOTE: ... and Automatically Free the Associated Memory
The fact that the shared_ptr class automatically frees dynamic objects 
when they are no longer needed makes it fairly easy to use dynamic memory. 
For example, we might have a function that returns a shared_ptr 
to a dynamically allocated object of a type named Foo that can be initialized by an argument of type T.


-> NOTE: If you put shared_ptrs in a container, and you subsequently need to use some, 
but not all, of the elements, remember to erase the elements you no longer need.


-> NOTE: Classes with Resources That Have Dynamic Lifetime
Programs tend to use dynamic memory for one of three purposes:
1. They don’t know how many objects they’ll need
2. They don’t know the precise type of the objects they need
3. They want to share data between several objects


-> NOTE: One common reason to use dynamic memory is to allow multiple objects to share the same state.


-> NOTE: Managing Memory Directly
The language itself defines two operators that allocate and free dynamic memory.
The new operator allocates memory, and delete frees memory allocated by new.
For reasons that will become clear as we describe how these operators work, 
using these operators to manage memory is considerably more error-prone than using a smart pointer. 
Moreover, classes that do manage their own memory—
unlike those that use smart pointers—cannot rely on the default definitions for the members that copy, assign, and destroy class objects (§ 7.1.4, p. 264). 
As a result, programs that use smart pointers are likely to be easier to write and debug.


-> NOTE: Recommendation: Your classes should allocate dynamic memory only if they use smart pointers to manage that memory.


-> NOTE:  Using new to Dynamically Allocate and Initialize Objects

Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. 
Instead, new returns a pointer to the object it allocates: 
int *pi = new int; // pi points to a dynamically allocated, unnamed, uninitialized int

This new expression constructs an object of type int on the free store and returns a pointer to that object.
By default, dynamically allocated objects are default initialized (§ 2.2.1, p. 43),
which means that objects of built-in or compound type have undefined value; 
objects of class type are initialized by their default constructor:
string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

We can initialize a dynamically allocated object using direct initialization (§ 3.2.1, p. 84). 
We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, ’9’); // *ps is "9999999999"
// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
We can also value initialize (§ 3.3.1, p. 98) a dynamically allocated object by following the type name with a pair of empty parentheses:
string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

For class types (such as string) that define their own constructors (§ 7.1.4, p. 262),
requesting value initialization is of no consequence; 
regardless of form, the object is initialized by the default constructor. 
In the case of built-in types the difference is SIGNIFICANT; 
a value-initialized object of built-in type has a well-defined value but a default-initialized object does not. 
Similarly, members of built-in type in classes that rely on the synthesized default constructor 
will also be uninitialized if those members are not initialized in the class body (§ 7.1.4, p. 263).


-> NOTE: ME: By default, dynamically allocated objects are default initialized (ME: discussed above, this is just a reminder).


-> NOTE: For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.


-> NOTE: When we provide an initializer inside parentheses, 
we can use auto (§ 2.5.2, p. 68) to deduce the type of the object we want to allocate from that initializer.
However, because the compiler uses the initializer’s type to deduce the type to allocate, 
we can use auto only with a single initializer inside parentheses:
auto p1 = new auto(obj); // p points to an object of the type of obj
// that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer


-> NOTE: Dynamically Allocated const Objects
It is legal to use new to allocate const objects:
// allocate and initialize a const int
const int *pci = new const int(1024);
// allocate a default-initialized const empty string
const string *pcs = new const string;
Like any other const, a dynamically allocated const object must be initialized.
A const dynamic object of a class type that defines a default constructor (§ 7.1.4, p. 263) may be initialized implicitly. 
Objects of other types must be explicitly initialized.
Because the allocated object is const, the pointer returned by new is a pointer to const (§ 2.4.2, p. 62).



-> NOTE: Memory Exhaustion
Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. 
Once a program has used all of its available memory, new expressions will fail. 
By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc (§ 5.6, p. 193). 
We can prevent new from throwing an exception by using a different form of new:
// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

For reasons we’ll explain in § 19.1.2 (p. 824) this form of new is referred to as placement new. 
A placement new expression lets us pass additional arguments to new.
In this case, we pass an object named nothrow that is defined by the library.
When we pass nothrow to new, we tell new that it must not throw an exception. 
If this form of new is unable to allocate the requested storage, it will return a null pointer.
Both bad_alloc and nothrow are defined in the new header.


-> NOTE: Freeing Dynamic Memory
In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. 
We return memory through a delete expression. 
A delete expression takes a pointer to the object we want to free:
delete p; // p must point to a dynamically allocated object or be null
Like new, a delete expression performs two actions: 
It destroys the object to which its given pointer points, and it frees the corresponding memory.


-> NOTE: Pointer Values and delete
The pointer we pass to delete must either point to dynamically allocated memory or be a null pointer (§ 2.3.2, p. 53). 
Deleting a pointer to memory that was not allocated by new, or deleting the same pointer value more than once, is undefined:
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd; // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer
Although the value of a const object cannot be modified, the object itself can be destroyed. 
As with any other dynamic object, a const dynamic object is freed by executing delete on a pointer that points to that object:
const int *pci = new const int(1024);
delete pci; // ok: deletes a const object


-> NOTE: Dynamically Allocated Objects Exist until They Are Freed
As we saw in § 12.1.1 (p. 452), memory that is managed through a shared_ptr is automatically deleted when the last shared_ptr is destroyed. 
The same is not true for memory we manage using built-in pointers. 
A dynamic object managed through a built-in pointer exists until it is explicitly deleted.
Functions that return pointers (rather than smart pointers) to dynamic memory put a burden 
on their callers—the caller must remember to delete the memory:
// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg)
{
// process arg as appropriate
return new Foo(arg); // caller is responsible for deleting this memory
}
Unlike class types, nothing happens when objects of built-in type are destroyed.
In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. 
If that pointer points to dynamic memory, that memory is not automatically freed.


-> NOTE: Dynamic memory managed through built-in pointers (rather than smart pointers) exists until it is explicitly freed.


-> NOTE: CAUTION: MANAGING DYNAMIC MEMORY IS ERROR-PRONE
There are three common problems with using new and delete to manage dynamic memory:
1. Forgetting to delete memory. 
Neglecting to delete dynamic memory is known as a “memory leak,” because the memory is never returned to the free store.
Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually exhaust memory.
2. Using an object after it has been deleted. 
This error can sometimes be detected by making the pointer null after the delete.
3. Deleting the same memory twice. This error can happen when two pointers address the same dynamically allocated object. 
If delete is applied to one of the pointers, then the object’s memory is returned to the free store.
If we subsequently delete the second pointer, then the free store may be corrupted.
These kinds of errors are considerably easier to make than they are to find and fix.
You can avoid all of these problems by using smart pointers exclusively.
The smart pointer will take care of deleting the memory only when there are no remaining smart pointers pointing to that memory.


-> NOTE: Resetting the Value of a Pointer after a delete ...
When we delete a pointer, that pointer becomes invalid. 
Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. 
After the delete, the pointer becomes what is referred to as a dangling pointer. 
A dangling pointer is one that refers to memory that once held an object but no longer does so.


-> NOTE: Dangling pointers have all the problems of uninitialized pointers (§ 2.3.2, p. 54).
We can avoid the problems with dangling pointers by deleting the memory associated with a pointer 
just before the pointer itself goes out of scope. 
That way there is no chance to use the pointer after the memory associated with the pointer is freed.
If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. 
Doing so makes it clear that the pointer points to no object.


-> NOTE: ... Provides Only Limited Protection
A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. 
Resetting the pointer we use to delete that memory lets us check that particular pointer 
but has no effect on any of the other pointers that still point at the (freed) memory. 
For example:
int *p(new int(42)); // p points to dynamic memory
auto q = p; // p and q point to the same memory
delete p; // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object
Here both p and q point at the same dynamically allocated object. 
We delete that memory and set p to nullptr, indicating that the pointer no longer points to an object. 
However, resetting p has no effect on q, which became invalid when we deleted the memory to which p (and q!) pointed. 
In real systems, finding all the pointers that point to the same memory is surprisingly difficult.


-> NOTE: Using shared_ptrs with new
As we’ve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. 
As described in Table 12.3, we can also initialize a smart pointer from a pointer returned by new:
shared_ptr<double> p1; // shared_ptr that can point at a double
shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42
The smart pointer constructors that take pointers are explicit (§ 7.5.4, p. 296).
Hence, we cannot implicitly convert a built-in pointer to a smart pointer; 
we must use the direct form of initialization (§ 3.2.1, p. 84) to initialize a smart pointer:
shared_ptr<int> p1 = new int(1024); // error: must use direct initialization
shared_ptr<int> p2(new int(1024)); // ok: uses direct initialization
The initialization of p1 implicitly asks the compiler to create a shared_ptr from the int* returned by new. 
Because we can’t implicitly convert a pointer to a smart pointer, this initialization is an error. 
For the same reason, a function that returns a shared_ptr cannot implicitly convert a plain pointer in its return statement:
shared_ptr<int> clone(int p) {
return new int(p); // error: implicit conversion to shared_ptr<int>
}
We must explicitly bind a shared_ptr to the pointer we want to return:
shared_ptr<int> clone(int p) {
// ok: explicitly create a shared_ptr<int> from int*
return shared_ptr<int>(new int(p));
}
By default, a pointer used to initialize a smart pointer must point to dynamic memory because, 
by default, smart pointers use delete to free the associated object.
We can bind smart pointers to pointers to other kinds of resources. 
However, to do so, we must supply our own operation to use in place of delete. 
We’ll see how to supply our own deletion code in § 12.1.4 (p. 468).


-> NOTE: Don’t Mix Ordinary Pointers and Smart Pointers ...
A shared_ptr can coordinate destruction only with other shared_ptrs that are copies of itself.
Indeed, this fact is one of the reasons we recommend using make_shared rather than new. 
That way, we bind a shared_ptr to the object at the same time that we allocate it. 
There is no way to inadvertently bind the same memory to more than one independently created shared_ptr.
Consider the following function that operates on a shared_ptr:
// ptr is created and initialized when process is called
void process(shared_ptr<int> ptr)
{
// use ptr
} // ptr goes out of scope and is destroyed
The parameter to process is passed by value, so the argument to process is copied into ptr.
Copying a shared_ptr increments its reference count. 
Thus, inside process the count is at least 2. 
When process completes, the reference count of ptr is decremented but cannot go to zero. 
Therefore, when the local variable ptr is destroyed, the memory to which ptr points will not be deleted.
The right way to use this function is to pass it a shared_ptr:
shared_ptr<int> p(new int(42)); // reference count is 1
process(p); // copying p increments its count; in process the reference count is 2
int i = *p; // ok: reference count is 1
Although we cannot pass a built-in pointer to process, 
we can pass process a (temporary) shared_ptr that we explicitly construct from a built-in pointer.
However, doing so is likely to be an error:
int *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointer
process(x); // error: cannot convert int* to shared_ptr<int>
process(shared_ptr<int>(x)); // legal, but the memory will be deleted!
int j = *x; // undefined: x is a dangling pointer!
In this call, we passed a temporary shared_ptr to process. 
That temporary is destroyed when the expression in which the call appears finishes. 
Destroying the temporary decrements the reference count, which goes to zero. 
The memory to which the temporary points is freed when the temporary is destroyed.
But x continues to point to that (freed) memory; x is now a dangling pointer.
Attempting to use the value of x is undefined.
When we bind a shared_ptr to a plain pointer, we give responsibility for that memory to that shared_ptr. 
Once we give shared_ptr responsibility for a pointer, 
we should no longer use a built-in pointer to access the memory to which the shared_ptr now points.


-> NOTE: Other Ways to Define and Change shared_ptrs
1) shared_ptr<T> p(q) 
p manages the object to which the built-in pointer q points;
q must point to memory allocated by new and must be convertible to T*.
2) shared_ptr<T> p(u) 
p assumes ownership from the unique_ptr u; makes u null.
3) shared_ptr<T> p(q, d) 
p assumes ownership for the object to which the built-in pointer q points. 
q must be convertible to T* (§ 4.11.2, p. 161).
p will use the callable object d (§ 10.3.2, p. 388) in place of delete to free q.
4) shared_ptr<T> p(p2, d) 
p is a copy of the shared_ptr p2 as described in Table 12.2 except that p uses the callable object d in place of delete.
5) p.reset() or p.reset(q) or p.reset(q, d)
If p is the only shared_ptr pointing at its object, reset frees p’s existing object. 
If the optional built-in pointer q is passed, makes p point to q, otherwise makes p null. 
If d is supplied, will call d to free q otherwise uses delete to free q.


-> NOTE: ... and Don’t Use get to Initialize or Assign Another Smart Pointer
The smart pointer types define a function named get (described in Table 12.1 (p. 452)) 
that returns a built-in pointer to the object that the smart pointer is managing.
This function is intended for cases when we need to pass a built-in pointer to code that can’t use a smart pointer. 
The code that uses the return from get must not delete that pointer.
Although the compiler will not complain, it is an error to bind another smart pointer to the pointer returned by get:
shared_ptr<int> p(new int(42)); // reference count is 1
int *q = p.get(); // ok: but don’t use q in any way that might delete its pointer
{ // new block
// undefined: two independent shared_ptrs point to the same memory
shared_ptr<int>(q);
} // block ends, q is destroyed, and the memory to which q points is freed
int foo = *p; // undefined; the memory to which p points was freed
In this case, both p and q point to the same memory. 
Because they were created independently from each other, each has a reference count of 1. 
When the block in which q was defined ends, q is destroyed. 
Destroying q frees the memory to which q points. 
That makes p into a dangling pointer, meaning that what happens when we attempt to use p is undefined. 
Moreover, when p is destroyed, the pointer to that memory will be deleted a second time.


-> NOTE: Use get only to pass access to the pointer to code that you know will not delete the pointer. 
In particular, never use get to initialize or assign to another smart pointer.


-> NOTE: Other shared_ptr Operations
The shared_ptr class gives us a few other operations, which are listed in Table 12.2 (p. 453) and Table 12.3 (on the previous page). 
We can use reset to assign a newpointer to a shared_ptr:
p = new int(1024); // error: cannot assign a pointer to a shared_ptr
p.reset(new int(1024)); // ok: p points to a new object
Like assignment, reset updates the reference counts and, if appropriate, deletes the object to which p points. 
The reset member is often used together with unique to control changes to the object shared among several shared_ptrs. 
Before changing the underlying object, we check whether we’re the only user. 
If not, we make a new copy before making the change:
if (!p.unique()){
p.reset(new string(*p)); // we aren’t alone; allocate a new copy
}
*p += newVal; // now that we know we’re the only pointer, okay to change this object


-> NOTE: Smart Pointers and Exceptions
In § 5.6.2 (p. 196) we noted that programs that use exception handling to continue processing 
after an exception occurs need to ensure that resources are properly freed if an exception occurs. 
One easy way to make sure resources are freed is to use smart pointers.
When we use a smart pointer, the smart pointer class ensures that memory is freed 
when it is no longer needed even if the block is exited prematurely:
void f()
{
shared_ptr<int> sp(new int(42)); // allocate a new object
// code that throws an exception that is not caught inside f
} // shared_ptr freed automatically when the function ends
When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. 
In this case, sp is a shared_ptr, so destroying sp checks its reference count. 
Here, sp is the only pointer to the memory it manages; 
that memory will be freed as part of destroying sp.
In contrast, memory that we manage directly is not automatically freed when an exception occurs. 
If we use built-in pointers to manage memory and an exception occurs after a new but before the corresponding delete, then that memory won’t be freed:
void f()
{
int *ip = new int(42); // dynamically allocate a new object
// code that throws an exception that is not caught inside f
delete ip; // free the memory before exiting
}
If an exception happens between the new and the delete, and is not caught inside f, then this memory can never be freed. 
There is no pointer to this memory outside the function f. 
Thus, there is no way to free this memory.


-> NOTE: Smart Pointers and Dumb Classes
Many C++ classes, including all the library classes, define destructors (§ 12.1.1, p. 452) 
that take care of cleaning up the resources used by that object. 
However, not all classes are so well behaved. 
In particular, classes that are designed to be used by both C and C++ 
generally require the user to specifically free any resources that are used.

When we create a shared_ptr, we can pass an optional argument that points to a deleter function (§ 6.7, p. 247):
void f(destination &d /* other parameters */)
{
connection c = connect(&d);
shared_ptr<connection> p(&c, end_connection);
// use the connection
// when f exits, even if by an exception, the connection will be properly closed
}
When p is destroyed, it won’t execute delete on its stored pointer. 
Instead, p will call end_connection on that pointer. 
In turn, end_connection will call disconnect, thus ensuring that the connection is closed. 
If f exits normally, then p will be destroyed as part of the return. 
Moreover, p will also be destroyed, and the connection will be closed, if an exception occurs.



-> NOTE: CAUTION: SMART POINTER PITFALLS
Smart pointers can provide safety and convenience for handling dynamically allocated memory only when they are used properly. 
To use smart pointers correctly, we must adhere to a set of conventions:
• Don’t use the same built-in pointer value to initialize (or reset) more than one smart pointer.
• Don’t delete the pointer returned from get().
• Don’t use get() to initialize or reset another smart pointer.
• If you use a pointer returned by get(), remember that the pointer will become invalid when the last corresponding smart pointer goes away.
• If you use a smart pointer to manage a resource other than memory allocated by new, remember to pass a deleter (§ 12.1.4, p. 468, and § 12.1.5, p. 471).



-> NOTE: unique_ptr
A unique_ptr “owns” the object to which it points. 
Unlike shared_ptr, only one unique_ptr at a time can point to a given object. 
The object to which a unique_ptr points is destroyed when the unique_ptr is destroyed. 
Table 12.4 lists the operations specific to unique_ptrs. 
The operations common to both were covered in Table 12.1 (p. 452).


-> NOTE: Unlike shared_ptr, there is no library function comparable to make_shared that returns a unique_ptr. (ME: THERES MAKE_UNIQUE)
Instead, when we define a unique_ptr, we bind it to a pointer returned by new. 
As with shared_ptrs, we must use the direct form of initialization:
unique_ptr<double> p1; // unique_ptr that can point at a double
unique_ptr<int> p2(new int(42)); // p2 points to int with value 42
Because a unique_ptr owns the object to which it points, 
unique_ptr does not support ordinary copy or assignment:
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1); // error: no copy for unique_ptr
unique_ptr<string> p3;
p3 = p2;


-> NOTE: Although we can’t copy or assign a unique_ptr,
we can transfer ownership from one (nonconst) unique_ptr to another by calling release or reset:
// transfers ownership from p1 (which points to the string Stegosaurus) to p2
unique_ptr<string> p2(p1.release()); // release makes p1 null
unique_ptr<string> p3(new string("Trex"));
// transfers ownership from p3 to p2
p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed
The release member returns the pointer currently stored in the unique_ptr and makes that unique_ptr null. 
Thus, p2 is initialized from the pointer value that had been stored in p1 and p1 becomes null.


-> NOTE: unique_ptr Operations (See Also Table 12.1 (p. 452))
1) unique_ptr<T> u1 or unique_ptr<T, D> u2
Null unique_ptrs that can point to objects of type T. 
u1 will use delete to free its pointer; 
u2 will use a callable object of type D to free its pointer.
2) unique_ptr<T, D> u(d) 
Null unique_ptr that point to objects of type T that uses d,
which must be an object of type D in place of delete.
u = nullptr Deletes the object to which u points; makes u null.
3) u.release() 
Relinquishes control of the pointer u had held; returns the pointer u had held and makes u null.
4) u.reset() or u.reset(q) u.reset(nullptr)
Deletes the object to which u points;
If the built-in pointer q is supplied, makes u point to that object.
Otherwise makes u null.


-> NOTE: Passing and Returning unique_ptrs
There is one exception to the rule that we cannot copy a unique_ptr: 
We can copy or assign a unique_ptr that is about to be destroyed. 
The most common example is when we return a unique_ptr from a function:
unique_ptr<int> clone(int p) {
// ok: explicitly create a unique_ptr<int> from int*
return unique_ptr<int>(new int(p));
}
Alternatively, we can also return a copy of a local object:
unique_ptr<int> clone(int p) {
unique_ptr<int> ret(new int (p));
// . . .
return ret;
}
In both cases, the compiler knows that the object being returned is about to be destroyed. 
In such cases, the compiler does a special kind of “copy” which we’ll discuss in § 13.6.2 (p. 534).


-> NOTE: BACKWARD COMPATIBILITY: AUTO_PTR
Earlier versions of the library included a class named auto_ptr that had some, but not all, of the properties of unique_ptr. 
In particular, it was not possible to store an auto_ptr in a container, nor could we return one from a function.
Although auto_ptr is still part of the standard library, programs should use unique_ptr instead.


-> NOTE: Passing a Deleter to unique_ptr (ME: decltype can be used here)
Like shared_ptr, by default, unique_ptr uses delete to free the object to which a unique_ptr points. 
As with shared_ptr, we can override the default deleter in a unique_ptr (§ 12.1.4, p. 468). 
However, for reasons we’ll describe in § 16.1.6 (p. 676), the way unique_ptr manages its deleter is differs from the way shared_ptr does.
Overridding the deleter in a unique_ptr affects the unique_ptr type as well as how we construct (or reset) objects of that type. 
Similar to overriding the comparison operation of an associative container (§ 11.2.2, p. 425), 
we must supply the deleter type inside the angle brackets along with the type to which the unique_ptr can point. 
We supply a callable object of the specified type when we create or reset an object of this type:
// p points to an object of type objT and uses an object of type delT to free that object
// it will call an object named fcn of type delT
unique_ptr<objT, delT> p (new objT, fcn);
As a somewhat more concrete example, we’ll rewrite our connection program to use a unique_ptr in place of a shared_ptr as follows:
void f(destination &d /* other needed parameters */)
{
connection c = connect(&d); // open the connection
// when p is destroyed, the connection will be closed
unique_ptr<connection, decltype(end_connection)*> // decltype can be used here
p(&c, end_connection);
// use the connection
// when f exits, even if by an exception, the connection will be properly closed
}
Here we use decltype (§ 2.5.3, p. 70) to specify the function pointer type. 
Because decltype(end_connection) returns a function type, 
we must remember to add a * to indicate that we’re using a pointer to that type (§ 6.7, p. 250).



-> NOTE: weak_ptr
A weak_ptr (Table 12.5) is a smart pointer that does not control the lifetime of the object to which it points. 
Instead, a weak_ptr points to an object that is managed by a shared_ptr. 
Binding a weak_ptr to a shared_ptr does not change the reference count of that shared_ptr. 
Once the last shared_ptr pointing to the object goes away, the object itself will be deleted. 
That object will be deleted even if there are weak_ptrs pointing to it—hence the name weak_ptr, 
which captures the idea that a weak_ptr shares its object “weakly.”


-> NOTE: When we create a weak_ptr, we initialize it from a shared_ptr:
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); // wp weakly shares with p; use count in p is unchanged
Here both wp and p point to the same object. 
Because the sharing is weak, creating wp doesn’t change the reference count of p; 
it is possible that the object to which wp points might be deleted.


-> NOTE: Because the object might no longer exist, we cannot use a weak_ptr to access its object directly. 
To access that object, we must call lock. 
The lock function checks whether the object to which the weak_ptr points still exists. 
If so, lock returns a shared_ptr to the shared object. 
As with any other shared_ptr, we are guaranteed that the underlying object to which that 
shared_ptr points continues to exist at least as long as that shared_ptr exists. 
For example:
if (shared_ptr<int> np = wp.lock()) { // true if np is not null
// inside the if, np shares its object with p
}
Here we enter the body of the if only if the call to lock succeeds. 
Inside the if, it is safe to use np to access that object.


-> NOTE: weak_ptrs
1) weak_ptr<T> 
w Null weak_ptr that can point at objects of type T.
2) weak_ptr<T> w(sp) 
weak_ptr that points to the same object as the shared_ptr sp.
T must be convertible to the type to which sp points.
3) w = p 
p can be a shared_ptr or a weak_ptr. After the assignment w
shares ownership with p.
4) w.reset() 
Makes w null.
5) w.use_count() 
The number of shared_ptrs that share ownership with w.
6) w.expired() 
Returns true if w.use_count() is zero, false otherwise.
7) w.lock() 
If expired is true, returns a null shared_ptr; otherwise returns a shared_ptr to the object to which w points.



-> NOTE: Dynamic Arrays
The new and delete operators allocate objects one at a time. 
Some applications, need the ability to allocate storage for many objects at once. 
For example, vectors and strings store their elements in contiguous memory 
and must allocate several elements at once whenever the container has to be reallocated (§ 9.4, p. 355).

To support such usage, the language and library provide two ways to allocate an array of objects at once. 
The language defines a second kind of new expression that allocates and initializes an array of objects. 
The library includes a template class named allocator that lets us separate allocation from initialization. 
For reasons we’ll explain in § 12.2.2 (p. 481), using an allocator generally provides better performance and more flexible memory management.

Many, perhaps even most, applications have no direct need for dynamic arrays.
When an application needs a varying number of objects, it is almost always easier, faster, and safer to use a vector (or other library container). 
For reasons we’ll explain in § 13.6 (p. 531), the advantages of using a library container are even more pronounced under the new standard. 
Libraries that support the new standard tend to be dramatically faster than previous releases.


-> NOTE: new and Arrays
We ask new to allocate an array of objects by specifying the number of objects to allocate in a pair of square brackets after a type name. 
In this case, new allocates the requested number of objects and (assuming the allocation succeeds) returns a pointer to the first one:
// call get_size to determine how many ints to allocate
int *pia = new int[get_size()]; // pia points to the first of these ints
The size inside the brackets must have integral type but need not be a constant.
We can also allocate an array by using a type alias (§ 2.5.1, p. 67) to represent an array type. 
In this case, we omit the brackets:
typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first one
Here, new allocates an array of ints and returns a pointer to the first one. 
Even though there are no brackets in our code, the compiler executes this expression using new[].
That is, the compiler executes this expression as if we had written 
int *p = new int[42];


-> NOTE: Allocating an Array Yields a Pointer to the Element Type
Although it is common to refer to memory allocated by new T[] as a “dynamic array,” this usage is somewhat misleading.
When we use new to allocate an array, we do not get an object with an array type. 
Instead, we get a pointer to the element type of the array. 
Even if we use a type alias to define an array type, new does not allocate an object of array type. 
In this case, the fact that we’re allocating an array is not even visible; there is no [num]. 
Even so, new returns a pointer to the element type.
Because the allocated memory does not have an array type, we cannot call begin or end (§ 3.5.3, p. 118) on a dynamic array. 
These functions use the array dimension (which is part of an array’s type) 
to return pointers to the first and one past the last elements, respectively. 
For the same reasons, we also cannot use a range for to process the elements in a (so-called) dynamic array.


-> NOTE: It is important to remember that what we call a dynamic array does not have an array type.


-> NOTE: Initializing an Array of Dynamically Allocated Objects
By default, objects allocated by new—whether allocated as a single object or in an array—are default initialized. 
We can value initialize (§ 3.3.1, p. 98) the elements in an array by following the size with an empty pair of parentheses.
int *pia = new int[10]; // block of ten uninitialized ints
int *pia2 = new int[10](); // block of ten ints value initialized to 0
string *psa = new string[10]; // block of ten empty strings
string *psa2 = new string[10](); // block of ten empty strings
Under the new standard, we can also provide a braced list of element initializers:
// block of ten ints each initialized from the corresponding initializer
int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9}; // ME: WOW, this is new!
// block of ten strings; the first four are initialized from the given initializers
// remaining elements are value initialized
string *psa3 = new string[10]{"a", "an", "the", string(3,’x’)};


-> NOTE: It Is Legal to Dynamically Allocate an Empty Array
We can use an arbitrary expression to determine the number of objects to allocate:
size_t n = get_size(); // get_size returns the number of elements needed
int* p = new int[n]; // allocate an array to hold the elements
for (int* q = p; q != p + n; ++q)
/* process the array */ ;
An interesting question arises: 
What happens if get_size returns 0? 
The answer is that our code works fine. 
Calling new[n] with n equal to 0 is legal even though we cannot create an array variable of size 0:
char arr[0]; // error: cannot define a zero-length array
char *cp = new char[0]; // ok: but cp can’t be dereferenced


-> NOTE: Freeing Dynamic Arrays
To free a dynamic array, we use a special form of delete that includes an empty pair of square brackets:
delete p; // p must point to a dynamically allocated object or be null
delete [] pa; // pa must point to a dynamically allocated array or be null
The second statement destroys the elements in the array to which pa points and frees the corresponding memory. 
Elements in an array are destroyed in reverse order. (ME: This is important!)
That is, the last element is destroyed first, then the second to last, and so on.
When we delete a pointer to an array, the empty bracket pair is essential: 
It indicates to the compiler that the pointer addresses the first element of an array of objects. 
If we omit the brackets when we delete a pointer to an array (or provide them when we delete a pointer to an object), the behavior is undefined.
Recall that when we use a type alias that defines an array type, 
we can allocate an array without using [] with new. 
Even so, we must use brackets when we delete a pointer to that array:
typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first one
delete [] p; // brackets are necessary because we allocated an array
Despite appearances, p points to the first element of an array of objects, not to a single object of type arrT.
Thus, we must use [] when we delete p.


-> NOTE: The compiler is unlikely to warn us if we forget the brackets when we delete a pointer to an array 
or if we use them when we delete a pointer to an object. 
Instead, our program is apt to misbehave without warning during execution.


-> NOTE: Smart Pointers and Dynamic Arrays
The library provides a version of unique_ptr that can manage arrays allocated by new. 
To use a unique_ptr to manage a dynamic array, we must include a pair of empty brackets after the object type:
// up points to an array of ten uninitialized ints
unique_ptr<int[]> up(new int[10]);
up.release(); // automatically uses delete[] to destroy its pointer


-> NOTE: When a unique_ptr points to an array, we cannot use the dot and arrow member access operators.


-> NOTE: unique_ptrs to Arrays
Member access operators (dot and arrow) are NOT supported for unique_ptrs to arrays.
Other unique_ptr operations unchanged.
1) unique_ptr<T[]> u
u can point to a dynamically allocated array of type T.
2) unique_ptr<T[]> u(p) 
u points to the dynamically allocated array to which the built-in pointer p points. 
p must be convertible to T* (§ 4.11.2, p. 161).
3) u[i] 
Returns the object at position i in the array that u owns. 
u must point to an array.


-> NOTE: Unlike unique_ptr, shared_ptrs provide no direct support for managing a dynamic array. 
If we want to use a shared_ptr to manage a dynamic array, we must provide our own deleter:
// to use a shared_ptr we must supply a deleter
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
sp.reset(); // uses the lambda we supplied that uses delete[] to free the array
Here we pass a lambda (§ 10.3.2, p. 388) that uses delete[] as the deleter.
Had we neglected to supply a deleter, this code would be undefined. 
By default, shared_ptr uses delete to destroy the object to which it points. 
If that object is a dynamic array, using delete has the same kinds of problems 
that arise if we forget to use [] when we delete a pointer to a dynamic array (§ 12.2.1, p. 479).


-> NOTE: The fact that shared_ptr does not directly support managing arrays affects how we access the elements in the array:
// shared_ptrs don’t have subscript operator and don’t support pointer arithmetic
for (size_t i = 0; i != 10; ++i)
*(sp.get() + i) = i; // use get to get a built-in pointer



-> NOTE: The allocator Class
The library allocator class, which is defined in the memory header, lets us separate allocation from construction. 
It provides type-aware allocation of raw, unconstructed, memory. 
Table 12.7 (overleaf) outlines the operations that allocator supports. 
In this section, we’ll describe the allocator operations. 
In § 13.5 (p. 524), we’ll see an example of how this class is typically used.
Like vector, allocator is a template (§ 3.3, p. 96). 
To define an allocator we must specify the type of objects that a particular allocator can allocate.
When an allocator object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type:
allocator<string> alloc; // object that can allocate strings
auto const p = alloc.allocate(n); // allocate n unconstructed strings
This call to allocate allocates memory for n strings.


-> NOTE: allocators Allocate Unconstructed Memory
The memory an allocator allocates is unconstructed. 
We use this memory by constructing objects in that memory. 
In the new library the construct member takes a pointer and zero or more additional arguments; 
it constructs an element at the given location. 
The additional arguments are used to initialize the object being constructed. 
Like the arguments to make_shared (§ 12.1.1, p. 451), these additional arguments 
must be valid initializers for an object of the type being constructed.
In particular, if the object is a class type, these arguments must match a constructor for that class:
auto q = p; // q will point to one past the last constructed element
alloc.construct(q++); // *q is the empty string
alloc.construct(q++, 10, ’c’); // *q is cccccccccc
alloc.construct(q++, "hi"); // *q is hi!
In earlier versions of the library, construct took only two arguments: 
the pointer at which to construct an object and a value of the element type. 
As a result, we could only copy an element into unconstructed space, we could not use any other constructor for the element type.
It is an error to use raw memory in which an object has not been constructed:
cout << *p << endl; // ok: uses the string output operator
cout << *q << endl; // disaster: q points to unconstructed memory!


-> NOTE: Standard allocator Class and Customized Algorithms
1) allocator<T> a 
Defines an allocator object named a that can allocate memory for objects of type T.
2) a.allocate(n) 
Allocates raw, unconstructed memory to hold n objects of type T.
3) a.deallocate(p, n) 
Deallocates memory that held n objects of type T starting at the address in the T* pointer p; 
p must be a pointer previously returned by allocate, and n must be the size requested when p was created. 
The user must run destroy on any objects that were constructed in this memory before calling deallocate.
4) a.construct(p, args) 
pmust be a pointer to type T that points to raw memory; 
args are passed to a constructor for type T, which is used to construct an object in the memory pointed to by p.
5) a.destroy(p) 
Runs the destructor (§ 12.1.1, p. 452) on the object pointed to by the T* pointer p.


-> NOTE: allocators Allocate Unconstructed Memory
The memory an allocator allocates is unconstructed.
We use this memory by constructing objects in that memory. 
In the new library the construct member takes a pointer and zero or more additional arguments; 
it constructs an element at the given location. 
The additional arguments are used to initialize the object being constructed. 
Like the arguments to make_shared (§ 12.1.1, p. 451), these additional arguments must be valid initializers for an object of the type being constructed.
In particular, if the , object is a class type, these arguments must match a constructor for that class:
auto q = p; // q will point to one past the last constructed element
alloc.construct(q++); // *q is the empty string
alloc.construct(q++, 10, ’c’); // *q is cccccccccc
alloc.construct(q++, "hi"); // *q is hi!


-> NOTE: We must construct objects in order to use memory returned by allocate. 
Using unconstructed memory in other ways is undefined.


-> NOTE: When we’re finished using the objects, we must destroy the elements we constructed, which we do by calling destroy on each constructed element. 
The destroy function takes a pointer and runs the destructor (§ 12.1.1, p. 452) on the pointed-to object:
while (q != p)
alloc.destroy(--q); // free the strings we actually allocated
At the beginning of our loop, q points one past the last constructed element. 
We decrement q before calling destroy. 
Thus, on the first call to destroy, q points to the last constructed element. 
We destroy the first element in the last iteration, after which q will equal p and the loop ends.


-> NOTE: Once the elements have been destroyed, we can either reuse the memory to hold other strings or return the memory to the system. 
We free the memory by calling deallocate:
alloc.deallocate(p, n);
The pointer we pass to deallocate cannot be null; it must point to memory allocated by allocate. 
Moreover, the size argument passed to deallocate must be the same size as used in the call to allocate that obtained the memory to which the pointer points.


-> NOTE: Algorithms to Copy and Fill Uninitialized Memory
As a companion to the allocator class, the library also defines two algorithms that can construct objects in uninitialized memory. 
These functions, described in Table 12.8, are defined in the memory header.
As an example, assume we have a vector of ints that we want to copy into dynamic memory. 
We’ll allocate memory for twice as many ints as are in the vector. 
We’ll construct the first half of the newly allocated memory by copying elements from the original vector. 
We’ll construct elements in the second half by filling them with a given value:
// allocate twice as many elements as vi holds
auto p = alloc.allocate(vi.size() * 2);
// construct elements starting at p as copies of elements in vi
auto q = uninitialized_copy(vi.begin(), vi.end(), p);
// initialize the remaining elements to 42
uninitialized_fill_n(q, vi.size(), 42);
Like the copy algorithm (§ 10.2.2, p. 382), uninitialized_copy takes three iterators. 
The first two denote an input sequence and the third denotes the destination into which those elements will be copied. 
The destination iterator passed to uninitialized_copy must denote unconstructed memory. 
Unlike copy, uninitialized_copy constructs elements in its destination.
Like copy, uninitialized_copy returns its (incremented) destination iterator.
Thus, a call to uninitialized_copy returns a pointer positioned one element past the last constructed element. 
In this example, we store that pointer in q, which we pass to uninitialized_fill_n. 
This function, like fill_n (§ 10.2.2, p. 380), takes a pointer to a destination, a count, and a value. 
It will construct the given number of objects from the given value at locations starting at the given destination.


-> NOTE: Unlike copy, uninitialized_copy constructs elements in its destination.


-> NOTE: ME: From bard, std::copy ensures that all of the elements in the destination range are initialized before the copy operation begins.
uninitialized_copy does not initialize any of the elements in the destination range.


-> NOTE: allocator Algorithms
These functions construct elements in the destination, rather than assigning to them.
) uninitialized_copy(b, e, b2)
Copies elements from the input range denoted by iterators b and e into unconstructed, raw memory denoted by the iterator b2. 
The memory denoted by b2 must be large enough to hold a copy of the elements in the input range.
) uninitialized_copy_n(b, n, b2)
Copies n elements starting from the one denoted by the iterator b into raw memory starting at b2.
) uninitialized_fill(b, e, t)
Constructs objects in the range of raw memory denoted by iterators b and e as a copy of t.
) uninitialized_fill_n(b, n, t)
Constructs an unsigned number n objects starting at b. b must denote unconstructed, 
raw memory large enough to hold the given number of objects.


-> NOTE: ME: uninitialized_copy vs copy
uninitialized_copy constructs an object "in-place", using placement-new expression, 
means that there is an existing span of storage into which the object is constructed. 
This is in contrast with allocating-new, which allocates a new piece of dynamic storage into which the object is created.
Note that in contrast, std::copy does not create any objects. 
It calls the assignment operator on existing objects whose lifetime is not affected by the operation. 
(Although, an overloaded assignment operator may indirectly result in creation of objects).
A case where std::uninitialized_copy is useful is reusal of raw memory, such as in the implementation of std::vector.



-> NOTE: Copy Control
When we define a class, we specify—explicitly or implicitly—what happens 
when objects of that class type are copied, moved, assigned, and destroyed.
A class controls these operations by defining five special member functions: 
copy constructor, copy-assignment operator, move constructor, move-assignment operator, and destructor.


-> NOTE: Copy control is an essential part of defining any C++ class. 
Programmers new to C++ are often confused by having to define 
what happens when objects are copied, moved, assigned, or destroyed. 
This confusion is compounded because if we do not explicitly define these operations,
the compiler defines them for us—although the compiler-defined versions might not behave as we intend.


-> NOTE: The Copy Constructor
A constructor is the copy constructor if its first parameter is a reference to the class type and any additional parameters have default values:
class Foo {
public:
Foo(); // default constructor
Foo(const Foo&); // copy constructor
// . . .
};
For reasons we’ll explain shortly, the first parameter must be a reference type. 
That parameter is almost always a reference to const, although we can define the copy constructor to take a reference to nonconst. 
The copy constructor is used implicitly in several circumstances. 
Hence, the copy constructor usually should not be explicit (§ 7.5.4, p. 296).


-> NOTE: The Synthesized Copy Constructor
When we do not define a copy constructor for a class, the compiler synthesizes one for us. 
Unlike the synthesized default constructor (§ 7.1.4, p. 262), a copy constructor is synthesized even if we define other constructors.
As we’ll see in § 13.1.6 (p. 508), the synthesized copy constructor for some classes prevents us from copying objects of that class type. 
Otherwise, the synthesized copy constructor memberwise copies the members of its argument into the object being created (§ 7.1.5, p. 267). 
The compiler copies each nonstatic member in turn from the given object into the one being created.


-> NOTE: Copy Initialization
We are now in a position to fully understand the differences between direct initialization and copy initialization (§ 3.2.1, p. 84):
string dots(10, ’.’); // direct initialization
string s(dots); // direct initialization
string s2 = dots; // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, ’9’); // copy initialization
When we use direct initialization, we are asking the compiler to use ordinary function matching (§ 6.4, p. 233) 
to select the constructor that best matches the arguments we provide. 
When we use copy initialization, we are asking the compiler to copy the right-hand operand into the object being created, 
converting that operand if necessary (§ 7.5.4, p. 294).


-> NOTE: Copy initialization ordinarily uses the copy constructor. 
However, as we’ll see in § 13.6.2 (p. 534), if a class has a move constructor, 
then copy initialization sometimes uses the move constructor instead of the copy constructor. 
For now, what’s useful to know is when copy initialization happens 
and that copy initialization requires either the copy constructor or the move constructor.
Copy initialization happens NOT only when we define variables using an =, but also when we
• Pass an object as an argument to a parameter of nonreference type
• Return an object from a function that has a nonreference return type
• Brace initialize the elements in an array or the members of an aggregate class (§ 7.5.5, p. 298)
Some class types also use copy initialization for the objects they allocate. 
For example, the library containers copy initialize their elements when we initialize the container,
or when we call an insert or push member (§ 9.3.1, p. 342). 
By contrast, elements created by an emplace member are direct initialized (§ 9.3.1, p. 345).


-> NOTE: Parameters and Return Values
During a function call, parameters that have a nonreference type are copy initialized (§ 6.2.1, p. 209). 
Similarly, when a function has a nonreference return type, 
the return value is used to copy initialize the result of the call operator at the call site (§ 6.3.2, p. 224).
The fact that the copy constructor is used to initialize nonreference parameters of class type 
explains why the copy constructor’s own parameter must be a reference.
If that parameter were not a reference, then the call would never succeed—to call the copy constructor, 
we’d need to use the copy constructor to copy the argument,
but to copy the argument, we’d need to call the copy constructor, and so on indefinitely.


-> NOTE: Constraints on Copy Initialization
As we’ve seen, whether we use copy or direct initialization matters 
if we use an initializer that requires conversion by an explicit constructor (§ 7.5.4, p. 296):
vector<int> v1(10); // ok: direct initialization
vector<int> v2 = 10; // error: constructor that takes a size is explicit
void f(vector<int>); // f’s parameter is copy initialized
f(10); // error: can’t use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
Directly initializing v1 is fine, but the seemingly equivalent copy initialization of v2 is an error, 
because the vector constructor that takes a single size parameter is explicit. 
For the same reasons that we cannot copy initialize v2, 
we cannot implicitly use an explicit constructor when we pass an argument or return a value from a function. 
If we want to use an explicit constructor, we must do so explicitly, as in the last line of the example above.


-> NOTE: The Compiler Can Bypass the Copy Constructor
During copy initialization, the compiler is permitted (but not obligated) 
to skip the copy/move constructor and create the object directly. 
That is, the compiler is permitted to rewrite
string null_book = "9-999-99999-9"; // copy initialization
into
string null_book("9-999-99999-9"); // compiler omits the copy constructor
However, even if the compiler omits the call to the copy/move constructor, 
the copy/move constructor must exist and must be accessible (e.g., not private) at that point in the program.


-> NOTE: The Copy-Assignment Operator
Just as a class controls how objects of that class are initialized, 
it also controls how objects of its class are assigned:
Sales_data trans, accum;
trans = accum; // uses the Sales_data copy-assignment operator
As with the copy constructor, the compiler synthesizes a copy-assignment operator if the class does not define its own.


-> NOTE: Introducing Overloaded Assignment
Before we look at the synthesized assignment operator, 
we need to know a bit about overloaded operators, which we cover in detail in Chapter 14.
Overloaded operators are functions that have the name operator followed by the symbol for the operator being defined. 
Hence, the assignment operator is a function named operator=. 
Like any other function, an operator function has a return type and a parameter list.


-> NOTE: Assignment operators ordinarily should return a reference to their left hand operand.


-> NOTE: The Synthesized Copy-Assignment Operator
Just as it does for the copy constructor, the compiler generates 
a synthesized copy assignment operator for a class if the class does not define its own. 
Analogously to the copy constructor, for some classes the synthesized copy-assignment operator disallows assignment (§ 13.1.6, p. 508).
Otherwise, it assigns each nonstatic member of the right-hand object 
to the corresponding member of the left-hand object using the copy-assignment operator for the type of that member. 
Array members are assigned by assigning each element of the array. 
The synthesized copy-assignment operator returns a reference to its left-hand object.


-> NOTE: The Destructor
The destructor operates inversely to the constructors: 
Constructors initialize the nonstatic data members of an object and may do other work; 
destructors do whatever work is needed to free the resources used by an object and destroy the nonstatic data members of the object.
The destructor is a member function with the name of the class prefixed by a tilde (~). 
It has no return value and takes no parameters:
class Foo {
public:
~Foo(); // destructor
// . . .
};
Because it takes no parameters, it cannot be overloaded. 
There is always only one destructor for a given class.


-> NOTE: What a Destructor Does
Just as a constructor has an initialization part and a function body (§ 7.5.1, p. 288), 
a destructor has a function body and a destruction part. 
In a constructor, members are initialized before the function body is executed, 
and members are initialized in the same order as they appear in the class. 
In a destructor, the function body is executed first and then the members are destroyed. 
Members are destroyed in reverse order from the order in which they were initialized.


-> In a destructor, there is nothing akin to the constructor initializer list 
to control how members are destroyed; the destruction part is implicit. 
What happens whena member is destroyed depends on the type of the member. 
Members of class type are destroyed by running the member’s own destructor. 
The built-in types do NOT have destructors, so nothing is done to destroy members of built-in type.


-> NOTE: The implicit destruction of a member of built-in pointer type does not delete the object to which that pointer points.


-> NOTE: When a Destructor Is Called
The destructor is used automatically whenever an object of its type is destroyed:
• Variables are destroyed when they go out of scope.
• Members of an object are destroyed when the object of which they are a part is destroyed.
• Elements in a container—whether a library container or an array—are destroyed when the container is destroyed.
• Dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object (§ 12.1.2, p. 460).
• Temporary objects are destroyed at the end of the full expression in which the temporary was created.
Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.


-> NOTE: The destructor is not run when a reference or a pointer to an object goes out of scope.


-> NOTE: The Synthesized Destructor
The compiler defines a synthesized destructor for any class that does not define its own destructor. 
As with the copy constructor and the copy-assignment operator, for some classes, 
the synthesized destructor is defined to disallow objects of the type from being destroyed (§ 13.1.6, p. 508). 
Otherwise, the synthesized destructor has an empty function body.
The members are automatically destroyed after the (empty) destructor body is run.
It is important to realize that the destructor body does not directly destroy the members themselves. 
Members are destroyed as part of the implicit destruction phase that follows the destructor body. 
A destructor body executes in addition to the memberwise destruction that takes place as part of destroying an object.


-> NOTE: The Rule of Three/Five
As we’ve seen, there are three basic operations to control copies of class objects: 
the copy constructor, copy-assignment operator, and destructor. 
Moreover, as we’ll see in § 13.6 (p. 531), under the new standard, 
a class can also define a move constructor and move-assignment operator
There is no requirement that we define all of these operations: 
We can define one or two of them without having to define all of them. 
However, ordinarily these operations should be thought of as a unit. 
In general, it is unusual to need one without needing to define them all.


-> NOTE: Classes That Need Destructors Need Copy and Assignment
One rule of thumb to use when you decide whether a class needs to define its own versions 
of the copy-control members is to decide first whether the class needs a destructor. 
Often, the need for a destructor is more obvious than the need for the copy constructor or assignment operator. 
If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.
ME: This is for classes that has a specialized destructor (so it mean something needs to be done during destruction -> then its mean something needs to be done on assign ment) 


-> NOTE: If a class needs a destructor, it almost surely also needs the copy assignment operator and a copy constructor.


-> NOTE: Classes That Need Copy Need Assignment, and Vice Versa
Although many classes need to define all of (or none of) the copy-control members, 
some classes have work that needs to be done to copy or assign objects but has no need for the destructor.


-> NOTE: If a class needs a copy constructor, it almost surely needs a copy-assignment operator. 
And vice versa if the class needs an assignment operator, it almost surely needs a copy constructor as well. 
Nevertheless, needing either the copy constructor or the copy-assignment operator does not (necessarily) indicate the need for a destructor.


-> NOTE: Using = default
We can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as = default (§ 7.1.4, p. 264):
class Sales_data {
public:
// copy control; use defaults
Sales_data() = default;
Sales_data(const Sales_data&) = default;
Sales_data& operator=(const Sales_data &);
~Sales_data() = default;
// other members as before
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
When we specify = default on the declaration of the member inside the class body, 
the synthesized function is implicitly inline (just as is any other member function defined in the body of the class). 
If we do not want the synthesized member to be an inline function, 
we can specify = default on themember’s definition,
as we do in the definition of the copy-assignment operator.


-> NOTE: We can use = default only on member functions that have a synthesized version (i.e., the default constructor or a copy-control member).


-> NOTE: Preventing Copies
Although most classes should (and generally do) define a copy constructor and a copy-assignment operator, 
for some classes, there really is no sensible meaning for these operations. 
In such cases, the class must be defined so as to prevent copies or assignments from being made. 
For example, the iostream classes prevent copying to avoid letting multiple objects write to or read from the same IO buffer. 
It might seem that we could prevent copies by not defining the copy-control members.
However, this strategy doesn’t work: If our class doesn’t define these operations, the compiler will synthesize them.


-> NOTE: Most classes should define—either implicitly or explicitly—the default and copy constructors and the copy-assignment operator.


-> NOTE: Defining a Function as Deleted
Under the new standard, we can prevent copies by defining the copy constructor and copy-assignment operator as deleted functions. 
A deleted function is one that is declared but may not be used in any other way. 
We indicate that we want to define a function as deleted by following its parameter list with = delete:
struct NoCopy {
NoCopy() = default; // use the synthesized default constructor
NoCopy(const NoCopy&) = delete; // no copy
NoCopy &operator=(const NoCopy&) = delete; // no assignment
~NoCopy() = default; // use the synthesized destructor
// other members
};


-> NOTE: The = delete signals to the compiler (and to readers of our code) that we are intentionally not defining these members.


-> NOTE: Unlike = default, = delete must appear on the first declaration of a deleted function. 
This difference follows logically from the meaning of these declarations. 
A defaulted member affects only what code the compiler generates; 
hence the = default is not needed until the compiler generates code. 
On the other hand, the compiler needs to know that a function is deleted in order to prohibit operations that attempt to use it.


-> NOTE: Also unlike = default, we can specify = delete on any function 
(we can use = default only on the default constructor or a copy-control member that the compiler can synthesize). 
Although the primary use of deleted functions is to suppress the copy-control members, 
deleted functions are sometimes also useful when we want to guide the function-matching process.


-> NOTE: The Destructor Should Not be a Deleted Member
It is worth noting that we did not delete the destructor. 
If the destructor is deleted, then there is no way to destroy objects of that type. 
The compiler will not let us define variables or create temporaries of a type that has a deleted destructor.
Moreover, we cannot define variables or temporaries of a class that has a member whose type has a deleted destructor. 
If a member has a deleted destructor, then that member cannot be destroyed. 
If a member can’t be destroyed, the object as a whole can’t be destroyed.


-> NOTE: Although we cannot define variables or members of such types, we can dynamically allocate objects with a deleted destructor. 
However, we cannot free them:
struct NoDtor {
NoDtor() = default; // use the synthesized default constructor
~NoDtor() = delete; // we can’t destroy objects of type NoDtor
};
NoDtor nd; // error: NoDtor destructor is deleted
NoDtor *p = new NoDtor(); // ok: but we can’t delete p
delete p; // error: NoDtor destructor is deleted


-> NOTE: It is not possible to define an object or delete a pointer to a dynamically allocated object of a type with a deleted destructor.


-> NOTE: The Copy-Control Members May Be Synthesized as Deleted
As we’ve seen, if we do not define the copy-control members, the compiler defines them for us. 
Similarly, if a class defines no constructors, the compiler synthesizes a default constructor for that class (§ 7.1.4, p. 262). 
For some classes, the compiler defines these synthesized members as deleted functions:
• The synthesized destructor is defined as deleted if the class has a member whose own destructor is deleted or is inaccessible (e.g., private).
• The synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. 
It is also deleted if the class has a member with a deleted or inaccessible destructor.
• The synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, 
or if the class has a const or reference member.
• The synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; 
or has a reference member that does not have an in-class initializer (§ 2.6.1, p. 73); 
or has a const member whose type does not explicitly define a default constructor and that member does not have an in-class initializer.


-> NOTE: In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, 
then the corresponding member will be a deleted function.
It may be surprising that a member that has a deleted or inaccessible destructor 
causes the synthesized default and copy constructors to be defined as deleted. 
The reason for this rule is that without it, we could create objects that we could not destroy.


-> NOTE: In essence, the copy-control members are synthesized as deleted when it is impossible to copy, assign, or destroy a member of the class.


-> NOTE: private Copy Control
Prior to the new standard, classes prevented copies by declaring their copy constructor
and copy-assignment operator as private:
class PrivateCopy {
// no access specifier; following members are private by default; see § 7.2 (p. 268)
// copy control is private and so is inaccessible to ordinary user code
PrivateCopy(const PrivateCopy&);
PrivateCopy &operator=(const PrivateCopy&);
// other members
public:
PrivateCopy() = default; // use the synthesized default constructor
~PrivateCopy(); // users can define objects of this type but not copy them
};
Because the destructor is public, users will be able to define PrivateCopy objects.
However, because the copy constructor and copy-assignment operator are private, user code will not be able to copy such objects. 
However, friends and members of the class can still make copies. 
To prevent copies by friends and members, we declare these members as private but do not define them.
With one exception, which we’ll cover in § 15.2.1 (p. 594), it is legal to declare,
but not define, a member function (§ 6.1.2, p. 206). 
An attempt to use an undefined member results in a link-time failure. 
By declaring (but not defining) a private copy constructor, 
we can forestall any attempt to copy an object of the class type:
User code that tries to make a copy will be flagged as an error at compile time;
copies made in member functions or friends will result in an error at link time.


-> NOTE: Classes that want to prevent copying should define their copy constructor 
and copy-assignment operators using = delete rather than making those members private.


-> NOTE: Copy Control and Resource Management
Ordinarily, classes that manage resources that do not reside in the class must define the copy-control members. 
As we saw in § 13.1.4 (p. 504), such classes will need destructors to free the resources allocated by the object. 
Once a class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.
In order to define these members, we first have to decide what copying an object of our type will mean. 
In general, we have two choices: 
We can define the copy operations to make the class behave like a value or like a pointer.


-> NOTE: Classes that behave like values have their own state. 
When we copy a valuelike object, the copy and the original are independent of each other. 
Changes made to the copy have no effect on the original, and vice versa.


-> NOTE: Classes that act like pointers share state. 
When we copy objects of such classes, the copy and the original use the same underlying data. 
Changes made to the copy also change the original, and vice versa.


-> NOTE: Classes That Act Like Values
To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. 
That means each HasPtr object must have its own copy of the string to which ps points. 
To implement valuelike behavior HasPtr needs
• A copy constructor that copies the string, not just the pointer
• A destructor to free the string
• A copy-assignment operator to free the object’s existing string and copy
the string from its right-hand operand


-> NOTE: Valuelike Copy-Assignment Operator
Assignment operators typically combine the actions of the destructor and the copy constructor. 
Like the destructor, assignment destroys the left-hand operand’s resources.
Like the copy constructor, assignment copies data from the right-hand operand. 
However, it is crucially important that these actions be done in a sequence that is correct even if an object is assigned to itself. 
Moreover, when possible, we should also write our assignment operators so that 
they will leave the left-hand operand in a sensible state should an exception occur (§ 5.6.2, p. 196).
In this case, we can handle SELF-ASSIGNMENT and make our code safe should an exception happen—by first copying the right-hand side. 
After the copy is made, we’ll free the left-hand side and update the pointer to point to the newly allocated string:
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
auto newp = new string(*rhs.ps); // copy the underlying string
delete ps; // free the old memory
ps = newp; // copy data from rhs into this object
i = rhs.i;
return *this; // return this object
}
In this assignment operator, we quite clearly first do the work of the constructor:
The initializer of newp is identical to the initializer of ps in HasPtr’s copy constructor.
As in the destructor, we next delete the string to which ps currently points. 
What remains is to copy the pointer to the newly allocated string and the int value from rhs into this object.


-> NOTE: KEY CONCEPT: ASSIGNMENT OPERATORS
There are two points to keep in mind when you write an assignment operator:
• Assignment operators must work correctly if an object is assigned to itself.
• Most assignment operators share work with the destructor and copy constructor.
A good pattern to use when you write an assignment operator is to first copy the righthand operand into a local temporary. 
After the copy is done, it is safe to destroy the existing members of the left-hand operand. 
Once the left-hand operand is destroyed, copy the data from the temporary into the members of the left-hand operand.


-> NOTE: It is crucially important for assignment operators to work correctly, even when an object is assigned to itself. 
A good way to do so is to copy the right-hand operand before destroying the left-hand operand.


-> NOTE: Defining Classes That Act Like Pointers
For our HasPtr class to act like a pointer, we need the copy constructor 
and copy assignment operator to copy the pointer member, not the string to which that pointer points. 
Our class will still need its own destructor to free the memory allocated by the constructor that takes a string (§ 13.1.4, p. 504). 
In this case, though, the destructor cannot unilaterally free its associated string. 
It can do so only when the last HasPtr pointing to that string goes away.
The easiest way to make a class act like a pointer is to use shared_ptrs to manage the resources in the class. 
Copying (or assigning) a shared_ptr copies (assigns) the pointer to which the shared_ptr points. 
The shared_ptr class itself keeps track of how many users are sharing the pointed-to object. 
When there are no more users, the shared_ptr class takes care of freeing the resource.
However, sometimes we want to manage a resource directly. 
In such cases, it can be useful to use a reference count (§ 12.1.1, p. 452). 
To show how reference counting works, we’ll redefine HasPtr to provide pointerlike behavior, but we will do our own reference counting.


-> NOTE: Reference Counts
Reference counting works as follows:
• In addition to initializing the object, each constructor (other than the copy constructor) creates a counter. 
This counter will keep track of how many objects share state with the object we are creating. 
When we create an object, there is only one such object, so we initialize the counter to 1. 
• The copy constructor does not allocate a new counter; 
instead, it copies the data members of its given object, including the counter. 
The copy constructor increments this shared counter, indicating that there is another user of that object’s state.
• The destructor decrements the counter, indicating that there is one less user of the shared state. 
If the count goes to zero, the destructor deletes that state.
• The copy-assignment operator increments the right-hand operand’s counter and decrements the counter of the left-hand operand. 
If the counter for the left-hand operand goes to zero, there are no more users. 
In this case, the copy-assignment operator must destroy the state of the left-hand operand.
The only wrinkle is deciding where to put the reference count. 
The counter cannot be a directmember of a HasPtr object. 
To see why, consider what happens in the following example:
HasPtr p1("Hiya!");
HasPtr p2(p1); // p1 and p2 point to the same string
HasPtr p3(p1); // p1, p2, and p3 all point to the same string
If the reference count is stored in each object, how can we update it correctly when p3 is created? 
We could increment the count in p1 and copy that count into p3, but how wouldwe update the counter in p2?
One way to solve this problem is to store the counter in dynamic memory.
When we create an object, we’ll also allocate a new counter. 
When we copy or assign an object, we’ll copy the pointer to the counter. 
That way the copy and the original will point to the same counter.


-> NOTE: Pointerlike CopyMembers “Fiddle” the Reference Count
When we copy or assign a HasPtr object, we want the copy and the original to point to the same string. 
That is, when we copy a HasPtr, we’ll copy ps itself, not the string to which ps points. 
When we make a copy, we also increment the counter associated with that string.
The copy constructor (which we defined inside the class) copies all three members from its given HasPtr. 
This constructor also increments the use member, indicating that there is another user for the string to which ps and p.ps point.
The destructor cannot unconditionally delete ps—there might be other objects pointing to that memory. 
Instead, the destructor decrements the reference count, indicating that one less object shares the string. 
If the counter goes to zero, then the destructor frees the memory to which both ps and use point:
HasPtr::~HasPtr()
{
if (--*use == 0) { // if the reference count goes to 0
delete ps; // delete the string
delete use; // and the counter
}
}


-> NOTE: Swap function
In addition to defining the copy-control members, classes that manage resources often also define a function named swap (§ 9.2.5, p. 339). 
Defining swap is particularly important for classes that we plan to use with algorithms that reorder elements (§ 10.2.3, p. 383). 
Such algorithms call swap whenever they need to exchange two elements.


-> NOTE: Writing Our Own swap Function
We can override the default behavior of swap by defining a version of swap that operates on our class. 
The typical implementation of swap is:
class HasPtr {
friend void swap(HasPtr&, HasPtr&);
// other members as in § 13.2.1 (p. 511)
};
inline
void swap(HasPtr &lhs, HasPtr &rhs)
{
using std::swap;
swap(lhs.ps, rhs.ps); // swap the pointers, not the string data
swap(lhs.i, rhs.i); // swap the int members
}
We start by declaring swap as a friend to give it access to HasPtr’s (private) data members. 
Because swap exists to optimize our code, we’ve defined swap as an inline function (§ 6.5.2, p. 238). 
The body of swap calls swap on each of the data members of the given object. 
In this case, we first swap the pointers and then the int members of the objects bound to rhs and lhs.


-> NOTE: Unlike the copy-control members, swap is never necessary. 
However, defining swap can be an important optimization for classes that allocate resources.


-> NOTE: swap Functions Should Call swap, Not std::swap
There is one important subtlety in this code: 
Although it doesn’t matter in this particular case, it is essential that swap functions call swap and not std::swap.
In the HasPtr function, the data members have built-in types. 
There is no type specific version of swap for the built-in types. 
In this case, these calls will invoke the library std::swap.
However, if a class has a member that has its own type-specific swap function, calling std::swap would be a mistake. 
For example, assume we had another class named Foo that has a member named h, which has type HasPtr. 
If we did not write a Foo version of swap, then the library version of swap would be used.
As we’ve already seen, the LIBRARY SWAP makes unnecessary copies of the strings managed by HasPtr.
We can avoid these copies by writing a swap function for Foo. 
However, if we wrote the Foo version of swap as:
void swap(Foo &lhs, Foo &rhs)
{
// WRONG: this function uses the library version of swap, not the HasPtr version
std::swap(lhs.h, rhs.h);
// swap other members of type Foo
}
this code would compile and execute. 
However, there would be no performance difference between this code and simply using the default version of swap. 
The problem is that we’ve explicitly requested the library version of swap. 
However, we don’t want the version in std; we want the one defined for HasPtr objects.
The right way to write this swap function is:
void swap(Foo &lhs, Foo &rhs)
{
using std::swap; // ME: Put "using" here so other members uses the std one.
swap(lhs.h, rhs.h); // uses the HasPtr version of swap (ME: It uses the user defined version because its a friend on HasPtr)
// swap other members of type Foo
}


-> NOTE: Using swap in Assignment Operators
Classes that define swap often use swap to define their assignment operator. 
These operators use a technique known as copy and swap.
This technique swaps the lefthand operand with a copy of the right-hand operand:
// note rhs is passed by value, which means the HasPtr copy constructor
// copies the string in the right-hand operand into rhs
HasPtr& HasPtr::operator=(HasPtr rhs)
{
// swap the contents of the left-hand operand with the local variable rhs
swap(*this, rhs); // rhs now points to the memory this object had used
return *this; // rhs is destroyed, which deletes the pointer in rhs
}

In this version of the assignment operator, the parameter is not a reference. 
Instead, we pass the right-hand operand by value. 
Thus, rhs is a copy of the right-hand operand. 
Copying a HasPtr allocates a new copy of that object’s string.
In the body of the assignment operator, we call swap, which swaps the data members of rhs with those in *this. 
This call puts the pointer that had been in the left-hand operand into rhs, and puts the pointer that was in rhs into *this.
Thus, after the swap, the pointer member in *this points to the newly allocated string that is a copy of the right-hand operand.
When the assignment operator finishes, rhs is destroyed and the HasPtr destructor is run. 
That destructor deletes the memory to which rhs now points,
thus freeing the memory to which the left-hand operand had pointed.
The interesting thing about this technique is that it automatically handles self assignment and is automatically exception safe. 
By copying the right-hand operand before changing the left-hand operand, 
it handles self assignment in the same was as we did in our original assignment operator (§ 13.2.1, p. 512). 
It manages exception safety in the same way as the original definition as well. 
The only code that might throw is the new expression inside the copy constructor. 
If an exception occurs, it will happen before we have changed the left-hand operand.


-> NOTE: Assignment operators that use copy and swap are automatically exception safe and correctly handle self-assignment.


-> NOTE: The copy-assignment operator often does the same work as is needed in the copy constructor and destructor. 
In such cases, the common work should be put in private utility functions.


-> NOTE: Classes That Manage Dynamic Memory
Some classes need to allocate a varying amount of storage at run time. 
Such classes often can (and if they can, generally should) use a library container to hold their data. 
For example, our StrBlob class uses a vector to manage the underlying storage for its elements.
However, this strategy does not work for every class; some classes need to do their own allocation. 
Such classes generally must define their own copy-control members to manage the memory they allocate.


-> NOTE: Check C++ Primer to see an example of StringVector class that uses allocators and Uninitialized Memory


-> NOTE: Moving Objects
One of the major features in the new standard is the ability to move rather than copy an object. 
In some of these circumstances, an object is immediately destroyed after it is copied. 
In those cases, moving, rather than copying, the object can provide a significant performance boost.
As we’ve just seen, our StrVec class is a good example of this kind of superfluous copy. 
During reallocation, there is no need to copy—rather than move—the elements from the old memory to the new. 
A second reason to move rather than copy occurs in classes such as the IO or unique_ptr classes. 
These classes have a resource (such as a pointer or an IO buffer) that may not be shared. 
Hence, objects of these types can’t be copied but can be moved.
Under earlier versions of the language, there was no direct way to move an object. 
We had to make a copy even if there was no need for the copy. 
If the objects are large, or if the objects themselves require memory allocation (e.g., strings), making a needless copy can be expensive. 
Similarly, in previous versions of the library, classes stored in a container had to be copyable. 
Under the new standard, we can use containers on types that cannot be copied so long as they can be moved.
The library containers, string, and shared_ptr classes support move as well as copy. 
The IO and unique_ptr classes can be moved but not copied.


-> NOTE: Rvalue References
To support move operations, the new standard introduced a newkind of reference, an rvalue reference. 
An rvalue reference is a reference that must be bound to an rvalue. 
An rvalue reference is obtained by using && rather than &. 
As we’ll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. 
As a result, we are free to “move” resources from an rvalue reference to another object.
Recall that lvalue and rvalue are properties of an expression (§ 4.1.1, p. 135).
Some expressions yield or require lvalues; others yield or require rvalues. 
Generally speaking, an lvalue expression refers to an object’s identity whereas an rvalue expression refers to an object’s value.


-> NOTE:  Functions that return lvalue references, along with the assignment, subscript, dereference, 
and prefix increment/decrement operators, are all examples of expressions that return lvalues. 
We can bind an lvalue reference to the result of any of these expressions.


-> NOTE: Functions that return a nonreference type, along with the arithmetic, 
relational, bitwise, and postfix increment/decrement operators, all yield rvalues. 
We cannot bind an lvalue reference to these expressions, 
but we can bind either an lvalue reference to const or an rvalue reference to such expressions.


-> NOTE: Lvalues Persist; Rvalues Are Ephemeral
Looking at the list of lvalue and rvalue expressions, 
it should be clear that lvalues and rvalues differ from each other in an important manner: 
Lvalues have persistent state, whereas rvalues are either literals 
or temporary objects created in the course of evaluating expressions.
Because rvalue references can only be bound to temporaries, we know that
• The referred-to object is about to be destroyed
• There can be no other users of that object
These facts together mean that code that uses an rvalue reference 
is free to take over resources from the object to which the reference refers.


-> NOTE: Rvalue references refer to objects that are about to be destroyed. 
Hence, we can “steal” state from an object bound to an rvalue reference.


-> NOTE: Variables Are Lvalues
Although we rarely think about it this way, a variable is an expression with one operand and no operator. 
Like any other expression, a variable expression has the lvalue/rvalue property. 
Variable expressions are lvalues. It may be surprising, but as a consequence, 
we cannot bind an rvalue reference to a variable defined as an rvalue reference type:
int &&rr1 = 42; // ok: literals are rvalues
int &&rr2 = rr1; // error: the expression rr1 is an lvalue!
Given our previous observation that rvalues represent ephemeral objects, it should not be surprising that a variable is an lvalue. 
After all, a variable persists until it goes out of scope.


-> NOTE: A variable is an lvalue; we cannot directly bind an rvalue reference to a variable even if that variable was defined as an rvalue reference type.


-> NOTE: The Library move Function
Although we cannot directly bind an rvalue reference to an lvalue, 
we can explicitly cast an lvalue to its corresponding rvalue reference type. 
We can also obtain an rvalue reference bound to an lvalue by calling a new library function named move, which is defined in the utility header. 
The move function uses facilities that we’ll describe in § 16.2.6 (p. 690) to return an rvalue reference to its given object.
int &&rr3 = std::move(rr1); // ok
Calling move tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. 
It is essential to realize that the call to move promises that we do not intend to use rr1 again except to assign to it or to destroy it. 
After a call to move, we cannot make any assumptions about the value of the moved-from object.


-> NOTE: We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.


-> NOTE: As we’ve seen, differently from how we use most names from the library, 
we do not provide a using declaration (§ 3.1, p. 82) for move (§ 13.5, p. 530). 
We call std::move not move. 
We’ll explain the reasons for this usage in § 18.2.3 (p. 798).


-> NOTE: Code that uses move should use std::move, not move. Doing so avoids potential name collisions.


-> NOTE: Move Constructor and Move Assignment
Like the string class (and other library classes), our own classes can benefit from being able to be moved as well as copied. 
To enable move operations for our own types, we define a move constructor and a move-assignment operator. 
These members are similar to the corresponding copy operations, but they “steal” resources from their given object rather than copy them.
Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. 
Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. 
As in the copy constructor, any additional parameters must all have default arguments.
In addition to moving resources, the move constructor must ensure 
that the moved-from object is left in a state such that destroying that object will be harmless.
In particular, once its resources are moved, the original object must no longer point to those 
moved resources—responsibility for those resources has been assumed by the newly created object.


-> NOTE: Unlike the copy constructor, the move constructor does not allocate any new memory


-> NOTE: Move Operations, Library Containers, and Exceptions
Because a move operation executes by “stealing” resources, it ordinarily does not itself allocate any resources. 
As a result, move operations ordinarily will not throw any exceptions. 
When we write a move operation that cannot throw, we should inform the library of that fact. 
As we’ll see, unless the library knows that our move constructor won’t throw, 
it will do extra work to cater to the possibliity that moving an object of our class type might throw.


-> NOTE: One way inform the library is to specify noexcept on our constructor. 
We’ll cover noexcept, which was introduced by the new standard, in more detail in § 18.1.4 (p. 779). 
For now what’s important to know is that noexcept is a way for us to promise that a function does not throw any exceptions.


-> NOTE: Move constructors and move assignment operators that cannot throw exceptions should be marked as noexcept.


-> NOTE: What is the need for noexcept?
Understanding why noexcept is needed can help deepen our understanding of how the library interacts with objects of the types we write. 
We need to indicate that a move operation doesn’t throw because of two interrelated facts: 
First, although move operations usually don’t throw exceptions, they are permitted to do so. 
Second, the library containers provide guarantees as to what they do if an exception happens. 
As one example, vector guarantees that if an exception happens when we call push_back, the vector itself will be left unchanged.

As we’ve just seen moving an object generally changes the value of the moved from object. 
If reallocation uses a move constructor and that constructor throws an exception after moving some but not all of the elements, there would be a problem.
The moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. 
In this case, vector would be unable to meet its requirement that the vector is left unchanged.

On the other hand, if vector uses the copy constructor and an exception happens, it can easily meet this requirement. 
In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. 
If an exception happens, vector can free the space it allocated (but could not successfully construct) and return. 
The original vector elements still exist.

To avoid this potential problem, vector must use a copy constructor instead of a move constructor 
during reallocation unless it knows that the element type’s move constructor cannot throw an exception. 
If we want objects of our type to be moved rather than copied in circumstances such as vector reallocation, 
we must explicity tell the library that our move constructor is safe to use. 
We do so by marking the move constructor (and move-assignment operator) noexcept.


-> NOTE: Move-Assignment Operator
The move-assignment operator does the same work as the destructor and the move constructor. 
As with the move constructor, if our move-assignment operator won’t throw any exceptions, we should make it noexcept. 
Like a copy-assignment operator, a move-assignment operator must guard against self-assignment.
In this case we check directly whether the this pointer and the address of rhs are the same. 
If they are, the right- and left-hand operands refer to the same object and there is no work to do. 
Otherwise, we free the memory that the left-hand operand had used, and then take over the memory from the given object. 
As in the move constructor, we set the pointers in rhs to nullptr.
It may seem surprising that we bother to check for self-assignment. 
After all, move assignment requires an rvalue for the right-hand operand. 
We do the check because that rvalue could be the result of calling move. 
As in any other assignment operator, it is crucial that we not free the left-hand resources 
before using those (possibly same) resources from the right-hand operand.


-> NOTE: A Moved-from Object Must Be Destructible
Moving from an object does not destroy that object: 
Sometime after the move operation completes, the moved-from object will be destroyed. 
Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in which the destructor can be run. 
Our StrVec move operations meet this requirement by setting the pointer members of the moved-from object to nullptr.
In addition to leaving the moved-from object in a state that is safe to destroy,
move operations must guarantee that the object remains valid. 
In general, a valid object is one that can safely be given a new value or used in other ways that do not depend on its current value. 
On the other hand, move operations have no requirements as to the value that remains in the moved-from object. 
As a result, our programs should never depend on the value of a moved-from object.

-> NOTE: After a move operation, the “moved-from” object must remain a valid, destructible object but users may make no assumptions about its value.


-> NOTE: The Synthesized Move Operations
As it does for the copy constructor and copy-assignment operator, 
the compiler will synthesize the move constructor and move-assignment operator. 
However, the conditions under which it synthesizes a move operation 
are quite different from those in which it synthesizes a copy operation.
Recall that if we do not declare our own copy constructor or copy-assignment operator 
the compiler always synthesizes these operations (§ 13.1.1, p. 497 and § 13.1.2, p. 500). 
The copy operations are defined either to memberwise copy or assign the object or they are defined as deleted functions.

Differently from the copy operations, for some classes the compiler does not synthesize the move operations at all. 
In particular, if a class defines its own copy constructor, copy-assignment operator, or destructor,
the move constructor and move-assignment operator are not synthesized. 
As a result, some classes do not have a move constructor or a move-assignment operator. 
As we’ll see on page 540, when a class doesn’t have a move operation, 
the corresponding copy operation is used in place of move through normal function matching.

The compiler will synthesize a move constructor or a move-assignment operator 
only if the class doesn’t define any of its own copy-control members 
and if every nonstatic data member of the class can bemoved. 
The compiler can move members of built-in type. 
It can also move members of a class type if themember’s class has the corresponding move operation


-> NOTE: The compiler synthesizes the move constructor and move assignment only if a class 
does not define any of its own copy-control members 
and only if all the data members can be moved constructed and move assigned, respectively.


-> NOTE: Unlike the copy operations, a move operation is never implicitly defined as a deleted function. 
However, if we explicitly ask the compiler to generate a move operation by using = default (§ 7.1.4, p. 264), 
and the compiler is unable to move all the members, then the move operation will be defined as deleted. 
With one important exception, the rules for when a synthesized move operation is defined as deleted 
are analogous to those for the copy operations (§ 13.1.6, p. 508):
• Unlike the copy constructor, the move constructor is defined as deleted 
if the class has a member that defines its own copy constructor but does not also define a move constructor, 
or if the class has a member that doesn’t define its own copy operations 
and for which the compiler is unable to synthesize a move constructor. 
Similarly for move-assignment.
• The move constructor or move-assignment operator is defined as deleted if the class has a member 
whose own move constructor or move-assignment operator is deleted or inaccessible.
• Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.
• Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a const or reference member.


-> NOTE: Classes that define a move constructor or move-assignment operator must also define their own copy operations. 
Otherwise, those members are deleted by default.


-> NOTE: Rvalues Are Moved, Lvalues Are Copied ...
When a class has both a move constructor and a copy constructor, 
the compiler uses ordinary function matching to determine which constructor to use (§ 6.4, p. 233). 
Similarly for assignment.


-> NOTE: ... But Rvalues Are Copied If There Is No Move Constructor
What if a class has a copy constructor but does not define a move constructor?
In this case, the compiler will not synthesize the move constructor, which means the class has a copy constructor but no move constructor. 
If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling move.


-> NOTE: If a class has a usable copy constructor and no move constructor, objects will be “moved” by the copy constructor. 
Similarly for the copy assignment operator and move-assignment.


-> NOTE: Copy-and-Swap Assignment Operators and Move
The version of our HasPtr class that defined a copy-and-swap assignment operator (§ 13.3, p. 518) 
is a good illustration of the interaction between function matching and move operations. 
If we add a move constructor to this class, it will effectively get a move assignment operator as well.
class HasPtr {
public:
// added move constructor
HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
// assignment operator is both the move- and copy-assignment operator (ME: I've seen this example.)
HasPtr& operator=(HasPtr rhs)
{ swap(*this, rhs); return *this; }
// other members as in § 13.2.1 (p. 511)
};
In this version of the class, we’ve added a move constructor that takes over the values from its given argument. 
The constructor body sets the pointer member of the given HasPtr to zero to ensure that it is safe to destroy the moved-from object.
Nothing this function does can throw an exception so we mark it as noexcept (§ 13.6.2, p. 535).


-> NOTE: ADVICE: UPDATING THE RULE OF THREE
All five copy-control members should be thought of as a unit: 
Ordinarily, if a class defines any of these operations, it usually should define the mall. 
As we’ve seen, some classes must define the copy constructor, copy-assignment operator, and destructor to work correctly (§ 13.1.4, p. 504). 
Such classes typically have a resource that the copy members must copy. 
Ordinarily, copying a resource entails some amount of overhead.
Classes that define the move constructor and move-assignment operator can avoid this overhead in those circumstances where a copy isn’t necessary.


-> NOTE: ADVICE: DON’T BE TOO QUICK TO MOVE
Because a moved-from object has indeterminate state, calling std::move on an object is a dangerous operation. 
When we call move, we must be absolutely certain that there can be no other users of the moved-from object.
Judiciously used inside class code, move can offer significant performance benefits.
Casually used in ordinary user code (as opposed to class implementation code),
moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.
Outside of class implementation code such as move constructors or move assignment operators, 
use std::move only when you are certain that you need to do a move and that the move is guaranteed to be safe.


-> NOTE: Rvalue References and Member Functions
Member functions other than constructors and assignment can benefit from providing both copy and move versions. 
Such move-enabled members typically use the same parameter pattern as the copy/move constructor 
and the assignment operators—one version takes an lvalue reference to const, 
and the second takes an rvalue reference to nonconst.
For example, the library containers that define push_back provide two versions:
one that has an rvalue reference parameter and the other a const lvalue reference. 
Assuming X is the element type, these containers define:
void push_back(const X&); // copy: binds to any kind of X
void push_back(X&&); // move: binds only to modifiable rvalues of type X
We can pass any object that can be converted to type X to the first version of push_back. 
This version copies data from its parameter. 
We can pass only an rvalue that is not const to the second version. 
This version is an exactmatch (and a better match) for nonconst rvalues 
and will be run when we pass a modifiable rvalue (§ 13.6.2, p. 539). 
This version is free to steal resources from its parameter.


-> NOTE: Ordinarily, there is no need to define versions of the operation that take a const X&& or a (plain) X&. 
Usually, we pass an rvalue reference when we want to “steal” from the argument. 
In order to do so, the argument must not be const.
Similarly, copying from an object should not change the object being copied. 
As a result, there is usually no need to define a version that take a (plain) X& parameter.


-> NOTE: Overloaded functions that distinguish between moving and copying a parameter 
typically have one version that takes a const T& and one that takes a T&&.


-> NOTE: ME: Reference functions are C++11 feature.


-> NOTE: Rvalue and Lvalue Reference Member Functions (ME: WTF? This is the first time i've heard of this!)
Ordinarily, we can call a member function on an object, regardless of whether that object is an lvalue or an rvalue. 
For example:
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find(’a’);
Here, we called the find member (§ 9.5.3, p. 364) on the string rvalue that results from adding two strings. 
Sometimes such usage can be surprising:
s1 + s2 = "wow!";
Here we assign to the rvalue result of concatentating these strings.
Prior to the new standard, there was no way to prevent such usage. 
In order to maintain backward compatability, the library classes continue to allow assignment to rvalues.
However, we might want to prevent such usage in our own classes. 
In this case, we’d like to force the left-hand operand (i.e., the object to which this points) to be an lvalue.
We indicate the lvalue/rvalue property of this in the sameway that we define const member functions (§ 7.1.2, p. 258);
we place a reference qualifier after the parameter list:
class Foo {
public:
Foo &operator=(const Foo&) &; // may assign only to modifiable lvalues
// other members of Foo
};
Foo &Foo::operator=(const Foo &rhs) &
{
// do whatever is needed to assign rhs to this object
return *this;
}
The reference qualifier can be either & or &&, indicating that this may point to an rvalue or lvalue, respectively. 
Like the const qualifier, a reference qualifier may appear only on a (nonstatic) member function 
and must appear in both the declaration and definition of the function.
We may run a function qualified by & only on an lvalue andmay run a function qualified by && only on an rvalue.
Foo &retFoo(); // returns a reference; a call to retFoo is an lvalue
Foo retVal(); // returns by value; a call to retVal is an rvalue
Foo i, j; // i and j are lvalues
i = j; // ok: i is an lvalue
retFoo() = j; // ok: retFoo() returns an lvalue
retVal() = j; // error: retVal() returns an rvalue
i = retVal(); // ok: we can pass an rvalue as the right-hand operand to assignment
A function can be both const and reference qualified. 
In such cases, the reference qualifier must follow the const qualifier:
class Foo {
public:
Foo someMem() & const; // error: const qualifier must come first
Foo anotherMem() const &; // ok: const qualifier comes first
};


-> NOTE: Overloading and Reference Functions
Just as we can overload a member function based on whether it is const (§ 7.3.2, p. 276), 
we can also overload a function based on its reference qualifier. 
Moreover, we may overload a function by its reference qualifier and by whether it is a const member. 
As an example, we’ll give Foo a vector member and a function named sorted 
that returns a copy of the Foo object in which the vector is sorted:
class Foo {
public:
Foo sorted() &&; // may run on modifiable rvalues
Foo sorted() const &; // may run on any kind of Foo
// other members of Foo
private:
vector<int> data;
};
// this object is an rvalue, so we can sort in place
Foo Foo::sorted() &&
{
sort(data.begin(), data.end());
return *this;
}
// this object is either const or it is an lvalue; either way we can’t sort in place
Foo Foo::sorted() const & {
Foo ret(*this); // make a copy
sort(ret.data.begin(), ret.data.end()); // sort the copy
return ret; // return the copy
}
When we run sorted on an rvalue, it is safe to sort the data member directly.
The object is an rvalue, which means it has no other users, so we can change the object itself. 
When we run sorted on a const rvalue or on an lvalue, we can’t change this object, so we copy data before sorting it.
Overload resolution uses the lvalue/rvalue property of the object 
that calls sorted to determine which version is used:
retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &&
retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &
When we define const memeber functions, we can define two versions that differ only in that one is const qualified and the other is not. 
There is no similar default for reference qualified functions. 
When we define two or more members that have the same name and the same parameter list, 
we must provide a reference qualifier on all or none of those functions:
class Foo {
public:
Foo sorted() &&;
Foo sorted() const; // error: must have reference qualifier
// Comp is type alias for the function type (see § 6.7 (p. 249))
// that can be used to compare int values
using Comp = bool(const int&, const int&);
Foo sorted(Comp*); // ok: different parameter list
Foo sorted(Comp*) const; // ok: neither version is reference qualified
};
Here the declaration of the const version of sorted that has no parameters is an error. 
There is a second version of sorted that has no parameters and that function has a reference qualifier, 
so the const version of that function must have a reference qualifier as well. 
On the other hand, the versions of sorted that take a pointer to a comparison operation are fine, because neither function has a qualifier.


-> NOTE: If a member function has a reference qualifier, all the versions of that member with the same parameter list must have reference qualifiers.



-> NOTE: Operator overloading
Operator overloading lets us define the meaning of an operator when applied to operand(s) of a class type. 
Judicious use of operator overloading can make our programs easier to write and easier to read. 


-> NOTE: Basic Concepts

-> NOTE: Overloaded operators are functions with special names: the keyword operator followed by the symbol for the operator being defined. 
Like any other function, an overloaded operator has a return type, a parameter list, and a body.

-> NOTE: An overloaded operator function has the same number of parameters as the operator has operands. 
A unary operator has one parameter; a binary operator has two. 
In a binary operator, the left-hand operand is passed to the first parameter and the right-hand operand to the second. 
Except for the overloaded function-call operator, operator(), an overloaded operator may not have default arguments (§ 6.5.1, p. 236).

-> NOTE: If an operator function is a member function, the first (left-hand) operand is bound to the implicit this pointer (§ 7.1.2, p. 257). 
Because the first operand is implicitly bound to this, 
a member operator function has one less (explicit) parameter than the operator has operands.

-> NOTE: When an overloaded operator is a member function, this is bound to the left-hand operand. 
Member operator functions have one less (explicit) parameter than the number of operands.

-> NOTE: An operator function must either be a member of a class or have at least one parameter of class type:
int operator+(int, int); // error: cannot redefine the built-in operator for ints
This restriction means that we cannot change the meaning of an operator when applied to operands of built-in type.

-> NOTE: We can overload most, but not all, of the operators. 
Table 14.1 shows whether or not an operator may be overloaded. 
We’ll cover overloading new and delete in § 19.1.1 (p. 820).

-> NOTE: Operators That May Be Overloaded
+ - * / % ^
& | ~ ! , =
< > <= >= ++ --
<< >> == != && ||
+= -= /= %= ^= &=
|= *= <<= >>= [] ()
-> ->* new new [] delete delete []

-> NOTE: Operators That Cannot Be Overloaded
:: .* . ?:

-> NOTE: We can overload only existing operators and cannot invent new operator symbols.
For example, we cannot define operator** to provide exponentiation.

-> NOTE: Four symbols (+, -, *, and &) serve as both unary and binary operators. 
Either or both of these operators can be overloaded. 
The number of parameters determines which operator is being defined.

-> NOTE: An overloaded operator has the same precedence and associativity (§ 4.1.2, p. 136) as the corresponding built-in operator. 
Regardless of the operand types x == y + z  is always equivalent to x == (y + z).


-> NOTE: Calling an Overloaded Operator Function Directly
Ordinarily, we “call” an overloaded operator function indirectly by using the operator on arguments of the appropriate type. 
However, we can also call an overloaded operator function directly in the same way that we call an ordinary function.
We name the function and pass an appropriate number of arguments of the appropriate type:
// equivalent calls to a nonmember operator function
data1 + data2; // normal expression
operator+(data1, data2); // equivalent function call
These calls are equivalent: 
Both call the nonmember function operator+, passing data1 as the first argument and data2 as the second.
We call a member operator function explicitly in the same way that we call any other member function. 
We name an object (or pointer) on which to run the function and use the dot (or arrow) operator to fetch the function we wish to call:
data1 += data2; // expression-based ‘‘call’’
data1.operator+=(data2); // equivalent call to a member operator function
Each of these statements calls the member function operator+=, 
binding this to the address of data1 and passing data2 as an argument.


-> NOTE: Some Operators Shouldn’t Be Overloaded
Recall that a few operators guarantee the order in which operands are evaluated.
Because using an overloaded operator is really a function call, these guarantees do not apply to overloaded operators. 
In particular, the operand-evaluation guarantees of the logical AND, logical OR (§ 4.3, p. 141), and comma (§ 4.10, p. 157) operators are not preserved. 
Moreover, overloaded versions of && or || operators do not preserve short-circuit evaluation properties of the built-in operators. 
Both operands are always evaluated.
Because the overloaded versions of these operators do not preserve order of evaluation and/or short-circuit evaluation, 
it is usually a bad idea to overload them. 
Users are likely to be surprised when the evaluation guarantees they are accustomed 
to are not honored for code that happens to use an overloaded version of one of these operators.
Another reason not to overload comma, which also applies to the address-of operator, is that unlike most operators,
the language defines what the comma and address-of operators mean when applied to objects of class type. 
Because these operators have built-in meaning, they ordinarily should not be overloaded. 
Users of the class will be surprised if these operators behave differently from their normal meanings.


-> NOTE: Ordinarily, the comma, address-of, logical AND, and logical OR operators should not be overloaded.


-> NOTE: Use Definitions That Are Consistent with the Built-in Meaning
When you design a class, you should always think first about what operations the class will provide. 
Only after you know what operations are needed should you think about whether to define each operation as an ordinary function or as an overloaded operator. 
Those operations with a logical mapping to an operator are good candidates for defining as overloaded operators:
• If the class does IO, define the shift operators to be consistent with how IO is done for the built-in types.
• If the class has an operation to test for equality, define operator==. If the class has operator==, it should usually have operator!= as well.
• If the class has a single, natural ordering operation, define operator<. If the class has operator<, it should probably have all of the relational operators.
• The return type of an overloaded operator usually should be compatible with the return fromthe built-in version of the operator: 
The logical and relational operators should return bool, the arithmetic operators should return a value of the class type, 
and assignment and compound assignment should return a reference to the left-hand operand.


-> NOTE: Assignment and Compound Assignment Operators (+= -= /= %= ^= &= |= *= <<= >>=)
Assignment operators should behave analogously to the synthesized operators:
After an assignment, the values in the left-hand and right-hand operands should have the same value, 
and the operator should return a reference to its left-hand operand. 
Overloaded assignment should generalize the built-in meaning of assignment, not circumvent it.
If a class has an arithmetic (§ 4.2, p. 139) or bitwise (§ 4.8, p. 152) operator,
then it is usually a good idea to provide the corresponding compound-assignment operator as well.
Needless to say, the += operator should be defined to behave the same way the built-in operators do: it should behave as + followed by =.


-> NOTE: CAUTION: USE OPERATOR OVERLOADING JUDICIOUSLY
Each operator has an associated meaning from its use on the built-in types. 
Binary +, for example, is strongly identified with addition. 
Mapping binary + to an analogous operation for a class type can provide a convenient notational shorthand. 
For example, the library string type, following a convention common to many programming languages, 
uses + to represent concatenation—“adding” one string to the other.
Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type. 
Using overloaded operators rather than inventing named operations can make our programs more natural and intuitive. 
Overuse or outright abuse of operator overloading can make our classes incomprehensible.
Obvious abuses of operator overloading rarely happen in practice. 
As an example, no responsible programmer would define operator+ to perform subtraction. 
More common, but still inadvisable, are uses that contort an operator’s “normal”meaning to force a fit to a given type. 
Operators should be used only for operations that are likely to be unambiguous to users. 
An operator has an ambiguous meaning if it plausibly has more than one interpretation.


-> NOTE: Choosing Member or Nonmember Implementation (ME: THIS IS IMPORTANT)
When we define an overloaded operator, we must decide whether to make the operator a class member or an ordinary nonmember function. 
In some cases, there is no choice—some operators are required to be members; 
in other cases, we may not be able to define the operator appropriately if it is a member.
The following guidelines can be of help in deciding whether to make an operator a member or an ordinary nonmember function:
• The assignment (=), subscript ([]), call (()), and member access arrow (->) operators must be defined as members.
• The compound-assignment operators ordinarily ought to be members. 
However, unlike assignment, they are not required to be members.
• Operators that change the state of their object or that are closely tied to their given type—
such as increment, decrement, and dereference—usually should be members.
• Symmetric operators—those that might convert either operand, such as the arithmetic, equality, relational, 
and bitwise operators—usually should be defined as ordinary nonmember functions.
Programmers expect to be able to use symmetric operators in expressions with mixed types. 
For example, we can add an int and a double. 
The addition is symmetric because we can use either type as the left-hand or the right-hand operand.
If we want to provide similar mixed-type expressions involving class objects, then the operator must be defined as a nonmember function.
When we define an operator as a member function, then the left-hand operand must be an object of the class of which that operator is a member. 
For example:
string s = "world";
string t = s + "!"; // ok: we can add a const char* to a string
string u = "hi" + s; // would be an error if + were a member of string (ME: WTF?)
If operator+ were a member of the string class, the first addition would be equivalent to s.operator+("!"). 
Likewise, "hi" + s would be equivalent to "hi".operator+(s). 
However, the type of "hi" is const char*, and that is a built-in type; it does not even have member functions.
Because string defines + as an ordinary nonmember function, "hi" + s is equivalent to operator+("hi", s). 
As with any function call, either of the arguments can be converted to the type of the parameter.
The only requirements are that at least one of the operands has a class type, and that both operands can be converted (unambiguously) to string.


-> NOTE: ME: Bard question:
In C++, why is there a difference in performance for member operator overloading vs nonmember operator overloading?
There are a few reasons why there is a difference in performance for member operator overloading vs nonmember operator overloading in C++.
    -> Member operator overloading uses the this pointer: When you overload an operator as a member function, the compiler generates code that uses the this pointer. 
	The this pointer is a pointer to the current object, and it can add some overhead to the operation.
    -> Nonmember operator overloading does not use the this pointer: When you overload an operator as a nonmember function, 
	the compiler generates code that does not use the this pointer. 
	This can make the operation more efficient, because the compiler does not have to worry about dereferencing the this pointer.
    -> Member operator overloading can access private members: 
	When you overload an operator as a member function, the compiler can access private members of the class. 
	This can make the operation more efficient, because the compiler does not have to pass the private members as arguments to the function.
    -> Nonmember operator overloading cannot access private members: 
	When you overload an operator as a nonmember function, the compiler cannot access private members of the class. 
	This can make the operation less efficient, because the compiler has to pass the private members as arguments to the function.
In general, nonmember operator overloading is more efficient than member operator overloading. 
However, there are cases where member operator overloading can be more efficient, such as when the operator needs to access private members of the class.
It is important to note that the performance difference between member operator overloading and nonmember operator overloading is typically small. 
In most cases, the difference in performance will not be noticeable. 
However, if you are writing code that is performance-critical, you may want to consider using nonmember operator overloading.


-> NOTE: Output Operators Usually Do Minimal Formatting
The output operators for the built-in types do little if any formatting. 
In particular, they do not print newlines. 
Users expect class output operators to behave similarly.
If the operator does print a newline, then users would be unable to print descriptive text along with the object on the same line. 
An output operator that does minimal formatting lets users control the details of their output.
Generally, output operators should print the contents of the object, with minimal formatting. 
They should not print a newline.


-> NOTE: IO Operators Must Be Nonmember Functions
Input and output operators that conform to the conventions of the iostream library must be ordinary nonmember functions. 
These operators cannot be members of our own class. 
If they were, then the left-hand operand would have to be an object of our class type:
Sales_data data;
data << cout; // if operator<< is a member of Sales_data
If these operators are members of any class, they would have to be members of istream or ostream. 
However, those classes are part of the standard library, and we cannot add members to a class in the library.


-> NOTE: Errors during Input
The kinds of errors that might happen in an input operator include the following:
• A read operation might fail because the stream contains data of an incorrect type. 
For example, after reading bookNo, the input operator assumes that the next two items will be numeric data. 
If nonnumeric data is input, that read and any subsequent use of the stream will fail.
• Any of the reads could hit end-of-file or some other error on the input stream.


-> NOTE: Rather than checking each read, we check once after reading all the data and before using those data:
if (is) // check that the inputs succeeded
item.revenue = item.units_sold * price;
else
item = Sales_data(); // input failed: give the object the default state


-> NOTE: Input operators should decide what, if anything, to do about error recovery.


-> NOTE: Indicating Errors
Some input operators need to do additional data verification. 
For example, our input operator might check that the bookNo we read is in an appropriate format.
In such cases, the input operator might need to set the stream’s condition state to indicate failure (§ 8.1.2, p. 312), 
even though technically speaking the actual IO was successful. 
Usually an input operator should set only the failbit. 
Setting eofbit would imply that the file was exhausted, and setting badbit would indicate that the stream was corrupted. 
These errors are best left to the IO library itself to indicate.


-> NOTE: An arithmetic operator usually generates a new value that is the result of a computation on its two operands. 
That value is distinct fromeither operand and is calculated in a local variable. 
The operation returns a copy of this local as its result.
Classes that define an arithmetic operator generally define the corresponding compound assignment operator as well. 
When a class has both operators, it is usually more efficient to define the arithmetic operator to use compound assignment:
// assumes that both objects refer to the same book
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
Sales_data sum = lhs; // copy data members from lhs into sum
sum += rhs; // add rhs into sum
return sum;
}


-> NOTE: Classes that define both an arithmetic operator and the related compound assignment ordinarily 
ought to implement the arithmetic operator by using the compound assignment.


-> NOTE: Equality Operators important are the design principles that these functions embody:
• If a class has an operation to determine whether two objects are equal, 
it should define that function as operator== rather than as a named function:
Users will expect to be able to compare objects using ==; providing == means 
they won’t need to learn and remember a new name for the operation; 
and it is easier to use the library containers and algorithms with classes that define the == operator.
• If a class defines operator==, that operator ordinarily should determine whether the given objects contain equivalent data.
• Ordinarily, the equality operator should be transitive, meaning that if a == b and b == c are both true, then a == c should also be true.
• If a class defines operator==, it should also define operator!=. 
Users will expect that if they can use == then they can also use !=, and vice versa.
• One of the equality or inequality operators should delegate the work to the other. 
That is, one of these operators should do the real work to compare objects. 
The other should call the one that does the real work.


-> NOTE: Classes for which there is a logical meaning for equality normally should define operator==. 
Classes that define == make it easier for users to use the class with the library algorithms.


-> NOTE: Relational Operators
Classes for which the equality operator is defined also often (but not always) have relational operators. 
In particular, because the associative containers 
and some of the algorithms use the less-than operator, it can be useful to define an operator<.
Ordinarily the relational operators should:
1. Define an ordering relation that is consistent with
the requirements for use as a key to an associative container (§ 11.2.2, p. 424); and
2. Define a relation that is consistent with == if the class has both operators. 
In particular, if two objects are !=, then one object should be < the other.



-> NOTE: Assignment operators can be overloaded. 
Assignment operators, regardless of parameter type, must be defined as member functions.


-> NOTE: Assignment operators must, and ordinarily compound-assignment operators should, be defined as members. 
These operators should return a reference to the left-hand operand.


-> NOTE: The subscript operator must be a member function.


-> NOTE: If a class has a subscript operator, it usually should define two versions:
one that returns a plain reference and the other that is a const member and returns a reference to const.


-> NOTE: Classes that define increment or decrement operators should define both the prefix and postfix versions. 
These operators usually should be defined as members.


-> NOTE: To be consistent with the built-in operators, 
the prefix operators should return a reference to the incremented or decremented object.


-> NOTE: Differentiating Prefix and Postfix Operators
There is one problem with defining both the prefix and postfix operators: 
Normal overloading cannot distinguish between these operators. 
The prefix and postfix versions use the same symbol, 
meaning that the overloaded versions of these operators have the same name. 
They also have the same number and type of operands.
To solve this problem, the postfix versions take an extra (unused) parameter of type int. 
When we use a postfix operator, the compiler supplies 0 as the argument for this parameter. 
Although the postfix function can use this extra parameter, it usually should not. 
That parameter is not needed for the work normally performed by a postfix operator. 
Its sole purpose is to distinguish a postfix function from the prefix version.


-> NOTE: To be consistent with the built-in operators, 
the postfix operators should return the old (unincremented or undecremented) value. 
That value is returned as a value, not a reference.


-> NOTE: The int parameter is not used, so we do not give it a name.


-> NOTE: Calling the Postfix Operators Explicitly
As we saw on page 553, we can explicitly call an overloaded operator 
as an alternative to using it as an operator in an expression. 
If we want to call the postfix version using a function call, 
then we must pass a value for the integer argument:
StrBlobPtr p(a1); // p points to the vector inside a1
p.operator++(0); // call postfix operator++
p.operator++(); // call prefix operator++
The value passed usually is ignored but is necessary in order 
to tell the compiler to use the postfix version.


-> NOTE: Member Access Operators
Operator arrow must be a member. 
The dereference operator is not required to be a member but usually should be a member as well.


-> NOTE: Constraints on the Return from Operator Arrow
As with most of the other operators (although it would be a bad idea to do so), 
we can define operator* to do whatever processing we like. 
That is, we can define operator* to return a fixed value, say, 42, 
or print the contents of the object to which it is applied, or whatever. 
The same is not true for overloaded arrow. 
The arrow operator never loses its fundamental meaning of member access. 
When we overload arrow, we change the object from which arrow fetches the specified member. 
We cannot change the fact that arrow fetches a member.
When we write point->mem, point must be a pointer to a class object 
or it must be an object of a class with an overloaded operator->. 
Depending on the type of point, writing point->mem is equivalent to
(*point).mem; // point is a built-in pointer type
point.operator()->mem; // point is an object of class type
Otherwise the code is in error. 
That is, point->mem executes as follows:
1. If point is a pointer, then the built-in arrow operator is applied, 
which means this expression is a synonym for (*point).mem. 
The pointer is dereferenced and the indicated member is fetched from the resulting object.
If the type pointed to by point does not have a member named mem, then the code is in error.
2. If point is an object of a class that defines operator->, 
then the result of point.operator->() is used to fetch mem. 
If that result is a pointer, then step 1 is executed on that pointer. 
If the result is an object that itself has an overloaded operator->(), 
then this step is repeated on that object.
This process continues until either a pointer to an object with 
the indicated member is returned or some other value is returned, in which case the code is in error.


-> NOTE: The overloaded arrow operator must return either a pointer to a class type 
or an object of a class type that defines its own operator arrow.


-> NOTE: The function-call operator must be a member function. 
A class may define multiple versions of the call operator, 
each of which must differ as to the number or types of their parameters.


-> NOTE: Function-Call Operator
Classes that overload the call operator allow objects of its type to be used as if they were a function. 
Because such classes can also store state, they can be more flexible than ordinary functions.
As a simple example, the following struct, named absInt, 
has a call operator that returns the absolute value of its argument:
struct absInt {
int operator()(int val) const {
return val < 0 ? -val : val;
}
};
This class defines a single operation: the function-call operator. 
That operator takes an argument of type int and returns the argument’s absolute value.
We use the call operator by applying an argument list 
to an absInt object in a way that looks like a function call:
int i = -42;
absInt absObj; // object that has a function-call operator
int ui = absObj(i); // passes i to absObj.operator()
Even though absObj is an object, not a function, we can “call” this object. 
Calling an object runs its overloaded call operator. 
In this case, that operator takes an int value and returns its absolute value.


-> NOTE: The function-call operator must be a member function. 
A class may define multiple versions of the call operator, 
each of which must differ as to the number or types of their parameters.


-> NOTE: Objects of classes that define the call operator are referred to as function objects.
Such objects “act like functions” because we can call them.


-> NOTE: Function-Object Classes with State
Like any other class, a function-object class can have additional members aside from operator(). 
Function-object classes often contain data members that are used to customize the operations in the call operator.


-> NOTE: Lambdas Are Function Objects
In the previous section, we used a PrintString object as an argument in a call to for_each. 
This usage is similar to the programs we wrote in § 10.3.2 (p. 388) that used lambda expressions. 
When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class (§ 10.3.3, p. 392).


-> NOTE: Classes Representing Lambdas with Captures
As we’ve seen, when a lambda captures a variable by reference, 
it is up to the program to ensure that the variable to which the reference 
refers exists when the lambda is executed (§ 10.3.3, p. 393). 
Therefore, the compiler is permitted to use the reference directly 
without storing that reference as a datamember in the generated class.
In contrast, variables that are captured by value are copied into the lambda (§ 10.3.3, p. 392). 
As a result, classes generated from lambdas that capture variables by value have data members corresponding to each such variable. 
These classes also have a constructor to initialize these data members from the value of the captured variables.


-> NOTE: Library-Defined Function Objects
The standard library defines a set of classes that represent the arithmetic, relational, and logical operators. 
Each class defines a call operator that applies the named operation. 
For example, the plus class has a function-call operator that applies + to a pair of operands; 
the modulus class defines a call operator that applies the binary % operator; the equal_to class applies ==; and so on.


-> NOTE: Library Function Objects
1) Arithmetic:
plus<Type>
minus<Type>
multiplies<Type> 
divides<Type>
modulus<Type>
negate<Type>
2) Relational 
equal_to<Type> 
not_equal_to<Type> 
greater<Type> 
greater_equal<Type>
less<Type>
less_equal<Type>
3) Logical
logical_and<Type>
logical_or<Type>
logical_not<Type>


-> NOTE: Using a Library Function Object with the Algorithms
The function-object classes that represent operators are often used 
to override the default operator used by an algorithm. 
As we’ve seen, by default, the sorting algorithms use operator<, 
which ordinarily sorts the sequence into ascending order.
To sort into descending order, we can pass an object of type greater. 
That class generates a call operator that invokes the greater-than operator of the underlying element type. 
For example, if svec is a vector<string>,
// passes a temporary function object that applies the < operator to two strings
sort(svec.begin(), svec.end(), greater<string>());


-> NOTE: Callable Objects and function
C++ has several kinds of callable objects: functions and pointers to functions, 
lambdas (§ 10.3.2, p. 388), objects created by bind (§ 10.3.4, p. 397), 
and classes that overload the function-call operator.


-> NOTE: However, two callable objects with different types may share the same call signature.
The call signature specifies the type returned by a call to the object 
and the argument type(s) that must be passed in the call. 
A call signature corresponds to a function type. 
For example:
int(int, int)
is a function type that takes two ints and returns an int.


-> NOTE: Different Types Can Have the Same Call Signature
Sometimes we want to treat several callable objects that share a call signature as if they had the same type.
For example, consider the following different types of
callable objects:
// ordinary function
int add(int i, int j) { return i + j; }
// lambda, which generates an unnamed function-object class
auto mod = [](int i, int j) { return i % j; };
// function-object class
struct divide {
int operator()(int denominator, int divisor) {
return denominator / divisor;
}
};
Each of these callables applies an arithmetic operation to its parameters. 
Even though each has a distinct type, they all share the same call signature:
int(int, int)


-> NOTE: The Library function Type
We can solve this problem using a new library type named function that is defined in the functional header; 
Table 14.3 (p. 579) lists the operations defined by function.
function is a template. 
As with other templates we’ve used, we must specify additional information when we create a function type. 
In this case, that information is the call signature of the objects that this particular function type can represent. 
As with other templates, we specify the type inside angle brackets:
function<int(int, int)>
Here we’ve declared a function type that can represent callable objects that return an int result and have two int parameters.
We canuse that type to represent any of our desk calculator types:
function<int(int, int)> f1 = add; // function pointer
function<int(int, int)> f2 = divide(); // object of a function-object class
function<int(int, int)> f3 = [](int i, int j) // lambda
{ return i * j; };
cout << f1(4,2) << endl; // prints 6
cout << f2(4,2) << endl; // prints 2
cout << f3(4,2) << endl; // prints 8


-> NOTE: Operations on function
1) function<T> f; 
f is a null function object that can store callable objects with a call signature that is equivalent to the function type T
(i.e., T is retType(args)).
2) function<T> f(nullptr); 
Explicitly construct a null function.
3) function<T> f(obj); 
Stores a copy of the callable object obj in f.
f Use f as a condition; true if f holds a callable object; false otherwise.
4) f(args) 
Calls the object in f passing args.
----------------------------------------------------------------
Types defined as members of function<T>
----------------------------------------------------------------
5) result_type 
The type returned by this function type’s callable object.
6) argument_type, first_argument_type, second_argument_type
Types defined when T has exactly one or two arguments.
If T has one argument, argument_type is a synonym for that type. 
If T has two arguments, first_argument_type and second_argument_type 
are synonyms for those argument types.


-> NOTE: The function class in the new library is not related to classes named unary_function a
nd binary_function that were part of earlier versions of the library. 
These classes have been deprecated by the more general bind function (§ 10.3.4, p. 401).


-> NOTE: Overloading, Conversions, and Operators
In § 7.5.4 (p. 294) we saw that a nonexplicit constructor that can be called with one argument defines an implicit conversion. 
Such constructors convert an object from the argument’s type to the class type. 
We can also define conversions from the class type. 
We define a conversion from a class type by defining a conversion operator. 
Converting constructors and conversion operators define class-type conversions.
Such conversions are also referred to as user-defined conversions.


-> NOTE: Conversion Operators
A conversion operator is a special kind of member function 
that converts a value of a class type to a value of some other type. 
A conversion function typically has the general form:
operator type() const;
where type represents a type. 
Conversion operators can be defined for any type (other than void) 
that can be a function return type (§ 6.1, p. 204). 
Conversions to an array or a function type are not permitted. 
Conversions to pointer types—both data and function pointers—and to reference types are allowed.


-> NOTE: CAUTION: AVOID OVERUSE OF CONVERSION FUNCTIONS
As with using overloaded operators, judicious use of conversion operators 
can greatly simplify the job of a class designer and make using a class easier. 
However, some conversions can be misleading. 
Conversion operators are misleading when there is no obvious single mapping between the class type and the conversion type.
For example, consider a class that represents a Date. 
We might think it would be a good idea to provide a conversion fromDate to int. 
However, what value should the conversion function return? 
The function might return a decimal representation of the year, month, and day. 
For example, July 30, 1989 might be represented as the int value 19800730. 
Alternatively, the conversion operator might return an int representing the number of days 
that have elapsed since some epoch point, such as January 1, 1970. 
Both these conversions have the desirable property that later dates correspond to larger integers, and so either might be useful.
The problem is that there is no single one-to-one mapping between an object of type Date and a value of type int. 
In such cases, it is better not to define the conversion operator. 
Instead, the class ought to define one or more ordinary members to extract the information in these various forms.


-> NOTE: Conversion Operators Can Yield Suprising Results
In practice, classes rarely provide conversion operators. 
Too often users are more likely to be surprised if a conversion happens automatically 
than to be helped by the existence of the conversion. 
However, there is one important exception to this rule of thumb: 
It is not uncommon for classes to define conversions to bool.


-> NOTE: Implicit bool conversion problems
Under earlier versions of the standard, classes that wanted to define a conversion to bool faced a problem: 
Because bool is an arithmetic type, a class-type object that is converted to bool 
can be used in any context where an arithmetic type is expected. 
Such conversions can happen in surprising ways. 
In particular, if istream had a conversion to bool, the following code would compile:
int i = 42;
cin << i; // this code would be legal if the conversion to bool were not explicit!
This program attempts to use the output operator on an input stream. 
There is no << defined for istream, so the code is almost surely in error. 
However, this code could use the bool conversion operator to convert cin to bool. 
The resulting bool value would then be promoted to int 
and used as the left-hand operand to the built-in version of the left-shift operator. 
The promoted bool value (either 1 or 0) would be shifted left 42 positions.


-> NOTE: explicit Conversion Operators
To prevent such problems, the new standard introduced explicit conversion operators:
class SmallInt {
public:
// the compiler won’t automatically apply this conversion
explicit operator int() const { return val; }
// other members as before
};
As with an explicit constructor (§ 7.5.4, p. 296), the compiler won’t (generally)
use an explicit conversion operator for implicit conversions:
SmallInt si = 3; // ok: the SmallInt constructor is not explicit
si + 3; // error: implicit is conversion required, but operator int is explicit
static_cast<int>(si) + 3; // ok: explicitly request the conversion
If the conversion operator is explicit, we can still do the conversion. 
However, with one exception, we must do so explicitly through a cast.


-> NOTE: The exception is that the compiler will apply an explicit conversion to an expression used as a condition. (ME: THIS IS IMPORTANT!)
That is, an explicit conversion will be used implicitly to convert an expression used as
• The condition of an if, while, or do statement
• The condition expression in a for statement header
• An operand to the logical NOT (!), OR (||), or AND (&&) operators
• The condition expression in a conditional (?:) operator


-> NOTE: Conversion to bool
In earlier versions of the library, the IO types defined a conversion to void*. 
They did so to avoid the kinds of problems illustrated above. 
Under the new standard, the IO library instead defines an explicit conversion to bool.
Whenever we use a stream object in a condition, we use the operator bool that is defined for the IO types. 
For example,
while (std::cin >> value)
The condition in the while executes the input operator, which reads into value and returns cin. 
To evaluate the condition, cin is implicitly converted by the istream operator bool conversion function. 
That function returns true if the condition state of cin is good (§ 8.1.2, p. 312), and false otherwise.


-> NOTE: Conversion to bool is usually intended for use in conditions. 
As a result, operator bool ordinarily should be defined as explicit.


-> NOTE: Avoiding Ambiguous Conversions
If a class has one or more conversions, it is important to ensure 
that there is only one way to convert from the class type to the target type. 
If there is more than one way to perform a conversion, it will be hard to write unambiguous code.
There are two ways that multiple conversion paths can occur. 
1) The first happens when two classes provide mutual conversions. 
For example, mutual conversions exist when a class A defines a converting constructor 
that takes an object of class B and B itself defines a conversion operator to type A.
2) The second way to generate multiple conversion paths is 
to define multiple conversions from or to types that are themselves related by conversions. 
The most obvious instance is the built-in arithmetic types. 
A given class ordinarily ought to define at most one conversion to or from an arithmetic type.


-> NOTE: Ordinarily, it is a bad idea to define classes with mutual conversions 
or to define conversions to or from two arithmetic types.


-> NOTE: Argument Matching and Mutual Conversions
In the following example, we’ve defined two ways to obtain an A from a B: 
either by using B’s conversion operator or by using the A constructor that takes a B:
// usually a bad idea to have mutual conversions between two class types
struct B;
struct A {
A() = default;
A(const B&); // converts a B to an A
// other members
};
struct B {
operator A() const; // also converts a B to an A
// other members
};
A f(const A&);
B b;
A a = f(b); // error ambiguous: f(B::operator A())
// or f(A::A(const B&))
Because there are two ways to obtain an A from a B, 
the compiler doesn’t know which conversion to run; the call to f is ambiguous. 
This call can use the A constructor that takes a B, 
or it can use the B conversion operator that converts a B to an A. 
Because these two functions are equally good, the call is in error.
If we want to make this call, we have to explicitly call the conversion operator or the constructor:
A a1 = f(b.operator A()); // ok: use B’s conversion operator
A a2 = f(A(b)); // ok: use A’s constructor
Note that we can’t resolve the ambiguity by using a cast—the cast itself would have the same ambiguity.


-> NOTE: Ambiguities and Multiple Conversions to Built-in Types
Ambiguities also occur when a class defines multiple conversions to (or from) types that are themselves related by conversions. 
The easiest case to illustrate— and one that is particularly problematic—
is when a class defines constructors from or conversions to more than one arithmetic type.
For example, the following class has converting constructors from two different arithmetic types, 
and conversion operators to two different arithmetic types:
struct A {
A(int = 0); // usually a bad idea to have two
A(double); // conversions from arithmetic types
operator int() const; // usually a bad idea to have two
operator double() const; // conversions to arithmetic types
// other members
};
void f2(long double);
A a;
f2(a); // error ambiguous: f(A::operator int()) or f(A::operator double())
long lg;
A a2(lg); // error ambiguous: A::A(int) or A::A(double)
In the call to f2, neither conversion is an exact match to long double. 
However, either conversion can be used, followed by a standard conversion to get to long double. 
Hence, neither conversion is better than the other; the call is ambiguous.
We encounter the same problem when we try to initialize a2 from a long. 
Neither constructor is an exact match for long. 
Each would require that the argument be converted before using the constructor:
• Standard long to double conversion followed by A(double)
• Standard long to int conversion followed by A(int)
These conversion sequences are indistinguishable, so the call is ambiguous.
The call to f2, and the initialization of a2, are ambiguous because 
the standard conversions that were needed had the same rank (§ 6.6.1, p. 245). 
When a userdefined conversion is used, the rank of the standard conversion, if any, is used to select the best match:
short s = 42;
// promoting short to int is better than converting short to double
A a3(s); // uses A::A(int)
In this case, promoting a short to an int is preferred to converting the short to a double. 
Hence a3 is constructed using the A::A(int) constructor, which is run on the (promoted) value of s.


-> NOTE: When two user-defined conversions are used, the rank of the standard conversion, 
if any, preceding or following the conversion function is used to select the best match.


-> NOTE: Overloaded Functions and Converting Constructors
Choosing among multiple conversions is further complicated when we call an overloaded function. 
If two or more conversions provide a viable match, then the conversions are considered equally good.


-> NOTE: CAUTION: CONVERSIONS AND OPERATORS
Correctly designing the overloaded operators, conversion constructors, 
and conversion functions for a class requires some care. 
In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. 
A few rules of thumb can be helpful:
• Don’t define mutually converting classes—if class Foo has a constructor that takes an object of class Bar, 
do not give Bar a conversion operator to type Foo.
• Avoid conversions to the built-in arithmetic types. 
In particular, if you do define a conversion to an arithmetic type, then
– Do not define overloaded versions of the operators that take arithmetic types. 
If users need to use these operators, the conversion operation will convert objects of your type, 
and then the built-in operators can be used.
– Do not define a conversion to more than one arithmetic type. 
Let the standard conversions provide conversions to the other arithmetic types.
The easiest rule of all: With the exception of an explicit conversion to bool, 
avoid defining conversion functions and limit nonexplicit constructors to those that are “obviously right.”


-> NOTE: Needing to use a constructor or a cast to convert an argument in a call 
to an overloaded function frequently is a sign of bad design.


-> NOTE: Overloaded Functions and User-Defined Conversion
In a call to an overloaded function, if two (or more) user-defined conversions provide a viable match, 
the conversions are considered equally good. 
The rank of any standard conversions that might or might not be required is not considered.
Whether a built-in conversion is also needed is considered only 
if the overload set can be matched using the same conversion function.

For example, our call to manip would be ambiguous even if one of 
the classes defined a constructor that required a standard conversion for the argument:
struct E {
E(double);
// other members
};
void manip2(const C&);
void manip2(const E&);
// error ambiguous: two different user-defined conversions could be usedmanip2(10); // manip2(C(10) or manip2(E(double(10)))
In this case, C has a conversion from int and E has a conversion from double.
For the call manip2(10), both manip2 functions are viable:
• manip2(const C&) is viable because C has a converting constructor that takes an int. 
That constructor is an exact match for the argument.
• manip2(const E&) is viable because E has a converting constructor that takes a double 
and we can use a standard conversion to convert the int argument in order to use that converting constructor.
Because calls to the overloaded functions require different user-defined conversions from one another, this call is ambiguous. 
In particular, even though one of the calls requires a standard conversion and the other is an exact match, 
he compiler will still flag this call as an error.


-> NOTE: In a call to an overloaded function, the rank of an additional standard conversion (if any) matters only 
if the viable functions require the same user-defined conversion. 
If different user-defined conversions are needed, then the call is ambiguous.


-> NOTE: Function Matching and Overloaded Operators
Overloaded operators are overloaded functions. 
Normal function matching (§ 6.4, p. 233) is used to determine which operator—built-in or overloaded—to apply to
a given expression. 
However, when an operator function is used in an expression,
the set of candidate functions is broader than when we call a function using the call operator. 
If a has a class type, the expression a sym b might be
a.operatorsym(b); // a has operatorsym as a member function
operatorsym(a, b);// operatorsym is an ordinary function
Unlike ordinary function calls, we cannot use the form of the call to distinquish 
whether we’re calling a nonmember or a member function.


-> NOTE: The set of candidate functions for an operator used in an expression can contain both non member and member functions.


-> NOTE: Providing both conversion functions to an arithmetic type 
and overloaded operators for the same class type may lead to ambiguities between
the overloaded operators and the built-in operators.



-> NOTE: OOP: An Overview
The key ideas in object-oriented programming are data abstraction, inheritance, and dynamic binding. 
Using data abstraction, we can define classes that separate interface from implementation (Chapter 7). 
Through inheritance, we can define classes that model the relationships among similar types. 
Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.


-> NOTE: Inheritance
Classes related by inheritance form a hierarchy. 
Typically there is a base class at the root of the hierarchy, fromwhich the other classes inherit, directly or indirectly.
These inheriting classes are known as derived classes. 
The base class defines those members that are common to the types in the hierarchy. 
Each derived class defines those members that are specific to the derived class itself.

In C++, a base class distinguishes functions that are type dependent from those 
that it expects its derived classes to inherit without change. 
The base class defines as virtual those functions it expects its derived classes to define for themselves.

A derived class must specify the class(es) from which it intends to inherit. 
It does so in a class derivation list, which is a colon followed by a comma-separated list
of base classes each of which may have an optional access specifier:
class Bulk_quote : public Quote { // Bulk_quote inherits fromQuote
public:
double net_price(std::size_t) const override;
};
Because Bulk_quote uses public in its derivation list, we can use objects of type Bulk_quote as if they were Quote objects.
A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself. 
A derived class may include the virtual keyword on these functions but is not required to do so. 
For reasons we’ll explain in § 15.3 (p. 606), the new standard lets a derived class explicitly note that 
it intends a member function to override a virtual that it inherits. 
It does so by specifying override after its parameter list.


-> NOTE: Dynamic Binding
Through dynamic binding, we can use the same code to process objects of either type Quote or Bulk_quote interchangeably.
Because the decision as to which version to run depends on the type of the argument, that decision can’t be made until run time. 
Therefore, dynamic binding is sometimes known as run-time binding.


-> NOTE: In C++, dynamic binding happens when a virtual function is called through a reference (or a pointer) to a base class.


-> NOTE: Base classes ordinarily should define a virtual destructor. 
Virtual destructors are needed even if they do no work.


-> NOTE: Member Functions and Inheritance
Derived classes inherit the members of their base class. 
However, a derived class needs to be able to provide its own definition for operations, such as net_price, that are type dependent. 
In such cases, the derived class needs to override the definition it inherits from the base class, by providing its own definition.

In C++, a base class must distinguish the functions it expects its derived classes to override 
from those that it expects its derived classes to inherit without change.
The base class defines as virtual those functions it expects its derived classes to override.
When we call a virtual function through a pointer or reference, the call will be dynamically bound. 
Depending on the type of the object to which the reference or pointer is bound, 
the version in the base class or in one of its derived classes will be executed.

A base class specifies that a member function should be dynamically bound by preceding its declaration with the keyword virtual. 
Any nonstatic member function (§ 7.6, p. 300), other than a constructor, may be virtual. 
The virtual keyword appears only on the declaration inside the class 
and may not be used on a function definition that appears outside the class body. 
A function that is declared as virtual in the base class is implicitly virtual in the derived classes as well. 
We’ll have more to say about virtual functions in § 15.3 (p. 603).

Member functions that are not declared as virtual are resolved at compile time, not run time. 


-> NOTE: Access Control and Inheritance
A derived class inherits the members defined in its base class. 
However, the member functions in a derived class may not necessarily access the members that are inherited from the base class. 
Like any other code that uses the base class, a derived class may access 
the public members of its base class but may not access the private members. 
However, sometimes a base class has members that it wants to let its derived classes 
use while still prohibiting access to those same members by other users. 
We specify such members after a protected access specifier.


-> NOTE: Defining a Derived Class
A derived class must specify from which class(es) it inherits. 
It does so in its class derivation list, which is a colon followed by a comma-separated list of names of previously defined classes. 
Each base class name may be preceded by an optional access specifier, which is one of public, protected, or private.


-> NOTE: Virtual Functions in the Derived Class
Derived classes frequently, but not always, override the virtual functions that they inherit. 
If a derived class does not override a virtual from its base, then, 
like any other member, the derived class inherits the version defined in its base class.

A derived class may include the virtual keyword on the functions it overrides, but it is not required to do so. 
For reasons we’ll explain in § 15.3 (p. 606), the new standard lets a derived class explicitly 
note that it intends a member function to override a virtual that it inherits. 
It does so by specifying override after the parameter list, or after the const or reference qualifier(s) 
if the member is a const (§ 7.1.2, p. 258) or reference (§ 13.6.3, p. 546) function.


-> NOTE: Derived-Class Objects and the Derived-to-Base Conversion
A derived object contains multiple parts: 
a subobject containing the (nonstatic) members defined in the derived class itself, 
plus subobjects corresponding to each base class from which the derived class inherits.

Because a derived object contains subparts corresponding to its base class(es),
we can use an object of a derived type as if it were an object of its base type(s). 
In particular, we can bind a base-class reference or pointer to the base-class part of a derived object.
Quote item; // object of base type
Bulk_quote bulk; // object of derived type
Quote *p = &item; // p points to a Quote object
p = &bulk; // p points to the Quote part of bulk
Quote &r = bulk; // r bound to the Quote part of bulk
This conversion is often referred to as the "DERIVED-TO-BASE conversion". 
As with any other conversion, the compiler will apply the derived-to-base conversion implicitly (§ 4.11, p. 159).
The fact that the derived-to-base conversion is implicit means that we can use an object of derived type
or a reference to a derived type when a reference to the base type is required. 
Similarly, we can use a pointer to a derived type where a pointer to the base type is required.


-> NOTE: The fact that a derived object contains subobjects for its base classes is key to how inheritance works.


-> NOTE: Derived-Class Constructors
Although a derived object contains members that it inherits from its base, it cannot directly initialize those members. 
Like any other code that creates an object of the base-class type, 
a derived class must use a base-class constructor to initialize its base-class part.

The base-class part of an object is initialized, along with the data members of the derived class, 
during the initialization phase of the constructor (§ 7.5.1, p. 288).
Analogously to how we initialize a member, a derived-class constructor uses its constructor initializer list
to pass arguments to a base-class constructor. 
For example, the Bulk_quote constructor with four parameters:
Bulk_quote(const std::string& book, double p,
std::size_t qty, double disc) :
Quote(book, p), min_qty(qty), discount(disc) { }
// as before
};
passes its first two parameters (representing the ISBN and price) to the Quote constructor.
That Quote constructor initializes the Bulk_quote’s base-class part (i.e., the bookNo and price members). 
When the (empty) Quote constructor body completes, the base-class part of the object being constructed will have been initialized.
Next the direct members, min_qty and discount, are initialized. 
Finally, the (empty) function body of the Bulk_quote constructor is run.
As with a data member, unless we say otherwise, the base part of a derived object is default initialized. 
To use a different base-class constructor, we provide a constructor initializer using the name of the base class, 
followed (as usual) by a parenthesized list of arguments. 
Those arguments are used to select which base class constructor to use to initialize the base-class part of the derived object.


-> NOTE: Each class controls how its members are initialized.

-> NOTE: The base class is initialized first, and then the members of the derived class are initialized 
in the order in which they are declared in the class.


-> NOTE: Using Members of the Base Class from the Derived Class
A derived class may access the public and protected members of its base class:
We’ll have more to say about scope in § 15.6 (p. 617), 
but for now it’s worth knowing that the scope of a derived class is nested inside the scope of its base class. 
As a result, there is no distinction between how a member of the derived class uses members defined in its own class 
and how it uses members defined in its base (e.g., price).


-> NOTE: KEY CONCEPT: RESPECTING THE BASE-CLASS INTERFACE
It is essential to understand that each class defines its own interface. 
Interactions with an object of a class-type should use the interface of that class,
even if that object is the base-class part of a derived object.
As a result, derived-class constructors may not directly initialize the members of its base class. 
The constructor body of a derived constructor can assign values to its public or protected base-class members. (ME: WTF?)
Although it can assign to those members, it generally should not do so. 
Like any other user of the base class, a derived class should respect the interface of its base class 
by using a constructor to initialize its inherited members.


-> NOTE: Inheritance and static Members
If a base class defines a static member (§ 7.6, p. 300), there is only ONE SUCH MEMBER defined for the entire hierarchy. 
Regardless of the number of classes derived from a base class, there exists a SINGLE instance of EACH STATIC MEMBER.
class Base {
public:
static void statmem();
};
class Derived : public Base {
void f(const Derived&);
};
static members obey normal access control. 
If the member is private in the base class, then derived classes have no access to it. 
Assuming the member is accessible, we can use a static member through either the base or derived:
void Derived::f(const Derived &derived_obj)
{
Base::statmem(); // ok: Base defines statmem
Derived::statmem(); // ok: Derived inherits statmem
// ok: derived objects can be used to access static from base
derived_obj.statmem(); // accessed through a Derived object
statmem(); // accessed through this object
}


-> NOTE: Declarations of Derived Classes
A derived class is declared like any other class (§ 7.3.3, p. 278). 
The declaration contains the class name but does not include its derivation list:
class Bulk_quote : public Quote; // error: derivation list can’t appear here
class Bulk_quote; // ok: right way to declare a derived class
The purpose of a declaration is to make known that a name exists 
and what kind of entity it denotes, for example, a class, function, or variable. 
The derivation list, and all other details of the definition, must appear together in the class body.


-> NOTE: Classes Used as a Base Class
A class must be defined, not just declared, before we can use it as a base class:
class Quote; // declared but not defined
// error: Quote must be defined
class Bulk_quote : public Quote { ... };
The reason for this restriction should be easy to see: 
Each derived class contains, and may use, the members it inherits from its base class. 
To use those members, the derived class must know what they are. 
One implication of this rule is that it is impossible to derive a class from itself.
A base class can itself be a derived class:
class Base { /* . . . */ };
class D1: public Base { /* . . . */ };
class D2: public D1 { /* . . . */ };
In this hierarchy, Base is a direct base to D1 and an indirect base to D2. 
A direct base class is named in the derivation list. 
An indirect base is one that a derived class inherits through its direct base class.
Each class inherits all the members of its direct base class. 
The most derived class inherits the members of its direct base. 
The members in the direct base include those it inherits from its base class, and so on up the inheritance chain. 
Effectively, the most derived object contains a sub object for its direct base and for each of its indirect bases.


-> NOTE: Preventing Inheritance
Sometimes we define a class that we don’t want others to inherit from. 
Or we might define a class for which we don’t want to think about whether it is appropriate as a base class. 
Under the new standard, we can prevent a class from being used as a base by following the class name with final:
class NoDerived final { /* */ }; // NoDerived can’t be a base class
class Base { /* */ };
// Last is final; we cannot inherit fromLast
class Last final : Base { /* */ }; // Last can’t be a base class
class Bad : NoDerived { /* */ }; // error: NoDerived is final
class Bad2 : Last { /* */ }; // error: Last is final


-> NOTE: Conversions and Inheritance
Ordinarily, we can bind a reference or a pointer only to an object that has the same type 
as the corresponding reference or pointer (§ 2.3.1, p. 51, and § 2.3.2, p. 52) 
or to a type that involves an acceptable const conversion (§ 4.11.2, p. 162). 
Classes related by inheritance are an important exception: 
We can bind a pointer or reference to a base-class type to an object of a type derived from that base class.

The fact that we can bind a reference (or pointer) to a base-class type to a derived object has a crucially important implication: 
When we use a reference (or pointer) to a base-class type, 
we don’t know the actual type of the object to which the pointer or reference is bound. 
That object can be an object of the base class or it can be an object of a derived class.


-> NOTE: Understanding conversions between base and derived classes is essential to understanding how object-oriented programming works in C++.

-> NOTE: Like built-in pointers, the smart pointer classes (§ 12.1, p. 450) support the derived-to-base conversion
-we can store a pointer to a derived object in a smart pointer to the base type.



-> NOTE: Static Type and Dynamic Type
When we use types related by inheritance, 
we often need to distinguish between the static type of a variable or other expression 
and the dynamic type of the object that expression represents. 
The static type of an expression is always known at compile time
—it is the type with which a variable is declared or that an expression yields. 
The dynamic type is the type of the object in memory that the variable or expression represents. 
The dynamic type may not be known until run time.

For example, when print_total calls net_price (§ 15.1, p. 593):
double ret = item.net_price(n);
we know that the static type of item is Quote&. 
The dynamic type depends on the type of the argument to which item is bound. 
That type cannot be known until a call is executed at run time. 
If we pass a Bulk_quote object to print_total, then the static type of item will differ from its dynamic type. 
As we’ve seen, the static type of item is Quote&, but in this case the dynamic type is Bulk_quote.
The dynamic type of an expression that is neither a reference nor a pointer is always the same as that expression’s static type. 
For example, a variable of type Quote is always a Quote object; 
there is nothing we can do that will change the type of the object to which that variable corresponds.


-> NOTE: It is crucial to understand that the static type of a pointer or reference to a base class may differ from its dynamic type.


-> NOTE: There Is No Implicit Conversion from Base to Derived ...
The conversion from derived to base exists because every derived object contains 
a base-class part to which a pointer or reference of the base-class type can be bound.
There is no similar guarantee for base-class objects.
A base-class object can exist either as an independent object or as part of a derived object. 
A base object that is not part of a derived object has only the members defined by the base class; 
it doesn’t have the members defined by the derived class..

Because a base object might or might not be part of a derived object, 
there is no automatic conversion from the base class to its derived class(s):
Quote base;
Bulk_quote* bulkP = &base; // error: can’t convert base to derived
Bulk_quote& bulkRef = base; // error: can’t convert base to derived
If these assignments were legal, we might attempt to use bulkP or bulkRef to use members that do not exist in base.

What is sometimes a bit surprising is that we cannot convert from base to derived 
even when a base pointer or reference is bound to a derived object:
Bulk_quote bulk;
Quote *itemP = &bulk; // ok: dynamic type is Bulk_quote
Bulk_quote *bulkP = itemP; // error: can’t convert base to derived

The compiler has no way to know (at compile time) that a specific conversion will be safe at run time. 
The compiler looks only at the static types of the pointer or reference to determine whether a conversion is legal. 
If the base class has one or more virtual functions, 
we can use a dynamic_cast (which we’ll cover in § 19.2.1 (p. 825)) to request a conversion that is checked at run time. 
Alternatively, in those cases when we know that the conversion from base to derived is safe, 
we can use a static_cast (§ 4.11.3, p. 162) to override the compiler.


-> NOTE: ... and No Conversion between Objects
The automatic derived-to-base conversion applies only for conversions to a reference or pointer type. 
There is no such conversion from a derived-class type to the base-class type. 
Nevertheless, it is often possible to convert an object of a derived class to its base-class type. 
However, such conversions may not behave as we might want.

Remember that when we initialize or assign an object of a class type, we are actually calling a function. 
When we initialize, we’re calling a constructor (§ 13.1.1, p. 496, and § 13.6.2, p. 534); 
when we assign, we’re calling an assignment operator (§ 13.1.2, p. 500, and § 13.6.2, p. 536). 
These members normally have a parameter that is a reference to the const version of the class type.

Because these members take references, 
the derived-to-base conversion lets us pass a derived object to a base-class copy/move operation. 
These operations are not virtual. 
When we pass a derived object to a base-class constructor, 
the constructor that is run is defined in the base class. 
That constructor knows only about the members of the base class itself. 
Similarly, if we assign a derived object to a base object, 
the assignment operator that is run is the one defined in the base class.
That operator also knows only about the members of the base class itself.

For example, our bookstore classes use the synthesized versions of copy and assignment (§ 13.1.1, p. 497, and § 13.1.2, p. 500). 
We’ll have more to say about copy control and inheritance in § 15.7.2 (p. 623), 
but for now what’s useful to know is that the synthesized versions 
memberwise copy or assign the data members of the class the same way as for any other class:
Bulk_quote bulk; // object of derived type
Quote item(bulk); // uses the Quote::Quote(const Quote&) constructor
item = bulk; // calls Quote::operator=(const Quote&)

When item is constructed, the Quote copy constructor is run. 
That constructor knows only about the bookNo and pricemembers.
It copies those members from the Quote part of bulk and ignores the members that are part of the Bulk_quote portion of bulk. 
Similarly for the assignment of bulk to item; only the Quote part of bulk is assigned to item.
Because the Bulk_quote part is ignored, we say that the Bulk_quote portion of bulk is SLICED DOWN.


-> NOTE: When we initialize or assign an object of a base type from an object of a derived type, 
only the base-class part of the derived object is copied, moved, or assigned. 
The derived part of the object is ignored.


-> NOTE: KEY CONCEPT: CONVERSIONS AMONG TYPES RELATED BY INHERITANCE
There are three things that are important to understand about conversions among classes related by inheritance:
• The conversion from derived to base applies only to pointer or reference types.
• There is no implicit conversion from the base-class type to the derived type.
• Like any member, the derived-to-base conversion may be inaccessible due to access controls. 
Although the automatic conversion applies only to pointers and references, 
most classes in an inheritance hierarchy (implicitly or explicitly) define the copy-control members (Chapter 13). 
As a result, we can often copy, move, or assign an object of derived type to a base-type object. 
However, copying, moving, or assigning a derived type object to a base-type object 
copies, moves, or assigns only the members in the base-class part of the object.


-> NOTE: Virtual Functions
As we’ve seen, in C++ dynamic binding happens when a virtual member function
is called through a reference or a pointer to a base-class type (§ 15.1, p. 593). 
Because we don’t know which version of a function is called until run time, virtual functions must always be defined. 
Ordinarily, if we do not use a function, we don’t need to supply a definition for that function (§ 6.1.2, p. 206). 
However, we must define every virtual function, regardless of whether it is used, 
because the compiler has no way to determine whether a virtual function is used.


-> NOTE: Calls to Virtual Functions May Be Resolved at Run Time
When a virtual function is called through a reference or pointer, 
the compiler generates code to decide at run time which function to call. 
The function that is called is the one that corresponds to the dynamic type of the object bound to that pointer or reference.
However when we call a virtual function on an expression that has a plain—nonreference and nonpointer—type, that call is bound at compile time.


-> NOTE: KEY CONCEPT: POLYMORPHISM IN C++
The key idea behind OOP is polymorphism. 
Polymorphism is derived from a Greek word meaning “many forms.” 
We speak of types related by inheritance as polymorphic types, 
because we can use the “many forms” of these types while ignoring the differences among them. 
The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.
When we call a function defined in a base class through a reference or pointer to the base class, 
we do not know the type of the object on which that member is executed.
The object can be a base-class object or an object of a derived class. 
If the function is virtual, then the decision as to which function to run is delayed until run time. 
The version of the virtual function that is run is the one defined by 
the type of the object to which the reference is bound or to which the pointer points.
On the other hand, calls to nonvirtual functions are bound at compile time. 
Similarly, calls to any function (virtual or not) on an object are also bound at compile time.
The type of an object is fixed and unvarying—there is nothing we can do to make the dynamic type of an object differ from its static type. 
Therefore, calls made on an object are bound at compile time to the version defined by the type of the object.
Virtuals are resolved at run time only if the call is made through a reference or pointer. 
Only in these cases is it possible for an object’s dynamic type to differ from its static type.


-> NOTE: Virtual Functions in a Derived Class
When a derived class overrides a virtual function, it may, but is not required to, repeat the virtual keyword. 
Once a function is declared as virtual, it remains virtual in all the derived classes.
A derived-class function that overrides an inherited virtual function 
must have exactly the same parameter type(s) as the base-class function that it overrides.
With one exception, the return type of a virtual in the derived class also 
must match the return type of the function from the base class. 
The exception applies to virtuals that return a reference (or pointer) to types that are themselves related by inheritance.
That is, if D is derived from B, then a base class virtual can return a B* and the version in the derived can return a D*. 
However, such return types require that the derived-to-base conversion from D to B is accessible. 
§ 15.5 (p. 613) covers how to determine whether a base class is accessible. 
We’ll see an example of this kind of virtual function in § 15.8.1 (p. 633).


-> NOTE: A function that is virtual in a base class is implicitly virtual in its derived classes. 
When a derived class overrides a virtual, the parameters in the base and derived classes must match exactly.


-> NOTE: The final and override Specifiers
As we’ll see in § 15.6 (p. 620), it is legal for a derived class to define a function 
with the same name as a virtual in its base class but with a different parameter list. 
The compiler considers such a function to be independent from the base-class function. 
In such cases, the derived version does not override the version in the base class. 
In practice, such declarations often are a mistake—the class author intended 
to override a virtual from the base class but made a mistake in specifying the parameter list.
Finding such bugs can be surprisingly hard. 
Under the new standard we can specify override on a virtual function in a derived class. 
Doing so makes our intention clear and (more importantly) enlists the compiler in finding such problems for us. 
The compiler will reject a program if a function marked override does not override an existing virtual function.
struct B {
virtual void f1(int) const;
virtual void f2();
void f3();
};
struct D1 : B {
void f1(int) const override; // ok: f1 matches f1 in the base
void f2(int) override; // error: B has no f2(int) function
void f3() override; // error: f3 not virtual
void f4() override; // error: B doesn’t have a function named f4
};

We can also designate a function as final. 
Any attempt to override a function that has been defined as final will be flagged as an error:
struct D2 : B {
// inherits f2() and f3() fromB and overrides f1(int)
void f1(int) const final; // subsequent classes can’t override f1(int)
};
struct D3 : D2 {
void f2(); // ok: overrides f2 inherited from the indirect base, B
void f1(int) const; // error: D2 declared f2 as final
};

The final and override specifiers appear after the parameter list 
(including any const or reference qualifiers) and after a trailing return (§ 6.3.3, p. 229).


-> NOTE: Virtual Functions and Default Arguments
Like any other function, a virtual function can have default arguments (§ 6.5.1, p. 236). 
If a call uses a default argument, the value that is used is the one defined by the static type through which the function is called.
That is, when a call is made through a reference or pointer to base, the default argument(s) will be those defined in the base class. 
The base-class arguments will be used even when the derived version of the function is run. 
In this case, the derived function will be passed the default arguments defined for the base-class version of the function. 
If the derived function relies on being passed different arguments, the program will not execute as expected. (ME: THIS IS DANGEROUS WTF?)


-> NOTE: Virtual functions that have default arguments should use the same argument values in the base and derived classes. (ME: Hard to maintain)


-> NOTE: Circumventing the Virtual Mechanism (ME: THIS IS IMPORTANT)
In some cases, we want to prevent dynamic binding of a call to a virtual function;
we want to force the call to use a particular version of that virtual. 
We can use the scope operator to do so. 
For example, this code:
double undiscounted = baseP->Quote::net_price(42); // calls the version from the base class regardless of the dynamic type of baseP
calls the Quote version of net_price regardless of the type of the object to which baseP actually points. 
This call will be resolved at compile time.
Why might we wish to circumvent the virtual mechanism? 
The most common reason is when a derived-class virtual function calls the version from the base class.
In such cases, the base-class version might do work common to all types in the hierarchy.
The versions defined in the derived classes would do whatever additional work is particular to their own type.


-> NOTE: Ordinarily, only code inside member functions (or friends) should need to use the scope operator to circumvent the virtual mechanism.


-> NOTE: If a derived virtual function that intended to call its base-class version omits the scope operator, 
the call will be resolved at run time as a call to the derived version itself, resulting in an infinite recursion.


-> NOTE: Pure Virtual Functions
Unlike ordinary virtuals, a pure virtual function does not have to be defined. 
We specify that a virtual function is a pure virtual by writing = 0 in place of a function body 
(i.e., just before the semicolon that ends the declaration). 
The = 0 may appear only on the declaration of a virtual function in the class body


-> NOTE: It is worth noting that we can provide a definition for a pure virtual. 
However, the function body must be defined outside the class. 
That is, we cannot provide a function body inside the class for a function that is = 0.


-> NOTE: Classes with Pure Virtuals Are Abstract Base Classes
A class containing (or inheriting without overridding) a pure virtual function is an abstract base class. 
An abstract base class defines an interface for subsequent classes to override. 
We cannot (directly) create objects of a type that is an abstract base class.


-> NOTE: We may not create objects of a type that is an abstract base class.


-> NOTE: A Derived Class Constructor Initializes Its Direct Base Class Only
Now we can reimplement Bulk_quote to inherit from Disc_quote rather than inheriting directly from Quote:
// the discount kicks in when a specified number of copies of the same book are sold
// the discount is expressed as a fraction to use to reduce the normal price
class Bulk_quote : public Disc_quote {
public:
Bulk_quote() = default;
Bulk_quote(const std::string& book, double price,
std::size_t qty, double disc):
Disc_quote(book, price, qty, disc) { }
// overrides the base version to implement the bulk purchase discount policy
double net_price(std::size_t) const override;
};
This version of Bulk_quote has a direct base class, Disc_quote, and an indirect base class, Quote. 
Each Bulk_quote object has three subobjects: an (empty) Bulk_quote part, a Disc_quote subobject, and a Quote subobject.
As we’ve seen, each class controls the initialization of objects of its type.


-> NOTE: KEY CONCEPT: REFACTORING
Adding Disc_quote to the Quote hierarchy is an example of refactoring. 
Refactoring involves redesigning a class hierarchy to move operations and/or data from one class to another. 
Refactoring is common in object-oriented applications.
It is noteworthy that even though we changed the inheritance hierarchy, 
code that uses Bulk_quote or Quote would not need to change. 
However, when classes are refactored (or changed in any other way) 
we must recompile any code that uses those classes.


-> NOTE: Access Control and Inheritance
Just as each class controls the initialization of its own members (§ 15.2.2, p. 598),
each class also controls whether its members are accessible to a derived class.


-> NOTE: protected Members
As we’ve seen, a class uses protected for those members that it is willing to share
with its derived classes butwants to protect from general access. 
The protected specifier can be thought of as a blend of private and public:
• Like private, protected members are inaccessible to users of the class.
• Like public, protected members are accessible to members and friends of classes derived from this class.
In addition, protected has another important property:
• A derived class member or friend may access the protected members of the base class only through a derived object. 
The derived class has no special access to the protected members of base-class objects.

To understand this last rule, consider the following example:
class Base {
protected:
int prot_mem; // protected member
};
class Sneaky : public Base {
friend void clobber(Sneaky&); // can access Sneaky::prot_mem
friend void clobber(Base&); // can’t access Base::prot_mem
int j; // j is private by default
};
void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }   // ok: clobber can access the private and protected members in Sneaky objects
void clobber(Base &b) { b.prot_mem = 0; }   // error: clobber can’t access the protected members in Base
If derived classes (and friends) could access protected members in a base-class object, 
then our second version of clobber (that takes a Base&) would be legal.
That function is not a friend of Base, yet it would be allowed to change an object of type Base; 
we could circumvent the protection provided by protected for any class simply by defining a new class along the lines of Sneaky.
To prevent such usage, members and friends of a derived class can access the protected members only in base-class objects 
that are embedded inside a derived type object; they have no special access to ordinary objects of the base type.


-> NOTE: public, private, and protected Inheritance
Access to a member that a class inherits is controlled by a combination of the access specifier for that member in the base class, 
and the access specifier in the derivation list of the derived class.


-> NOTE: Accessibility of Derived-to-Base Conversion
Whether the derived-to-base conversion (§ 15.2.2, p. 597) is accessible depends on which code is trying to use the conversion 
and may depend on the access specifier used in the derived class’ derivation. 
Assuming D inherits from B:
• User code may use the derived-to-base conversion only if D inherits publicly from B. 
User code may not use the conversion if D inherits from B using either protected or private.
• Member functions and friends of D can use the conversion to B regardless of how D inherits from B. 
The derived-to-base conversion to a direct base class is always accessible to members and friends of a derived class.
• Member functions and friends of classes derived from D may use the derived-to-base conversion 
if D inherits from B using either public or protected.
Such code may not use the conversion if D inherits privately from B.


-> NOTE: For any given point in your code, if a public member of the base class would be accessible, 
then the derived-to-base conversion is also accessible, and not otherwise.


-> NOTE: KEY CONCEPT: CLASS DESIGN AND PROTECTED MEMBERS
In the absence of inheritance, we can think of a class as having two different kinds of users: ordinary users and implementors. 
Ordinary users write code that uses objects of the class type; such code can access only the public (interface) members of the class. 
Implementors write the code contained in the members and friends of the class. 
The members and friends of the class can access both the public and private (implementation) sections.
Under inheritance, there is a third kind of user, namely, derived classes. 
A base class makes protected those parts of its implementation that it is willing to let its derived classes use. 
The protected members remain inaccessible to ordinary user code; private members remain inaccessible to derived classes and their friends.
Like any other class, a class that is used as a base class makes its interface members public . 
A class that is used as a base class may divide its implementation into those members that are accessible to derived classes 
and those that remain accessible only to the base class and its friends. 
An implementation member should be protected if it provides an operation or data 
that a derived class will need to use in its own implementation. 
Otherwise, implementation members should be private.


-> NOTE: Friendship and Inheritance
Just as friendship is not transitive (§ 7.3.4, p. 279), friendship is also not inherited.
Friends of the base have no special access to members of its derived classes, 
and friends of a derived class have no special access to the base class:


-> NOTE: Friendship is not inherited; each class controls access to its members.


-> NOTE: Exempting Individual Members
Sometimes we need to change the access level of a name that a derived class inherits.
We can do so by providing a using declaration (§ 3.1, p. 82):
class Base {
public:
std::size_t size() const { return n; }
protected:
std::size_t n;
};
class Derived : private Base { // note: private inheritance
public:
// maintain access levels for members related to the size of the object
using Base::size;
protected:
using Base::n;
};
Because Derived uses private inheritance, the inherited members, size and n, are (by default) private members of Derived. 
The using declarations adjust the accessibility of these members. 
Users of Derived can access the size member, and classes subsequently derived from Derived can access n.
A using declaration inside a class can name any accessible (e.g., not private) member of a direct or indirect base class. 
Access to a name specified in a using declaration depends on the access specifier preceding the using declaration. 
That is, if a using declaration appears in a private part of the class, that name is accessible to members and friends only. 
If the declaration is in a public section, the name is available to all users of the class. 
If the declaration is in a protected section, the name is accessible to the members, friends, and derived classes.


-> NOTE: A derived class may provide a using declaration only for names it is permitted to access.


-> NOTE: Default Inheritance Protection Levels
In § 7.2 (p. 268) we saw that classes defined with the struct and class keywords have different default access specifiers. 
Similarly, the default derivation specifier depends on which keyword is used to define a derived class. 
By default, a derived class defined with the class keyword has private inheritance; 
a derived class defined with struct has public inheritance:
class Base { /* . . . */ };
struct D1 : Base { /* . . . */ }; // public inheritance by default
class D2 : Base { /* . . . */ }; // private inheritance by default
It is a common misconception to think that there are deeper differences between classes 
defined using the struct keyword and those defined using class.
The only differences are the default access specifier for members and the default derivation access specifier. 
There are NO other distinctions.


-> NOTE: A privately derived class should specify private explicitly rather than rely on the default. 
Being explicit makes it clear that private inheritance is intended and not an oversight.


-> NOTE: Class Scope under Inheritance
Each class defines its own scope (§ 7.4, p. 282) within which its members are defined.
Under inheritance, the scope of a derived class is nested (§ 2.2.4, p. 48) inside the scope of its base classes. 
If a name is unresolved within the scope of the derived class, the enclosing base-class scopes are searched for a definition of that name.
The fact that the scope of a derived class nests inside the scope of its base classes can be surprising. 
After all, the base and derived classes are defined in separate parts of our program’s text. 
However, it is this hierarchical nesting of class scopes that allows the members of a derived class 
to use members of its base class as if those members were part of the derived class.



-> NOTE: Name Lookup Happens at Compile Time
The static type (§ 15.2.3, p. 601) of an object, reference, or pointer determines which members of that object are visible. 
Even when the static and dynamic types might differ (as can happen when a reference or pointer to a base class is used), 
the static type determines what members can be used.

As an example, we might add a member to the Disc_quote class that returns a pair (§ 11.2.3, p. 426) 
holding the minimum (or maximum) quantity and the discounted price:
class Disc_quote : public Quote {
public:
std::pair<size_t, double> discount_policy() const
{ return {quantity, discount}; }
// other members as before
};
We can use discount_policy only through an object, pointer, or reference of
type Disc_quote or of a class derived from Disc_quote:
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // static and dynamic types are the same
Quote *itemP = &bulk; // static and dynamic types differ
bulkP->discount_policy(); // ok: bulkP has type Bulk_quote*
itemP->discount_policy(); // error: itemP has type Quote*
Even though bulk has a member named discount_policy, that member is not visible through itemP. 
The type of itemP is a pointer to Quote, which means that the search for discount_policy starts in class Quote. 
The Quote class has no member named discount_policy, 
so we cannot call that member on an object, reference, or pointer of type Quote.


-> NOTE: Name Collisions and Inheritance
Like any other scope, a derived class can reuse a name defined in one of its direct or indirect base classes. 
As usual, names defined in an inner scope (e.g., a derived class) hide uses of that name in the outer scope (e.g., a base class)


-> NOTE: A derived-class member with the same name as a member of the base class hides direct use of the base-class member.


-> NOTE: Using the Scope Operator to Use Hidden Members
We can use a hidden base-class member by using the scope operator:
struct Derived : Base {
int get_base_mem() { return Base::mem; }
// . . .
};
The scope operator overrides the normal lookup and directs the compiler to look for mem starting in the scope of class Base. 
If we ran the code above with this version of Derived, the result of d.get_mem() would be 0.


-> NOTE: Aside from overriding inherited virtual functions, a derived class usually should not reuse names defined in its base class.


-> NOTE: KEY CONCEPT: NAME LOOKUP AND INHERITANCE
Understanding how function calls are resolved is crucial to understanding inheritance in C++. 
Given the call p->mem() (or obj.mem()), the following four steps happen:
• First determine the static type of p (or obj). 
Because we’re calling a member, that type must be a class type.
• Look for mem in the class that corresponds to the static type of p (or obj). 
If mem is not found, look in the direct base class 
and continue up the chain of classes until mem is found or the last class is searched. 
If mem is not found in the class or its enclosing base classes, then the call will not compile.
• Once mem is found, do normal type checking (§ 6.1, p. 203) 
to see if this call is legal given the definition that was found.
• Assuming the call is legal, the compiler generates code,
which varies depending on whether the call is virtual or not:
– If mem is virtual and the call is made through a reference or pointer, 
then the compiler generates code to determine at run time which version to run based on the dynamic type of the object.
– Otherwise, if the function is nonvirtual, or if the call is on an object (not a reference or pointer), 
the compiler generates a normal function call.


-> NOTE: As Usual, Name Lookup Happens before Type Checking (ME: THIS IS IMPORTANT, THIS IS WHY PREFER TO HAVE DIFFERENT NAMES, RATHER THAN OVERLOADING)
As we’ve seen, functions declared in an inner scope do not overload functions declared in an outer scope (§ 6.4.1, p. 234). 
As a result, functions defined in a derived class do not overload members defined in its base class(es). 
As in any other scope, if a member in a derived class (i.e., in an inner scope) 
has the same name as a base-class member (i.e., a name defined in an outer scope), 
then the derived member hides the base-class member within the scope of the derived class.

The base member is hidden even if the functions have different parameter lists:
struct Base {
int memfcn();
};
struct Derived : Base {
int memfcn(int); // hides memfcn in the base
};
Derived d; Base b;
b.memfcn(); // calls Base::memfcn
d.memfcn(10); // calls Derived::memfcn
d.memfcn(); // error: memfcn with no arguments is hidden
d.Base::memfcn(); // ok: calls Base::memfcn
The declaration of memfcn in Derived hides the declaration of memfcn in Base.
Not surprisingly, the first call through b, which is a Base object, calls the version in the base class. 
Similarly, the second call (through d) calls the one from Derived.
What can be surprising is that the third call, d.memfcn(), is illegal.
To resolve this call, the compiler looks for the name memfcn in Derived. 
That class defines a member named memfcn and the search stops. 
Once the name is found, the compiler looks no further. 
The version of memfcn in Derived expects an int argument. 
This call provides no such argument; it is in error.


-> NOTE: Virtual Functions and Scope (ME: THIS IS IMPORTANT)
We can now understand why virtual functions MUST HAVE the same parameter list in the base and derived classes (§ 15.3, p. 605). 
If the base and derived members took arguments that differed from one another, 
there would be no way to call the derived version through a reference or pointer to the base class.

For example:
class Base {
public:
virtual int fcn();
};
class D1 : public Base {
public:
// hides fcn in the base; this fcn is not virtual
// D1 inherits the definition of Base::fcn()
int fcn(int); // parameter list differs fromfcn in Base
virtual void f2(); // new virtual function that does not exist in Base
};
class D2 : public D1 {
public:
int fcn(int); // nonvirtual function hides D1::fcn(int)
int fcn(); // overrides virtual fcn from Base
void f2(); // overrides virtual f2 from D1
};
The fcn function in D1 does not override the virtual fcn from Base because they have different parameter lists. 
Instead, it hides fcn from the base. (ME: WTF?)
Effectively, D1 has two functions named fcn: D1 inherits a virtual named fcn from Base and defines its own, 
nonvirtual member named fcn that takes an int parameter.


-> NOTE: Calling a Hidden Virtual through the Base Class
Given the classes above, let’s look at several different ways to call these functions:
Base bobj; D1 d1obj; D2 d2obj;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
bp1->fcn(); // virtual call, will call Base::fcn at run time
bp2->fcn(); // virtual call, will call Base::fcn at run time
bp3->fcn(); // virtual call, will call D2::fcn at run time
D1 *d1p = &d1obj; D2 *d2p = &d2obj;
bp2->f2(); // error: Base has no member named f2
d1p->f2(); // virtual call, will call D1::f2() at run time
d2p->f2(); // virtual call, will call D2::f2() at run time
The first three calls are all made through pointers to the base class. 
Because fcn is virtual, the compiler generates code to decide at run time which version to call.
That decision will be based on the actual type of the object to which the pointer is bound. 
In the case of bp2, the underlying object is a D1. 
That class did not override the fcn function that takes no arguments. 
Thus, the call through bp2 is resolved (at run time) to the version defined in Base.
The next three calls are made through pointers with differing types. 
Each pointer points to one of the types in this hierarchy. 
The first call is illegal because there is no f2() in class Base. 
The fact that the pointer happens to point to a derived object is irrelevant.
For completeness, let’s look at calls to the nonvirtual function fcn(int):
Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj;
p1->fcn(42); // error: Base has no version of fcn that takes an int
p2->fcn(42); // statically bound, calls D1::fcn(int)
p3->fcn(42); // statically bound, calls D2::fcn(int)
In each call the pointer happens to point to an object of type D2. 
However, the dynamic type doesn’t matter when we call a nonvirtual function. 
The version that is called depends only on the static type of the pointer.


-> NOTE: Overriding Overloaded Functions (ME: THIS IS A GOOD TRICK)
As with any other function, a member function (virtual or otherwise) can be overloaded.
A derived class can override zero or more instances of the overloaded functions it inherits. 
If a derived class wants to make all the overloaded versions available through its type, 
then it must override all of them or none of them.
Sometimes a class needs to override some, but not all, of the functions in an overloaded set. 
It would be tedious in such cases to have to override every base class version 
in order to override the ones that the class needs to specialize.

Instead of overriding every base-class version that it inherits, 
a derived class can provide a using declaration (§ 15.5, p. 615) for the overloaded member. 
A using declaration specifies only a name; it may not specify a parameter list. 
Thus, a using declaration for a base-class member function adds all 
the overloaded instances of that function to the scope of the derived class. 
Having brought all the names into its scope, 
the derived class needs to define only those functions that truly depend on its type. 
It can use the inherited definitions for the others.
The normal rules for a using declaration inside a class apply to names of overloaded functions (§ 15.5, p. 615); 
every overloaded instance of the function in the base class must be accessible to the derived class. 
The access to the overloaded versions that are not otherwise 
redefined by the derived class will be the access in effect at the point of the using declaration.



-> NOTE: Constructors and Copy Control
Like any other class, a class in an inheritance hierarchy controls 
what happens when objects of its type are created, copied, moved, assigned, or destroyed. 
As for any other class, if a class (base or derived) does not itself 
define one of the copy control operations, the compiler will synthesize that operation. 
Also, as usual, the synthesized version of any of these members might be a deleted function.


-> NOTE: Virtual Destructors
The primary direct impact that inheritance has on copy control for 
a base class is that a base class generally should define a virtual destructor (§ 15.2.1, p. 594). 
The destructor needs to be virtual to allow objects in the inheritance hierarchy to be dynamically allocated.

Recall that the destructor is run when we delete a pointer to a dynamically allocated object (§ 13.1.3, p. 502). 
If that pointer points to a type in an inheritance hierarchy, 
it is possible that the static type of the pointer might differ from the dynamic type of the object being destroyed (§ 15.2.2, p. 597). 
For example, if we delete a pointer of type Quote*, that pointer might point at a Bulk_quote object.
If the pointer points at a Bulk_quote, the compiler has to know that it should run the Bulk_quote destructor. 
As with any other function, we arrange to run the proper destructor by defining the destructor as virtual in the base class:
class Quote {
public:
// virtual destructor needed if a base pointer pointing to a derived object is deleted
virtual ~Quote() = default; // dynamic binding for the destructor
};

Like any other virtual, the virtual nature of the destructor is inherited. 
Thus, classes derived from Quote have virtual destructors, 
whether they use the synthesized destructor or define their own version. 
So long as the base class destructor is virtual, when we delete a pointer to base, the correct destructor will be run:
Quote *itemP = new Quote; // same static and dynamic type
delete itemP; // destructor for Quote called
itemP = new Bulk_quote; // static and dynamic types differ
delete itemP; // destructor for Bulk_quote called


-> NOTE: Executing delete on a pointer to base that points to a derived object 
has undefined behavior if the base’s destructor is not virtual.


-> NOTE: Destructors for base classes are an important exception to the rule of thumb 
that if a class needs a destructor, it also needs copy and assignment (§ 13.1.4, p. 504).
A base class almost always needs a destructor, so that it can make the destructor virtual. 
If a base class has an empty destructor in order to make it virtual, 
then the fact that the class has a destructor does not indicate 
that the assignment operator or copy constructor is also needed.


-> NOTE: Virtual Destructors Turn Off Synthesized Move
The fact that a base class needs a virtual destructor 
has an important indirect impact on the definition of base and derived classes: 
If a class defines a destructor—even if it uses = default to use the synthesized version
—the compiler will not synthesize a move operation for that class (§ 13.6.2, p. 537).


-> NOTE: Synthesized Copy Control and Inheritance
The synthesized copy-control members in a base or a derived class execute like 
any other synthesized constructor, assignment operator, or destructor: 
They memberwise initialize, assign, or destroy the members of the class itself. 
In addition, these synthesized members initialize, assign, or destroy 
the direct base part of an object by using the corresponding operation from the base class.

For example:
• The synthesized Bulk_quote default constructor runs the Disc_Quote default constructor, 
which in turn runs the Quote default constructor.
• The Quote default constructor default initializes the bookNo member to the empty string 
and uses the in-class initializer to initialize price to zero.
• When the Quote constructor finishes, the Disc_Quote constructor continues, 
which uses the in-class initializers to initialize qty and discount.
• When the Disc_quote constructor finishes, the Bulk_quote constructor continues but has no other work to do.
Similarly, the synthesized Bulk_quote copy constructor uses the (synthesized) Disc_quote copy constructor, 
which uses the (synthesized) Quote copy constructor.
The Quote copy constructor copies the bookNo and price members;
and the Disc_Quote copy constructor copies the qty and discount members.
Each of our Quote classes use the synthesized destructor. 
The derived classes do so implicitly, whereas the Quote class does so explicitly by defining its (virtual) destructor as = default. 
The synthesized destructor is (as usual) empty and its implicit destruction part destroys the members of the class (§ 13.1.3, p. 501). 
In addition to destroying its own members, the destruction phase of a destructor in a derived class also destroys its direct base.
That destructor in turn invokes the destructor for its own direct base, if any. 
And, so on up to the root of the hierarchy.
As we’ve seen, Quote does not have synthesized move operations because it defines a destructor. 
The (synthesized) copy operations will be used whenever we move a Quote object (§ 13.6.2, p. 540). 
As we’re about to see, the fact that Quote does not have move operations means that its derived classes don’t either.


-> NOTE: It is worth noting that it doesn’t matter whether the base-class member is itself synthesized 
(as is the case in our Quote hierarchy) or has a an user-provided definition. 
All that matters is that the corresponding member is accessible (§ 15.5, p. 611) and that it is not a deleted function.


-> NOTE: Base Classes and Deleted Copy Control in the Derived
The synthesized default constructor, or any of the copy-control members of either a base or a derived class, 
may be defined as deleted for the same reasons as in any other class (§ 13.1.6, p. 508, and § 13.6.2, p. 537). 
In addition, the way in which a base class is defined can cause a derived-class member to be defined as deleted:
• If the default constructor, copy constructor, copy-assignment operator, 
or destructor in the base class is deleted or inaccessible (§ 15.5, p. 612), 
then the corresponding member in the derived class is defined as deleted, 
because the compiler can’t use the base-class member to construct, assign, or destroy the base-class part of the object.
• If the base class has an inaccessible or deleted destructor, 
then the synthesized default and copy constructors in the derived classes are defined as deleted, 
because there is noway to destroy the base part of the derived object.
• As usual, the compiler will not synthesize a deleted move operation. 
If we use = default to request a move operation, 
it will be a deleted function in the derived if the corresponding operation in the base is deleted or inaccessible,
because the base class part cannot be moved. 
The move constructor will also be deleted if the base class destructor is deleted or inaccessible.


-> NOTE: Move Operations and Inheritance
As we’ve seen, most base classes define a virtual destructor. 
As a result, by default, base classes generally do not get synthesized move operations. 
Moreover, by default, classes derived from a base class that doesn’t 
have move operations don’t get synthesized move operations either.
Because lack of a move operation in a base class suppresses synthesized move for its derived classes, 
base classes ordinarily should define the move operations if it is sensible to do so. 
Our Quote class can use the synthesized versions. 
However, Quote must define these members explicitly. 
Once it defines its move operations, it must also explicitly define the copy versions as well (§ 13.6.2, p. 539)


-> NOTE: Derived-Class Copy-Control Members
As we saw in § 15.2.2 (p. 598), the initialization phase of a derived-class constructor 
initializes the base-class part(s) of a derived object as well as initializing its own members. 
As a result, the copy and move constructors for a derived class must copy/move 
the members of its base part as well as the members in the derived.
Similarly, a derived-class assignment operator must assign the members in the base part of the derived object.
Unlike the constructors and assignment operators, 
the destructor is responsible only for destroying the resources allocated by the derived class. 
Recall that the members of an object are implicitly destroyed (§ 13.1.3, p. 502). 
Similarly, the base class part of a derived object is destroyed automatically.


-> NOTE: When a derived class defines a copy or move operation, 
that operation is responsible for copying or moving the entire object, 
including base-class members.


-> NOTE: Defining a Derived Copy or Move Constructor
When we define a copy or move constructor (§ 13.1.1, p. 496, and § 13.6.2, p. 534) for a derived class, 
we ordinarily use the corresponding base-class constructor to initialize the base part of the object:
class Base { /* . . . */ };
class D: public Base {
public:
// by default, the base class default constructor initializes the base part of an object
// to use the copy or move constructor, we must explicitly call that
// constructor in the constructor initializer list
D(const D& d): Base(d) // copy the base members
/* initializers for members of D */ { /* ... */ }
D(D&& d): Base(std::move(d)) // move the base members
/* initializers for members of D */ { /* ... */ }
};


-> NOTE: By default, the base-class default constructor initializes the base-class part of a derived object. 
If we want copy (or move) the base-class part, we must explicitly use the copy (or move) constructor 
for the base class in the derived’s constructor initializer list.


-> NOTE: Derived-Class Assignment Operator
Like the copy and move constructors, a derived-class assignment operator (§ 13.1.2, p. 500, and § 13.6.2, p. 536),
must assign its base part explicitly.
This operator starts by explicitly calling the base-class assignment operator to assign the members of the base part of the derived object. 
The base-class operator will (presumably) correctly handle self-assignment and, if appropriate, 
will free the old value in the base part of the left-hand operand and assign the new values from rhs. 
Once that operator finishes, we continue doing whatever is needed to assign the members in the derived class.


-> NOTE: It is worth noting that a derived constructor or assignment operator can use its corresponding base class operation 
regardless of whether the base defined its own version of that operator or uses the synthesized version. 
For example, the call to Base::operator= executes the copy-assignment operator in class Base.
It is immaterial whether that operator is defined explicitly by the Base class or is synthesized by the compiler.


-> NOTE: Derived-Class Destructor
Recall that the data members of an object are implicitly destroyed after the destructor body completes (§ 13.1.3, p. 502). 
Similarly, the base-class parts of an object are also implicitly destroyed. 
As a result, unlike the constructors and assignment operators, 
a derived destructor is responsible only for destroying the resources allocated by the derived class.
Objects are destroyed in the opposite order from which they are constructed:
The derived destructor is run first, and then the base-class destructors are invoked, back up through the inheritance hierarchy.


-> NOTE: Calls to Virtuals in Constructors and Destructors (THIS IS IMPORTANT)
As we’ve seen, the base-class part of a derived object is constructed first. 
While the base-class constructor is executing, the derived part of the object is uninitialized.
Similarly, derived objects are destroyed in reverse order, 
so that when a base class destructor runs, the derived part has already been destroyed. 
As a result, while these base-class members are executing, the object is incomplete.

To accommodate this incompleteness, the compiler treats the object as if its type changes during construction or destruction. 
That is, while an object is being constructed it is treated as if it has the same class as the constructor; 
calls to virtual functions will be bound as if the object has the same type as the constructor itself.
Similarly, for destructors. 
This binding applies to virtuals called directly or that are called indirectly from a function that the constructor (or destructor) calls.

To understand this behavior, consider what would happen if 
the derived-class version of a virtual was called from a base-class constructor. 
This virtual probably accesses members of the derived object. 
After all, if the virtual didn’t need to use members of the derived object, 
the derived class probably could use the version in its base class. 
However, those members are uninitialized while a base constructor is running. 
If such access were allowed, the program would probably crash.


-> NOTE: If a constructor or destructor calls a virtual, 
the version that is run is the one corresponding to the type of the constructor or destructor itself (ME: NO POLYMORPHIC CALLS).


-> NOTE: Inherited Constructors (THIS IS IMPORTANT)
Under the new standard, a derived class can reuse the constructors defined by its direct base class. 
Although, as we’ll see, such constructors are not inherited in the normal sense of that term, 
it is nonetheless common to refer to such constructors as “inherited.” 
For the same reasons that a class may initialize only its direct base class, 
a class may inherit constructors only from its direct base. 
A class cannot inherit the default, copy, and move constructors. 
If the derived class does not directly define these constructors, the compiler synthesizes them as usual.
A derived class inherits its base-class constructors by providing a using declaration that names its (direct) base class. 
As an example, we can redefine our Bulk_quote class (§ 15.4, p. 610) to inherit its constructors from Disc_quote:
class Bulk_quote : public Disc_quote {
public:
using Disc_quote::Disc_quote; // inherit Disc_quote’s constructors
double net_price(std::size_t) const;
};

Ordinarily, a using declaration only makes a name visible in the current scope.
When applied to a constructor, a using declaration causes the compiler to generate code. 
The compiler generates a derived constructor corresponding to each constructor in the base. 
That is, for each constructor in the base class, 
the compiler generates a constructor in the derived class that has the same parameter list. (ME: WTF?)

These compiler-generated constructors have the form
derived(parms) : base(args) { }
where derived is the name of the derived class, base is the name of the base class, parms is the parameter list of the constructor, 
and args pass the parameters from the derived constructor to the base constructor. 
In our Bulk_quote class, the inherited constructor would be equivalent to
Bulk_quote(const std::string& book, double price,
std::size_t qty, double disc):
Disc_quote(book, price, qty, disc) { }
If the derived class has any data members of its own, those members are default initialized (§ 7.1.4, p. 266).


-> NOTE: Characteristics of an Inherited Constructor
Unlike using declarations for ordinary members, 
a constructor using declaration does not change the access level of the inherited constructor(s). 
For example, regardless of where the using declaration appears, 
a private constructor in the base is a private constructor in the derived; 
similarly for protected and public constructors.

Moreover, a using declaration can’t specify explicit or constexpr. 
If a constructor in the base is explicit (§ 7.5.4, p. 296) or constexpr (§ 7.5.6, p. 299),
the inherited constructor has the same property.

If a base-class constructor has default arguments (§ 6.5.1, p. 236), those arguments are not inherited. 
Instead, the derived class gets multiple inherited constructors in which each parameter with a default argument is successively omitted. 
For example, if the base has a constructor with two parameters, the second of which has a default, 
the derived class will obtain two constructors: 
one with both parameters (and no default argument) 
and a second constructor with a single parameter corresponding to the left-most, non-defaulted parameter in the base class.

If a base class has several constructors, then with two exceptions, the derived class inherits each of the constructors from its base class. 
The first exception is that a derived class can inherit some constructors and define its own versions of other constructors. 
If the derived class defines a constructor with the same parameters as a constructor in the base, then that constructor is not inherited. 
The one defined in the derived class is used in place of the inherited constructor.

The second exception is that the default, copy, and move constructors are not inherited. 
These constructors are synthesized using the normal rules. 
An inherited constructor is not treated as a user-defined constructor. 
Therefore, a class that contains only inherited constructors will have a synthesized default constructor. (THIS IS IMPORTANT)


-> NOTE: Because derived objects are “sliced down” when assigned to a base-type object, containers and types related by inheritance do not mix well.


-> NOTE: Put (Smart) Pointers, Not Objects, in Containers
When we need a container that holds objects related by inheritance, 
we typically define the container to hold pointers (preferably smart pointers (§ 12.1, p. 450)) to the base class. 
As usual, the dynamic type of the object to which those pointers point might be the base-class type or a type derived from that base.


-> NOTE: KEY CONCEPT: INHERITANCE VERSUS COMPOSITION
The design of inheritance hierarchies is a complicated topic in its own right and well beyond the scope of this language Primer. 
However, there is one important design guide that is so fundamental that every programmer should be familiar with it.
When we define a class as publicly inherited fromanother, the derived class should reflect an “Is A” relationship to the base class. 
In well-designed class hierarchies, objects of a publicly derived class can be used wherever an object of the base class is expected.
Another common relationship among types is a “Has A” relationship. 
Types related by a “Has A” relationship imply membership.
In our bookstore example, our base class represents the concept of a quote for a book sold at a stipulated price. 
Our Bulk_quote “is a” kind of quote, but one with a different pricing strategy. 
Our bookstore classes “have a” price and an ISBN.



-> NOTE: Templates and Generic Programming
Templates are the foundation for generic programming in C++. 
A template is a blueprint or formula for creating classes or functions. 
When we use a generic type, such as vector, or a generic function, such as find, 
we supply the information needed to transform that blueprint into a specific class or function. 
That transformation happens during compilation.
In Chapter 3 and Part II we learned how to use templates. 
In this chapter we’ll learn how to define them.


-> NOTE: Defining a Template
Imagine that we want to write a function to compare two values 
and indicate whether the first is less than, equal to, or greater than the second. 
In practice, we’d want to define several such functions, each of which will compare values of a given type.


-> NOTE: Function Templates
Rather than defining a new function for each type, we can define a function template.
A function template is a formula from which we can generate type-specific versions of that function.
A template definition starts with the keyword template followed by a template parameter list, 
which is a comma-separated list of one or more template parameters bracketed by the less-than (<) and greater-than (>) tokens.
The template parameter list actsmuch like a function parameter list. 
A function parameter list defines local variable(s) of a specified type but does not say how to initialize them. 
At run time, arguments are supplied that initialize the parameters.
Analogously, template parameters represent types or values used in the definition of a class or function. 
When we use a template, we specify—either implicitly or explicitly—template argument(s) to bind to the template parameter(s).
Our compare function declares one type parameter named T. 
Inside compare, we use the name T to refer to a type. 
Which actual type T represents is determined at compile time based on how compare is used.


-> NOTE: In a template definition, the template parameter list cannot be empty. (ME: HOW ABOUT IN SPECIALIZATION)


-> NOTE: Instantiating a Function Template
When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template argument(s) for us. 
That is, when we call compare, the compiler uses the type of the arguments to determine what type to bind to the template parameter T.
The compiler uses the deduced template parameter(s) to instantiate a specific version of the function for us. 
When the compiler instantiates a template, 
it creates a new “instance” of the template using the actual template argument(s) in place of the corresponding template parameter(s).


-> NOTE: Template Type Parameters
Our compare function has one template type parameter. 
In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. 
In particular, a type parameter can be used to name the return type or a function parameter type, 
and for variable declarations or casts inside the function body.


-> NOTE: It may seem more intuitive to use the keyword typename rather than class to designate a template type parameter. 
After all, we can use built-in (nonclass) types as a template type argument. 
Moreover, typename more clearly indicates that the name that follows is a type name. 
However, typename was added to C++ after templates were already in widespread use; 
some programmers continue to use class exclusively


-> NOTE: Nontype Template Parameters
In addition to defining type parameters, we can define templates that take nontype parameters. 
A nontype parameter represents a value rather than a type. 
Nontype parameters are specified by using a specific type name instead of the class or typename keyword.


-> NOTE: When the template is instantiated, nontype parameters are replaced
with a value supplied by the user or deduced by the compiler. 
These values must be constant expressions (§ 2.4.4, p. 65), 
which allows the compiler to instantiate the templates during compile time.


-> NOTE: A nontype parameter may be an integral type, or a pointer or (lvalue) reference to an object or to a function type. 
An argument bound to a nontype integral parameter must be a constant expression. 
Arguments bound to a pointer or reference nontype parameter must have static lifetime (Chapter 12, p. 450). 
We may not use an ordinary (nonstatic) local object or a dynamic object as a template argument 
for reference or pointer nontype template parameters. 
A pointer parameter can also be instantiated by nullptr or a zero-valued constant expression.


-> NOTE: A template nontype parameter is a constant value inside the template definition.
A nontype parameter can be used when constant expressions are required, for example, to specify the size of an array.


-> NOTE: Template arguments used for nontype template parameters must be constant expressions.


-> NOTE: inline and constexpr Function Templates
A function template can be declared inline or constexpr in the same ways as nontemplate functions. 
The inline or constexpr specifier follows the template parameter list and precedes the return type:
template <typename T> inline T min(const T&, const T&); // ok: inline specifier follows the template parameter list
inline template <typename T> T min(const T&, const T&); // error: incorrect placement of the inline specifier


-> NOTE: Template programs should try to minimize the number of requirements placed on the argument types.


-> NOTE: Template Compilation
When the compiler sees the definition of a template, it does not generate code. 
It generates code only when we instantiate a specific instance of the template. 
The fact that code is generated only when we use a template (and not when we define it) 
affects how we organize our source code and when errors are detected.

Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. 
Similarly, when we use objects of class type, the class definition must be available, 
but the definitions of the member functions need not be present. 
As a result, we put class definitions and function declarations in header files 
and definitions of ordinary and class-member functions in source files.

Templates are different: 
To generate an instantiation, the compiler needs to have the code 
that defines a function template or class template member function.
As a result, unlike nontemplate code, headers for templates typically include definitions as well as declarations.


-> NOTE: Definitions of function templates and member functions of class templates are ordinarily put into header files. (ME: HOW ABOUT SPECIALIZATIONS)


-> NOTE: KEY CONCEPT: TEMPLATES AND HEADERS
Templates contain two kinds of names:
• Those that do not depend on a template parameter
• Those that do depend on a template parameter

It is up to the provider of a template to ensure that all names 
that do not depend on a template parameter are visible when the template is used. 
Moreover, the template provider must ensure that the definition of the template, 
including the definitions of the members of a class template, 
are visible when the template is instantiated.

It is up to users of a template to ensure that declarations for all functions, types, 
and operators associated with the types used to instantiate the template are visible.

Both of these requirements are easily satisfied by well-structured programs that make appropriate use of headers. 
Authors of templates should provide a header that contains the template definition 
along with declarations for all the names used in the class template or in the definitions of its members. 
Users of the template must include the header for the template and for any types used to instantiate that template.


-> NOTE: Compilation Errors Are Mostly Reported during Instantiation
The fact that code is not generated until a template is instantiated affects 
when we learn about compilation errors in the code inside the template. 
In general, there are three stages during which the compiler might flag an error.

(1) The first stage is when we compile the template itself. 
The compiler generally can’t find many errors at this stage. 
The compiler can detect syntax errors—such as forgetting a semicolon or misspelling a variable name—but not much else.

(2) The second error-detection time is when the compiler sees a use of the template.
At this stage, there is still not much the compiler can check. 
For a call to a function template, the compiler typically will check that the number of the arguments is appropriate. 
It can also detect whether two arguments that are supposed to have the same type do so. 
For a class template, the compiler can check that the right number of template arguments are provided but not much more.

(3) The third time when errors are detected is during instantiation. 
It is only then that type-related errors can be found. 
Depending on how the compiler manages instantiation, these errors may be reported at link time.


-> NOTE: It is up to the caller to guarantee that the arguments passed to the template support any operations that template uses, 
and that those operations behave correctly in the context in which the template uses them.


-> NOTE: Class Templates
A class template is a blueprint for generating classes. 
Class templates differ from function templates in that 
the compiler cannot deduce the template parameter type(s) for a class template. 
Instead, as we’ve seen many times, to use a class template we must supply 
additional information inside angle brackets following the template’s name (§ 3.3, p. 97). 
That extra information is the list of template arguments to use in place of the template parameters.


-> NOTE: Defining a Class Template
Like function templates, class templates begin with the keyword template followed by a template parameter list. 
In the definition of the class template (and its members), we use the template parameters as stand-ins for types 
or values that will be supplied when the template is used.


-> NOTE: Instantiating a Class Template
As we’ve seen many times, when we use a class template, we must supply extra information. 
We can now see that that extra information is a list of explicit template arguments that are bound to the template’s parameters. 
The compiler uses these template arguments to instantiate a specific class from the template.


-> NOTE: Each instantiation of a class template constitutes an independent class.
The type Blob<string> has no relationship to, or any special access to, the members of any other Blob type.


-> NOTE: References to a Template Type in the Scope of the Template
In order to read template class code, it can be helpful to remember 
that the name of a class template is not the name of a type (§ 3.3, p. 97). 
A class template is used to instantiate a type, and an instantiated type always includes template argument(s).

What can be confusing is that code in a class template generally doesn’t use 
the name of an actual type (or value) as a template argument. 
Instead, we often use the template’s own parameter(s) as the template argument(s). 

For example, our data member uses two templates, vector and shared_ptr. 
Whenever we use a template, we must supply template arguments. 
In this case, the template argument we supply is the same type that is used to instantiate the Blob. 
Therefore, the definition of data
std::shared_ptr<std::vector<T>> data;
uses Blob’s type parameter to say that data is the instantiation of shared_ptr 
that points to the instantiation of vector that holds objects of type T. 
When we instantiate a particular kind of Blob, such as Blob<string>, then data will be shared_ptr<vector<string>>
If we instantiate Blob<int>, then data will be shared_ptr<vector<int>>, and so on.


-> NOTE: Member Functions of Class Templates
As with any class, we can define the member functions of a class template either inside or outside of the class body. 
As with any other class, members defined inside the class body are implicitly inline.

A class template member function is itself an ordinary function. 
However, each instantiation of the class template has its own version of each member. 
As a result, a member function of a class template has the same template parameters as the class itself. 
Therefore, a member function defined outside the class template body starts with 
the keyword template followed by the class’ template parameter list.

As usual, when we define a member outside its class, we must say to which class the member belongs. 
Also as usual, the name of a class generated from a template includes its template arguments. 
When we define a member, the template argument(s) are the same as the template parameter(s). 
That is, for a given member function of StrBlob that was defined as:
ret-type StrBlob::member-name(parm-list)
the corresponding Blob member will look like:
template <typename T> ret-type Blob<T>::member-name(parm-list)


-> NOTE: Instantiation of Class-Template Member Functions (ME: THIS IS IMPORTANT)
By default, a member function of a class template is instantiated only if the program uses that member function. 
For example, this code:
// instantiates Blob<int> and the initializer_list<int> constructor
Blob<int> squares = {0,1,2,3,4,5,6,7,8,9}; 
// instantiates Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
squares[i] = i*i; // instantiates Blob<int>::operator[](size_t)

If a member function isn’t used, it is not instantiated. 
The fact that members are instantiated only if we use them lets us instantiate a class with a type 
that may not meet the requirements for some of the template’s operations (§ 9.2, p. 329).


-> NOTE: By default, a member of an instantiated class template is instantiated only if the member is used.


-> NOTE: Simplifying Use of a Template Class Name inside Class Code (ME: THIS IS IMPORTANT)
There is one exception to the rule that we must supply template arguments when we use a class template type. 
Inside the scope of the class template itself, we may use the name of the template without arguments.


-> NOTE: Using a Class Template Name outside the Class Template Body
When we define members outside the body of a class template,
we must remember that we are not in the scope of the class until the class name is seen


-> NOTE: Inside the scope of a class template, we may refer to the template without specifying template argument(s).


-> NOTE: Class Templates and Friends
When a class contains a friend declaration (§ 7.2.1, p. 269), the class and the friend can independently be templates or not. 
A class template that has a nontemplate friend grants that friend access to all the instantiations of the template. 
When the friend is itself a template, the class granting friendship controls 
whether friendship includes all instantiations of the template or only specific instantiation(s).


-> NOTE: One-to-One Friendship
The most common form of friendship from a class template to another template (class or function) 
establishes friendship between corresponding instantiations of the class and its friend.

Example:
template <typename T> class Blob {
// each instantiation of Blob grants access to the version of
// BlobPtr and the equality operator instantiated with the same type
friend class BlobPtr<T>;
friend bool operator==<T>
(const Blob<T>&, const Blob<T>&);
// other members as in § 12.1.1 (p. 456)
};


-> NOTE: General and Specific Template Friendship
A class can also make every instantiation of another template its friend,
or it may limit friendship to a specific instantiation.

Example:
// forward declaration necessary to befriend a specific instantiation of a template
template <typename T> class Pal;
class C { // C is an ordinary, nontemplate class
friend class Pal<C>; // Pal instantiated with class C is a friend to C
// all instances of Pal2 are friends to C;
// no forward declaration required when we befriend all instantiations
template <typename T> friend class Pal2;
};
template <typename T> class C2 { // C2 is itself a class template
// each instantiation of C2 has the same instance of Pal as a friend
friend class Pal<T>; // a template declaration for Pal must be in scope
// all instances of Pal2 are friends of each instance of C2, prior declaration needed
template <typename X> friend class Pal2;
// Pal3 is a nontemplate class that is a friend of every instance of C2
friend class Pal3; // prior declaration for Pal3 not needed
};


-> NOTE: Befriending the Template’s Own Type Parameter
Under the new standard, we can make a template type parameter a friend:
template <typename Type> class Bar {
friend Type; // grants access to the type used to instantiate Bar
// . . .
};


-> NOTE: Template Type Aliases
An instantiation of a class template defines a class type, and as with any other class type, 
we can define a typedef (§ 2.5.1, p. 67) that refers to that instantiated class:
typedef Blob<string> StrBlob;

However, the new standard lets us define a type alias for a class template:
template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors is a pair<string, string>


-> NOTE: static Members of Class Templates
Like any other class, a class template can declare static members (§ 7.6, p. 300).
template <typename T> class Foo {
public:
static std::size_t count() { return ctr; }
// other interface members
private:
static std::size_t ctr;
// other implementation members
};
Here Foo is a class template that has a public static member function named count and a private static data member named ctr. 
Each instantiation of Foo has its own instance of the static members. 
That is, for any given type X, there is one Foo<X>::ctr and one Foo<X>::count member. 
All objects of type Foo<X> share the same ctr object and count function. 
For example, // instantiates static members Foo<string>::ctr and Foo<string>::count
Foo<string> fs;
// all three objects share the same Foo<int>::ctr and Foo<int>::count members
Foo<int> fi, fi2, fi3;
As with any other static data member, there must be exactly one definition of each static data member of a template class. 
However, there is a distinct object for each instantiation of a class template. 
As a result, we define a static data member as a template similarly to how we define the member functions of that template:
template <typename T> size_t Foo<T>::ctr = 0; // define and initialize ctr
As with any other member of a class template, we start by defining the template parameter list, 
followed by the type of the memberwe are defining and the member’s name. 
As usual, a member’s name includes the member’s class name, 
which for a class generated from a template includes its template arguments. 
Thus, when Foo is instantiated for a particular template argument type, 
a separate ctr will be instantiated for that class type and initialized to 0.
As with static members of nontemplate classes, we can access a static member of a class template 
through an object of the class type or by using the scope operator to access the member directly. 
Of course, to use a static member through the class, we must refer to a specific instantiation:
Foo<int> fi; // instantiates Foo<int> class
// and the static data member ctr
auto ct = Foo<int>::count(); // instantiates Foo<int>::count
ct = fi.count(); // uses Foo<int>::count
ct = Foo::count(); // error: which template instantiation?
Like any other member function, a static member function is instantiated only if it is used in a program.


-> NOTE: Template Parameters
Like the names of function parameters, a template parameter name has no intrinsic meaning. 
We ordinarily name type parameters T, but we can use any name:
template <typename Foo> Foo calc(const Foo& a, const Foo& b)
{
Foo tmp = a; // tmp has the same type as the parameters and return type
// . . .
return tmp; // return type and parameters have the same type
}


-> NOTE: Template Parameters and Scope
Template parameters follow normal scoping rules. 
The name of a template parameter can be used after it has been declared 
and until the end of the template declaration or definition. 
As with any other name, a template parameter hides any declaration of that name in an outer scope. 
Unlike most other contexts, however, a name used as a template parameter may not be reused within the template:
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
A tmp = a; // tmp has same type as the template parameter A, not double
double B; // error: redeclares template parameter B
}
Normal name hiding says that the typedef of A is hidden by the type parameter named A. 
Thus, tmp is not a double; it has whatever type gets bound to the template parameter A when calc is used. 
Because we cannot reuse names of template parameters, the declaration of the variable named B is an error.
Because a parameter name cannot be reused, 
the name of a template parameter can appear only once with in a given template parameter list:
// error: illegal reuse of template parameter name V
template <typename V, typename V> // ...


-> NOTE: Template Declarations
A template declaration must include the template parameters:
// declares but does not define compare and Blob
template <typename T> int compare(const T&, const T&);
template <typename T> class Blob;
As with function parameters, the names of a template parameter need not be 
the same across the declaration(s) and the definition of the same template:
// all three uses of calc refer to the same function template
template <typename T> T calc(const T&, const T&); // declaration
template <typename U> U calc(const U&, const U&); // declaration
// definition of the template
template <typename Type> Type calc(const Type& a, const Type& b) { /* ... */ }
Of course, every declaration and the definition of a given template must have the same number and kind (i.e., type or nontype) of parameters.


-> NOTE: For reasons we’ll explain in § 16.3 (p. 698), declarations for all the templates needed by a given file 
usually should appear together at the beginning of a file before any code that uses those names.


-> NOTE: Using Class Members That Are Types
Recall that we use the scope operator (::) to access both static members and type members (§ 7.4, p. 282, and § 7.6, p. 301). 
In ordinary (nontemplate) code, the compiler has access to the class defintion. 
As a result, it knows whether a name accessed through the scope operator is a type or a static member.
For example,  when we write string::size_type, the compiler has the definition of string and can see that size_type is a type.

Assuming T is a template type parameter, when the compiler sees code such as T::mem it won’t know 
until instantiation time whether mem is a type or a static data member. 
However, in order to process the template, the compiler must know whether a name represents a type. 
For example, assuming T is the name of a type parameter, when the compiler sees a statement of the following form:
T::size_type * p;
it needs to know whether we’re defining a variable named p or are multiplying a static data member named size_type by a variable named p.

By default, the language assumes that a name accessed through the scope operator is not a type (ME: THIS IS IMPORTANT). 
As a result, if we want to use a typemember of a template type parameter, 
we must explicitly tell the compiler that the name is a type. 
We do so by using the keyword typename:
template <typename T>
typename T::value_type top(const T& c)
{
if (!c.empty())
return c.back();
else
return typename T::value_type();
}
Our top function expects a container as its argument and uses typename to specify its return type 
and to generate a value initialized element (§ 7.5.3, p. 293) to return if c has no elements.


-> NOTE: When we want to inform the compiler that a name represents a type, we must use the keyword typename, not class.


-> NOTE: Default Template Arguments
Just as we can supply default arguments to function parameters (§ 6.5.1, p. 236), we can also supply default template arguments. 
Under the new standard, we can supply default arguments for both function and class templates. 
Earlier versions of the language, allowed default arguments only with class templates.
As an example, we’ll rewrite compare to use the library less function-object template (§ 14.8.2, p. 574) by default:
// compare has a default template argument, less<T>
// and a default function argument, F()
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
if (f(v1, v2)) return -1;
if (f(v2, v1)) return 1;
return 0;
}
When users call this version of compare, they may supply their own comparison operation but are not required to do so:
bool i = compare(0, 42); // uses less; i is -1
// result depends on the isbns initem1 and item2
Sales_data item1(cin), item2(cin);
bool j = compare(item1, item2, compareIsbn);
The first call uses the default function argument, which is a default-initialized object of type less<T>. 
In this call, T is int so that object has type less<int>. 
This instantiation of compare will use less<int> to do its comparisons.
In the second call, we pass compareIsbn (§ 11.2.2, p. 425) and two objects of type Sales_data. 
When compare is called with three arguments, the type of the third argument must be a callable object 
that returns a type that is convertible to bool and takes arguments of a type compatible with the types of the first two arguments. 
As usual, the types of the template parameters are deduced from their corresponding function arguments. 
In this call, the type of T is deduced as Sales_data and F is deduced as the type of compareIsbn.


-> NOTE: As with function default arguments, a template parameter may have a default argument only
if all of the parameters to its right also have default arguments.


-> NOTE: Template Default Arguments and Class Templates
Whenever we use a class template, we must always follow the template’s name with brackets. 
The brackets indicate that a class must be instantiated from a template.
In particular, if a class template provides default arguments for all of its template parameters, 
and we want to use those defaults, we must put an empty bracket pair following the template’s name.
template <class T = int> class Numbers { // by default T is int
public:
Numbers(T v = 0): val(v) { }
// various operations on numbers
private:
T val;
};
Numbers<long double> lots_of_precision;
Numbers<> average_precision; // empty <> says we want the default type
Here we instantiate two versions of Numbers: average_precision instantiates Numbers with T replaced by int; 
lots_of_precision instantiates Numbers with T replaced by long double.



-> NOTE: Member Templates
A class—either an ordinary class or a class template—may have a member function that is itself a template. 
Such members are referred to as member templates.


-> NOTE: Member templates may not be virtual.


-> NOTE: Member Templates of Ordinary (Nontemplate) Classes
As an example of an ordinary class that has a member template, 
we’ll define a class that is similar to the default deleter type used by unique_ptr (§ 12.1.5, p. 471).
Like the default deleter, our class will have an overloaded function-call operator (§ 14.8, p. 571) 
that will take a pointer and execute delete on the given pointer.
Unlike the default deleter, our class will also print a message whenever the deleter is executed. 
Because we want to use our deleter with any type, we’ll make the call operator a template:
// function-object class that calls delete on a given pointer
class DebugDelete {
public:
DebugDelete(std::ostream &s = std::cerr): os(s) { }
// as with any function template, the type of T is deduced by the compiler
template <typename T> void operator()(T *p) const
{ os << "deleting unique_ptr" << std::endl; delete p; }
private:
std::ostream &os;
};

Like any other template, a member template starts with its own template parameter list. 
Each DebugDelete object has an ostream member on which to write,and a member function that is itself a template. 
We can use this class as a replacement for delete:
double* p = new double;
DebugDelete d; // an object that can act like a delete expression
d(p); // calls DebugDelete::operator()(double*), which deletes p
int* ip = new int;
// calls operator()(int*) on a temporary DebugDelete object
DebugDelete()(ip);

Because calling a DebugDelete object deletes its given pointer, we can also use DebugDelete as the deleter of a unique_ptr. 
To override the deleter of a unique_ptr, we supply the type of the deleter inside brackets 
and supply an object of the deleter type to the constructor (§ 12.1.5, p. 471):
// destroying the the object to which p points
// instantiates DebugDelete::operator()<int>(int *)
unique_ptr<int, DebugDelete> p(new int, DebugDelete());
// destroying the the object to which sp points
// instantiates DebugDelete::operator()<string>(string*)
unique_ptr<string, DebugDelete> sp(new string, DebugDelete());

Here, we’ve said that p’s deleter will have type DebugDelete, and we have supplied an unnamed object of that type in p’s constructor.
The unique_ptr destructor calls the DebugDelete’s call operator. 
Thus, whenever unique_ptr’s destructor is instantiated, DebugDelete’s call operator will also be instantiated: 
Thus, the definitions above will instantiate:
// sample instantiations for member templates of DebugDelete
void DebugDelete::operator()(int *p) const { delete p; }
void DebugDelete::operator()(string *p) const { delete p; }



-> NOTE: Member Templates of Class Templates
We can also define a member template of a class template. 
In this case, both the class and the member have their own, independent, template parameters.

As an example, we’ll give our Blob class a constructor that will 
take two iterators denoting a range of elements to copy. 
Because we’d like to support iterators into varying kinds of sequences, we’ll make this constructor a template:
template <typename T> class Blob {
template <typename It> Blob(It b, It e);
// . . .
};
This constructor has its own template type parameter, It, which it uses for the type of its two function parameters.

Unlike ordinary function members of class templates, member templates are function templates. 
When we define a member template outside the body of a class template, 
we must provide the template parameter list for the class template and for the function template. 
The parameter list for the class template comes first, followed by the member’s own template parameter list (ME: THIS IS IMPORTANT, SEPARATE TEMPLATE KEYWORD):
template <typename T> // type parameter for the class
template <typename It> // type parameter for the constructor
Blob<T>::Blob(It b, It e):
data(std::make_shared<std::vector<T>>(b, e)) { }

Here we are defining a member of a class template that has one template type parameter, which we have named T. 
The member itself is a function template that has a type parameter named It.


-> NOTE: Instantiation and Member Templates
To instantiate a member template of a class template, 
we must supply arguments for the template parameters for both the class and the function templates. 
As usual, argument(s) for the class template parameter(s) are determined by 
the type of the object through which we call the member template. 
Also as usual, the compiler typically deduces template argument(s) for 
the member template’s own parameter(s) from the arguments passed in the call (§ 16.1.1, p. 653):
int ia[] = {0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is", "the", "time"};
// instantiates the Blob<int> class
// and the Blob<int> constructor that has two int* parameters
Blob<int> a1(begin(ia), end(ia));
// instantiates the Blob<int> constructor that has
// two vector<long>::iterator parameters
Blob<int> a2(vi.begin(), vi.end());
// instantiates the Blob<string> class and the Blob<string>
// constructor that has two (list<const char*>::iterator parameters
Blob<string> a3(w.begin(), w.end());

When we define a1, we explicitly specify that the compiler should instantiate a version of Blob with the template parameter bound to int. 
The type parameter for the constructor’s own parameters will be deduced fromthe type of begin(ia) and end(ia). 
That type is int*. 
Thus, the definition of a1 instantiates:
Blob<int>::Blob(int*, int*);
The definition of a2 uses the already instantiated Blob<int> class, and instantiates the constructor with It replaced by vector<short>::iterator. 
The definition of a3 (explicitly) instantiates the Blob with its template parameter bound to string 
and (implicitly) instantiates the member template constructor of that class with its parameter bound to list<const char*>.


-> NOTE: Controlling Instantiations
The fact that instantiations are generated when a template is used (§ 16.1.1, p. 656) 
means that the same instantiation may appear in multiple object files. 
When two or more separately compiled source files use the same template with the same template arguments, 
there is an instantiation of that template in each of those files.

In large systems, the overhead of instantiating the same template in multiple files can become significant. 
Under the new standard, we can avoid this overhead through an explicit instantiation. 
An explicit instantiation has the form:
extern template declaration; // instantiation declaration
template declaration; // instantiation definition
where declaration is a class or function declaration in which all the template parameters are replaced by the template arguments. 
For example:
// instantion declaration and definition
extern template class Blob<string>; // declaration
template int compare(const int&, const int&); // definition

When the compiler sees an extern template declaration, it will not generate code for that instantiation in that file. 
Declaring an instantiation as extern is a promise that there will be a nonextern use of that instantiation elsewhere in the program.
There may be several extern declarations for a given instantiation but there must be exactly one definition for that instantiation.

Because the compiler automatically instantiates a template when we use it, 
the extern declaration must appear before any code that uses that instantiation:
// Application.cc
// these template types must be instantiated elsewhere in the program
extern template class Blob<string>;
extern template int compare(const int&, const int&);
Blob<string> sa1, sa2; // instantiation will appear elsewhere
// Blob<int> and its initializer_list constructor instantiated in this file
Blob<int> a1 = {0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1); // copy constructor instantiated in this file
int i = compare(a1[0], a2[0]); // instantiation will appear elsewhere

The file Application.o will contain instantiations for Blob<int>, along with the initializer_list and copy constructors for that class. 
The compare<int> function and Blob<string> class will not be instantiated in that file. 
There must be definitions of these templates in some other file in the program:
// templateBuild.cc
// instantiation file must provide a (nonextern) definition for every
// type and function that other files declare as extern
template int compare(const int&, const int&);
template class Blob<string>; // instantiates all members of the class template

When the compiler sees an instantiation definition (as opposed to a declaration), it generates code.
Thus, the file templateBuild.o will contain the definitions for compare instantiated with int and for the Blob<string> class. 
When we build the application, we must link templateBuild.o with the Application.o files.


-> NOTE: There must be an explicit instantiation definition somewhere in the program for every instantiation declaration.


-> NOTE: Instantiation Definitions Instantiate All Members (ME: THIS IS CORRECT BARD CONFIMRED IT. Yes, doing an instantiation definition for a template class instantiates all members.)
An instantiation definition for a class template instantiates all the members of that template including inline member functions. 
When the compiler sees an instantiation definition it cannot know which member functions the program uses. 
Hence, unlike the way it handles ordinary class template instantiations, the compiler instantiates all the members of that class. 
Even if we do not use a member, that member will be instantiated. 
Consequently, we can use explicit instantiation only for types that can be used with all the members of that template.


-> NOTE: An instantiation definition can be used only for types that can be used with every member function of a class template.



-> NOTE: By binding the deleter at compile time, unique_ptr avoids the run-time cost of an indirect call to its deleter. 
The unique_ptr has two template parameters, one that represents the pointer 
that the unique_ptr manages and the other that represents the type of the deleter. 
Because the type of the deleter is part of the type of a unique_ptr, 
the type of the deleter member is known at compile time. 
The deleter can be stored directly in each unique_ptr object.

-> NOTE: By binding the deleter at run time, shared_ptr makes it easier for users to override the deleter.
We can construct a shared_ptr using a deleter of one type, and subsequently 
use reset to give that same shared_ptr a different type of deleter. 
In general, we cannot have a member whose type changes at run time. 
Hence, the deleter must be stored indirectly.



-> NOTE: Template Argument Deduction
We’ve seen that, by default, the compiler uses the arguments in a call to determine the template parameters for a function template. 
The process of determining the template arguments from the function arguments is known as template argument deduction. 
During template argument deduction, the compiler uses types of the arguments in the call 
to find the template arguments that generate a version of the function that best matches the given call.


-> NOTE: Conversions and Template Type Parameters
As with a nontemplate function, the arguments we pass in a call to a function template are used to initialize that function’s parameters. 
Function parameters whose type uses a template type parameter have special initialization rules. 
Only a very limited number of conversions are automatically applied to such arguments.
Rather than converting the arguments, the compiler generates a new instantiation.

As usual, top-level consts (§ 2.4.3, p. 63) in either the parameter or the argument are ignored. 
The only other conversions performed in a call to a function template are
(1) const conversions:
A function parameter that is a reference (or pointer) to a const can be passed a reference (or pointer) to a nonconst object (§ 4.11.2, p. 162).
(2) Array- or function-to-pointer conversions: 
If the function parameter is not a reference type, 
then the normal pointer conversion will be applied to arguments of array or function type. 
An array argument will be converted to a pointer to its first element. 
Similarly, a function argument will be converted to a pointer to the function’s type (§ 4.11.2, p. 161).

Other conversions, such as the arithmetic conversions (§ 4.11.1, p. 159), 
derivedto-base (§ 15.2.2, p. 597), and user-defined conversions (§ 7.5.4, p. 294, and § 14.9, p. 579), are not performed.

Example:
template <typename T> T fobj(T, T); // arguments are copied
template <typename T> T fref(const T&, const T&); // references
string s1("a value");
const string s2("another value");
fobj(s1, s2); // calls fobj(string, string); const is ignored
fref(s1, s2); // calls fref(const string&, const string&)
// uses premissible conversion to const on s1
int a[10], b[42];
fobj(a, b); // calls f(int*, int*)
fref(a, b); // error: array types don’t match

In the call to fobj, the fact that the array types differ doesn’t matter. 
Both arrays are converted to pointers. 
The template parameter type in fobj is int*. 
The call to fref, however, is illegal. 
When the parameter is a reference, the arrays are not converted to pointers (§ 6.2.4, p. 217).
The types of a and b don’t match, so the call is in error.


-> NOTE: const conversions and array or function to pointer are the only automatic conversions for arguments to parameters with template types.


-> NOTE: Function Parameters That Use the Same Template Parameter Type
A template type parameter can be used as the type of more than one function parameter.
Because there are limited conversions, the arguments to such parameters must have essentially the same type. 
If the deduced types do not match, then the call is an error. 

For example, our compare function (§ 16.1.1, p. 652) takes two const T& parameters.
Its arguments must have essentially the same type:
long lng;
compare(lng, 1024); // error: cannot instantiate compare(long, int)
This call is in error because the arguments to compare don’t have the same type.
The template argument deduced from the first argument is long; the one for the second is int. 
These types don’t match, so template argument deduction fails.
If we want to allow normal conversions on the arguments, we can define the function with two type parameters:
// argument types can differ but must be compatible
template <typename A, typename B>
int flexibleCompare(const A& v1, const B& v2)
{
if (v1 < v2) return -1;
if (v2 < v1) return 1;
return 0;
}
Now the user may supply arguments of different types:
long lng;
flexibleCompare(lng, 1024); // ok: calls flexibleCompare(long, int)


-> NOTE: Normal Conversions Apply for Ordinary Arguments
A function template can have parameters that are defined using ordinary types—that is, 
types that do not involve a template type parameter. 
Such arguments have no special processing; 
they are converted as usual to the corresponding type of the parameter (§ 6.1, p. 203). 
For example, consider the following template:
template <typename T> ostream &print(ostream &os, const T &obj)
{
return os << obj;
}
The first function parameter has a known type, ostream&. 
The second parameter, obj, has a template parameter type. 
Because the type of os is fixed, normal conversions are applied to arguments passed to os when print is called:
print(cout, 42); // instantiates print(ostream&, int)
ofstream f("output");
print(f, 10); // uses print(ostream&, int); converts f to ostream&
In the first call, the type of the first argument exactly matches the type of the first parameter. 
This call will cause a version of print that takes an ostream& and an int to be instantiated. 
In the second call, the first argument is an ofstream and there is a conversion from ofstream to ostream& (§ 8.2.1, p. 317). 
Because the type of this parameter does not depend on a template parameter, the compiler will implicitly convert f to ostream&.


-> NOTE: Normal conversions are applied to arguments whose type is not a template parameter.


-> NOTE: Function-Template Explicit Arguments
In some situations, it is not possible for the compiler to deduce the types of the template arguments. 
In others, we want to allow the user to control the template instantiation. 
Both cases arise most often when a function return type differs from any of those used in the parameter list.


-> NOTE: Specifying an Explicit Template Argument
As an example in which we want to let the user specify which type to use, 
we’ll define a function template named sum that takes arguments of two different types.
We’d like to let the user specify the type of the result. 
That way the user can choose whatever precision is appropriate.

We can let the user control the type of the return by defining a third template parameter to represent the return type:
// T1 cannot be deduced: it doesn’t appear in the function parameter list
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
In this case, there is no argument whose type can be used to deduce the type of T1.
The caller must provide an explicit template argument for this parameter on each call to sum.

We supply an explicit template argument to a call the same way that we define an instance of a class template. 
Explicit template arguments are specified inside angle brackets after the function name and before the argument list:
// T1 is explicitly specified; T2 and T3 are inferred from the argument types
auto val3 = sum<long long>(i, lng); // long long sum(int, long)
This call explicitly specifies the type for T1. 
The compiler will deduce the types for T2 and T3 from the types of i and lng.

Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; 
the first template argument is matched to the first template parameter, 
the second argument to the second parameter, and so on. 
An explicit template argument may be omitted only for the trailing (right-most) parameters,
and then only if these can be deduced from the function parameters. 
If our sum function had been written as
// poor design: users must explicitly specify all three template parameters
template <typename T1, typename T2, typename T3>
T3 alternative_sum(T2, T1);
then we would always have to specify arguments for all three parameters:
// error: can’t infer initial template parameters
auto val3 = alternative_sum<long long>(i, lng);
// ok: all three parameters are explicitly specified
auto val2 = alternative_sum<long long, int, long>(i, lng);


-> NOTE: Normal Conversions Apply for Explicitly Specified Arguments
For the same reasons that normal conversions are permitted for parameters 
that are defined using ordinary types (§ 16.2.1, p. 680), 
normal conversions also apply for arguments whose template type parameter is explicitly specified:
long lng;
compare(lng, 1024); // error: template parameters don’t match
compare<long>(lng, 1024); // ok: instantiates compare(long, long)
compare<int>(lng, 1024); // ok: instantiates compare(int, int)
As we’ve seen, the first call is in error because the arguments to compare must have the same type. 
If we explicitly specify the template parameter type, normal conversions apply. 
Thus, the call to compare<long> is equivalent to calling a function taking two const long& parameters. 
The int parameter is automatically converted to long. 
In the second call, T is explicitly specified as int, so lng is converted to int.



-> NOTE: Trailing Return Types and Type Transformation
Using an explicit template argument to represent a template function’s return type works well 
when we want to let the user determine the return type. 
In other cases, requiring an explicit template argument imposes a burden on the user with no compensating advantage. 
For example, we might want to write a function that takes a pair of iterators denoting a sequence 
and returns a reference to an element in the sequence:
template <typename It>
??? &fcn(It beg, It end)
{
// process the range
return *beg; // return a reference to an element from the range
}
We don’t know the exact type we want to return, 
but we do know that we want that type to be a reference to the element type of the sequence we’re processing:
vector<int> vi = {1,2,3,4,5};
Blob<string> ca = { "hi", "bye" };
auto &i = fcn(vi.begin(), vi.end()); // fcn should return int&
auto &s = fcn(ca.begin(), ca.end()); // fcn should return string&

Here, we know that our function will return *beg, and we know that we can use decltype(*beg) to obtain the type of that expression. 
However, beg doesn’t exist until the parameter list has been seen. 
To define this function, we must use a trailing return type (§ 6.3.3, p. 229). 
Because a trailing return appears after the parameter list, it can use the function’s parameters:
// a trailing return lets us declare the return type after the parameter list is seen
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
// process the range
return *beg; // return a reference to an element from the range
}

Here we’ve told the compiler that fcn’s return type is the same as the type returned by dereferencing its beg parameter. 
The dereference operator returns an lvalue (§ 4.1.1, p. 136), 
so the type deduced by decltype is a reference to the type of the element that beg denotes. 
Thus, if fcn is called on a sequence of strings, the return type will be string&. 
If the sequence is int, the return will be int&.


-> NOTE: The Type Transformation Library Template Classes
Sometimes we do not have direct access to the type that we need. 
For example, we might want to write a function similar to fcn 
that returns an element by value (§ 6.3.2, p. 224), rather than a reference to an element.

The problem we face in writing this function is that we know almost nothing about the types we’re passed. 
In this function, the only operations we know we can use are iterator operations, 
and there are no iterator operations that yield elements (as opposed to references to elements).

To obtain the element type, we can use a library type transformation template.
These templates are defined in the type_traits header. 
In general the classes in type_traits are used for so-called template metaprogramming, 
a topic that is beyond the scope of this Primer. 
However, the type transformation templates are useful in ordinary programming as well. 
These templates are described in Table 16.1 and we’ll see how they are implemented in § 16.5 (p. 710).

In this case, we can use remove_reference to obtain the element type. 
The remove_reference template has one template type parameter and a (public) type member named type. 
If we instantiate remove_reference with a reference type, then type will be the referred-to type. 
For example, if we instantiate remove_reference<int&>, the type member will be int. 
Similarly, if we instantiate remove_reference<string&>, type will be string, and so on.
More generally, given that beg is an iterator:
remove_reference<decltype(*beg)>::type
will be the type of the element to which beg refers: decltype(*beg) returns the reference type of the element type. 
remove_reference::type strips off the reference, leaving the element type itself.

Using remove_reference and a trailing returnwith decltype, we can write our function to return a copy of an element’s value:
// must use typename to use a type member of a template parameter; see § 16.1.3 (p. 670)
template <typename It>
auto fcn2(It beg, It end) ->
typename remove_reference<decltype(*beg)>::type
{
// process the range
return *beg; // return a copy of an element from the range
}
Note that type is member of a class that depends on a template parameter. 
As a result, we must use typename in the declaration of the return type to tell 
the compiler that type represents a type (§ 16.1.3, p. 670).


-> NOTE: Standard Type Transformation Templates
Form: TemplateName<T>
-> remove_reference
If [X& or X&&] then [X], otherwise [T]
-> add_const
If [X&, const X, or function] then [T], otherwise [const T]
-> add_lvalue_reference
If [X&] then [T], else if [X&&] then [X&], otherwise [T&]
-> add_rvalue_reference
If [X& or X&&] then [T], otherwise [T&&]
-> remove_pointer
If [X*] then [X], otherwise [T]
-> add_pointer
If [X& or X&&] then [X*], otherwise [T*]
-> make_signed
If [unsigned X] then [X], otherwise [T]
-> make_unsigned
If [singed type] then [unsigned T], otherwise [T]
-> remove_extent
If [X[i]] then [X], otherwise [T]
-> remove_all_extents
If [X[i][j][k]] then [X], otherwise [T]


-> NOTE: Function Pointers and Argument Deduction
When we initialize or assign a function pointer (§ 6.7, p. 247) from a function template,
the compiler uses the type of the pointer to deduce the template argument(s).

As an example, assume we have a function pointer that points to 
a function returning an int that takes two parameters, 
each of which is a reference to a const int. 
We can use that pointer to point to an instantiation of compare:
template <typename T> int compare(const T&, const T&);
// pf1 points to the instantiation int compare(const int&, const int&)
int (*pf1)(const int&, const int&) = compare;

The type of the parameters in pf1 determines the type of the template argument for T. 
The template argument for T is int. 
The pointer pf1 points to the instantiation of compare with T bound to int. 
It is an error if the template arguments cannot be determined from the function pointer type:
// overloaded versions of func; each takes a different function pointer type
void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare); // error: which instantiation of compare?

The problem is that by looking at the type of func’s parameter, 
it is not possible to determine a unique type for the template argument. 
The call to func could instantiate the version of compare that takes ints or the version that takes strings.
Because it is not possible to identify a unique instantiation for the argument to func, this call won’t compile.

We can disambiguate the call to func by using explicit template arguments:
// ok: explicitly specify which version of compare to instantiate
func(compare<int>); // passing compare(const int&, const int&)

This expression calls the version of func that takes a function pointer with two const int& parameters.


-> NOTE: When the address of a function-template instantiation is taken, 
the context must be such that it allows a unique type or value to be determined for each template parameter.


-> NOTE: Template Argument Deduction and References
In order to understand type deduction from a call to a function such as
template <typename T> void f(T &p);
in which the function’s parameter p is a reference to a template type parameter T,
it is important to keep in mind two points: 
Normal reference binding rules apply; and consts are low level, not top level.


-> NOTE: Type Deduction from Lvalue Reference Function Parameters
When a function parameter is an ordinary (lvalue) reference to a template type parameter (i.e., that has the form T&), 
the binding rules say that we can pass only an lvalue (e.g., a variable or an expression that returns a reference type). 
That argument might or might not have a const type. 
If the argument is const, then T will be deduced as a const type:
template <typename T> void f1(T&); // argument must be an lvalue
// calls to f1 use the referred-to type of the argument as the template parameter type
f1(i); // i is an int; template parameter T is int
f1(ci); // ci is a const int; template parameter T is const int
f1(5); // error: argument to a & parameter must be an lvalue

If a function parameter has type const T&, normal binding rules say 
that we can pass any kind of argument—an object (const or otherwise), a temporary, or a literal value. 
When the function parameter is itself const, the type deduced for T will not be a const type. 
The const is already part of the function parameter type; therefore, 
it does not also become part of the template parameter type:
template <typename T> void f2(const T&); // can take an rvalue
// parameter in f2 is const &; const in the argument is irrelevant
// in each of these three calls, f2’s function parameter is inferred as const int&
f2(i); // i is an int; template parameter T is int
f2(ci); // ci is a const int, but template parameter T is int
f2(5); // a const & parameter can be bound to an rvalue; T is int


-> NOTE: Type Deduction from Rvalue Reference Function Parameters
When a function parameter is an rvalue reference (§ 13.6.1, p. 532) (i.e., has the form T&&), 
normal binding rules say that we can pass an rvalue to this parameter.
When we do so, type deduction behaves similarly to deduction for an ordinary lvalue reference function parameter. 

The deduced type for T is the type of the rvalue:
template <typename T> void f3(T&&);
f3(42); // argument is an rvalue of type int; template parameter T is int


-> NOTE: Reference Collapsing and Rvalue Reference Parameters (ME: THIS IS IMPORTANT)
Assuming i is an int object, we might think that a call such as f3(i) would be illegal. 
After all, i is an lvalue, and normally we cannot bind an rvalue reference to an lvalue. 
However, the language defines two exceptions to normal binding rules that allow this kind of usage. 
These exceptions are the foundation for how library facilities such as "std::move" operate.

(1) The first exception affects how type deduction is done for rvalue reference parameters.
When we pass an lvalue (e.g., i) to a function parameter that is an rvalue reference to a template type parameter (e.g, T&&), 
the compiler deduces the template type parameter as the argument’s lvalue reference type. 
So, when we call f3(i), the compiler deduces the type of T as int&, not int.

Deducing T as int& would seem to mean that f3’s function parameter would be an rvalue reference to the type int&. 
Ordinarily, we cannot (directly) define a reference to a reference (§ 2.3.1, p. 51). 
However, it is possible to do so indirectly through a type alias (§ 2.5.1, p. 67) or through a template type parameter.

(2) In such contexts, we see the second exception to the normal binding rules: 
If we indirectly create a reference to a reference, then those references “collapse.” 
In all but one case, the references collapse to form an ordinary lvalue reference type.
The new standard, expanded the collapsing rules to include rvalue references. 
References collapse to form an rvalue reference only in the specific case of an rvalue reference to an rvalue reference. 
That is, for a given type X:
• X& &, X& &&, and X&& & all collapse to type X&
• The type X&& && collapses to X&&

The combination of the reference collapsing rule and the special rule 
for type deduction for rvalue reference parameters means that we can call f3 on an lvalue.
Whenwe pass an lvalue to f3’s (rvalue reference) function parameter, 
the compiler will deduce T as an lvalue reference type:
f3(i); // argument is an lvalue; template parameter T is int&
f3(ci); // argument is an lvalue; template parameter T is const int&

When a template parameter T is deduced as a reference type, 
the collapsing rule says that the function parameter T&& collapses to an lvalue reference type. 
For example, the resulting instantiation for f3(i) would be something like
// invalid code, for illustration purposes only
void f3<int&>(int& &&); // when T is int&, function parameter is int& &&

The function parameter in f3 is T&& and T is int&, so T&& is int& &&, which collapses to int&. 
Thus, even though the form of the function parameter in f3 is an rvalue reference (i.e., T&&), 
this call instantiates f3 with an lvalue reference
type (i.e., int&):
void f3<int&>(int&); // when T is int&, function parameter collapses to int&


There are two important consequences from these rules (ME: THIS IS IMPORTANT):
(1) A function parameter that is an rvalue reference to a template type parameter (e.g., T&&) can be bound to an lvalue; and
(2) If the argument is an lvalue, then the deduced template argument type will be an lvalue reference type 
and the function parameter will be instantiated as an (ordinary) lvalue reference parameter (T&)


-> NOTE: It is also worth noting that by implication, we can pass any type of argument to a T&& function parameter. 
A parameter of such a type can (obviously) be used with rvalues, and as we’ve just seen, can be used by lvalues as well.


-> NOTE: Reference collapsing applies only when a reference to a reference is created indirectly, 
such as in a type alias or a template parameter.


-> NOTE: An argument of any type can be passed to a function parameter that is an rvalue reference to a template parameter type (i.e., T&&). 
When an lvalue is passed to such a parameter, the function parameter is instantiated as an ordinary, lvalue reference (T&).


-> NOTE: Writing Template Functions with Rvalue Reference Parameters (THIS IS IMPORTANT)
The fact that the template parameter can be deduced to a reference type 
can have surprising impacts on the code inside the template:
template <typename T> void f3(T&& val)
{
T t = val; // copy or binding a reference?
t = fcn(t); // does the assignment change only t or val and t?
if (val == t) { /* . . . */ } // always true if T is a reference type
}
When we call f3 on an rvalue, such as the literal 42, T is int. 
In this case, the local variable t has type int and is initialized by copying the value of the parameter val. 
When we assign to t, the parameter val remains unchanged.

On the other hand, when we call f3 on the lvalue i, then T is int&. 
When we define and initialize the local variable t, that variable has type int&. 
The initialization of t binds t to val. 
When we assign to t, we change val at the same time. 
In this instantiation of f3, the if test will always yield true.

It is surprisingly hard to write code that is correct when the types involved might be plain (nonreference) types 
or reference types (although the type transformation classes such as remove_reference can help (§ 16.2.3, p. 684)).
In practice, rvalue reference parameters are used in one of two contexts: 
Either the template is forwarding its arguments, or the template is overloaded. 
We’ll look at forwarding in § 16.2.7 (p. 692) and at template overloading in § 16.3 (p. 694).



-> NOTE: (ME: THIS IS IMPORTANT) For now, it’s worth noting that function templates that use rvalue references
often use overloading in the same way as we saw in § 13.6.3 (p. 544):
template <typename T> void f(T&&); // binds to nonconst rvalues
template <typename T> void f(const T&); // lvalues and const rvalues
As with nontemplate functions, the first version will bind to modifiable rvalues and the second to lvalues or to const rvalues.


-> NOTE: Understanding std::move
The library move function (§ 13.6.1, p. 533) is a good illustration of a template that uses rvalue references. 
Fortunately, we can use move without understanding the template mechanisms that it uses. 
However, looking at how move works can help cement our general understanding, and use, of templates.

In § 13.6.2 (p. 534) we noted that although we cannot directly bind an rvalue reference to an lvalue, 
we can use move to obtain an rvalue reference bound to an lvalue. 
Because move can take arguments of essentially any type, it should not be surprising that move is a function template.


-> NOTE: How std::move Is Defined
The standard defines move as follows:
// for the use of typename in the return type and the cast see § 16.1.3 (p. 670)
// remove_reference is covered in § 16.2.3 (p. 684)
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
// static_cast covered in § 4.11.3 (p. 163)
return static_cast<typename remove_reference<T>::type&&>(t);
}
This code is short but subtle. 
First, move’s function parameter, T&&, is an rvalue reference to a template parameter type. 
Through reference collapsing, this parameter can match arguments of any type. 
In particular, we can pass either an lvalue or an rvalue to move:
string s1("hi!"), s2;
s2 = std::move(string("bye!")); // ok: moving from an rvalue
s2 = std::move(s1); // ok: but after the assigment s1 has indeterminate value


-> NOTE: How std::move Works
In the first assignment, the argument to move is the rvalue result of the string constructor, string("bye"). 
As we’ve seen, when we pass an rvalue to an rvalue reference function parameter, 
the type deduced from that argument is the referred-to type (§ 16.2.5, p. 687). 
Thus, in std::move(string("bye!")):
• The deduced type of T is string.
• Therefore, remove_reference is instantiated with string.
• The type member of remove_reference<string> is string.
• The return type of move is string&&.
• move’s function parameter, t, has type string&&.
Accordingly, this call instantiates move<string>, which is the function string&& move(string &&t)
The body of this function returns static_cast<string&&>(t). 
The type of t is already string&&, so the cast does nothing. 
Therefore, the result of this call is the rvalue reference it was given.

Now consider the second assignment, which calls std::move(s1). 
In this call, the argument to move is an lvalue. 
This time:
• The deduced type of T is string& (reference to string, not plain string).
• Therefore, remove_reference is instantiated with string&.
• The type member of remove_reference<string&> is string,
• The return type of move is still string&&.
• move’s function parameter, t, instantiates as string& &&, which collapses to string&.
Thus, this call instantiates move<string&>, which is
string&& move(string &t)
and which is exactly what we’re after—we want to bind an rvalue reference to an lvalue. 
The body of this instantiation returns static_cast<string&&>(t). 
In this case, the type of t is string&, which the cast converts to string&&.


-> NOTE: static_cast from an Lvalue to an Rvalue Reference Is Permitted
Ordinarily, a static_cast can perform only otherwise legitimate conversions (§ 4.11.3, p. 163). 
However, there is again a special dispensation for rvalue references:
Even though we cannot implicitly convert an lvalue to an rvalue reference,
we can explicitly cast an lvalue to an rvalue reference using static_cast.
Binding an rvalue reference to an lvalue gives code that operates on the rvalue reference permission to clobber the lvalue. 
There are times, such as in our StrVec reallocate function in § 13.6.1 (p. 533), 
when we know it is safe to clobber an lvalue. 
By letting us do the cast, the language allows this usage. 
By forcing us to use a cast, the language tries to prevent us from doing so accidentally.
Finally, although we can write such casts directly, it is much easier to use the library move function. 
Moreover, using std::move consistently makes it easy to find the places in our code that might potentially clobber lvalues.


-> NOTE: Forwarding
Some functions need to forward one or more of their arguments with their types unchanged to another,  forwarded-to, function. 
In such cases, we need to preserve everything about the forwarded arguments, 
including whether or not the argument type is const, and whether the argument is an lvalue or an rvalue.

As an example, we’ll write a function that takes a callable expression and two additional arguments. 
Our function will call the given callable with the other two arguments in reverse order. 
The following is a first cut at our flip function:
// template that takes a callable and two parameters
// and calls the given callable with the parameters ‘‘flipped’’
// flip1 is an incomplete implementation: top-level const and references are lost
template <typename F, typename T1, typename T2>
void flip1(F f, T1 t1, T2 t2)
{
f(t2, t1);
}
This template works fine until we want to use it to call a function that has a reference parameter:
void f(int v1, int &v2) // note v2 is a reference
{
cout << v1 << " " << ++v2 << endl;
}
Here f changes the value of the argument bound to v2. 
However, if we call f through flip1, the changes made by f do not affect the original argument:
f(42, i); // f changes its argument i
flip1(f, j, 42); // f called through flip1 leaves j unchanged
The problem is that j is passed to the t1 parameter in flip1. 
That parameter has is a plain, nonreference type, int, not an int&. 
That is, the instantiation of this call to flip1 is:
void flip1(void(*fcn)(int, int&), int t1, int t2);
The value of j is copied into t1. 
The reference parameter in f is bound to t1, not to j.


-> NOTE: Defining Function Parameters That Retain Type Information
To pass a reference through our flip function, we need to rewrite our function 
so that its parameters preserve the “lvalueness” of its given arguments. 
Thinking ahead a bit, we can imagine that we’d also like to preserve the constness of the arguments as well.

We can preserve all the type information in an argument by defining its 
corresponding function parameter as an rvalue reference to a template type parameter.
Using a reference parameter (either lvalue or rvalue) lets us preserve constness, 
because the const in a reference type is low-level. 
Through reference collapsing (§ 16.2.5, p. 688), if we define the function parameters as T1&& and T2&&, 
we can preserve the lvalue/rvalue property of flip’s arguments (§ 16.2.5, p. 687):
template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
f(t2, t1);
}
As in our earlier call, if we call flip2(f, j, 42), the lvalue j is passed to the parameter t1. 
However, in flip2, the type deduced for T1 is int&, which means that the type of t1 collapses to int&. 
The reference t1 is bound to j. 
When flip2 calls f, the reference parameter v2 in f is bound to t1, 
which in turn is bound to j. When f increments v2, it is changing the value of j.

This version of flip2 solves one half of our problem. 
Our flip2 function works fine for functions that take lvalue references 
but cannot be used to call a function that has an rvalue reference parameter. 
For example:
void g(int &&i, int& j)
{
cout << i << " " << j << endl;
}
If we try to call g through flip2, we will bepassing the parameter t2 to g’s rvalue reference parameter. 
Even if we pass an rvalue to flip2:
flip2(g, i, 42); // error: can’t initialize int&& from an lvalue
what is passed to g will be the parameter named t2 inside flip2. 
A function parameter, like any other variable, is an lvalue expression (§ 13.6.1, p. 533). 
As a result, the call to g in flip2 passes an lvalue to g’s rvalue reference parameter.


-> NOTE: A function parameter that is an rvalue reference to a template type parameter (i.e., T&&) 
preserves the constness and lvalue/rvalue property of its corresponding argument.


-> NOTE: Using std::forward to Preserve Type Information in a Call
We can use a new library facility named forward to pass flip2’s parameters 
in a way that preserves the types of the original arguments. 
Like move, forward is defined in the utility header. 
Unlike move, forward must be called with an explicit template argument (§ 16.2.2, p. 682). 
forward returns an rvalue reference to that explicit argument type. 
That is, the return type of forward<T> is T&&.
Ordinarily, we use forward to pass a function parameter 
that is defined as an rvalue reference to a template type parameter. 
Through reference collapsing on its return type, 
forward preserves the lvalue/rvalue nature of its given argument:
template <typename Type> intermediary(Type &&arg)
{
finalFcn(std::forward<Type>(arg));
// . . .
}
Here we use Type—which is deduced from arg—as forward’s explicit template argument type. 
Because arg is an rvalue reference to a template type parameter, 
Type will represent all the type information in the argument passed to arg.
If that argument was an rvalue, then Type is an ordinary (nonreference) type and forward<Type> will return Type&&. 
If the argument was an lvalue, then— through reference collapsing—Type itself is an lvalue reference type. 
In this case, the return type is an rvalue reference to an lvalue reference type. 
Again through reference collapsing—this time on the return type — forward<Type> will return an lvalue reference type.


-> NOTE: Using forward, we’ll rewrite our flip function once more:
template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)
{
f(std::forward<T2>(t2), std::forward<T1>(t1));
}
If we call flip(g, i, 42), i will be passed to g as an int& and 42 will be passed as an int&&.


-> NOTE: When used with a function parameter that is an rvalue reference to template type parameter (T&&), 
forward preserves all the details about an argument’s type.


-> NOTE: As with std::move, it’s a good idea not to provide a using declaration for std::forward. § 18.2.3 (p. 798) will explain why.


-> NOTE: Overloading and Templates
Function templates can be overloaded by other templates or by ordinary, nontemplate functions. 
As usual, functions with the same name must differ either as to the number or the type(s) of their parameters.

Function matching (§ 6.4, p. 233) is affected by the presence of function templates in the following ways:
• The candidate functions for a call include any function-template instantiation 
for which template argument deduction (§ 16.2, p. 678) succeeds.
• The candidate function templates are always viable, because template argument deduction 
will have eliminated any templates that are not viable.
• As usual, the viable functions (template and nontemplate) are ranked by the conversions, if any, needed to make the call. 
Of course, the conversions used to call a function template are quite limited (§ 16.2.1, p. 679).
• Also as usual, if exactly one function provides a better match than any of the others, that function is selected. 
However, if there are several functions that provide an equally good match, then:
– If there is only one nontemplate function in the set of equally good matches, the nontemplate function is called.
– If there are no nontemplate functions in the set, but there are multiple function templates, 
and one of these templates is more specialized than any of the others, 
the more specialized function template is called.
– Otherwise, the call is ambiguous.


-> NOTE: Correctly defining a set of overloaded function templates requires a good understanding of the relationship 
among types and of the restricted conversions applied to arguments in template functions.


-> NOTE: Writing Overloaded Templates
As an example, we’ll build a set of functions that might be useful during debugging.
We’ll name our debugging functions debug_rep, each of which will return a string representation of a given object. 
We’ll start by writing the most general version of this function as a template that takes a reference to a const object:
// print any type we don’t otherwise handle
template <typename T> string debug_rep(const T &t)
{
ostringstream ret; // see § 8.3 (p. 321)
ret << t; // uses T’s output operator to print a representation of t
return ret.str(); // return a copy of the string to which ret is bound
}
This function can be used to generate a string corresponding to an object of any type that has an output operator.
Next, we’ll define a version of debug_rep to print pointers:
// print pointers as their pointer value, followed by the object to which the pointer points
// NB: this function will not work properly with char*; see § 16.3 (p. 698)
template <typename T> string debug_rep(T *p)
{
ostringstream ret;
ret << "pointer: " << p; // print the pointer’s own value
if (p)
ret << " " << debug_rep(*p); // print the value to which p points
else
ret << " null pointer"; // or indicate that the p is null
return ret.str(); // return a copy of the string to which ret is bound
}
This version generates a string that contains the pointer’s own value 
and calls debug_rep to print the object to which that pointer points. 
Note that this function can’t be used to print character pointers, 
because the IO library defines a version of the << for char* values. 
That version of << assumes the pointer denotes a nullterminated character array, 
and prints the contents of the array, not its address.
We’ll see in § 16.3 (p. 698) how to handle character pointers.
We might use these functions as follows:
string s("hi");
cout << debug_rep(s) << endl;
For this call, only the first version of debug_rep is viable. 
The second version of debug_rep requires a pointer parameter, and in this call we passed a nonpointer object. 
There is no way to instantiate a function template that expects a pointer type from a nonpointer argument, so argument deduction fails. 
Because there is only one viable function, that is the one that is called.
If we call debug_rep with a pointer:
cout << debug_rep(&s) << endl;
both functions generate viable instantiations:
• debug_rep(const string*&), which is the instantiation of the first version of debug_rep with T bound to string*
• debug_rep(string*), which is the instantiation of the second version of debug_rep with T bound to string
The instantiation of the second version of debug_rep is an exact match for this call. 
The instantiation of the first version requires a conversion of the plain pointer to a pointer to const. 
Normal function matching says we should prefer the second template, and indeed that is the one that is run.


-> NOTE: Multiple Viable Templates
As another example, consider the following call:
const string *sp = &s;
cout << debug_rep(sp) << endl;
Here both templates are viable and both provide an exact match:
• debug_rep(const string*&), the instantiation of the first version of the template with T bound to const string*
• debug_rep(const string*), the instantiation of the second version of the template with T bound to const string
In this case, normal function matching can’t distinguish between these two calls.
We might expect this call to be ambiguous. 
However, due to the special rule for overloaded function templates, 
this call resolves to debug_rep(T*), which is the more specialized template.
The reason for this rule is that without it, there would be no way 
to call the pointer version of debug_rep on a pointer to const. 
The problem is that the template debug_rep(const T&) can be called on essentially any type, including pointer types. 
That template is more general than debug_rep(T*), which can be called only on pointer types. 
Without this rule, calls that passed pointers to const would always be ambiguous.


-> NOTE: When there are several overloaded templates that provide an equally good match for a call, the most specialized version is preferred.


-> NOTE: Nontemplate and Template Overloads
For our next example, we’ll define an ordinary nontemplate version of debug_rep
to print strings inside double quotes:
// print strings inside double quotes
string debug_rep(const string &s)
{
return ’"’ + s + ’"’;
}
Now, when we call debug_rep on a string,
string s("hi");
cout << debug_rep(s) << endl;
there are two equally good viable functions:
• debug_rep<string>(const string&), the first template with T bound to string
• debug_rep(const string&), the ordinary, nontemplate function

In this case, both functions have the same parameter list, so obviously, each function provides an equally good match for this call. 
However, the nontemplate version is selected. 
For the same reasons that the most specialized of equally good function templates is preferred, 
a nontemplate function is preferred over equally good match(es) to a function template.


-> NOTE: When a nontemplate function provides an equally good match for a call as a function template, the nontemplate version is preferred.


-> NOTE: Overloaded Templates and Conversions
There’s one case we haven’t covered so far: pointers to C-style character strings and string literals. 
Now that we have a version of debug_rep that takes a string, 
we might expect that a call that passes character strings would match that version.
However, consider this call:
cout << debug_rep("hi world!") << endl; // calls debug_rep(T*)
Here all three of the debug_rep functions are viable:
• debug_rep(const T&), with T bound to char[10]
• debug_rep(T*), with T bound to const char
• debug_rep(const string&), which requires a conversion from const char* to string
Both templates provide an exact match to the argument—the second template requires a (permissible) conversion from array to pointer, 
and that conversion is considered as an exact match for function-matching purposes (§ 6.6.1, p. 245). 
The nontemplate version is viable but requires a user-defined conversion. 
That function is less good than an exact match, leaving the two templates as the possible functions to call. 
As before, the T* version is more specialized and is the one that will be selected.
If we want to handle character pointers as strings, we can define two more nontemplate overloads:
// convert the character pointers to string and call the string version of debug_rep
string debug_rep(char *p)
{
return debug_rep(string(p));
}
string debug_rep(const char *p)
{
return debug_rep(string(p));
}


-> NOTE: Missing Declarations Can Cause the Program to Misbehave (ME: REMINDER FOR THIS)
It is worth noting that for the char* versions of debug_rep to work correctly, 
a declaration for debug_rep(const string&) must be in scope when these functions are defined. 
If not, the wrong version of debug_rep will be called:
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
// the following declaration must be in scope
// for the definition of debug_rep(char*) to do the right thing
string debug_rep(const string &);
string debug_rep(char *p)
{
// if the declaration for the version that takes a const string& is not in scope
// the return will call debug_rep(const T&) with T instantiated to string
return debug_rep(string(p));
}
Ordinarily, if we use a function that we forgot to declare, our code won’t compile.
Not so with functions that overload a template function. 
If the compiler can instantiate the call from the template, then the missing declaration won’t matter. 
In this example, if we forget to declare the version of debug_rep that takes a string,
the compiler will silently instantiate the template version that takes a const T&.


-> NOTE: Declare every function in an overload set before you define any of the functions. 
That way you don’t have to worry whether the compiler will instantiate a call before it sees the function you intended to call.


-> NOTE: Variadic Templates
A variadic template is a template function or class that can take a varying number of parameters. 
The varying parameters are known as a parameter pack. 
There are two kinds of parameter packs: 
A template parameter pack represents zero or more template parameters, 
and a function parameter pack represents zero or more function parameters.

We use an ellipsis to indicate that a template or function parameter represents a pack. 
In a template parameter list, class... or typename... indicates 
that the following parameter represents a list of zero or more types; 
the name of a type followed by an ellipsis represents a list of zero or more
non type parameters of the given type. 
In the function parameter list, a parameter whose type is a template parameter pack is a function parameter pack. 
For example:
// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters
template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);
declares that foo is a variadic function that has one type parameter named T and a template parameter pack named Args. 
That pack represents zero or more additional type parameters. 
The function parameter list of foo has one parameter, whose type is a const & to whatever type T has, 
and a function parameter pack named rest. 
That pack represents zero or more function parameters.
As usual, the compiler deduces the template parameter types from the function’s arguments. 
For a variadic template, the compiler also deduces the number of parameters in the pack. 
For example, given these calls:
int i = 0; double d = 3.14; string s = "how now brown cow";
foo(i, s, 42, d); // three parameters in the pack
foo(s, 42, "hi"); // two parameters in the pack
foo(d, s); // one parameter in the pack
foo("hi"); // empty pack
the compiler will instantiate four different instances of foo:
void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char(&)[3]);
void foo(const double&, const string&);
void foo(const char(&)[3]);
In each case, the type of T is deduced from the type of the first argument. 
The remaining arguments (if any) provide the number of, and types for, the additional arguments to the function.


-> NOTE: The sizeof... Operator
When we need to know how many elements there are in a pack, we can use the sizeof... operator. 
Like sizeof (§ 4.9, p. 156), sizeof... returns a constant expression (§ 2.4.4, p. 65) and does not evaluate its argument:
template<typename ... Args> void g(Args ... args) {
cout << sizeof...(Args) << endl; // number of type parameters
cout << sizeof...(args) << endl; // number of function parameters
}


-> NOTE: Writing a Variadic Function Template
In § 6.2.6 (p. 220) we saw that we can use an initializer_list 
to define a function that can take a varying number of arguments. 
However, the arguments must have the same type (or types that are convertible to a common type). 
Variadic functions are used when we know neither the number nor the types of the arguments we want to process. 
As an example, we’ll define a function like our earlier error_msg function, 
only this time we’ll allow the argument types to vary as well. 
We’ll start by defining a variadic function named print 
that will print the contents of a given list of arguments on a given stream.
Variadic functions are often recursive (§ 6.3.2, p. 227). 
The first call processes the first argument in the pack and calls itself on the remaining arguments. 
Our print function will execute this way—each call will print 
its second argument on the stream denoted by its first argument. 
To stop the recursion, we’ll also need to define a nonvariadic print function that will take a stream and an object:
// function to end the recursion and print the last element
// this function must be declared before the variadic version of print is defined
template<typename T>
ostream &print(ostream &os, const T &t)
{
return os << t; // no separator after the last element in the pack
}
// this version of print will be called for all but the last element in the pack
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
os << t << ", "; // print the first argument
return print(os, rest...); // recursive call; print the other arguments
}
The first version of print stops the recursion and prints the last argument in the initial call to print. 
The second, variadic, version prints the argument bound to t 
and calls itself to print the remaining values in the function parameter pack.
The key part is the call to print inside the variadic function:
return print(os, rest...); // recursive call; print the other arguments
The variadic version of our print function takes three parameters: an ostream&, a const T&, and a parameter pack. 
Yet this call passes only two arguments. 
What happens is that the first argument in rest gets bound to t. 
The remaining arguments in rest form the parameter pack for the next call to print. 
Thus, on each call, the first argument in the pack is removed from the pack and becomes the argument bound to t. 
That is, given: print(cout, i, s, 42); // two parameters in the pack
the recursion will execute as follows:
(1) Call-> print(cout, i, s, 42) | t: i | rest: s, 42
(2) Call-> print(cout, s, 42)    | t: s | rest: 42
(3) Call-> print(cout, 42) calls the nonvariadic version of print

The first two calls canmatch only the variadic version of print because the nonvariadic version isn’t viable. 
These calls pass four and three arguments, respectively, and the nonvariadic print takes only two arguments.

For the last call in the recursion, print(cout, 42), both versions of print are viable. 
This call passes exactly two arguments, and the type of the first argument
is ostream&. Thus, the nonvariadic version of print is viable.
The variadic version is also viable. 
Unlike an ordinary argument, a parameter pack can be empty. 
Hence, the variadic version of print can be instantiated with only two parameters: 
one for the ostream& parameter and the other for the const T& parameter.
Both functions provide an equally good match for the call. 
However, a nonvariadic template is more specialized than a variadic template, 
so the nonvariadic version is chosen for this call (§ 16.3, p. 695).


-> NOTE: A declaration for the nonvariadic version of print must be in scope when the variadic version is defined. 
Otherwise, the variadic function will recurse indefinitely.


-> NOTE: Pack Expansion
Aside from taking its size, the only other thing we can do with a parameter pack is to expand it. 
When we expand a pack, we also provide a pattern to be used on each expanded element. 
Expanding a pack separates the pack into its constituent elements, 
applying the pattern to each element as it does so. 
We trigger an expansion by putting an ellipsis (...) to the right of the pattern.
For example, our print function contains two expansions:
template <typename T, typename... Args>
ostream &
print(ostream &os, const T &t, const Args&... rest)// expand Args
{
os << t << ", ";
return print(os, rest...); // expand rest
}
The first expansion expands the template parameter pack and generates the function parameter list for print. 
The second expansion appears in the call to print.
That pattern generates the argument list for the call to print.
The expansion of Args applies the pattern const Args& to each element in the template parameter pack Args. 
The expansion of this pattern is a comma separated list of zero or more parameter types, 
each of which will have the form const type&. 
For example:
print(cout, i, s, 42); // two parameters in the pack
The types of the last two arguments along with the pattern determine the types of the trailing parameters. 
This call is instantiated as 
ostream& print(ostream&, const int&, const string&, const int&);
The second expansion happens in the (recursive) call to print. 
In this case, the pattern is the name of the function parameter pack (i.e., rest). 
This pattern expands to a comma-separated list of the elements in the pack. 
Thus, this call is equivalent to
print(os, s, 42);


-> NOTE: Understanding Pack Expansions (ME: THIS IS IMPORTANT! EXPANSION!!! YOU CAN APPLY FUNCTION TO EACH ELEMENT IN THE PACK!)
The expansion of the function parameter pack in print just expanded the pack into its constituent parts. 
More complicated patterns are also possible when we expand a function parameter pack. 
For example, we might write a second variadic function that calls debug_rep (§ 16.3, p. 695) 
on each of its arguments and then calls print to print the resulting strings:
// call debug_rep on each argument in the call to print
template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest)
{
// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
return print(os, debug_rep(rest)...);
}
The call to print uses the pattern debug_rep(rest). 
That pattern says that we want to call debug_rep on each element in the function parameter pack rest. 
The resulting expanded pack will be a comma-separated list of calls to debug_rep. 
That is, a call such as errorMsg(cerr, fcnName, code.num(), otherData, "other", item);
will execute as if we had written
print(cerr, debug_rep(fcnName), debug_rep(code.num()),
debug_rep(otherData), debug_rep("otherData"),
debug_rep(item));
In contrast, the following pattern would fail to compile:
// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))
print(os, debug_rep(rest...)); // error: no matching function to call
The problem here is that we expanded rest in the call to debug_rep. 
This call would execute as if we had written
print(cerr, debug_rep(fcnName, code.num(),
otherData, "otherData", item));
In this expansion, we attempted to call debug_rep with a list of five arguments.
There is no version of debug_rep that matches this call. 
The debug_rep function is not variadic and there is no version of debug_rep that has five parameters.


-> NOTE: The pattern in an expansion applies separately to each element in the pack. (ME: CHECK ABOVE)


-> NOTE: Forwarding Parameter Packs (ME: THIS IS IMPORTANT)
Under the new standard, we can use variadic templates together with forward 
to write functions that pass their arguments unchanged to some other function.
To illustrate such functions, we’ll add an emplace_back member to our StrVec class (§ 13.5, p. 526). 
The emplace_back member of the library containers is a variadic member template (§ 16.1.4, p. 673) 
that uses its arguments to construct an element directly in space managed by the container.

Our version of emplace_back for StrVec will also have to be variadic, 
because string has a number of constructors that differ in terms of their parameters.
Because we’d like to be able to use the string move constructor, 
we’ll also need to preserve all the type information about the arguments passed to emplace_back.
As we’ve seen, preserving type information is a two-step process. 
First, to preserve type information in the arguments, 
we must define emplace_back’s function parameters as rvalue references to a template type parameter (§ 16.2.7, p. 693):
class StrVec {
public:
template <class... Args> void emplace_back(Args&&...);
// remaining members as in § 13.5 (p. 526)
};
The pattern in the expansion of the template parameter pack, &&, 
means that each function parameter will be an rvalue reference to its corresponding argument.
Second, we must use forward to preserve the arguments’ original types 
when emplace_back passes those arguments to construct (§ 16.2.7, p. 694):
template <class... Args>
inline
void StrVec::emplace_back(Args&&... args)
{
chk_n_alloc(); // reallocates the StrVec if necessary
alloc.construct(first_free++, std::forward<Args>(args)...);
}
The body of emplace_back calls chk_n_alloc (§ 13.5, p. 526) to ensure that there is enough room 
for an element and calls construct to create an element in the first_free spot. 
The expansion in the call to construct:
std::forward<Args>(args)...
expands both the template parameter pack, Args, and the function parameter pack, args. 
This pattern generates elements with the form
std::forward<Ti>(ti)
where Ti represents the type of the ith element in the template parameter pack
and ti represents the ith element in the function parameter pack. 
For example,
assuming svec is a StrVec, if we call
svec.emplace_back(10, ’c’); // adds cccccccccc as a new last element
the pattern in the call to construct will expand to
std::forward<int>(10), std::forward<char>(c)
By using forward in this call, we guarantee that if emplace_back is called with an rvalue, 
then construct will also get an rvalue. 
For example, in this call:
svec.emplace_back(s1 + s2); // uses the move constructor
the argument to emplace_back is an rvalue, 
which is passed to construct as std::forward<string>(string("the end"))
The result type from forward<string> is string&&, so construct will be called with an rvalue reference. 
The construct function will, in turn, forward this argument to the string move constructor to build this element.


-> NOTE: ADVICE: FORWARDING AND VARIADIC TEMPLATES
Variadic functions often forward their parameters to other functions. 
Such functions typically have a form similar to our emplace_back function:
// fun has zero or more parameters each of which is
// an rvalue reference to a template parameter type
template<typename... Args>
void fun(Args&&... args) // expands Args as a list of rvalue references
{
// the argument to work expands both Args and args
work(std::forward<Args>(args)...);
}
Here we want to forward all of fun’s arguments to another function named work that presumably does the real work of the function. 
Like our call to construct inside emplace_back, the expansion in the call to work expands both 
the template parameter pack and the function parameter pack.
Because the parameters to fun are rvalue references, we can pass arguments of any type to fun; 
because we use std::forward to pass those arguments, 
all type information about those arguments will be preserved in the call to work.


-> NOTE: Template Specializations
It is not always possible to write a single template that is best suited 
for every possible template argument with which the template might be instantiated. 
In some cases, the general template definition is simply wrong for a type: 
The general definition might not compile or might do the wrong thing. 
At other times, we may be able to take advantage of some specific knowledge 
to write more efficient code than would be instantiated from the template. 
When we can’t (or don’t want to) use the template version, 
we can define a specialized version of the class or function template.

Our compare function is a good example of a function template for 
which the general definition is not appropriate for a particular type, namely, character pointers. 
We’d like compare to compare character pointers by calling strcmp rather than by comparing the pointer values. 
Indeed, we have already overloaded the compare function to handle character string literals (§ 16.1.1, p. 654):
// first version; can compare any two types
template <typename T> int compare(const T&, const T&);
// second version to handle string literals
template<size_t N, size_t M>
int compare(const char (&)[N], const char (&)[M]);
However, the version of compare that has two nontype template parameters 
will be called only when we pass a string literal or an array. 
If we call compare with character pointers, the first version of the template will be called:
const char *p1 = "hi", *p2 = "mom";
compare(p1, p2); // calls the first template
compare("hi", "mom"); // calls the template with two nontype parameters
There is noway to convert a pointer to a reference to an array, 
so the second version of compare is not viable when we pass p1 and p2 as arguments.
To handle character pointers (as opposed to arrays), 
we can define a template specialization of the first version of compare. 
A specialization is a separate definition of the template in which one 
or more template parameters are specified to have particular types.



-> NOTE: Defining a Function Template Specialization
When we specialize a function template, we must supply arguments 
for every template parameter in the original template. 
To indicate that we are specializing a template, 
we use the keyword template followed by an empty pair of angle brackets (< >). 
The empty brackets indicate that arguments will be supplied for all the template parameters of the original template:
// special version of compare to handle pointers to character arrays
template <>
int compare(const char* const &p1, const char* const &p2)
{
return strcmp(p1, p2);
}
The hard part in understanding this specialization is the function parameter types.
When we define a specialization, the function parameter type(s) must match 
the corresponding types in a previously declared template. 
Here we are specializing:
template <typename T> int compare(const T&, const T&);
in which the function parameters are references to a const type. 
As with type aliases, the interaction between template parameter types, 
pointers, and const can be surprising (§ 2.5.1, p. 68).
We want to define a specialization of this function with T as const char*. 
Our function requires a reference to the const version of this type. 
The const version of a pointer type is a constant pointer as distinct from a pointer to const (§ 2.4.2, p. 63). 
The type we need to use in our specialization is const char* const &, 
which is a reference to a const pointer to const char.


-> NOTE: Function Overloading versus Template Specializations
When we define a function template specialization, 
we are essentially taking over the job of the compiler. 
That is, we are supplying the definition to use for a specific instantiation of the original template. 
It is important to realize that a specialization is an instantiation; 
it is not an overloaded instance of the function name.

Whether we define a particular function as a specialization or as an independent,
nontemplate function can impact function matching. 
For example, we have defined two versions of our compare function template, one that takes references
to array parameters and the other that takes const T&. The fact that we also have
a specialization for character pointers has no impact on function matching. 
When we call compare on a string literal:
compare("hi", "mom")
both function templates are viable and provide an equally good (i.e., exact) match to the call. 
However, the version with character array parameters is more specialized (§ 16.3, p. 695) and is chosen for this call.
Had we defined the version of compare that takes character pointers as 
a plain nontemplate function (rather than as a specialization of the template), 
this call would resolve differently. 
In this case, there would be three viable functions: 
the two templates and the nontemplate character-pointer version. 
All three are also equally good matches for this call. 
As we’ve seen, when a nontemplate provides an equally good match as a function template, the nontemplate is selected (§ 16.3, p. 695)


-> NOTE: Specializations instantiate a template; they do not overload it. 
As a result, specializations do not affect function matching.
(ME: THIS IS IMPORTANT)


-> NOTE: KEY CONCEPT: ORDINARY SCOPE RULES APPLY TO SPECIALIZATIONS
In order to specialize a template, a declaration for the original template must be in scope. 
Moreover, a declaration for a specialization must be in scope before any code uses that instantiation of the template.
With ordinary classes and functions, missing declarations are (usually) easy to find—the compiler won’t be able to process our code. 
However, if a specialization declaration is missing, the compiler will usually generate code using the original template. 
Because the compiler can often instantiate the original template when a specialization is missing, 
errors in declaration order between a template and its specializations are easy to make but hard to find.
It is an error for a program to use a specialization and an instantiation of 
the original template with the same set of template arguments. 
However, it is an error that the compiler is unlikely to detect.
Templates and their specializations should be declared in the same header file. 
Declarations for all the templates with a given name should appear first, 
followed by any specializations of those templates.


-> NOTE: Class Template Specializations
In addition to specializing function templates, we can also specialize class templates.
As an example, we’ll define a specialization of the library hash template 
that we can use to store Sales_data objects in an unordered container. 
By default, the unordered containers use hash<key_type> (§ 11.4, p. 444) to organize their elements. 
To use this default with our own data type, we must define a specialization of the hash template. 
A specialized hash class must define
• An overloaded call operator (§ 14.8, p. 571) that returns a size_t and takes an object of the container’s key type
• Two type members, result_type and argument_type, which are the return and argument types, respectively, of the call operator
• The default constructor and a copy-assignment operator (which can be implicitly defined (§ 13.1.2, p. 500))
The only complication in defining this hash specialization is that when we specialize a template, 
we must do so in the same namespace in which the original template is defined. 
We’ll have more to say about namespaces in § 18.2 (p. 785).
For now, what we need to know is that we can add members to a namespace. 
To do so, we must first open the namespace:
// open the std namespace so we can specialize std::hash
namespace std {
} // close the std namespace; note: no semicolon after the close curly

Any definitions that appear between the open and close curlies will be part of the std namespace.
The following defines a specialization of hash for Sales_data:
// open the std namespace so we can specialize std::hash
namespace std {
template <> // we’re defining a specialization with
struct hash<Sales_data> // the template parameter of Sales_data
{
// the type used to hash an unordered container must define these types
typedef size_t result_type;
typedef Sales_data argument_type; // by default, this type needs ==
size_t operator()(const Sales_data& s) const;
// our class uses synthesized copy control and default constructor
};
size_t
hash<Sales_data>::operator()(const Sales_data& s) const
{
return hash<string>()(s.bookNo) ^
hash<unsigned>()(s.units_sold) ^
hash<double>()(s.revenue);
}
} // close the std namespace; note: no semicolon after the close curly

Our hash<Sales_data> definition starts with template<>, which indicates that we are defining a fully specialized template. 
The template we’re specializing is named hash and the specialized version is hash<Sales_data>. 
The members of the class follow directly from the requirements for specializing hash.
As with any other class, we can define the members of a specialization inside the class or out of it, as we did here. 
The overloaded call operator must define a hashing function over the values of the given type. 
This function is required to return the same result every time it is called for a given value. 
A good hash function will (almost always) yield different results for objects that are not equal.
Here, we delegate the complexity of defining a good hash function to the library.
The library defines specializations of the hash class for the built-in types and for many of the library types. 
We use an (unnamed) hash<string> object to generate a hash code for bookNo, 
an object of type hash<unsigned> to generate a hash from units_sold, 
and an object of type hash<double> to generate a hash from revenue. 
We exclusive OR (§ 4.8, p. 154) these results to form an overall hash code for the given Sales_data object.
It is worth noting that we defined our hash function to hash all three data members
so that our hash function will be compatible with our definition of operator== for Sales_data (§ 14.3.1, p. 561). 
By default, the unordered containers use the specialization of hash 
that corresponds to the key_type along with the equality operator on the key type.
Assuming our specialization is in scope, it will be used automatically when we use Sales_data as a key to one of these containers:
// uses hash<Sales_data> and Sales_data operator== from § 14.3.1 (p. 561)
unordered_multiset<Sales_data> SDset;
Because hash<Sales_data> uses the private members of Sales_data, we
must make this class a friend of Sales_data:
template <class T> class std::hash; // needed for the friend declaration
class Sales_data {
friend class std::hash<Sales_data>;
// other members as before
};
Here we say that the specific instantiation of hash<Sales_data> is a friend. 
Because that instantiation is defined in the std namespace, 
we must remember to that this hash type is defined in the std namespace. 
Hence, our friend declaration refers to std::hash.


-> NOTE: To enable users of Sales_data to use the specialization of hash, we should define this specialization in the Sales_data header.


-> NOTE: Class-Template Partial Specializations
Differently from function templates, a class template specialization 
does not have to supply an argument for every template parameter. 
We can specify some, but not all, of the template parameters or some, but not all, aspects of the parameters.
A class template partial specialization is itself a template. 
Users must supply arguments for those template parameters that are not fixed by the specialization.

In § 16.2.3 (p. 684), we introduced the library remove_reference type. 
That template works through a series of specializations:
// original, most general template
template <class T> struct remove_reference {
typedef T type;
};
// partial specializations that will be used for lvalue and rvalue references
template <class T> struct remove_reference<T&> // lvalue references
{ typedef T type; };
template <class T> struct remove_reference<T&&> // rvalue references
{ typedef T type; };
The first template defines the most general version. 
It can be instantiated with any type; it uses its template argument as the type for its member named type. 
The next two classes are partial specializations of this original template.
Because a partial specialization is a template, we start, as usual, by defining the template parameters. 
Like any other specialization, a partial specialization has the same name as the template it specializes. 
The specialization’s template parameter list includes an entry for each template parameter 
whose type is not completely fixed by this partial specialization. 
After the class name, we specify arguments for the template parameters we are specializing. 
These arguments are listed inside angle brackets following the template name. 
The arguments correspond positionally to the parameters in the original template.
The template parameter list of a partial specialization is a subset of, 
or a specialization of, the parameter list of the original template. 
In this case, the specializations have the same number of parameters as the original template. 
However, the parameter’s type in the specializations differ from the original template. 
The specializations will be used for lvalue and rvalue reference types, respectively:
int i;
// decltype(42) is int, uses the original template
remove_reference<decltype(42)>::type a;
// decltype(i) is int&, uses first (T&) partial specialization
remove_reference<decltype(i)>::type b;
// decltype(std::move(i)) is int&&, uses second (i.e., T&&) partial specialization
remove_reference<decltype(std::move(i))>::type c;
All three variables, a, b, and c, have type int.


-> NOTE: We can partially specialize only a class template. We cannot partially specialize a function template.
(ME: CHECK THIS! The partially specialize is different here. Check the discussion above)


-> NOTE: Specializing Members but Not the Class (ME: THIS IS IMPORTANT, CLASS TEMPLATES ARE WEIRD!)
Rather than specializing the whole template, we can specialize just specific member function(s). 
For example, if Foo is a template class with a member Bar, we can specialize just that member:
template <typename T> struct Foo {
Foo(const T &t = T()): mem(t) { }
void Bar() { /* . . . */ }
T mem;
// other members of Foo
};
template<> // we’re specializing a template
void Foo<int>::Bar() // we’re specializing the Bar member of Foo<int>
{
// do whatever specialized processing that applies to ints
}
Here we are specializing just one member of the Foo<int> class. 
The other members of Foo<int> will be supplied by the Foo template:
Foo<string> fs; // instantiates Foo<string>::Foo()
fs.Bar(); // instantiates Foo<string>::Bar()
Foo<int> fi; // instantiates Foo<int>::Foo()
fi.Bar(); // uses our specialization of Foo<int>::Bar()
When we use Foo with any type other than int, members are instantiated as usual. 
When we use Foo with int, members other than Bar are instantiated as usual. 
If we use the Bar member of Foo<int>, then we get our specialized definition.




-> NOTE: The tuple Type
A tuple is a template that is similar to a pair (§ 11.2.3, p. 426). 
Each pair type has different types for its members, but every pair always has exactly two members.
A tuple also has members whose types vary from one tuple type to another, but a tuple can have any number of members. 
Each distinct tuple type has a fixed number of members, 
but the number of members in one tuple type can differ from the number of members in another.
A tuple is most useful when we want to combine some data into a single object 
but do not want to bother to define a data structure to represent those data.
The tuple type, along with its companion types and functions, are defined in the tuple header.


-> NOTE: Defining and Initializing tuples
When we define a tuple,we name the type(s) of each of its members:
tuple<size_t, size_t, size_t> threeD; // all three members set to 0
tuple<string, vector<double>, int, list<int>>
someVal("constants", {3.14, 2.718}, 42, {0,1,2,3,4,5});
When we create a tuple object, we can use the default tuple constructor, which value initializes (§ 3.3.1, p. 98) each member, 
or we can supply an initializer for each member as we do in the initialization of someVal. 
This tuple constructor is explicit (§ 7.5.4, p. 296), so we must use the direct initialization syntax:
tuple<size_t, size_t, size_t> threeD = {1,2,3}; // error
tuple<size_t, size_t, size_t> threeD{1,2,3}; // ok
Alternatively, similar to the make_pair function (§ 11.2.3, p. 428), 
the library defines a make_tuple function that generates a tuple object:
// tuple that represents a bookstore transaction: ISBN, count, price per book
auto item = make_tuple("0-999-78345-X", 3, 20.00);
Like make_pair, the make_tuple function uses the types of the supplied initializers to infer the type of the tuple. 
In this case, item is a tuple whose type is tuple<const char*, int, double>.


-> NOTE: Operations on tuples
1) tuple<T1, T2, ..., Tn> t;
t is a tuple with as many members as there are types T1 . . . Tn. 
The members are value initialized (§ 3.3.1, p. 98).
2) tuple<T1, T2, ..., Tn> t(v1, v2, ..., vn);
t is a tuple with types T1 . . . Tn in which each member is initialized from the corresponding initializer, vi. 
This constructor is explicit (§ 7.5.4, p. 296).
make_tuple(v1, v2, ..., vn)
Returns a tuple initialized from the given initializers. 
The type of the tuple is inferred from the types of the initializers.
3) t1 == t2 or t1 != t2
Two tuples are equal if they have the same number of members and if each pair of members are equal. 
Uses each member’s underlying == operator. 
Once a member is found to be unequal, subsequent members are not tested.
4) t1 relop t2 
Relational operations on tuples using dictionary ordering (§ 9.2.7, p. 340). 
The tuples must have the same number of members. 
Members of t1 are compared with the corresponding members from t2 using the < operator 
5) get<i>(t) 
Returns a reference to the ith data member of t; if t is an lvalue, the result is an lvalue reference; 
otherwise, it is an rvalue reference. 
All members of a tuple are public.
6) tuple_size<tupleType>::value
A class template that can be instantiated by a tuple type
and has a public constexpr static data member named value of type size_t that is number of members in the specified tuple type.
7) tuple_element<i, tupleType>::type
A class template that can be instantiated by an integral constant and a tuple
type and has a public member named type that is the type of the specified
members in the specified tuple type.


-> NOTE: Accessing the Members of a tuple
A pair always has two members, which makes it possible for the library to give these members names (i.e., first and second). 
No such naming convention is possible for tuple because there is no limit on the number of members a tuple type can have. 
As a result, the members are unnamed. Instead, we access the members of a tuple through a library function template named get. 
To use get we must specify an explicit template argument (§ 16.2.2, p. 682), which is the position of the member we want to access. 
We pass a tuple object to get, which returns a reference to the specified member:
auto book = get<0>(item); // returns the first member of item
auto cnt = get<1>(item); // returns the second member of item
auto price = get<2>(item)/cnt; // returns the last member of item
get<2>(item) *= 0.8; // apply 20% discount

The value inside the brackets must be an integral constant expression (§ 2.4.4, p. 65). 
As usual, we count from 0, meaning that get<0> is the first member.
If we have a tuple whose precise type details we don’t know, 
we can use two auxilliary class templates to find the number and types of the tuple’s members:
typedef decltype(item) trans; // trans is the type of item
// returns the number of members in object’s of type trans
size_t sz = tuple_size<trans>::value; // returns 3
// cnt has the same type as the second member in item
tuple_element<1, trans>::type cnt = get<1>(item); // cnt is an int

To use tuple_size or tuple_element, we need to know the type of a tuple object. 
As usual, the easiest way to determine an object’s type is to use decltype (§ 2.5.3, p. 70). 
Here, we use decltype to define a type alias for the type of item, which we use to instantiate both templates.
tuple_size has a public static data member named value that is the number or members in the specified tuple. 
The tuple_element template takes an index as well as a tuple type. 
tuple_element has a public type member named type that is the type of the specified member of the specified tuple type.
Like get, tuple_element uses indices starting at 0.


-> NOTE: Relational and Equality Operators
The tuple relational and equality operators behave similarly to the corresponding operations on containers (§ 9.2.7, p. 340). 
These operators execute pairwise on the members of the left-hand and right-hand tuples. 
We can compare two tuples only if they have the same number of members. 
Moreover, to use the equality or inequality operators, 
it must be legal to compare each pair of members using the == operator; 
to use the relational operators, it must be legal to use <. 
For example:
tuple<string, string> duo("1", "2");
tuple<size_t, size_t> twoD(1, 2);
bool b = (duo == twoD); // error: can’t compare a size_t and a string
tuple<size_t, size_t, size_t> threeD(1, 2, 3);
b = (twoD < threeD); // error: differing number of members
tuple<size_t, size_t> origin(0, 0);
b = (origin < twoD); // ok: b is true


-> NOTE: Because tuple defines the < and == operators, 
we can pass sequences of tuples to the algorithms and can use a tuple as key type in an ordered container.


-> NOTE: Using a tuple to Return Multiple Values
A common use of tuple is to return multiple values from a function. 
For example, our bookstore might be one of several stores in a chain. 
Each store would have a transaction file that holds data on each book that the store recently sold. 
We might want to look at the sales for a given book in all the stores.
We’ll assume that we have a file of transactions for each store. 
Each of these per-store transaction files will contain all the transactions for each book grouped together. 
We’ll further assume that some other function reads these transaction files, 
builds a vector<Sales_data> for each store, and puts those vectors in a vector of vectors:
// each element in files holds the transactions for a particular store
vector<vector<Sales_data>> files;
We’ll write a function that will search files looking for the stores that sold a given book. 
For each store that has a matching transaction, we’ll create a tuple to hold the index of that store and two iterators. 
The index will be the position of the matching store in files. 
The iterators will mark the first and one past the last record for the given book in that store’s vector<Sales_data>.


-> NOTE: A Function That Returns a tuple
We’ll start by writing the function to find a given book. 
This function’s arguments are the vector of vectors just described, and a string that represents the book’s ISBN. 
Our function will return a vector of tuples that will have an entry for each store with at least one sale for the given book:
// matches has three members: an index of a store and iterators into that store’s vector
typedef tuple<vector<Sales_data>::size_type,
vector<Sales_data>::const_iterator,
vector<Sales_data>::const_iterator> matches;
// files holds the transactions for every store
// findBook returns a vector with an entry for each store that sold the given book
vector<matches>
findBook(const vector<vector<Sales_data>> &files,
const string &book)
{
vector<matches> ret; // initially empty
// for each store find the range of matching books, if any
for (auto it = files.cbegin(); it != files.cend(); ++it) {
// find the range of Sales_data that have the same ISBN
auto found = equal_range(it->cbegin(), it->cend(),
book, compareIsbn);
if (found.first != found.second) // this store had sales
// remember the index of this store and the matching range
ret.push_back(make_tuple(it - files.cbegin(),
found.first, found.second));
}
return ret; // empty if no matches found
}
The for loop iterates through the elements in files. 
Those elements are themselves vectors. 
Inside the for we call a library algorithm named equal_range, 
which operates like the associative container member of the same name (§ 11.3.5, p. 439). 
The first two arguments to equal_range are iterators denoting an input sequence (§ 10.1, p. 376). 
The third argument is a value. 
By default, equal_range uses the < operator to compare elements. 
Because Sales_data does not have a < operator, we pass a pointer to the compareIsbn function (§ 11.2.2, p. 425).
The equal_range algorithm returns a pair of iterators that denote a range of elements. 
If book is not found, then the iterators will be equal, indicating that the range is empty. 
Otherwise, the first member of the returned pair will denote 
the first matching transaction and second will be one past the last.


-> NOTE: Using a tuple Returned by a Function
Once we have built our vector of stores with matching transactions, we need toprocess these transactions. 
In this program, we’ll report the total sales results for each store that has a matching sale:
void reportResults(istream &in, ostream &os,
const vector<vector<Sales_data>> &files)
{
string s; // book to look for
while (in >> s) {
auto trans = findBook(files, s); // stores that sold this book
if (trans.empty()) {
cout << s << " not found in any stores" << endl;
continue; // get the next book to look for
}
for (const auto &store : trans) // for every store with a sale
// get<n> returns the specified member from the tuple in store
os << "store " << get<0>(store) << " sales: "
<< accumulate(get<1>(store), get<2>(store),
Sales_data(s))
<< endl;
}
}
The while loop repeatedly reads the istream named in to get the next book to process. 
We call findBook to see if s is present, and assign the results to trans.
We use auto to simplify writing the type of trans, which is a vector of tuples.
If trans is empty, there were no sales for s. 
In this case, we print a message and return to the while to get the next book to look for.
The for loop binds store to each element in trans. 
Because we don’t intend to change the elements in trans, we declare store as a reference to const. 
We use get to print the relevant data: get<0> is the index of the corresponding store,
get<1> is the iterator denoting the first transaction, and get<2> is the iterator one past the last.
Because Sales_data defines the addition operator (§ 14.3, p. 560), 
we can use the library accumulate algorithm (§ 10.2.1, p. 379) to sum the transactions. 
We pass a Sales_data object initialized by the Sales_data constructor that takes a string (§ 7.1.4, p. 264) 
as the starting point for the summation. 
That constructor initializes the bookNo member from the given string and the units_sold and revenue members to zero.


-> NOTE: Using a tuple Returned by a Function
Once we have built our vector of stores with matching transactions, we need to process these transactions. 
In this program, we’ll report the total sales results for each store that has a matching sale:
void reportResults(istream &in, ostream &os,
const vector<vector<Sales_data>> &files)
{
string s; // book to look for
while (in >> s) {
auto trans = findBook(files, s); // stores that sold this book
if (trans.empty()) {
cout << s << " not found in any stores" << endl;
continue; // get the next book to look for
}
for (const auto &store : trans) // for every store with a sale
// get<n> returns the specified member from the tuple in store
os << "store " << get<0>(store) << " sales: "
<< accumulate(get<1>(store), get<2>(store),
Sales_data(s))
<< endl;
}
}
The while loop repeatedly reads the istream named in to get the next book to process. 
We call findBook to see if s is present, and assign the results to trans.
We use auto to simplify writing the type of trans, which is a vector of tuples.
If trans is empty, there were no sales for s. 
In this case, we print a message and return to the while to get the next book to look for.
The for loop binds store to each element in trans. 
Because we don’t intend to change the elements in trans, we declare store as a reference to const. 
We use get to print the relevant data: get<0> is the index of the corresponding store,
get<1> is the iterator denoting the first transaction, and get<2> is the iterator one past the last.
Because Sales_data defines the addition operator (§ 14.3, p. 560), 
we can use the library accumulate algorithm (§ 10.2.1, p. 379) to sum the transactions. 
We pass a Sales_data object initialized by the Sales_data constructor that takes a string (§ 7.1.4, p. 264) 
as the starting point for the summation. 
That constructor initializes the bookNo member from the given string and the units_sold and revenue members to zero.


-> NOTE: The bitset Type
In § 4.8 (p. 152) we covered the built-in operators that treat an integral operand as a collection of bits. 
The standard library defines the bitset class to make it easier to use bit operations 
and possible to deal with collections of bits that are larger than the longest integral type. 
The bitset class is defined in the bitset header.


-> NOTE: Defining and Initializing bitsets
Table 17.2 (overleaf) lists the constructors for bitset. 
The bitset class is a class template that, like the array class, has a fixed size (§ 9.2.4, p. 336). 
When we define a bitset, we say how many bits the bitset will contain:
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0
The size must be a constant expression (§ 2.4.4, p. 65). 
This statement defines bitvec as a bitset that holds 32 bits. 
Just as with the elements of a vector, the bits in a bitset are not named. 
Instead, we refer to them positionally. 
The bits are numbered starting at 0. 
Thus, bitvec has bits numbered 0 through 31. 
The bits starting at 0 are referred to as the low-order bits, 
and those ending at 31 are referred to as high-order bits.


-> NOTE: Initializing a bitset from an unsigned Value
When we use an integral value as an initializer for a bitset, 
that value is converted to unsigned long long and is treated as a bit pattern. 
The bits in the bitset are a copy of that pattern.
If the size of the bitset is greater than the number of bits in an unsigned long long, 
then the remaining high-order bits are set to zero. 
If the size of the bitset is less than that number of bits, 
then only the low-order bits from the given value are used; 
the high-order bits beyond the size of the bitset object are discarded:
// bitvec1 is smaller than the initializer; high-order bits from the initializer are discarded
bitset<13> bitvec1(0xbeef); // bits are 1111011101111
// bitvec2 is larger than the initializer; high-order bits in bitvec2 are set to zero
bitset<20> bitvec2(0xbeef); // bits are 00001011111011101111
// on machines with 64-bit long long 0ULL is 64 bits of 0, so ~0ULL is 64 ones
bitset<128> bitvec3(~0ULL); // bits 0 . . . 63 are one; 63 . . . 127 are zero

We need not use the entire string as the initial value for the bitset. 
Instead, we can use a substring as the initializer:
string str("1111111000000011001101");
bitset<32> bitvec5(str, 5, 4); // four bits starting at str[5], 1100
bitset<32> bitvec6(str, str.size()-4); // use last four characters
Here bitvec5 is initialized by the substring in str starting at str[5] and continuing for four positions. 
As usual, the right-most character of the substring represents the lowest-order bit. 
Thus, bitvec5 is initialized with bit positions 3 through 0 set to 1100 and the remaining bits set to 0. 
The initializer for bitvec6 passes a string and a starting point, 
so bitvec6 is initialized from the characters in str starting four from the end of str. 
The remainder of the bits in bitvec6 are initialized to zero. 


-> NOTE: The indexing conventions of strings and bitsets are inversely related:
The character in the string with the highest subscript (the rightmost character) 
is used to initialize the low-order bit in the bitset (the bit with subscript 0). 
When you initialize a bitset from a string, it is essential to remember this difference.


-> NOTE: Ways to Initialize a bitset
1) bitset<n> b; 
b has n bits; each bit is 0. 
This constructor is a constexpr (§ 7.5.6, p. 299).
2) bitset<n> b(u); 
b is a copy of the n low-order bits of unsigned long long value u. 
If n is greater than the size of an unsigned long long, 
the high-order bits beyond those in the unsigned long long are set to zero. 
This constructor is a constexpr (§ 7.5.6, p. 299).
3) bitset<n> b(s, pos, m, zero, one);
b is a copy of the m characters from the string s starting at position pos. 
s may contain only the characters zero and one; 
if s contains any other character, throws invalid_argument. 
The characters are stored in b as zero and one, respectively. 
pos defaults to 0, m defaults to string::npos, zero defaults to ’0’, and one defaults to ’1’.
4) bitset<n> b(cp, pos, m, zero, one);
Same as the previous constructor, but copies from the character array to which cp points. 
If m is not supplied, then cp must point to a C-style string. 
If m is supplied, there must be at least m characters that are zero or one starting at cp.
The constructors that take a string or character pointer are explicit (§ 7.5.4, p. 296).
The ability to specify alternate characters for 0 and 1 was added in the new standard.


-> NOTE: bitset Operations
1) b.any() 
Is any bit in b on?
2) b.all() 
Are all the bits in b on?
3) b.none() 
Are no bits in b on?
4) b.count() 
Number of bits in b that are on.
5) b.size() 
A constexpr function (§ 2.4.4, p. 65) that returns the number of bits in b.
6) b.test(pos) 
Returns true if bit at position pos is on, false otherwise.
7) b.set(pos, v) or b.set()
Sets the bit at position pos to the bool value v. v defaults to true. 
If no arguments, turns on all the bits in b.
8) b.reset(pos) or b.reset()
Turns off the bit at position pos or turns off all the bits in b.
9) b.flip(pos) or b.flip()
Changes the state of the bit at position pos or of every bit in b.
10) b[pos] 
Gives access to the bit in b at position pos; if b is const, 
then b[pos] returns a bool value true if the bit is on, false otherwise.
11) b.to_ulong() or b.to_ullong()
Returns an unsigned long or an unsigned long long with the same bits as in b. 
Throws overflow_error if the bit pattern in b won’t fit in the indicated result type.
12) b.to_string(zero, one)
Returns a string representing the bit pattern in b. 
zero and one default to ’0’ and ’1’ and are used to represent the bits 0 and 1 in b.
13) os << b 
Prints the bits in b as the characters 1 or 0 to the stream os.
14) is >> b 
Reads characters from is into b. 
Reading stops when the next character is not a 1 or 0 orwhen b.size() bits have been read.


-> NOTE: Operations on bitsets
The bitset operations (Table 17.3 (overleaf)) define various ways to test or set one or more bits. 
The bitset class also supports the bitwise operators thatwe covered in § 4.8 (p. 152). 
The operators have the same meaning when applied to bitset objects as 
the built-in operators have when applied to unsigned operands.

Several operations—count, size, all, any, and none—take no arguments and return information about the state of the entire bitset. 
Others—set, reset, and flip—change the state of the bitset. 
The members that change the bitset are overloaded. 
In each case, the version that takes no arguments applies the given operation to the entire set; 
the versions that take a position apply the operation to the given bit:
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0
bool is_set = bitvec.any(); // true, one bit is set
bool is_not_set = bitvec.none(); // false, one bit is set
bool all_set = bitvec.all(); // false, only one bit is set
size_t onBits = bitvec.count(); // returns 1
size_t sz = bitvec.size(); // returns 32
bitvec.flip(); // reverses the value of all the bits in bitvec
bitvec.reset(); // sets all the bits to 0
bitvec.set(); // sets all the bits to 1

The any operation returns true if one ormore bits of the bitset object are turned on—that is, are equal to 1. 
Conversely, none returns true if all the bits are zero.
The new standard introduced the all operation, which returns true if all the bits are on. 
The count and size operations return a size_t (§ 3.5.2, p. 116) equal to the number of bits that are set,
 or the total number of bits in the object, respectively.
The size function is a constexpr and so can be usedwhere a constant expression is required (§ 2.4.4, p. 65).

The flip, set, reset, and test members let us read or write the bit at a
given position:
bitvec.flip(0); // reverses the value of the first bit
bitvec.set(bitvec.size() - 1); // turns on the last bit
bitvec.set(0, 0); // turns off the first bit
bitvec.reset(i); // turns off the ith bit
bitvec.test(0); // returns false because the first bit is off

The subscript operator is overloaded on const. The const version returns
a bool value true if the bit at the given index is on, false otherwise. The
nonconst version returns a special type defined by bitset that lets us manipulate
the bit value at the given index position:
bitvec[0] = 0; // turn off the bit at position 0
bitvec[31] = bitvec[0]; // set the last bit to the same value as the first bit
bitvec[0].flip(); // flip the value of the bit at position 0
~bitvec[0]; // equivalent operation; flips the bit at position 0
bool b = bitvec[0]; // convert the value of bitvec[0] to bool


-> NOTE: Retrieving the Value of a bitset
The to_ulong and to_ullong operations return a value that holds the same
bit pattern as the bitset object. We can use these operations only if the size of
the bitset is less than or equal to the corresponding size, unsigned long for
to_ulong and unsigned long long for to_ullong:
unsigned long ulong = bitvec3.to_ulong();
cout << "ulong = " << ulong << endl;


-> NOTE: bitset IO Operators
The input operator reads characters from the input stream into a temporary object of type string. 
It reads until it has read as many characters as the size of the corresponding bitset, 
or it encounters a character other than 1 or 0, or it encounters end-of-file or an input error. 
The bitset is then initialized from that temporary string (§ 17.2.1, p. 724). 
If fewer characters are read than the size of the bitset, the high-order bits are, as usual, set to 0.
The output operator prints the bit pattern in a bitset object:
bitset<16> bits;
cin >> bits; // read up to 16 1 or 0 characters from cin
cout << "bits: " << bits << endl; // print what we just read


-> NOTE: Using bitsets
To illustrate using bitsets,we’ll reimplement the grading code from§ 4.8 (p. 154)
that used an unsigned long to represent the pass/fail quiz results for 30 students:
bool status;
// version using bitwise operators
unsigned long quizA = 0; // this value is used as a collection of bits
quizA |= 1UL << 27; // indicate student number 27 passed
status = quizA & (1UL << 27); // check how student number 27 did
quizA &= ~(1UL << 27); // student number 27 failed
// equivalent actions using the bitset library
bitset<30> quizB; // allocate one bit per student; all bits initialized to 0
quizB.set(27); // indicate student number 27 passed
status = quizB[27]; // check how student number 27 did
quizB.reset(27); // student number 27 failed



-> NOTE: Regular Expressions
A regular expression is a way of describing a sequence of characters. 
Regular expressions are a stunningly powerful computational device. 
However, describing the languages used to define regular expressions is well beyond the scope of this Primer. 
Instead, we’ll focus on how to use the C++ regular-expression library (RE library), which is part of the new library. 
The RE library, which is defined in the regex header, involves several components, listed in Table 17.4.

The regex class represents a regular expression. 
Aside from initialization and assignment, regex has few operations. 

The functions regex_match and regex_search determine whether a given character sequence matches a given regex. 
The regex_match function returns true if the entire input sequence matches the expression; 
regex_search returns true if there is a substring in the input sequence that matches. 
There is also a regex_replace function that we’ll describe in § 17.3.4 (p. 741).
The arguments to the regex functions are described in Table 17.5 (overleaf).
These functions return a bool and are overloaded: 
One version takes an additional argument of type smatch. 
If present, these functions store additional information about a successful match in the given smatch object.


-> NOTE: If you are not already familiar with using regular expressions, 
you might want to skim this section to get an idea of the kinds of things regular expressions can do.


-> NOTE: Using the Regular Expression Library
As a fairly simple example,we’ll look for words that violate a well-known spelling rule of thumb, “i before e except after c”:
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
regex r(pattern); // construct a regex to find pattern
smatch results; // define an object to hold the results of a search
// define a string that has text that does and doesn’t match pattern
string test_str = "receipt freind theif receive";
// use r to find a match to pattern in test_str
if (regex_search(test_str, results, r)) // if there is a match
cout << results.str() << endl; // print the matching word

We start by defining a string to hold the regular expression we want to find.
The regular expression [^c] says we want any character that is not a ’c’, 
and [^c]ei says we want any such letter that is followed by the letters ei. 
This pattern describes strings containing exactly three characters. 
We want the entire word that contains this pattern. 
To match the word, we need a regular expression that will match the letters that come before and after our three-letter pattern.

That regular expression consists of zero or more letters followed by 
our original three-letter pattern followed by zero or more additional characters. 
By default, the regular-expression language used by regex objects is ECMAScript. 
In ECMAScript, the pattern [[:alpha:]] matches any alphabetic character, 
and the symbols + and * signify that we want “one or more” or “zero or more” matches, respectively. 
Thus, [[:alpha:]]* will match zero or more characters.
Having stored our regular expression in pattern, we use it to initialize a regex object named r. 
We next define a string that we’ll use to test our regular expression. 
We initialize test_str with words that match our pattern (e.g., “freind” and “theif”) 
and words (e.g., “receipt” and “receive”) that don’t. 
We also define an smatch object named results, which we will pass to regex_search.
If a match is found, results will hold the details aboutwhere the match occurred.
Next we call regex_search. 
If regex_search finds a match, it returns true. 
We use the str member of results to print the part of test_str that matched our pattern. 
The regex_search function stops looking as soon as it finds a matching substring in the input sequence. 
Thus, the output will be "freind"
§ 17.3.2 (p. 734) will show how to find all the matches in the input.


-> NOTE: Arguments to regex_search and regex_match
Note: These operations return bool indicating whether a match was found.
(seq, m, r, mft) or (seq, r, mft)
Look for the regular expression in the regex object r in the character sequence seq. 
seq can be a string, a pair of iterators denoting a range, or a pointer to a null-terminated character array.
m is a match object, which is used to hold details about the match.
m and seq must have compatible types (see § 17.3.1 (p. 733)).
mft is an optional regex_constants::match_flag_type value.
These values, listed in Table 17.13 (p. 744), affect the match process.


-> NOTE: regex (and wregex) Operations
1) regex r(re) or regex r(re, f)
re represents a regular expression and can be a string, a pair of iterators denoting a range of characters, 
a pointer to a null-terminated character array, a character pointer and a count, or a braced list of characters. 
f are flags that specify how the object will execute. 
f is set from the values listed below. 
If f is not specified, it defaults to ECMAScript.
2) r1 = re 
Replace the regular expression in r1 with re. 
re represents a regular expression and can be another regex, a string, 
a pointer to a null-terminated character array, or a braced list of characters.
3) r1.assign(re, f) 
Same effect as using the assignment operator (=). 
re and optional flag f same as corresponding arguments to regex constructors.
4) r.mark_count() 
Number of subexpressions (which we’ll cover in § 17.3.3 (p. 738)) in r.
5) r.flags() 
Returns the flags set for r.


-> NOTE: Constructors and assignment operations may throw exceptions of type regex_error.


-> NOTE: Specifying Options for a regex Object
When we define a regex or call assign on a regex to give it a new value, 
we can specify one or more flags that affect how the regex operates. 
These flags control the processing done by that object. 
The last six flags listed in Table 17.6 indicate the language in which the regular expression is written. 
Exactly one of the flags that specify a language must be set. 
By default, the ECMAScript flag is set, which causes the regex to use the ECMA-262 specification, 
which is the regular expression language that many Web browsers use.

The other three flags let us specify language-independent aspects of the regular expression processing. 
For example, we can indicate that we want the regular expression to be matched in a case-independent manner.

As one example, we can use the icase flag to find file names that have a particular file extension. 
Most operating systems recognize extensions in a case independent manner—
we can store a C++ program in a file that ends in .cc, or .Cc, or .cC, or .CC. 
We’ll write a regular expression to recognize any of these along with other common file extensions as follows:
// one or more alphanumeric characters followed by a ’.’ followed by "cpp" or "cxx" or "cc"
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results;
string filename;
while (cin >> filename)
if (regex_search(filename, results, r))
cout << results.str() << endl; // print the current match

This expression will match a string of one or more letters or digits 
followed by a period and followed by one of three file extensions. 
The regular expression will match the file extensions regardless of case.

Just as there are special characters in C++ (§ 2.1.3, p. 39), 
regular-expression languages typically also have special characters. 
For example, the dot (.) character usually matches any character. 
As we do in C++, we can escape the special nature of a character by preceding it with a backslash. 
Because the backslash is also a special character in C++, 
we must use a second backslash inside a string literal to indicate to C++ that we want a backslash. 
Hence, we must write \\. to represent a regular expression that will match a period.


-> NOTE: Flags Specified When a regex Is Defined
---> icase: Ignore case during the match
---> nosubs: Don’t store subexpression matches
---> optimize: Favor speed of execution over speed of construction
---> ECMAScript: Use grammar as specified by ECMA-262
---> basic: Use POSIX basic regular-expression grammar
---> extended: Use POSIX extended regular-expression grammar
---> awk: Use grammar from the POSIX version of the awk language
---> grep: Use grammar from the POSIX version of grep
---> egrep: Use grammar from the POSIX version of egrep


-> NOTE: Errors in Specifying or Using a Regular Expression
We can think of a regular expression as itself a “program” in a simple programming language. 
That language is not interpreted by the C++ compiler. 
Instead, a regular expression is “compiled” at run time when a regex object is initialized with or assigned a new pattern. 
As with any programming language, it is possible that the regular expressions we write can have errors.

If we make amistake in writing a regular expression, then at run time the library will throw an exception (§ 5.6, p. 193) of type regex_error. 
Like the standard exception types, regex_error has a what operation that describes the error that occurred (§ 5.6.2, p. 195). 
A regex_error also has a member named code that returns a numeric code corresponding to the type of error that was encountered.
The values code returns are implementation defined. 
The standard errors that the RE library can throw are listed in Table 17.7.
For example, we might inadvertently omit a bracket in a pattern:
try {
// error: missing close bracket after alnum; the constructor will throw
regex r("[[:alnum:]+\\.(cpp|cxx|cc)$", regex::icase);
} catch (regex_error e)
{ cout << e.what() << "\ncode: " << e.code() << endl; }

When run on our system, this program generates
regex_error(error_brack):
The expression contained mismatched [ and ].
code: 4
Our compiler defines the code member to return the position of the error as listed in Table 17.7, counting, as usual, from zero.


-> NOTE: It is important to realize that the syntactic correctness of a regular expression is evaluated at run time.


-> NOTE: Regular Expression Error Conditions
This is Defined in regex and in regex_constants::error_type
error_collate: Invalid collating element request
error_ctype: Invalid character class
error_escape: Invalid escape character or trailing escape
error_backref: Invalid back reference
error_brack: Mismatched bracket ([ or ])
error_paren: Mismatched parentheses (( or ))
error_brace: Mismatched brace ({ or })
error_badbrace: Invalid range inside a{ }
error_range: Invalid character range (e.g., [z-a])
error_space: Insufficient memory to handle this regular expression
error_badrepeat: A repetition character (*, ?, +, or {) was not preceded by a valid regular expression
error_complexity: The requested match is too complex
error_stack: Insufficient memory to evaluate a match


-> NOTE: ADVICE: AVOID CREATING UNNECESSARY REGULAR EXPRESSIONS
As we’ve seen, the “program” that a regular expression represents is compiled at run time, not at compile time. 
Compiling a regular expression can be a surprisingly slow operation, 
especially if you’re using the extended regular-expression grammar or are using complicated expressions. 
As a result, constructing a regex object and assigning a new regular expression to an existing regex can be time-consuming. 
To minimize this overhead, you should try to avoid creating more regex objects than needed. 
In particular, if you use a regular expression in a loop, you should create it outside the loop rather than recompiling it on each iteration.


-> NOTE: Regular Expression Classes and the Input Sequence Type
We can search any of several types of input sequence. 
The input can be ordinary char data or wchar_t data and those characters can be stored in a library string 
or in an array of char (or the wide character versions, wstring or array of wchar_t). 
The RE library defines separate types that correspond to these differing types of input sequences.

For example, the regex class holds regular expressions of type char. 
The library also defines a wregex class that holds type wchar_t and has all the same operations as regex. 
The only difference is that the initializers of a wregex must use wchar_t instead of char.

The match and iterator types (which we will cover in the following sections) are more specific. 
These types differ not only by the character type, but also by whether the sequence is in a library string or an array: 
smatch represents string input sequences; cmatch, character array sequences; 
wsmatch, wide string (wstring) input; and wcmatch, arrays of wide characters.

The important point is that the RE library types we use must match the type of the input sequence. 
Table 17.8 indicates which types correspond to which kinds of input sequences. 
For example:
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results; // will match a string input sequence, but not char*
if (regex_search("myfile.cc", results, r)) // error: char* input
cout << results.str() << endl;

The (C++) compiler will reject this code because the type of the match argument and the type of the input sequence do not match. 
If we want to search a character array, then we must use a cmatch object:
cmatch results; // will match character array input sequences
if (regex_search("myfile.cc", results, r))
cout << results.str() << endl; // print the current match
In general, our programs will use string input sequences and the corresponding
string versions of the RE library components.


-> NOTE: Regular Expression Library Classes
If Input Sequence Has Type: Use Regular Expression Classes
For string: regex, smatch, ssub_match, and sregex_iterator
For const char*: regex, cmatch, csub_match, and cregex_iterator
For wstring: wregex, wsmatch, wssub_match, and wsregex_iterator
For const wchar_t*: wregex, wcmatch, wcsub_match, and wcregex_iterator


-> NOTE: The Match and Regex Iterator Types
The program on page 729 that found violations of the “i before e except after c” grammar rule printed only the first match in its input sequence. 
We can get all the matches by using an sregex_iterator. 
The regex iterators are iterator adaptors (§ 9.6, p. 368) that are bound to an input sequence and a regex object. 
As described in Table 17.8 (on the previous page), 
there are specific regex iterator types that correspond to each of the different types of input sequences. 
The iterator operations are described in Table 17.9 (p. 736).
When we bind an sregex_iterator to a string and a regex object, 
the iterator is automatically positioned on the first match in the given string. 
That is, the sregex_iterator constructor calls regex_search on the given string and regex. 
When we dereference the iterator, we get an smatch object corresponding to the results from the most recent search. 
When we increment the iterator, it calls regex_search to find the next match in the input string.


-> NOTE: Using an sregex_iterator
As an example, we’ll extend our program to find all the violations of 
the “i before e except after c” grammar rule in a file of text. 
We’ll assume that the string named file holds the entire contents of the input file that we want to search. 
This version of the program will use the same pattern as our original one, but will use a sregex_iterator to do the search:
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
regex r(pattern, regex::icase); // we’ll ignore case in doing the match
// it will repeatedly call regex_search to find all matches in file
for (sregex_iterator it(file.begin(), file.end(), r), end_it; it != end_it; ++it)
cout << it->str() << endl; // matched word
The for loop iterates through each match to r inside file. 
The initializer in the for defines it and end_it. 
When we define it, the sregex_iterator constructor calls regex_search to position it on the firstmatch in file. 
The empty sregex_iterator, end_it, acts as the off-the-end iterator. 
The increment in the for “advances” the iterator by calling regex_search. 
When we dereference the iterator, we get an smatch object representing the current match. 
We call the str member of the match to print the matching word.


-> NOTE: Using the Match Data
If we run this loop on test_str from our original program, the output would be
freind
theif
However, finding just the words that match our expression is not so useful. 
If we ran the program on a larger input sequence—for example, 
on the text of this chapter—we’d want to see the context within which the word occurs, 
such as hey read or write according to the type
>>> being <<<
handled. The input operators ignore whi

In addition to letting us print the part of the input string that was matched, 
the match classes give us more detailed information about the match. 
The operations on these types are listed in Table 17.10 (p. 737) and Table 17.11 (p. 741).

We’ll have more to say about the smatch and ssub_match types in the next section. 
For now, what we need to know is that these types let us see the context of a match. 
The match types have members named prefix and suffix, 
which return a ssub_match object representing the part of the input sequence ahead of and after the current match, respectively. 
A ssub_match object has members named str and length, which return the matched string and size of that string, respectively. 
We can use these operations to rewrite the loop of our grammar program:
// same for loop header as before
for (sregex_iterator it(file.begin(), file.end(), r), end_it; it != end_it; ++it) {
auto pos = it->prefix().length(); // size of the prefix
pos = pos > 40 ? pos - 40 : 0; // we want up to 40 characters
cout << it->prefix().str().substr(pos) // last part of the prefix
<< "\n\t\t>>> " << it->str() << " <<<\n" // matched word
<< it->suffix().str().substr(0, 40) // first part of the suffix
<< endl;
}

The loop itself operates the same way as our previous program. 
What’s changed is the processing inside the for, which is illustrated in Figure 17.2.

We call prefix, which returns an ssub_match object that represents the part of file ahead of the current match. 
We call length on that ssub_match to find out how many characters are in the part of file ahead of the match. 
Next we adjust pos to be the index of the character 40 from the end of the prefix. 
If the prefix has fewer than 40 characters, we set pos to 0, which means we’ll print the entire prefix. 
We use substr (§ 9.5.1, p. 361) to print from the given position to the end of the prefix.

Having printed the characters that precede the match, we next print the match itself 
with some additional formatting so that the matched word will stand out in the output. 
After printing the matched portion, we print (up to) the first 40 characters in the part of file that comes after this match.


-> NOTE: sregex_iterator Operations
These operations also apply to cregex_iterator, wsregex_iterator, and wcregex_iterator 
1) sregex_iterator it(b, e, r); 
it is an sregx_iterator that iterates through the string denoted by iterators b and e. 
Calls regex_search(b, e, r) to position it on the first match in the input.
2) sregex_iterator end; 
Off-the-end iterator for sregex_iterator.
3) *it or it->
Returns a reference to the smatch object or a pointer to the smatch object
from the most recent call to regex_search.
4) ++it or it++
Calls regex_search on the input sequence starting just after the current match. 
The prefix version returns a reference to the incremented iterator; postfix returns the old value.
5) it1 == it2 or it1 != it2
Two sregex_iterators are equal if they are both the off-the-end iterator.
Two non-end iterators are equal if they are constructed from the same input sequence and regex object.


-> NOTE: smatch Operations
These operations also apply to the cmatch, wsmatch, wcmatch 
and the corresponding csub_match, wssub_match, and wcsub_match types.
1) m.ready() 
true if m has been set by a call to regex_search or regex_match; false otherwise. 
Operations on m are undefined if ready returns false.
2) m.size() 
Zero if the match failed; otherwise, one plus the number of subexpressions in the most recently matched regular expression.
m.empty() true if m.size() is zero.
3) m.prefix() 
An ssub_match representing the sequence before the match.
4) m.suffix() 
An ssub_match representing the part after the end of the match.
5) m.format(...) 
See Table 17.12 (p. 742).

In the operations that take an index, n defaults to zero and must be less than m.size().
The first submatch (the one with index 0) represents the overall match.

1) m.length(n) 
Size of the nth matched subexpression.
2) m.position(n) 
Distance of the nth subexpression from the start of the sequence.
3) m.str(n) 
The matched string for the nth subexpression.
4) m[n] 
ssub_match object corresponding to the nth subexpression.
5) m.begin(), m.end() or m.cbegin(), m.cend()
Iterators across the sub_match elements in m. 
As usual, cbegin and cend return const_iterators.


-> NOTE: Using Subexpressions
A pattern in a regular expression often contains one or more subexpressions. 
A subexpression is a part of the pattern that itself has meaning. 
Regular-expression grammars typically use parentheses to denote subexpressions.

As an example, the pattern that we used to match C++ files (§ 17.3.1, p. 730) used parentheses to group the possible file extensions. 
Whenever we group alternatives using parentheses, we are also declaring that those alternatives form a subexpression. 
We can rewrite that expression so that it gives us access to the file name, 
which is the part of the pattern that precedes the period, as follows:
// r has two subexpressions: the first is the part of the file name before the period
// the second is the file extension
regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$", regex::icase);

Our pattern now has two parenthesized subexpressions:
• ([[:alnum:]]+), which is a sequence of one or more characters
• (cpp| cxx| cc), which is the file extension

We can also rewrite the program from § 17.3.1 (p. 730) to print just the file name by changing the output statement:
if (regex_search(filename, results, r))
cout << results.str(1) << endl; // print the first subexpression

As in our original program, we call regex_search to look for our pattern r in the string named filename, 
and we pass the smatch object results to hold the results of the match. 
If the call succeeds, then we print the results. 
However, in this program, we print str(1), which is the match for the first subexpression.
In addition to providing information about the overall match, 
the match objects provide access to each matched subexpression in the pattern. 
The submatches are accessed positionally. 
The first submatch, which is at position 0, represents the match for the entire pattern. 
Each subexpression appears in order thereafter.
Hence, the file name, which is the first subexpression in our pattern, is at position 1, and the file extension is in position 2.
For example, if the file name is foo.cpp, then results.str(0) will hold foo.cpp; 
results.str(1) will be foo; and results.str(2) will be cpp. 
In this program, we want the part of the name before the period, which is the first subexpression, so we print results.str(1).


-> NOTE: Subexpressions for Data Validation
One common use for subexpressions is to validate data that must match a specific format. 
For example, U.S. phone numbers have ten digits, consisting of an area code and a seven-digit local number. 
The area code is often, but not always, enclosed in parentheses. 
The remaining seven digits can be separated by a dash, a dot, or a space; or not separated at all. 
We might want to allow data with any of these formats and reject numbers in other forms. 
We’ll do a two-step process: 
First, we’ll use a regular expression to find sequences that might be phone numbers 
and then we’ll call a function to complete the validation of the data.
Before we write our phone number pattern, 
we need to describe a few more aspects of the ECMAScript regular-expression language:
• \{d} represents a single digit and \{d}{n} represents a sequence of n digits.
(E.g., \{d}{3} matches a sequence of three digits.)
• A collection of characters inside square brackets allows a match to any of those characters. 
(E.g., [-. ] matches a dash, a dot, or a space. Note that a dot has no special meaning inside brackets.)
• A component followed by ’?’ is optional. 
(E.g., \{d}{3}[-. ]?\{d}{4} matches three digits followed by an optional dash, period, or space, followed by four more digits. 
This pattern would match 555-0132 or 555.0132 or 555 0132 or 5550132.)
• Like C++, ECMAScript uses a backslash to indicate that a character should represent itself, rather than its specialmeaning. 
Because our pattern includes parentheses, which are special characters in ECMAScript, 
we must represent the parentheses that are part of our pattern as \( or \).

Because backslash is a special character in C++, each place that a \ appears in the pattern, 
we must use a second backslash to indicate to C++ that we want a backslash.
Hence, we write \\{d}{3} to represent the regular expression \{d}{3}.
In order to validate our phone numbers, we’ll need access to the components of the pattern. 
For example, we’ll want to verify that if a number uses an opening parenthesis for the area code, 
it also uses a close parenthesis after the area code.
That is, we’d like to reject a number such as (908.555.1800. 
To get at the components of thematch,we need to define our regular expression using subexpressions. 
Each subexpression is marked by a pair of parentheses:
// our overall expression has seven subexpressions: ( ddd ) separator ddd separator dddd
// subexpressions 1, 3, 4, and 6 are optional; 2, 5, and 7 hold the number
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
Because our pattern uses parentheses, and because we must escape backslashes, 
this pattern can be hard to read (and write!). 
The easiest way to read it is to pick off each (parenthesized) subexpression:
1. (\\()? an optional open parenthesis for the area code
2. (\\d{3}) the area code
3. (\\))? an optional close parenthesis for the area code
4. ([-. ])? an optional separator after the area code
5. (\\d{3}) the next three digits of the number
6. ([-. ])? another optional separator
7. (\\d{4}) the final four digits of the number

The following code uses this pattern to read a file and find data that match our overall phone pattern. 
It will call a function named valid to check whether the number has a valid format:
string phone =
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
regex r(phone); // a regex to find our pattern
smatch m;
string s;
// read each record from the input file
while (getline(cin, s)) {
// for each matching phone number
for (sregex_iterator it(s.begin(), s.end(), r), end_it;
it != end_it; ++it)
// check whether the number’s formatting is valid
if (valid(*it))
cout << "valid: " << it->str() << endl;
else
cout << "not valid: " << it->str() << endl;
}


-> NOTE: Using the Submatch Operations
We’ll use submatch operations, which are outlined in Table 17.11, to write the valid function. 
It is important to keep in mind that our pattern has seven subexpressions. 
As a result, each smatch object will contain eight ssub_match elements.
The element at [0]represents the overall match; the elements [1]. . .[7]
represent each of the corresponding subexpressions.
When we call valid,we know that we have an overallmatch, but we do not
know which of our optional subexpressions were part of thatmatch. 
The matched member of the ssub_match corresponding 
to a particular subexpression is true if that subexpression is part of the overall match.
In a valid phone number, the area code is either fully parenthesized or not parenthesized at all. 
Therefore, the work valid does depends on whether the number starts with a parenthesis or not:
bool valid(const smatch& m)
{
// if there is an open parenthesis before the area code
if(m[1].matched)
// the area code must be followed by a close parenthesis
// and followed immediately by the rest of the number or a space
return m[3].matched
&& (m[4].matched == 0 || m[4].str() == " ");
else
// then there can’t be a close after the area code
// the delimiters between the other two components must match
return !m[3].matched
&& m[4].str() == m[6].str();
}

We start by checkingwhether the first subexpression (i.e., the open parenthesis) matched. 
That subexpression is in m[1]. If itmatched, then the number starts with an open parenthesis. 
In this case, the overall number is valid if the subexpression following the area code also matched 
(meaning that there was a close parenthesis after the area code). 
Moreover, if the number is correctly parenthesized, 
then the next character must be a space or the first digit in the next part of the number.
If m[1] didn’t match (i.e., there was no open parenthesis), the subexpression following the area code must also be empty. 
If it’s empty, then the number is valid if the remaining separators are equal and not otherwise.


-> NOTE: Submatch Operations
Note: These operations apply to ssub_match, csub_match, wssub_match, wcsub_match
1) matched 
A public bool data member that indicates whether this ssub_match was matched.
2) first or second
public data members that are iterators to the start and one past the end of the matching sequence. 
If there was no match, then first and second are equal.
3) length() 
The size of this match. 
Returns 0 if matched is false.
4) str() 
Returns a string containing the matched portion of the input. 
Returns the empty string if matched is false.
5) s = ssub 
Convert the ssub_match object ssub to the string s. 
Equivalent to s = ssub.str(). 
The conversion operator is not explicit (§ 14.9.1, p. 581).


-> NOTE: Using regex_replace
Regular expressions are often used when we need not only to find a given sequence 
but also to replace that sequence with another one. 
For example, wemight want to translate U.S. phone numbers into the form “ddd.ddd.dddd,”
where the area code and next three digits are separated by a dot.

When we want to find and replace a regular expression in the input sequence, we call regex_replace. 
Like the search functions, regex_replace, which is described in Table 17.12, 
takes an input character sequence and a regex object.
We must also pass a string that describes the output we want.
We compose a replacement string by including the characters we want, 
intermixed with subexpressions from the matched substring. 
In this case, we want to use the second, fifth, and seventh subexpressions in our replacement string. 
We’ll ignore the first, third, fourth, and sixth, 
because these were used in the original formatting of the number but are not part of our replacement format. 
We refer to a particular subexpression by using a $ symbol followed by the index number for a subexpression:
string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd
We can use our regular-expression pattern and the replacement string as follows:
regex r(phone); // a regex to find our pattern
string number = "(908) 555-0132";
cout << regex_replace(number, r, fmt) << endl;
The output from this program is
908.555.0132


-> NOTE: Regular Expression Replace Operations
1) m.format(dest, fmt, mft) or m.format(fmt, mft)
Produces formatted output using the format string fmt, 
the match in m, and the optional match_flag_type flags in mft. 
The first version writes to the output iterator dest (§ 10.5.1, p. 410) 
and takes fmt that is either a string or a pair of pointers denoting a range in a character array. \
The second version returns a string that holds the output 
and takes fmt that is a string or a pointer to a null-terminated character array. 
mft defaults to format_default.
2) regex_replace(dest, seq, r, fmt, mft) or regex_replace (seq, r, fmt, mft)
Iterates through seq, using regex_search to find successive matches to regex r. 
Uses the format string fmt and optional match_flag_type flags in mft to produce its output. 
The first version writes to the output iterator dest, and takes a pair of iterators to denote seq. 
The second returns a string that holds the output 
and seq can be either a string or a pointer to a null-terminated character array. 
In all cases, fmt can be either a string or a pointer to a null-terminated character array, and mft defaults to match_default.


-> NOTE: Replacing Only Part of the Input Sequence
A more interesting use of our regular-expression processing 
would be to replace phone numbers that are embedded in a larger file. 

For example, we might have a file of names and phone number that had data like this:
morgan (201) 555-0168 862-555-0123
drew (973)555.0130
lee (609) 555-0132 2015550175 800.555-0100
that we want to transform to data like this:
morgan 201.555.0168 862.555.0123
drew 973.555.0130
lee 609.555.0132 201.555.0175 800.555.0100
We can generate this transformation with the following program:
int main()
{
string phone =
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";
regex r(phone); // a regex to find our pattern
smatch m;
string s;
string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd
// read each record from the input file
while (getline(cin, s))
cout << regex_replace(s, r, fmt) << endl;
return 0;
}
We read each record into s and hand that record to regex_replace. 
This function finds and transforms all the matches in its input sequence.


-> NOTE: Flags to Control Matches and Formatting
Just as the library defines flags to direct how to process a regular expression, 
the library also defines flags that we can use to control the match process or the formatting done during a replacement. 
These values are listed in Table 17.13 (overleaf).
These flags can be passed to the regex_search or regex_match functions or to the format members of class smatch.
The match and format flags have type match_flag_type. 
These values are defined in a namespace named regex_constants. Like placeholders, 
which we used with bind (§ 10.3.4, p. 399), regex_constants is a namespace defined inside the std namespace. 
To use a name from regex_constants, we must qualify that name with the names of both namespaces:
using std::regex_constants::format_no_copy;
This declaration says that when our code uses format_no_copy, 
we want the object of that name from the namespace std::regex_constants. 
We can instead provide the alternative form of using that we will cover in § 18.2.2 (p. 792):
using namespace std::regex_constants;


-> NOTE: Match Flags
Defined in regex_constants::match_flag_type
match_default: Equivalent to format_default
match_not_bol: Don’t treat the first character as the beginning of the line
match_not_eol: Don’t treat the last character as the end of the line
match_not_bow: Don’t treat the first character as the beginning of a word
match_not_eow: Don’t treat the last character as the end of a word
match_any: If there is more than one match, any match can be returned
match_not_null: Don’t match an empty sequence
match_continuous: The match must begin with the first character in the input
match_prev_avail: The input sequence has characters before the first
format_default: Replacement string uses the ECMAScript rules
format_sed Replacement: string uses the rules from POSIX sed
format_no_copy: Don’t output the unmatched parts of the input
format_first_only: Replace only the first occurrence


-> NOTE: Using Format Flags
By default, regex_replace outputs its entire input sequence. 
The parts that don’t match the regular expression are output without change; 
the parts that do match are formatted as indicated by the given format string. 
We can change this default behavior by specifying format_no_copy in the call to regex_replace:
// generate just the phone numbers: use a new format string
string fmt2 = "$2.$5.$7 "; // put space after the last number as a separator
// tell regex_replace to copy only the text that it replaces
cout << regex_replace(s, r, fmt2, format_no_copy) << endl;

Given the same input, this version of the program generates
201.555.0168 862.555.0123
973.555.0130
609.555.0132 201.555.0175 800.555.0100



-> NOTE: Random Numbers
Programs often need a source of random numbers. 
Prior to the new standard, both C and C++ relied on a simple C library function named rand. 
That function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system-dependent maximum value that is at least 32767.
The rand function has several problems: 
Many, if not most, programs need random numbers in a different range from the one produced by rand. 
Some applications require random floating-point numbers. 
Some programs need numbers that reflect a nonuniform distribution. 
Programmers often introduce nonrandomness when they try to transform the range, type, or distribution of the numbers generated by rand.

The random-number library, defined in the random header, solves these problems through a set of cooperating classes: 
random-number engines and randomnumber distribution classes. 
These clases are described in Table 17.14. An engine
generates a sequence of unsigned random numbers. 
A distribution uses an engine to generate random numbers of a specified type, 
in a given range, distributed according to a particular probability distribution.


-> NOTE: C++ programs should not use the library rand function. 
Instead, they should use the default_random_engine along with an appropriate distribution object.


-> NOTE: Random-Number Engines and Distribution
The random-number engines are function-object classes (§ 14.8, p. 571) 
that define a call operator that takes no arguments and returns a random unsigned number.
We can generate raw random numbers by calling an object of a random-number engine type:
default_random_engine e; // generates random unsigned integers
for (size_t i = 0; i < 10; ++i)
// e() "calls" the object to produce the next random number
cout << e() << " ";
On our system, this program generates:
16807 282475249 1622650073 984943658 1144108930 470211272 ...
Here, we defined an object named e that has type default_random_engine.
Inside the for, we call the object e to obtain the next random number.

The library defines several random-number engines that differ in terms of their performance and quality of randomness. 
Each compiler designates one of these engines as the default_random_engine type. 
This type is intended to be the engine with the most generally useful properties. 
Table 17.15 lists the engine operations and the engine types defined by the standard are listed in § A.3.2 (p. 884).
For most purposes, the output of an engine is not directly usable, 
which is why we described them earlier as raw random numbers. 
The problem is that the numbers usually span a range that differs fromthe one we need. 
Correctly transforming the range of a random number is surprisingly hard.


-> NOTE: Distribution Types and Engines
To get a number in a specified range, we use an object of a distribution type:
// uniformly distributed from 0 to 9 inclusive
uniform_int_distribution<unsigned> u(0,9);
default_random_engine e; // generates unsigned random integers
for (size_t i = 0; i < 10; ++i)
// u uses e as a source of numbers
// each call returns a uniformly distributed value in the specified range
cout << u(e) << " ";
This code produces output such as
0 1 7 4 5 2 0 6 6 9
Here we define u as a uniform_int_distribution<unsigned>. 
That type generates uniformly distributed unsigned values. 
When we define an object of this type, we can supply the minimum and maximum values we want. 
In this program, u(0,9) says that we want numbers to be in the range 0 to 9 inclusive.
The randomnumber distributions use inclusive ranges so that we can obtain every possible value of the given integral type.
Like the engine types, the distribution types are also function-object classes.
The distribution types define a call operator that takes a random-number engine as its argument. 
The distribution object uses its engine argument to produce random numbers 
that the distribution object maps to the specified distribution.
Note that we pass the engine object itself, u(e). 
Had we written the call as u(e()), we would have tried to pass the next value generated by e to u, 
which would be a compile-time error. 
We pass the engine, not the next result of the engine, because some distributions may need to call the engine more than once.


-> NOTE: When we refer to a random-number generator, we mean the combination of a distribution object with an engine.


-> NOTE: Comparing Random Engines and the rand Function
For readers familiar with the C library rand function, 
it is worth noting that the output of calling a default_random_engine object is similar to the output of rand. 
Engines deliver unsigned integers in a system-defined range. 
The range for rand is 0 to RAND_MAX. 
The range for an engine type is returned by calling the min and max members on an object of that type:
cout << "min: " << e.min() << " max: " << e.max() << endl;
On our system this program produces the following output:
min: 1 max: 2147483646


-> NOTE: Random Number Engine Operations
1) Engine e; 
Default constructor; uses the default seed for the engine type
2) Engine e(s); 
Uses the integral value s as the seed
3) e.seed(s) 
Reset the state of the engine using the seed s
4) e.min() or e.max()
The smallest and largest numbers this generator will generate
5) Engine::result_type 
The unsigned integral type this engine generates
6) e.discard(u) 
Advance the engine by u steps; u has type unsigned long long


-> NOTE: Engines Generate a Sequence of Numbers
Random number generators have one property that often confuses new users:
Even though the numbers that are generated appear to be random, 
a given generator returns the same sequence of numbers each time it is run. 
The fact that the sequence is unchanging is very helpful during testing. 
On the other hand, programs that use random-number generators have to take this fact into account.

As one example, assume we need a function that will generate a vector of 100 
random integers uniformly distributed in the range from 0 to 9. 
We might think we’d write this function as follows:
// almost surely the wrong way to generate a vector of random integers
// output from this function will be the same 100 numbers on every call!
vector<unsigned> bad_randVec()
{
default_random_engine e;
uniform_int_distribution<unsigned> u(0,9);
vector<unsigned> ret;
for (size_t i = 0; i < 100; ++i)
ret.push_back(u(e));
return ret;
}

However, this function will return the same vector every time it is called:
vector<unsigned> v1(bad_randVec());
vector<unsigned> v2(bad_randVec());
// will print equal
cout << ((v1 == v2) ? "equal" : "not equal") << endl;

This code will print equal because the vectors v1 and v2 have the same values.
The right way to write our function is to make the engine and associated distribution
objects static (§ 6.1.1, p. 205):
// returns a vector of 100 uniformly distributed random numbers
vector<unsigned> good_randVec()
{
// because engines and distributions retain state, they usually should be
// defined as static so that new numbers are generated on each call
static default_random_engine e;
static uniform_int_distribution<unsigned> u(0,9);
vector<unsigned> ret;
for (size_t i = 0; i < 100; ++i)
ret.push_back(u(e));
return ret;
}

Because e and u are static, they will hold their state across calls to the function.
The first call will use the first 100 random numbers from the sequence u(e) generates, 
the second call will get the next 100, and so on.


-> NOTE: A given random-number generator always produces the same sequence of numbers. 
A function with a local random-number generator should make that generator (both the engine and distribution objects) static.
Otherwise, the function will generate the identical sequence on each call.


-> NOTE: Seeding a Generator
The fact that a generator returns the same sequence of numbers is helpful during
debugging. However, once our programis tested, we often want to cause each run
of the programto generate different random results. We do so by providing a seed.
A seed is a value that an engine can use to cause it to start generating numbers at
a new point in its sequence.
We can seed an engine in one of two ways: We can provide the seed when we
create an engine object, or we can call the engine’s seed member:

default_random_engine e1; // uses the default seed
default_random_engine e2(2147483646); // use the given seed value
// e3 and e4 will generate the same sequence because they use the same seed
default_random_engine e3; // uses the default seed value
e3.seed(32767); // call seed to set a new seed value
default_random_engine e4(32767); // set the seed value to 32767
for (size_t i = 0; i != 100; ++i) {
if (e1() == e2())
cout << "unseeded match at iteration: " << i << endl;
if (e3() != e4())
cout << "seeded differs at iteration: " << i << endl;
}

Here we define four engines. The first two, e1 and e2, have different seeds and should generate different sequences. 
The second two, e3 and e4, have the same seed value. 
These two objects will generate the same sequence.
Picking a good seed, like most things about generating good random numbers, is surprisingly hard. 
Perhaps the most common approach is to call the system time function. 
This function, defined in the ctime header, returns the number of seconds since a given epoch. 
The time function takes a single parameter that is a pointer to a structure into which to write the time. 
If that pointer is null, the function just returns the time:
default_random_engine e1(time(0)); // a somewhat random seed
Because time returns time as the number of seconds, this seed is useful only for
applications that generate the seed at second-level, or longer, intervals.


-> NOTE: Using time as a seed usually doesn’t work if the program is run repeatedly as part of an automated process; 
it might wind up with the same seed several times.


-> NOTE: Other Kinds of Distributions
The engines produce unsigned numbers, and each number in the engine’s range has the same likelihood of being generated. 
Applications often need numbers of different types or distributions. 
The library handles both these needs by defining different distributions that, 
when used with an engine, produce the desired results.
Table 17.16 (overleaf) lists the operations supported by the distribution types.


-> NOTE: Generating Random Real Numbers
Programs often need a source of random floating-point values. 
In particular, programs frequently need random numbers between zero and one.
The most common, but incorrect, way to obtain a random floating-point from rand is to divide the result of rand() by RAND_MAX, 
which is a system-defined upper limit that is the largest random number that rand can return. 
This technique is incorrect because random integers usually have less precision than floating point numbers, 
in which case there are some floating-point values that will never be produced as output.

With the new library facilities, we can easily obtain a floating-point random number. 
We define an object of type uniform_real_distribution and let the library handle mapping random integers to random floating-point numbers. 
As we did for uniform_int_distribution, we specify the minimum and maximum values when we define the object:
default_random_engine e; // generates unsigned random integers
// uniformly distributed from 0 to 1 inclusive
uniform_real_distribution<double> u(0,1);
for (size_t i = 0; i < 10; ++i)
cout << u(e) << " ";
This code is nearly identical to the previous program that generated unsigned values. 
However, because we used a different distribution type, this version generates different results:
0.131538 0.45865 0.218959 0.678865 0.934693 0.519416 ...


-> NOTE: Using the Distribution’s Default Result Type
With one exception, which we’ll cover in § 17.4.2 (p. 752), 
the distribution types are templates that have a single template type parameter 
that represents the type of the numbers that the distribution generates. 
These types always generate either a floating-point type or an integral type.

Each distribution template has a default template argument (§ 16.1.3, p. 670).
The distribution types that generate floating-point values generate double by default.
Distributions that generate integral results use int as their default. 
Because the distribution types have only one template parameter,
when we want to use the default we must remember to follow the template’s name with 
empty angle brackets to signify that we want the default (§ 16.1.3, p. 671):
// empty <> signify we want to use the default result type
uniform_real_distribution<> u(0,1); // generates double by default


-> NOTE: Generating Numbers That Are Not Uniformly Distributed
In addition to correctly generating numbers in a specified range, 
another advantage of the new library is that we can obtain numbers that are nonuniformly distributed.
Indeed, the library defines 20 distribution types! 
These types are listed in § A.3 (p. 882).
As an example, we’ll generate a series of normally distributed values and plot the resulting distribution. 
Because normal_distribution generates floating point numbers, 
our program will use the lround function fromthe cmath header to round each result to its nearest integer. 
We’ll generate 200 numbers centered around a mean of 4 with a standard deviation of 1.5. 
Because we’re using a normal distribution, we can expect all 
but about 1 percent of the generated numbers to be in the range from 0 to 8, inclusive. 
Our program will count how many values appear that map to the integers in this range:
default_random_engine e; // generates random integers
normal_distribution<> n(4,1.5); // mean 4, standard deviation 1.5
vector<unsigned> vals(9); // nine elements each 0
for (size_t i = 0; i != 200; ++i) {
unsigned v = lround(n(e)); // round to the nearest integer
if (v < vals.size()) // if this result is in range
++vals[v]; // count how often each number appears
}
for (size_t j = 0; j != vals.size(); ++j)
cout << j << ": " << string(vals[j], ’*’) << endl;

We start by defining our random generator objects and a vector named vals.
We’ll use vals to count how often each number in the range 0 . . . 9 occurs. 
Unlike most of our programs that use vector, we allocate vals at its desired size. 
By doing so, we start out with each element initialized to 0.
Inside the for loop, we call lround(n(e)) to round the value returned by n(e) to the nearest integer. 
Having obtained the integer that corresponds to our floating-point random number, 
we use that number to index our vector of counters.
Because n(e) can produce a number outside the range 0 to 9, 
we check that the number we got is in range before using it to index vals. 
If the number is in range, we increment the associated counter.
When the loop completes, we print the contents of vals, which will generate output such as
0: ***
1: ********
2: ********************
3: **************************************
4: **********************************************************
5: ******************************************
6: ***********************
7: *******
8: *
Here we print a string with as many asterisks as the count of the times 
the current value was returned by our random-number generator. 
Note that this figure is not perfectly symmetrical. 
If it were, that symmetry should give us reason to suspect the quality of our random-number generator.


-> NOTE: The bernoulli_distribution Class
We noted that there was one distribution that does not take a template parameter.
That distribution is the bernoulli_distribution, which is an ordinary class, not a template. 
This distribution always returns a bool value. 
It returns true with a given probability. By default that probability is .5.

As an example of this kind of distribution, we might have a program that plays a game with a user. 
To play the game, one of the players—either the user or the program—has to go first. 
We could use a uniform_int_distribution object with a range of 0 to 1 to select the first player. 
Alternatively, we can use a Bernoulli distribution to make this choice. 
Assuming that we have a function named play that plays the game, 
we might have a loop such as the following to interact with the user:
string resp;
default_random_engine e; // e has state, so it must be outside the loop!
bernoulli_distribution b; // 50/50 odds by default
do {
bool first = b(e); // if true, the program will go first
cout << (first ? "We go first"
: "You get to go first") << endl;
// play the game passing the indicator of who goes first
cout << ((play(first)) ? "sorry, you lost"
: "congrats, you won") << endl;
cout << "play again? Enter ’yes’ or ’no’" << endl;
} while (cin >> resp && resp[0] == ’y’);
We use a do while (§ 5.4.4, p. 189) to repeatedly prompt the user to play.

One reason to use a bernoulli_distribution in this program is 
that doing so lets us give the program a better chance of going first:
bernoulli_distribution b(.55); // give the house a slight edge
If we use this definition for b, then the program has 55/45 odds of going first.


-> NOTE: Because engines return the same sequence of numbers (§ 17.4.1, p. 747),
it is essential that we declare engines outside of loops. 
Otherwise, we’d create a new engine on each iteration and generate the same values on each iteration. 
Similarly, distributions may retain state and should also be defined outside loops.
