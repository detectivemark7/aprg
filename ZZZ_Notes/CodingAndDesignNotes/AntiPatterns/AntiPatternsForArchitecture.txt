Note: This is taken from the book: [Antipatterns - Refactoring Software, Architectures, and Projects in Crisis]


Architecture AntiPatterns Summaries

The following AntiPatterns focus on some common problems and mistakes in the creation, implementation, and management of architecture. 
Lack of commonality between systems in terms of design and technology is the cause of much frustration and the inability to provide interoperability and reuse between related systems. 
Improved enterprise architecture planning is used to align system developments.

-> Autogenerated Stovepipe 
---> Description: 
-----> Automatic generation of interfaces for distributed, large−scale systems from fine−grain header files.
---> Solution: 
-----> Separate the architecture−level framework design from the subsystem−specific design to manage complexity.
---> Notes:
-----> This AntiPattern occurs when migrating an existing software system to a distributed infrastructure. 
-----> An Autogenerated Stovepipe arises when converting the existing software interfaces to distributed interfaces. 
-----> If the same design is used for distributed computing, a number of problems emerge.

-> Stovepipe Enterprise 
---> Description: 
-----> Uncoordinated software architectures lead to lack of adaptability, reuse, and interoperability.
---> Solution: 
-----> Use enterprise architecture planning to coordinate system conventions, reuse, and interoperability.
---> Notes:
-----> A Stovepipe System is characterized by a software structure that inhibits change. 
-----> The refactored solution describes how to abstract subsystem and components to achieve an improved system structure. 
-----> The Stovepipe Enterprise AntiPattern is characterized by a lack of coordination and planning across a set of systems.

-> Jumble 
---> Description: 
-----> Interface designs are an unfactored mixture of horizontal and vertical elements, which necessitates frequent interface changes and an inability to reuse.
---> Solution: 
-----> Partition architectural designs with respect to horizontal, vertical, and metadata elements.
---> Notes:
-----> When horizontal and vertical design elements are intermixed, an unstable architecture results. 
-----> The intermingling of horizontal and vertical design elements limits the reusability and robustness of the architecture and the system software components.

-> Stovepipe System 
---> Description: 
-----> Ad hoc integration solutions and absence of abstraction result in brittle, unmaintainable architectures.
---> Solution: 
-----> Use of abstraction, subsystem facades, and metadata to generate adaptable systems.
---> Notes:
-----> Subsystems are integrated in an ad hoc manner using multiple integration strategies and mechanisms, and all are integrated point to point. 
-----> The integration approach for each pair of subsystems is not easily leveraged toward that of other subsystems. 
-----> The Stovepipe System AntiPattern is the single−system analogy of Stovepipe Enterprise, and is concerned with how the subsystems are coordinated within a single system.

-> Cover Your Assets 
---> Description: 
-----> Document−driven software processes often employ authors who list alternatives instead of making decisions.
---> Solution: 
-----> Establish clear purposes and guidelines for documentation tasks; inspect the results for the value of documented decisions.
---> Notes:
-----> Document−driven software processes often produce less−than−useful requirements and specifications because the authors evade making important decisions. 
-----> In order to avoid making a mistake, the authors take a safer course and elaborate upon alternatives.

-> Vendor Lock−In 
---> Description: 
-----> Proprietary, product−dependent architectures do not manage complexity and lead to out−of−control architecture and maintenance costs.
---> Solution: 
-----> Install an isolation layer between product−dependent interfaces and the majority of application software to enable management of complexity and architecture.
---> Notes:
-----> Vendor Lock−In occurs in systems that are highly dependent upon proprietary architectures. 
-----> The use of architectural isolation layers can provide independence from vendor−specific solutions.

-> Wolf Ticket 
---> Description: 
-----> A technology is assumed to have positive qualities due to its open systems packaging or claimed standards compliance.
-----> Few standards have test suites (less than 6 percent), and few products are actually tested for conformance.
---> Solution: 
-----> Discover the truth behind the claims; question authority; assume nothing. 
-----> Shift the burden of proof to the marketing organization. 
-----> Talk directly to the technical product experts and developers.
---> Notes:
-----> A Wolf Ticket is a product that claims openness and conformance to standards that have no enforceable meaning. 
-----> The products are delivered with proprietary interfaces that may vary significantly from the published standard.

-> Architecture by Implication
---> Description: 
-----> System developed without a documented architecture, often due to overconfidence based on recent success.
---> Solution: 
-----> Define architecture in terms of by Implication multiple viewpoints corresponding to system stakeholders.
---> Notes:
-----> Management of risk in follow−on system development is often overlooked due to overconfidence and recent system successes. 
-----> A general architecture approach that is tailored to each application system can help identify unique requirements and risk areas.

-> Warm Bodies 
---> Description: 
-----> Large software project teams make for ineffective organizations and overruns. Heroic programmers are essential.
---> Solution: 
-----> Plan small projects (four people in four months); they are much more likely to produce software success.
---> Notes:
-----> Software projects are often staffed with programmers with widely varying skills and productivity levels. 
-----> Many of these people may be assigned to meet staff size objectives (so−called “warm bodies”). 
-----> Skilled programmers are essential to the success of a software project. 
-----> So−called heroic programmers are exceptionally productive, but as few as 1 in 20 have this talent. 
-----> They produce an order of magnitude more working software than an average programmer.

-> Design by Committee
---> Description: 
-----> Committee designs are overly complex and lack a common architectural vision.
---> Solution: 
-----> Assign proper facilitation and software development roles for more effective committee−based processes.
---> Notes:
-----> The classic AntiPattern from standards bodies, Design by Committee creates overly complex architectures that lack coherence. 
-----> Clarification of architectural roles and improved process facilitation can refactor bad meeting processes into highly productive events.

-> Swiss Army Knife 
---> Description: 
-----> Overdesign of interfaces results in objects with numerous methods that attempt to anticipate every possible need. 
-----> This leads to designs that are difficult to comprehend, utilize, and debug, as well as implementation dependencies.
---> Solution: 
-----> Define a clear purpose for the component and properly abstract the interface to manage complexity.
---> Notes:
-----> A Swiss Army Knife is an excessively complex class interface. 
-----> The designer attempts to provide for all possible uses of the class. 
-----> In the attempt, he or she adds a large number of interface signatures in a futile attempt to meet all possible needs.

-> Reinvent the Wheel
---> Description: 
-----> Legacy systems with overlapping functionality don’t interoperate. Every system is built in isolation.
---> Solution: 
-----> Use architecture mining and “best of breed” generalization to define a common interface; then use object wrapping to integrate.
---> Notes:
-----> The pervasive lack of technology transfer between software projects leads to substantial reinvention. 
-----> Design knowledge buried in legacy assets can be leveraged to reduce time−to−market, cost, and risk.

-> The Grand Old Duke of York
---> Description: 
-----> Four out of five developers cannot define good abstractions; this leads to excess complexity.
---> Solution: 
-----> Designate project team architects who are abstractionists—that is, who possess the architecture instinct.
---> Notes:
-----> Egalitarian software processes often ignore people’s talents to the detriment of the project. 
-----> Programming skill does not equate to skill in defining abstractions. 
-----> There appear to be two distinct groups involved in software development: abstractionists and their counterparts the implementationists.




Development AntiPattern Discussion




-> The Autogenerated Stovepipe

---> AntiPattern Problem
This AntiPattern occurs when migrating an existing software system to a distributed infrastructure. 
An Autogenerated Stovepipe arises when converting the existing software interfaces to distributed interfaces. 
If the same design is used for distributed computing, a number of problems emerge. 
For example, the existing interfaces may be using fine−grain operations to transfer information that may be inefficient in a distributed environment. 
Preexisting interfaces are usually implementation−specific, and will cause subsystem interdependencies when used in a larger−scale distributed system. 
Local operations often make various assumptions about location, including address space and access to the local file system. 
Excess complexity can arise when multiple existing interfaces are exposed across a larger−scale distributed system.

---> Refactored Solution
When designing distributed interfaces for existing software, the interfaces should be reengineered. 
A separate, larger−grained object model should be considered for the distributed interfaces. 
The interoperability functionality used by multiple subsystems should be the design center of the new interfaces. 
Design that is independent of particular subsystems can be achieved through architecture mining. 
The stability of the new interfaces is very important, given that separately compiled software will be dependent upon these new designs.




-> Stovepipe Enterprise

AntiPattern Name: Stovepipe Enterprise
Also Known As: Islands of Automation
Most Frequent Scale: Enterprise
Refactored Solution Name: Enterprise Architecture Planning
Refactored Solution Type: Process
Root Causes: Haste, Apathy, Narrow−Mindedness
Unbalanced Forces: Management of Change, Resources, Technology Transfer
Anecdotal Evidence: “Can I have my own island (of automation)?”
“We’re unique!”

---> Background
Stovepipe is a popular term used to describe software systems with ad hoc architectures. 
It is a metaphor to the exhaust pipes of wood−burning stoves, so−called pot−bellied stoves.
Since wood burning produces corrosive substances that erode metal, a stovepipe must be constantly maintained and repaired in order to avoid leakage. 
Often, the pipes are repaired with any materials at hand, thus wood−burning stovepipes quickly become a hodgepodge of ad hoc repairs—hence, the reference is used to describe the ad hoc structure of many software systems.

---> General Form
Multiple systems within an enterprise are designed independently at every level. 
Lack of commonality inhibits interoperability between systems, prevents reuse, and drives up cost.
In addition, reinvented system architecture and services lack quality structure supporting adaptability.

At the lowest level are the standards and guidelines. 
These work like architectural building codes and zoning laws across enterprise systems. 
The next level up in the hierarchy is the operating environment [Mowbray 97c], which comprises infrastructure and object services.
The top two layers include the value−added functional services and the mission−specific services. 
By selecting and defining all of these technologies independently, S
Stovepipe Enterprises “create islands of automation,” isolated from the rest of the enterprise.

---> Symptoms And Consequences
• Incompatible terminology, approaches, and technology between enterprise systems.
• Brittle, monolithic system architectures and undocumented architectures.
• Inability to extend systems to support business needs.
• Incorrect use of a technology standard.
• Lack of software reuse between enterprise systems.
• Lack of interoperability between enterprise systems.
• Inability of systems to interoperate even when using the same standards.
• Excessive maintenance costs due to changing business requirements; the need to extend the system to incorporate new products and technologies.
• Employee turnover, which causes project discontinuity and maintenance problems.

---> Typical Causes
• Lack of an enterprise technology strategy, specifically:
Lack of a standard reference model [Mowbray 97a].
Lack of system profiles [Mowbray 97a].
• Lack of incentive for cooperation across system developments: Competing business areas and executives.
• Lack of communication between system development projects.
• Lack of knowledge of the technology standard being used.
• Absence of horizontal interfaces in system integration solutions.

---> Known Exceptions
The Stovepipe Enterprise AntiPattern is unacceptable for new systems at an enterprise level in this day and age, 
particularly when most companies are facing the need to extend their business systems. 
However, when companies grow by takeover or merger, the Stovepipe AntiPattern is likely to occur; 
in which case, wrapping some systems can be an intermediate solution.

Another exception is when a common service layer is implemented across the enterprise systems. 
This is usually a manifestation of the Vendor Lock−In AntiPattern (discussed later in this chapter). 
These systems have a common horizontal component; for example, in banking, this is often true of databases such as DB2 and Oracle.

---> Refactored Solution
Coordination of technologies at several levels is essential to avoid a Stovepipe Enterprise. 
Initially, the selection of standards can be coordinated through the definition of a standards reference model [Mowbray 97a]. 
The standards reference model defines the common standards and a migration direction for enterprise systems. 
The establishment of a common operating environment coordinates the selection of products and controls the configuration of product versions. 
Defining system profiles that coordinate the utilization of products and standards is essential to assure standards benefits, reuse, and interoperability. 
At least one system profile should define usage conventions across systems.

Through much experience, large enterprises have worked out some useful conventions for the definition of object−oriented architectures that can apply to many organizations. 
A key challenge of large−scale architecture is to define detailed interoperability conventions across systems while addressing technology strategy and requirements. 
For very large enterprises, experience has shown that four requirements models and four specification models are necessary to properly scope and resolve interoperability challenges.

The requirements models include:
1. Open Systems Reference Model.
2. Technology Profile.
3. Operating Environment.
4. System Requirements Profile.

The specification models include:
1. Enterprise Architectures.
2. Computational Facilities Architecture.
3. Interoperability Specifications.
4. Development Profile.

---> Example
There are two Stovepipe Systems in the same enterprise. 
While similar in many ways, these systems lack commonality; they use different database products, different office automation tools, have different software interfaces, and use unique graphical user interfaces (GUIs). 
The potential commonalities between these systems was not recognized and therefore not utilized by the designers and developers.

To resolve the AntiPattern, the enterprise starts by defining a standards reference model.
This model, selects some baseline standards for interchange across all systems. 
The next step is to choose products for an operating environment. 
In this case, both database products are selected, but only one of the office automation tools. 
This is the supported direction for future migration of the enterprise. 
The enterprise can facilitate this operating environment through enterprise product licensing, training, and technical support.
This level also defines profiles for use of these technologies and common interfaces with reusable service implementations. 
The GUI applications comprise the remaining system−specific implementations.

---> Related Solutions
Reinvent the Wheel is an AntiPattern that comprises a subset of the overall problem of Stovepipe Systems. 
Reinvent the Wheel is focused upon the lack of maturity of designs and implementations caused by the lack of communication between development projects.
Standards reference model, operating environment, and profile are solutions from the book CORBA Design Patterns [Mowbray 97a]. 
They are all important components in the solution of Stovepipe Enterprises.

Examples of standards reference models include the IEEE POSIX.0, NIST Application Portability Profile (APP), 
and volume 7 of the U.S. Department of Defense’s Technical Architecture Framework for Information Management (TAFIM).
Examples of common interfaces and profiles can be found on www−ismc.itsi.disa.mil/ciiwg/ciiwg.html.

---> Applicability To Other Viewpoints And Scales
Stovepipe Enterprises are often the consequence of organizational boundaries imposed by management. 
Organizational structures that inhibit communication and the transfer of technology produce the kind of disconnects that result in the lack of coordination that characterizes Stovepipe Enterprises. 
The impact of the Stovepipe Enterprise AntiPattern on management is that every system development involves significant but unnecessary risk and cost. 
Since the systems do not interoperate and are difficult to integrate, the overall organizational effectiveness is impacted. 
The organization’s ability to accommodate changing business requirements is greatly impeded by the Stovepipe Enterprise. 
An emerging requirement for enterprises is called agile systems, which are able to accommodate changes in business processes because they already support interoperability across most or all enterprise systems.

Developers, too, are affected by the Stovepipe Enterprise because they are often asked to reate brittle solutions to bridge independently architected systems. 
These interfaces are difficult to maintain and reuse, and the absence of technology coordination makes the creation of these interfaces quite challenging. 
Often, combinations of middleware solutions and commercial products (database engines) must be bridged in order to achieve interoperability.




-> Jumble

---> AntiPattern Problem
When horizontal and vertical design elements are intermixed, an unstable architecture results. 
Vertical design elements are dependent upon the individual application and specific software implementations. 
Horizontal design elements are those that are common across applications and specific implementations. 
By default, the two are mixed together by developers and architects. 
But doing this limits the reusability and robustness of the architecture and the system software components. 
Vertical elements cause software dependencies that limit extensibility and reuse. 
Intermingling makes all the software designs less stable and reusable.

---> Refactored Solution
The first step is to identify the horizontal design elements and delegate them to a separate architecture layer. 
Then use the horizontal elements to capture the common interoperability functionality in the architecture. 
For example, the horizontal elements are abstractions of the specific subsystem implementations:
1. Add vertical elements as extensions for specialized functionality and for performance.
2. Incorporate metadata into the architecture.
3. Trade off the static elements of the design (horizontal and vertical) with the dynamic elements (metadata).
Proper balance of horizontal, vertical, and metadata elements in an architecture leads to well−structured, extensible, reusable software.

---> Background
It takes some time to fully understand the meaning and implications of horizontal and vertical design elements. 
These topics are explored further in our companion book, CORBA Design Patterns [Mowbray 97c]. 
In particular, the Horizontal−Vertical−Metadata (HVM) pattern and related CORBA design patterns establish key principles for software architecture design.
The Jumble AntiPattern describes the most common misuse of these principles.





-> Stovepipe System

AntiPattern Name: Stovepipe System
Also Known As: Legacy System, Uncle Sam Special, Ad Hoc Integration
Most Frequent Scale: System
Refactored Solution Name: Architecture Framework
Refactored Solution Type: Software
Root Causes: Haste, Avarice, Ignorance, Sloth
Unbalanced Forces: Management of Complexity, Change
Anecdotal Evidence: “The software project is way over−budget; it has slipped its schedule repeatedly; 
my users still don’t get the expected features; 
and I can’t modify the system. 
Every component is a stovepipe.”

---> Background
Stovepipe System is a widely used derogatory name for legacy software with undesirable qualities. 
In this AntiPattern, we attribute the cause of these negative qualities to the internal structure of the system. 
An improved system structure enables the evolution of the legacy system to meet new business needs and incorporate new technologies seamlessly. 
By applying the recommended solution, the system can gain new capabilities for adaptability that are uncharacteristic of Stovepipe Systems.

---> General Form
The Stovepipe System AntiPattern is the single−system analogy of Stovepipe Enterprise, which involves a lack of coordination and planning across a set of systems. 
The Stovepipe System AntiPattern addresses how the subsystems are coordinated within a single system.
The key problem in this AntiPattern is the lack of common subsystem abstractions, whereas in a Stovepipe Enterprise, the key problem is the absence of common multisystem conventions.
Subsystems are integrated in an ad hoc manner using multiple integration strategies and mechanisms. 
All subsystems are integrated point to point, as shown in Figure 6.7, thus the integration approach for each pair of subsystems is not easily leveraged toward that of other subsystems. 
Furthermore, the system implementation is brittle because there are many implicit dependencies upon system configuration, installation details, and system state. 
The system is difficult to extend, and extensions add additional point−to−point integration links.
As each new capability and alteration is integrated, system complexity increases, throughout the life cycle of the stovepipe system; subsequently, system extension and maintenance become increasingly intractable.

---> Symptoms And Consequences
• Large semantic gap between architecture documentation and implemented software; documentation does not correspond to system implementation.
• Architects are unfamiliar with key aspects of integration solution.
• Project is over−budget and has slipped its schedule for no obvious reason.
• Requirements changes are costly to implement, and system maintenance generates surprising costs.
• System may comply with most paper requirements but does not meet user expectations.
• Users must invent workarounds to cope with limitations of the system.
• Complex system and client installation procedures are followed that defy attempts to automate.
• Interoperability with other systems is not possible, and there is an inability to support integrated system management and intersystem security capabilities.
• Changes to the systems become increasingly difficult.
• System modifications become increasingly likely to introduce new serious bugs.

---> Typical Causes
• Multiple infrastructure mechanisms used to integrate subsystems; absence of a common mechanism makes the architecture difficult to describe and modify.
• Lack of abstraction; all interfaces are unique to each subsystem.
• Insufficient use of metadata; metadata is not available to support system extensions and reconfigurations without software changes.
• Tight coupling between implemented classes requires excessive client code that is service−specific.
• Lack of architectural vision.

---> Known Exceptions
Research and development software production often institute the Stovepipe System AntiPattern to achieve a rapid solution. 
This is perfectly acceptable for prototypes and mockups; 
and sometimes, insufficient knowledge about a domain may require a Stovepipe System to be initially developed to gain domain information either for building a more robust system 
or for evolving the initial system into an improved version [Foote 97]. 
Or, the choice to use a vendor’s product and not reinvent the wheel can lead to both the Stovepipe System AntiPattern and the Vendor Lock−In AntiPattern.

---> Refactored Solution
The refactored solution to the Stovepipe System AntiPattern is a component architecture that provides for flexible substitution of software modules. 
Subsystems are modeled abstractly so that there are many fewer exposed interfaces than there are subsystem implementations.
The substitution can be both static (compile−time component replacement) and dynamic (run−time dynamic binding). 
The key to defining the component interfaces is to discover the appropriate abstractions. 
The subsystem abstractions model the interoperability needs of the system without exposing unnecessary differences between subsystems and implementation−specific details, as shown in Figure 6.8.
In order to define a component architecture, you should choose a base level of functionality that the majority of applications will support. 
In general, that level should be low and focus upon a single aspect of interoperability, such as data interchange or conversion. 
Then define a set of system interfaces that support this base level of functionality; we recommend using ISO IDL. 
Most services have an additional interface to express finer−grained functional needs so the component interface should be small.
Having a base level of component services available to all clients in the domain encourages the development of thin clients that work well with existing and future services, without modification. 
By thin clients, we mean clients that do not require detailed knowledge of the services and architecture of the system; 
a framework may support and simplify their access to complex services. 
Having several plug−compatible implementations available increases the robustness of clients, as they potentially have many options in fulfilling their service request.

Applications will have clients that are written to more specialized (vertical) interfaces. 
Vertical clients should remain unaffected by the addition of the new component interfaces. 
Clients that require only the base level of functionality can be written to the horizontal interfaces, which should be more stable and easily supported by new or other existing applications. 
The horizontal interface should hide, via abstraction, all the lower−level details of a component and provide only the base−level functionality. 
The client should be written to handle whatever data types are indicated by the interface in order to support any future interchange of the horizontal component implementations. 
For example, if an “any” is returned, the client should be capable of handling all types that the “any” may contain. 
Admittedly, for CORBA implementations that don’t support the transfer of new user−defined types at run time, type management may have to occur at the horizontal level; 
specifically, it may be necessary to convert vertical types into horizontal types that are known at compile time.
Incorporation of metadata into the component architecture is key to service discovery and service discrimination. 
A fundamental level of metadata support is through naming and trading services [Mowbray 97c]. 
Naming services enable the discovery of known objects; a trading service lists the available services and their properties for discovery by clients.
Interoperable naming services are extended to incorporate some trading capabilities. 
More extensive use of metadata is usually required for enhanced decoupling of clients from services. 
For example, schema metadata for database services helps clients to adapt alternative schema and schema changes [Mowbray 95].

---> Example
Figure 6.9 is a representation of a typical stovepipe system. 
There are three client subsystems and six service subsystems. 
Each subsystem has a unique software interface, and each subsystem instance is modeled as a class in the class diagram. 
When the system is constructed, unique interface software for each client corresponds to each of the integrated subsystems. 
If additional subsystems are added or substituted, the clients must be modified with additional code that integrates new unique interfaces.
The refactored solution to this example considers the common abstractions between the subsystems (Figure 6.10). 
Since there are two services of each type, it is possible for each model to have one or more service interface in common. 
Then each particular device or service can be wrapped to support the common interface abstraction. 
If additional devices are added to the system from these abstract subsystem categories, they can be integrated transparently to the existing system software. 
The addition of a trader service adds the ability to discover and discriminate between the abstracted services.

---> Related Solutions
The Stovepipe Enterprise AntiPattern describes how stovepipe practices are promulgated on an enterprise scale. 
Note that Stovepipe Enterprise addresses a multisystem problem, which involves a larger scale of architecture than a single system.

---> Applicability To Other Viewpoints And Scales
The management consequences of Stovepipe Systems are: increased risk, bigger budget, and longer time to market. 
And because complexity increases throughout the life cycle of the system, the management problems magnify as development progresses. 
Eventually, the risks of system modification outweigh the potential benefits, and the Stovepipe System ceases to adapt to new business needs; 
the organization’s business processes are frozen by the Stovepipe System. 
Since the architecture information is buried in the implementation, employee turnover in the software maintenance staff can lead to a total loss of capability to modify or maintain the system.
For developers, Stovepipe Systems mean they must spend more time on system discovery and testing. 
In early development, developers have a great deal of freedom to choose implementation strategies with minimal architectural guidance, 
but as the complexity of the stovepipe interfaces supercedes the documentation, the system becomes increasingly complex and brittle. 
Development in a stovepipe environment resembles walking through a mine field. 
Every decision involves guesswork, uncertainty, and experiments. 
Developer decisions have high−risk consequences for the business, and often lead to repeated crises.

“Safe upon solid rock the ugly house stands: Come and see my shining palace built upon the sand!” —Edna St. Vincent Millay





-> Cover Your Assets

---> AntiPattern Problem
Document−driven software processes often produce less−than−useful requirements and specifications because the authors evade making important decisions. 
In order to avoid making a mistake, the authors take a safer course and elaborate upon alternatives. 
The resulting documents are voluminous and become an enigma; there is no useful abstraction of the contents that convey the authors’ intent. 
Unfortunate readers, who may have contractual obligations dependent upon the text, must pore through the mind−numbing details. 
When no decisions are made and no priorities are established, the documents have limited value. 
It is unreasonable to have hundreds of pages of requirements that are all equally important or mandatory. 
The developers are left without much useful guidance about what to implement in what priority.

---> Refactored Solution
Architecture blueprints are abstractions of information systems that facilitate communication of requirements and technical plans between the users and developers [Blueprint 97]. 
An architecture blueprint is a small set of diagrams and tables that communicate the operational, technical, and systems architecture of current and future information systems [C4ISR 96]. 
A typical blueprint comprises no more than a dozen diagrams and tables, and can be presented in an hour or less as a viewgraph presentation. 
Architecture blueprints are particularly useful in an enterprise with multiple information systems. 
Each system can establish its architecture blueprints, then the organization can compile enterprisewide blueprints based upon the system−specific details. 
Blueprints should characterize both existing systems and planned extensions. 
The extensions can be used to coordinate architecture planning across multiple systems. 
Because architecture blueprints allow multiple projects to portray their technologies, opportunities for interoperability and reuse are enhanced.





-> Vendor Lock−In

AntiPattern Name: Vendor Lock−In
Also Known As: Product−Dependent Architecture, Bondage and Submission,
Connector Conspiracy
Most Frequent Scale: System
Refactored Solution Name: Isolation Layer
Refactored Solution Type: Software
Root Causes: Sloth, Apathy, Pride/Ignorance (Gullibility)
Unbalanced Forces: Management of Technology Transfer, Management of Change
Anecdotal Evidence: We have often encountered software projects that claim their architecture is based upon a particular vendor or product line.

Other anecdotal evidence occurs around the time of product upgrades and new application installations: 
“When I try to read the new data files into the old version of the application, it crashes my system.” 
“Once you read data into the new application, you can never get it out again.” 
“The old software acts like it has a virus, but it’s probably just the new application data.” 
“Our architecture is ... What’s the name of our database again?”

---> Background
A worst−case scenario of this AntiPattern would occur if your data and software licenses were completely allocated to online services, and one day, a modal dialog box popped up.

Interactive word processing became more popular than formatting language technologies (like SGML)
because it allows the user to see the final format on the computer screen and print an exact copy of the on−screen appearance.
This capability is called “What you see is what you get” (WYSIWIG). 
A pervasive variation of Vendor Lock−In is the phenomenon called “What you see is sort−of like what you get” (WYSISLWYG, pronounced “weasel wig”).
Recently, given the desktop dominance of Microsoft, product misfeatures cause the printed versions of documents to vary significantly from their on−screen appearance. 
For example, symbols in drawings can change or disappear, and embedded objects are often printed as command strings (like “{EMBEDDED POWERPOINT FIGURE}”). 
Documents from different versions of the same Microsoft product can cause support problems on corporate networks and system crashes. 
Many companies discourage or outlaw co−mingling of product versions.
It is difficult to avoid this form of vendor lock−in and its product misfeatures because of organizational dependence on Microsoft’s products for document interchange.

---> General Form
A software project adopts a product technology and becomes completely dependent upon the vendor’s implementation. 
When upgrades are done, software changes and interoperability problems occur, and continuous maintenance is required to keep the system running. 
In addition, expected new product features are often delayed, causing schedule slips and an inability to complete desired application software features.

---> Symptoms And Consequences
• Commercial product upgrades drive the application software maintenance cycle.
• Promised product features are delayed or never delivered, subsequently, causing failure to deliver application updates.
• The product varies significantly from the advertised open systems standard.
• If a product upgrade is missed entirely, a product repurchase and reintegration is often necessary.

---> Typical Causes
• The product varies from published open system standards because there is no effective conformance process for the standard.
• The product is selected based entirely upon marketing and sales information, and not upon more detailed technical inspection.
• There is no technical approach for isolating application software from direct dependency upon the product.
• Application programming requires in−depth product knowledge.
• The complexity and generality of the product technology greatly exceeds that of the application needs; 
direct dependence upon the product results in failure to manage the complexity of the application system architecture.

---> Known Exceptions
The Vendor Lock−In AntiPattern is acceptable when a single vendor’s code makes up the majority of code needed in an application.

---> Refactored Solution
The refactioned solution to the Vendor Lock−In AntiPattern is called isolation layer. 
An isolation layer separates software packages and technology, as shown in Figure 6.12. 
It can be used to provide software portability from underlying middleware and platform−specific interfaces. 
This solution is applicable when one or more of the following conditions apply:
• Isolation of application software from lower−level infrastructure. 
This infrastructure may include middleware, operating systems, security mechanisms, or other low−level mechanisms.
• Changes to the underlying infrastructure are anticipated within the life cycle of the affected software; 
for example, new product releases or planned migration to new infrastructure.
• A more convenient programming interface is useful or necessary. 
The level of abstraction provided by the infrastructure is either too primitive or too flexible for the intended applications and systems.
• There a need for consistent handling of the infrastructure across many systems. 
Some heavyweight conventions for default handling of infrastructure interfaces must be instituted.
• Multiple infrastructures must be supported, either during the life cycle or concurrently.
The solution entails creating a layer of software that abstracts the underlying infrastructure or product−dependent software interfaces. 
This layer provides an application interface that completely isolates the application software from the underlying interfaces. 
The application interface should implement a convenient language−specific interface to desired capabilities.
The layering software should ensure default handling of some infrastructure calls and parameters, but expose other details when appropriate.
This isolation layer is used across multiple system development projects to assure interoperability, consistency, and isolation. 
To implement it, migrate the isolation to new infrastructures as necessary; also, update the isolation layer when the infrastructure is updated. 
In all cases, maintain the same application software interface, regardless of infrastructure changes.
It is also necessary to install gateways [Mowbray 97c] between multiple infrastructures that must be supported concurrently, 
and to install forward and reverse gateways during infrastructure migration [Brodie 95].
The benefits of this solution are:
• Mitigation of the risks and costs of infrastructure migration.
• Precluding obsolescence caused by to infrastructure changes.
• Reduction of the risk and cost of software upgrades required by infrastructure changes.
• Assurance of a less labor−intensive and more inexpensive programming interface to most application programmers.
• Support for the concurrent use of multiple infrastructures, transparently.
• Enforcement of coordinated default handling of flexible interfaces and parameters.
• Separation of infrastructure knowledge from application knowledge, 
thereby enabling a small team of infrastructure developers to maintain the isolation layer, 
while the majority of programmers have a customized interface to the layering software.
Other consequences of this solution are that:
• The isolation layer must be migrated and maintained, potentially on multiple platforms and infrastructures.
• The developers who define the initial isolation layer interfaces must be coordinated.
• Changes made to the application interfaces must be coordinated.

---> Variations
This solution is often used at the global level in commercial products and technologies.
Typically, the isolation layer enables the vendor to provide a convenient language−specific interface to a lower−level technology. 
Some of this convenience comes in the form of default handling of lower−level interfaces that are more flexible than necessary for most applications.
For example, the HP Object−Oriented Distributed Computing Environment (OO DCE) product comprises an isolation layer, 
and presents a C++ interface to application developers.
Underlying this interface is an isolation layer of software that is built upon the C language DCE environment. 
Calls to the C++ APIs can invoke several underlying DCE procedure calls; in particular, just two calls are needed to initialize OO DCE security service interfaces. 
The underlying isolation layer, in turn, makes more than 50 calls to DCE APIs to achieve this initialization with the legacy DCE security service.
The isolation layer solution is most applicable at the enterprise level. 
However, individual systems have applied this solution to provide middleware isolation; 
for example, the Paragon Electronic Light Table (ELT) product uses an isolation layer above the Common Desktop Environment (CDE) middleware infrastructure, called ToolTalk. 
By isolating ToolTalk, Paragon can easily migrate its product to a CORBA infrastructure and support both CORBA and ToolTalk infrastructures.

---> Example
The following examples are three known uses of the isolation layer solution:
1. The ORBlite framework, based on HP ORB plus, isolates application software from multiple language mappings and network protocols [Moore 97]. 
Thus, it was able to support multiple language mappings for C++, given the evolution of the OMG mappings during the adoption and revision process [Moore 97].
2. Even though OpenDoc is no longer in the product strategy of its creator, some interesting technical approaches were used, including the isolation layer solution. 
The OpenDoc Parts Framework (OPF) institutes a higher−level C++ programming interface to the penDoc compound document interface, defined in ISO IDL. 
OPF includes interfaces to operating system functions (including display graphics), as well as OpenDoc functions. 
In doing so, OPF enables source code portability interfaces for middleware, windowing, and operating systems. 
Compound document parts written using OPF can be ported via recompilation and linking to OS/2, MacOS, and Windows95. 
A testing capability called LiveObjects, from the Component Integration Labs, the consortium responsible for OpenDoc, assures component portability and interoperability.
3. EOSDIS (Earth Observing System Data and Information System) is a large−scale information retrieval project funded by NASA. 
The EOSDIS middleware abstraction layer was used to isolate application software and evolving middleware. 
Initial prototypes used a beta−test CORBA product. 
These prototyping efforts proved unsuccessful, largely due to difficulties in using the beta−test product. 
Although program management acknowledged the need for future CORBA support, 
a proprietary object−oriented DCE extension was chosen for short−term implementations. 
Management also did not want to rely entirely on proprietary interfaces. 
The situation was resolved through the addition of a middleware abstraction layer that masked the choice of middleware from EOSDIS application software; 
it hid differences in object creation, object activation, and object invocation.

---> Related Solutions
This pattern is related to the Object Wrapper pattern [Mowbray 97c], which provides isolation to and from a single application to a single object infrastructure. 
The isolation layer pattern provides insulation of multiple applications from multiple infrastructures. 
This pattern is also related to the Profile pattern [Mowbray 97c], where an isolation layer can be viewed as a particular enterprise profile for the use of middleware.
The isolation layer can be thought of as one the levels in a layered architecture [Mowbray 97c]. 
In contrast to most layers, this is a very thin layer that does not contain application objects. 
Typically, an isolation layer serves only as a proxy for integrating clients and services with one or more infrastructures. 
The Proxy pattern is described in Buschmann (1996).

---> Applicability To Other Viewpoints And Scales
The impact of Vendor Lock−In on management is a loss of control of the technology, IT functionality, 
and O&M budgets to the dictates of vendor product releases. 
Vendor Lock−In also impacts risk management. 
The AntiPattern is often accepted with the understanding that future features will be implemented. 
Unfortunately, these feature often deliver later than expected or needed, if ever.
Vendor Lock−In affects developers by requiring they have in−depth product knowledge. 
But this knowledge is transient; it will be made obsolete by the next product release. 
Thus, developers are expected to be on a continuous learning−curve treadmill about product features, product bugs, and product futures.





-> Wolf Ticket

AntiPattern Problem
There are many more information systems standards than there are mechanisms to assure conformance. 
Only 6 percent of information systems standards have test suites.
Most of the testable standards are for programming language compilers—FORTRAN, COBOL, Ada, and so forth.

A Wolf Ticket is a product that claims openness and conformance to standards that have no enforceable meaning. 
The products are delivered with proprietary interfaces that may vary significantly from the published standard. 
A key problem is that technology consumers often assume that openness comes with some benefits. 
In reality, standards are more important to technology suppliers for brand recognition than for any benefits that the standards may offer users.
Standards do reduce technology migration costs and improve technology stability, 
but, differences in the implementation of the standards often negate their assumed benefits, such as multivendor interoperability and software portability. 
Furthermore, many standards specifications are too flexible to assure interoperability and portability; 
other standards are excessively complex, and these are implemented incompletely and inconsistently in products. 
Frequently, different subsets of the standard are implemented by various vendors.
Wolf Tickets are a significant problem for de facto standards (an informal standard established through popular usage or market exposure). 
Unfortunately, some de facto standards have no effective specification; 
for example, a nascent database technology that is commercially available with multiple proprietary interfaces, unique to each vendor, has become a de facto standard.

---> Refactored Solution
Technology gaps cause deficiencies in specifications, product availability, conformance, interoperability, robustness, and functionality. 
The closing of these gaps is necessary to enable the delivery of whole products, those comprising the infrastructure and services necessary for the realization of useful systems. 
In the 1960s, a sophisticated user group called SHAPE advised the industry to stabilize technology 
and create whole products for the computer mainframe market, required for the realization of successful nonstovepipe systems. 
As a result, the mainframe workset remains the only whole−product information technology market.
Technology gaps become political issues for end users, corporate developers, and systems integrators. 
Politics is the exercise of power, and consumers must demand the resolution of technology gaps before they will be effectively addressed. 
For example, consumers must demand guarantees of merchantability and “fitness for purpose” before products are offered by commercial suppliers.
The core strategy of grassroots politics is heightening the contradiction. 
By spreading awareness of the contradictions in a system (such as the technology market), the establishment (in this case, technology suppliers) will resolve the issues. 
Three elements constitute an effective political message. With these three elements, the message has a good chance of being reported by the media:
1. The message must be controversial.
2. The message must be repetitive.
3. The message must be entertaining.
Currently, we are working on an initiative in technology consumer politics.
What is needed are whole products supporting mission−critical system development. 
A whole product that enables the construction of any mission−critical system has five key services: naming, trading, database access, transactions, and system management.
These services apply to mission−critical systems in any domain. 
Naming is a white−pages service that enables the retrieval of object references for known objects.
Trading is a yellow−pages service that supports system extensibility through retrieval of candidate services based upon attributes. 
A standard database access service is necessary for retrieval and updating of information resources. 
Transactions assure robust access to state information and orderly cleanup in case of failures. 
System management is required for maintaining heterogeneous hardware and software environments.
Because today, developers cannot buy these whole products in a robust, interworking form, developers are forced to re−create these services or build stovepipe systems.

---> Variation
All computer technology consumers can participate in improving the technologies that they are currently using. 
To do so, simply call the vendor with your questions, complaints, and support problems. 
Keep in mind, for shrink−wrap products, the profit margin is less than the resources required to answer a phone call and address your questions.
Most vendors track the support issues and incorporate relevant changes into their products in future releases. 
The priority for changes is usually based upon the frequency and urgency of the reported problems.

---> Background
The term Wolf Ticket originates from its slang use, where it is an unofficial pass sold to an event, such as a rock concert, by scalpers.





-> Architecture By Implication
AntiPattern Name: Architecture by Implication
Also Known As: Wherefore art thou architecture?
Most Frequent Scale: System
Refactored Solution Name: Goal Question Architecture
Refactored Solution Type: Documentation
Root Causes: Pride, Sloth
Unbalanced Forces: Management of Complexity, Change, and Risk
Anecdotal Evidence: “We’ve done systems like this before!” “There is no risk; we
know what we’re doing!”

---> Background
Dwight Eisenhower said that planning is essential, but plans are inconsequential. 
Another soldier said that no plans survive first contact with the enemy. 
The planning culture in modern management owes some credit to Robert McNamara, founder of the RAND Corporation. 
In McNamara’s approach, plans are generated for speculative purposes, to investigate the potential benefits and consequences of different courses of action. 
Given the large number of unknowns in systems development, planning for IT systems must be more pragmatic and iterative.
One professional planner said that 20 percent of an engineer’s time should be devoted to planning. 
As we gain experience, our belief in this assertion increases. 
Productivity and efficiency can be greatly amplified when the work is well organized through planning. 
The unfortunate consequence is that many organizations attempt to formalize too much of the planning. 
Planning is most effective when it is personally motivated and utilized. 
Time management experts teach that a key element of stress reduction is planning to balance life’s overall priorities. 
The form and use of time−management systems becomes increasingly personalized as the practice matures.
A group of CEOs from DoD Systems integration firms was formed to answer the question,
“Wherefore art thou architecture?” 
The goal was to reflect on the changing nature of systems development, which has evolved into the reuse of existing legacy components 
and commercial software, and away from greenfield, custom code development (see the Reinvent the Wheel AntiPattern in this chapter).

---> General Form
This AntiPattern is characterized by the lack of architecture specifications for a system under development (see Figure 6.13). 
Usually, the architects responsible for the project have experience with previous system construction, and therefore assume that documentation is unnecessary. 
This overconfidence leads to exacerbated risks in key areas that affect system success. 
Architecture definitions are often missing from one or more of these areas:
• Software architecture and specifications that include language use, library use, coding standards, memory management, and so forth.
• Hardware architecture that includes client and service configurations.
• Communications architecture that includes networking protocols and devices.
• Persistence architecture that includes databases and file−handling mechanisms.
• Application security architecture that includes thread models and trusted system base.
• Systems management architecture.
Symptoms And Consequences
• Lack of architecture planning and specification; insufficient definition of architecture for software, hardware, communications, persistence, security, and systems management.
• Hidden risks caused by scale, domain knowledge, technology, and complexity, all of which emerge as the project progresses.
• Impending project failure or unsuccessful system due to inadequate performance, excess complexity, misunderstood requirements, usability, and other system characteristics. 
For example, approximately 1 of 3 systems encounter serious performance problems during development and operations.
• Ignorance of new technologies.
• Absence of technical backup and contingency plans.

---> Typical Causes
• No risk management.
• Overconfidence of managers, architects, and/or developers.
• Reliance on previous experience, which may differ in critical areas.
• Implicit and unresolved architecture issues caused by gaps in systems engineering.

---> Known Exceptions
The Architecture by Implication AntiPattern is acceptable for a repeated solution, where there are minor differences in the code, such as installation scripts. 
This AntiPattern may also be useful in a new project domain as an exploratory effort to determine whether existing techniques are transferable into a new area.

---> Refactored Solution
The refactored solution to the Architecture by Implication AntiPattern entails an organized approach to systems architecture definition, and relies on multiple views of the system. 
Each view models the system from the perspective of a system stakeholder, who may be real or imaginary, individual or aggregate. 
Each stakeholder is responsible for a high−priority set of questions and issues, and each view represents the entire information system and answers these key questions and issues. 
The views comprising a set of diagrams, tables, or specifications, are linked for consistency. 
Generally, a view is a lightweight specification. 
The purpose of the architecture documentation is to communicate architecture decisions and other issues resolutions. 
The documentation should be easy to understand and inexpensive to maintain.

That said, the only people who can define and implement a successful architecture are those who already fully understand it. 
Unfortunately, this is often not the case, as many projects adopt some new technology that is not well understood. 
Therefore, developing a good architecture from scratch is an iterative process and should be recognized as such. 
An initial reference architecture should have strong strategies that can be implemented within the time period of the first product development. 
Thereafter, it will have to be incrementally refined by future versions of the reference architecture, and driven by new versions of the first product or new products.
The steps to define a system architecture using viewpoints are as follows [Hilliard 96]:
1. Define the architecture goals. What must this architecture achieve? 
Which stakeholders, real and imaginary, must be satisfied with the design and implementation? 
What is the vision for the system? Where are we now and where are we going?
2. Define the questions. What are the specific questions that must be addressed to satisfy the stakeholder issues? 
Prioritize the questions to support view selection.
3. Select the views. Each view will represent a blueprint of the system architecture.
4. Analyze each view. Detail the architecture definition from each viewpoint. Create the system blueprints.
5. Integrate the blueprints. Verify that the views present a consistent architecture definition.
6. Trace views to needs. The views should address the known questions and issues to discover any gaps not addressed by the architecture specifications. 
Validate the architecture with respect to formal requirements. 
Prioritize the outstanding issues.
7. Iterate the blueprints. Refine the views until all questions, issues, and gaps are resolved.
Utilize review processes to surface any remaining issues. If a significant number of unresolved issues remain, consider creating additional views.
8. Promote the architecture. Make an explicit effort to communicate the architecture to key stakeholders, particularly the system developers. 
Create lasting documents (such as a video tutorial) to provide valuable information throughout the development and maintenance life cycle.
9. Validate the implementation. The blueprints should represent an “as−built” design.
Determine any deltas between the blueprints and the system implementation. 
Decide whether these differences should result in system modifications of updates to the blueprints. 
Upgrade the documentation for consistency.
We refer to this method as the goal−question architecture (GQA), analogous to the goal−question metric approach in software metrics [Kitchenham 96].

---> Variations
A number of approaches consider the system architecture using viewpoints; in some, the viewpoints are predefined. 
Most of these approaches are open−ended, in that one can select additional viewpoints as described.
The Reference Model for Open Distributed Process (RM−ODP) is a popular, useful standard for distributed architectures. 
RM−ODP defines five standard viewpoints: enterprise, information, computational, engineering, and technology [ISO 96]. 
It also defines a useful set of transparency properties for distributed infrastructure through the engineering viewpoint.
Another approach, the Zachman Framework, analyzes system architectures from the perspectives of data, function, and network [Spewak 92]. 
Within each perspective are multiple levels of abstraction, corresponding to the planning needs of various groups of stakeholders. 
Enterprise Architecture Planning is an approach based upon the Zachman Framework for large−scale systems [Spewak 92]. 
Neither of these approaches is tailored to object−oriented systems development.
A third approach, the Command, Communication, Control, Computer, Intelligence, Surveillance, and Reconnaissance Architecture Framework (C4ISR−AF), is used to define various command and control system architectures. 
A version of C4ISR−AF is used for other types of civilian systems. 
This approach has been very beneficial in enabling communications between architects across disparate domains [Mowbray 97b].
A fourth, the 4 + 1 Model View, is a viewpoint−based architecture approach supported by software engineering tools, such as Rational Rose [Kruchten 95]. 
The viewpoints include logical, use−case, process, implementation, and deployment. 
Finally, GQA is a generalization of the underlying method used in several of these architecture approaches [Hilliard 96].

---> Example
A common but bad practice is object−oriented modeling without defining the viewpoint. 
In most modeling approaches, there is a blurring of the viewpoints. 
Many of the modeling constructs contain implementation detail, and the default practice is to intermingle implementation and specification constructs.
Three fundamental viewpoints are: conceptual, specification, and implementation [Cook 94].
The conceptual viewpoint defines the system from the perspective of the user. 
This is typically referred to as an analysis model. 
The distinction between what is automated and what is not is usually not represented in the model; 
rather, the model is drawn so that a user can explain and defend it to his or her peers. 
The specification viewpoint concerns only interfaces. 
ISO IDL is one important notation that is strictly limited to defining interface information and excludes implementation specifics. 
The separation of interfaces from implementations enables the realization of many important object technology benefits, 
such as reuse, system extension, variation, substitutability, polymorphism, and distributed object computing. 
The final viewpoint, implementation, is best represented by the source code.
Complex implementation structures are beneficially augmented with object−oriented design models to help current 
and future developers and maintainers understand the code.
Another example of the Architecture by Implication AntiPattern is the following, where the key stakeholders did not have collective experience in what was built. 
The project was intended to deliver a Microsoft Distributed Common Object Model (DCOM)−based solution to extract legacy mainframe data, filter it based on business rule, and display it on Web pages.

However, the manager was a good software engineer with no distributed object technology (DOT) experience and the architect was a “dyed−in−the−wool” CORBA addict who helped the OMG derive its Object Management Architecture. 
To compound the problem, the project had few DCOM−aware staff; less than 10 percent.
In addition, the architecture and subsequent design were based on the OMA view of the DOT world, rather than DCOM. 
This led to an attempt to deliver CORBA services under a DCOM architecture. 
The resulting product suffered from a set of components that had no DOT consistency and were poor performers. 
Also, SIs found it very difficult to use, due to lack of a standardized approach. 
Finally, it failed in the marketplace.

---> Related Solutions
Architecture by Implication AntiPattern differs from the Stovepipe Systems AntiPattern in scope; the latter focuses on deficiencies in computational architecture. 
In particular, it identifies how improper abstraction of subsystem APIs leads to brittle architecture solutions.
In contrast, the Architecture by Implication AntiPattern involves planning gaps constituted of multiple architecture viewpoints.

---> Applicability To Other Viewpoints And Scales
This AntiPattern significantly increases risk for managers, who defer important decisions until failures occur; often, it is too late to recover. 
Developers suffer from a lack of guidance for system implementation. 
They are given de facto responsibility for key architectural decisions for which they may not have the necessary architectural perspective. 
Systemwide consequences of interface design decisions should be considered; in particular: system adaptability, consistent interface abstractions, metadata availability, and management of complexity.
Another important result of this AntiPattern is the deferment of resource allocation. 
The essential tools and technology components may not be available when needed due to lack of planning.






-> Warm Bodies

Also Known As Deadwood, Body Shop, Seat Warmers, Mythical Man−Month [Brooks 79]
Anecdotal Evidence “One out of 20 programmers... produces 20 times the software compared to an average programmer.”
There are approximately two million working software managers and developers in America. 
Currently, there are 200,000 additional job openings. 
These figures indicate a negative 10 percent unemployment rate.

---> AntiPattern Problem
Skilled programmers are essential to the success of a software project. 
So−called heroic programmers are exceptionally productive, but as few as 1 in 20 have this talent.
They produce an order of magnitude of more working software than an average programmer.
Large−scale software projects are prevalent in many industries. 
These projects employ hundreds of programmers to build an enterprise system; a staff of 100 to 400 on a single project is not atypical. 
These large projects often involve outsourced development and contractual payments based upon labor−hours worked. 
Since profits are a percentage of the staff salaries, the more hours worked, the higher the profits.
System requirements always change and increase during development; 
so there is little risk involved if the project is underbid initially; 
the contractor can grow the staff to meet inevitable problems and new requirements. 
The fallacy of adding more staff to an ongoing software project was described by Frederick Brooks in the Mythical Man−Month (1979).

---> Refactored Solution
The ideal project size is four programmers; the ideal project duration is four months [Edwards 97]. 
Software projects are subject to the same group dynamics as committee meetings (see the Design by Committee AntiPattern, described next). 
Project teams that grow beyond five people generally experience escalating difficulties with group coordination. 
The members have trouble making efficient decisions and maintaining a common vision. 
Working toward a near−term deadline is essential to encourage the team to focus and begin producing a solution.
We submit that extremely large projects are futile efforts. 
Small project teams with individual accountability are much more likely to produce successful software.

---> Variations
Finding talented programmers is an important challenge for software−intensive companies. 
Some firms have resorted to incorporating testing as part of their hiring processes. 
These examinations resemble IQ tests. If the subject fails the test, he or she will probably end up on a large−scale project with hundreds of other programmers.
Working with independent contractors and consultants is an effective way to acquire programming talent quickly. 
In some areas of the United States, hundreds of contract programmers work out of their homes, and they can be engaged via a phone call or e−mail. 
These contract programmers can produce significant software products for reasonable rates, compared to the project failures and overruns that result from the Warm Bodies mini−AntiPattern.





-> Design By Committee
AntiPattern Name: Design by Committee
Also Known As: Gold Plating, Standards Disease, Make Everybody Happy, Political Party
Most Frequent Scale: Global
Refactored Solution Name: Meeting Facilitation
Refactored Solution Type: Process
Root Causes: Pride, Avarice
Unbalanced Forces: Management of Functionality, Complexity, and Resources
Anecdotal Evidence: “A camel is a horse designed by a committee.” “Too many cooks spoil the broth.”

---> Background
Object orientation is often described as a two−generation technology. 
Data−centric object analysis is characteristic of the first generation, and design patterns are characteristic of the second. 
The first generation espoused a philosophy that “objects are things you can touch.”
A consequence of this is that virtually all designs are uniquely vertical. 
In the first generation, people believed a number of assumptions that were unsubstantiated by practice. 
One of these was that project teams should be egalitarian; in other words, that everyone should have an equal say and that decisions are democratic. 
This leads to Design by Committee.
Given that only a small number of object developers can define good abstractions, the majority rule invariably leads to a diffusion of abstraction and excess complexity.

---> General Form
A complex software design is the product of a committee process. 
It has so many features and variations that it is infeasible for any group of developers to realize the specifications in a reasonable time frame. 
Even if the designs were possible, it would not be possible to test the full design due to excessive complexity, ambiguities, overconstraint, and other specification defects. 
The design would lack conceptual clarity because so many people contributed to it and extended it during its creation.

---> Symptoms And Consequences
• The design documentation is overly complex, unreadable, incoherent, or is excessively defective.
• The design documentation is voluminous (hundreds or thousands of pages).
• Convergence and stability are missing from the requirements and the design.
• The committee meetings resemble bull sessions during which substantive issues are rarely discussed and progress is painstakingly slow. 
People talk and work serially; that is, there is a single thread of discussion, and most people are unproductive most of the time.
• The environment is politically changed, and few decisions and actions can be undertaken outside of the meeting; and the meeting process precludes reaching timely decisions.
• There is no prioritization of the design features, and no ready answer to the questions:
Which features are essential? Which features will be implemented in the initial delivery?
• Architects and developers have conflicting interpretations of the design.
• Design development becomes significantly over−budget and overdue.
• It becomes necessary to employ specialists to interpret, develop, and manage the specifications. 
In other words, dealing with each specification that was designed by committee becomes a full−time job.

---> Typical Causes
“The lunatics have taken charge of the asylum.” — Richard Rowland
• No designated project architect.
• A degenerate or ineffective software process.
• Bad meeting processes, marked by lack of facilitation or ineffective facilitation. 
The meetings are bull sessions; the loudest people win and the level of discourse is the lowest common denominator of sophistication.
• Gold plating—that is, features are added to the specification based on proprietary interests. 
This can happen for many reasons: marketability, the existence of proprietary technologies already containing these features, or speculative placement of features in the specification for potential future work.
• The attempt to make everybody happy, to satisfy all of the committee participants by incorporating their ideas. 
Unfortunately, it’s impossible to accept every idea and still manage complexity.
• Design and editing is attempted during meetings with more than five people.
• Explicit priorities and a software−value system are undetermined [Mowbray 97c].
• Concerns are not separated, and reference models are not used.

---> Known Exceptions
There are few exceptions to the Design by Committee AntiPattern, and they occur when the committee is small: approximately 6 to 10 people; 
more than that and consensus becomes unlikely; fewer than six people and the breadth of understanding and experience become insufficient. 
Also, committees should often be tiger teams, a small group of “experts” in a particular problem domain, organized for the duration of the solution for a specific problem or issue.

---> Refactored Solution
The essence of the solution to Design by Committee is to reform the meeting process. 
It’s fair to say that most people are accustomed to enduring bad meetings, most of the time. 
Thus, even simple alterations in the meeting process can yield substantial productivity improvements. 
With improved productivity, there is an opportunity for enhanced quality and more sophisticated solutions. 
Typical gains for software optimizations are less than an order of magnitude (2 to 10 times). 
Meeting productivity gains are much more dramatic, with several orders of magnitude typical (100 times), and we have seen productivity gains over 100,000:1.

First, most meeting rooms do not have a clock on the wall, particularly in hotel facilities. 
Time awareness is essential to meeting progress. 
Participants should be coached to manage the time allotted efficiently; 
participants should start their comments with a “25−words−or−less” summary, and add details only if requested. 
Posting the meeting goals, an agenda, and a clock where they are visible to all participants can improve meetings dramatically.
Second, in all meetings it’s important that group members answer two questions: “Why are we here?” and “What outcomes do we want?” 
When no meeting plan is prepared, it is particularly important that the group start with these two questions, and then work on generating the desired outcomes.

Another important reform is to assign explicit roles in the software process: owner, facilitator, architect, developers, testers, and domain experts. 
The owner is the manager responsible for the software development. 
He or she makes strategic decisions about the overall software process, and invites and organizes the participants. 
At the beginning of the meeting, the process owner sets the goals and establishes expectations regarding the handling of the outcomes. 
For example, the decisions made at the meeting may be regarded simply as advice or be implemented exactly as discussed.
The facilitator is in charge of running the meeting. 
He or she is responsible for the process; other participants are responsible for technical content. 
The facilitator turns to the process owner if there are any key decisions to be made regarding the process.
“My specialty is being right when other people are wrong.”—George Bernard Shaw
The architect is the senior technical lead for the software project. 
He or she controls the editing of the architecture documentation, and may be in charge of key, system−level boundaries, such as the subsystem application program interfaces. 
Each developer is typically responsible for a single subsystem and unit testing. 
Testers are responsible for monitoring specification quality and value−added testing such as integration, portability, and stress tests. 
The domain experts input key requirements to the process, but may not be involved in all aspects of development.
There are three categories of meeting processes: divergent, convergent, and information sharing. 
In a divergent process, ideas are generated for later utilization. 
In a convergent process, a selection or decision is made that represents a consensus. 
Information sharing can involve presentation, teaching, writing, and review.
The number of people involved in each meeting process is managed by the facilitator.
Creative processes that require writing, highlighting, or drawing should be limited to breakout teams of five people or fewer. 
Groups larger than five are less effective at making progress in creative tasks, although they are successful at reviewing and integrating results after a creative process. 
Highly productive meetings involve many parallel processes, and frequent iterations of breakout and review groups. 
Encouraging people to make a paradigm shift between single−threaded discussion and parallel work is a key challenge for the facilitator.
The primary purpose of most meetings is problem solving. 
A general problem−solving approach begins with a convergent process: 
The problem is defined and scoped for the group to resolve. 
A divergent process is used to identify alternative solutions. 
Information sharing may be needed to explore the details and consequences of selected alternatives.
Finally, a convergent process is used to select among the options.
One highly effective meeting process is called Spitwads [Herrington 91]. 
It’s a general−purpose procedure that we have used on many occasions with excellent results.
1. Ask the question. 
The facilitator poses a question for the group to brainstorm. 
The question is written down on a viewgraph or flipchart) to avoid misunderstandings. 
The group is asked whether there are any suggested changes to the question before the brainstorming starts. 
Typical questions are: “What are ways that we can improve the performance of the system?” and “What is the most important requirement that has not been addressed?”
2. Write silently. 
The participants write responses on identical slips of paper. 
Each response is written on a separate piece of paper, and is limited to short phrases.
3. Toss spitwads. 
As the participants complete each idea, the facilitator instructs them to wad up the paper and toss it across the room into a receptacle—a cardboard box or a basket works best. 
This is done basketball style, and the facilitator encourages the participants to have fun with this exercise.
4. Conduct spitwad roll call. The “spitwads” are distributed randomly back to the participants, who one at a time read the ideas out loud to be recorded on a flipchart. 
Two flipchart recorders can be used simultaneously to speed up the process. 
The flipcharts are posted on the wall for all participants to see.
5. Reach common understanding. 
The ideas on the flipcharts are numbered. 
The facilitator then asks the group if there are any ideas that they do not understand. 
If so, the members of the group are encouraged to offer definitions. If an idea cannot be defined, it is safe to eliminate it.
6. Eliminate duplicates. 
The facilitator asks the group to identify any ideas that are duplicates or that should be combined. 
Participants identify the ideas by number to suggest changes. 
If there is an objection, the changes are overruled. (This is a common facilitation approach for editing: If there are objections to a proposed change, then the change is not accepted.)
7. Prioritize. 
The group is directed to silently select the best ideas on the list by number.
They can pick more than one. 
The facilitator walks through the list tabulating votes (raised hands, no discussion).
8. Discuss. 
The exercise is complete. 
The group discusses the highest−priority selections nd suggests what the follow−up actions will be.

Variations
The Railroad (also known as Rubber Stamp) AntiPattern is a variation of Design by Committee, whereby a political coalition dominates the process and forces the adoption of designs with serious defects. 
The Railroad is often motivated by mutual business interests of many members of the committee. 
By adopting incomplete and defective specifications, details of the technology can be hidden effectively in the software. 
In this way, software from a coalition developer becomes the de facto standard, as opposed to the written specifications. 
Some developers outside the coalition will even attempt to implement the “misfeatures,” resulting in wasted time and money.

---> Example
Two classic examples of Design by Committee come from the domain of software standardization: the Structured Query Language (SQL) and Common Object Request Broker Architecture (CORBA).

---> Related Solutions, Patterns, and AntiPatterns
Kyle Brown posted a version of the Design by Committee AntiPattern on the Portland Patterns Repository site [Brown 95]. 
That pattern uses a different template, which focuses entirely on describing the problematic solution and not upon the refactored solution. 
In contrast, this book includes a refactored solution with each AntiPattern, noting that Socrates was put to death for exposing society’s contradictions without offering any constructive 
suggestions.

---> Applicability to Other Viewpoints and Scales
The impact of the Design by Committee AntiPattern on developers is that they are expected to implement a highly complex and ambiguous design, which is a stressful situation. 
They may find the need to quietly subvert the demands of the committee with more realistic design approaches.
Managers suffer from this AntiPattern through a dramatic increase in project risk caused by the excessive complexity. 
Correspondingly, the schedule and budget of the project are likely to increase dramatically as the consequences of the design are discovered in the laboratory.
At the system level, it might be reasonable to deliver a system based on a Design by Committee specification, 
if no variations (multiple configurations) are required and the proposed implementation schedule is extended by 30 percent or more. 
Most developers can manage only a few variations, in platforms, databases, and feature sets.





-> Swiss Army Knife

---> AntiPattern Problem
A Swiss Army Knife, also known as Kitchen Sink, is an excessively complex class interface (see Figure 6.14). 
The designer attempts to provide for all possible uses of the class. 
In the attempt, he or she adds a large number of interface signatures in a futile attempt to meet all possible needs. 
Real−world examples of Swiss Army Knife include from dozens to thousands of method signatures for a single class. 
The designer may not have a clear abstraction or purpose for the class, which is represented by the lack of focus in the interface. 
Swiss Army Knives are prevalent in commercial software interfaces, where vendors are attempting to make their products applicable to all possible applications.

This AntiPattern is problematic because it ignores the force of managing complexity,
that is, the complicated interface is difficult for other programmers to understand, 
and obscures how the class is intended to be used, even in simple cases. 
Other consequences of complexity include the difficulties of debugging, documentation, and maintenance.

---> Refactored Solution
Often, complex interfaces and standards are encountered that must be utilized in a software development project; 
therefore, it is important to define conventions for using these technologies so that management of the application’s complex architecture is not compromised. 
This is called creating a profile. 
A profile is a documented convention explaining how to use a complex technology. 
Often, a profile is an implementation plan implementing the details of the technology. 
With profiles, two independent developers can use the same technology, with the likelihood of achieving interoperable software.
A profile of a software interface defines the subset of the signatures that are utilized, and should include conventions for the parameter values. 
In other words, the profile identifies the literal values that can be passed in each parameter. 
In addition, the profile may be required to define the dynamic behavior of the applications using the interfaces. 
This includes descriptions and specifications of sequences of execution, method calls, and exception handling.

---> Variations
A Swiss Army Knife differs from the Blob AntiPattern in that there may be several Swiss Army Knives in a single design. 
In addition, the intent of the Swiss Army Knife is that the designer is exposing complexity in a vain attempt to address all foreseeable needs for the class.
The Blob is a singleton object that monopolizes the process or data in a system.






-> Reinvent The Wheel

AntiPattern Name: Reinvent the Wheel
Also Known As: Design in a Vacuum, Greenfield System
Most Frequent Scale: System
Refactored Solution Name: Architecture Mining
Refactored Solution Type: Process
Root Causes: Pride, Ignorance
Unbalanced Forces: Management of Change, Technology Transfer
Anecdotal Evidence: “Our problem is unique.” 
Software developers generally have minimal knowledge of each other’s code. 
Even widely used software packages available in source code rarely have more than one experienced developer for each program.
Virtually all systems development is done in isolation of projects and systems with overlapping functionality. 
Reuse is rare in most software organizations. 
In a recent study of more than 32 object−oriented software projects, the researchers found virtually no evidence of successful reuse [Goldberg 95].

---> Background
Software and design reuse are significantly different paradigms. 
Software reuse involves the creation of a library of reusable components, the retrieval of those components, and the integration of the components with a software system. 
The typical result is a modest amount of reuse around the periphery of the system and additional software development to integrate the components. 
Design reuse involves the reuse of architecture and software interfaces in multiple application systems. 
It requires the identification of horizontal components with uses across multiple application systems. 
Design reuse also supports software reuse of the horizontal components without additional development for integration, 
thus it is a much more effective approach, in that a larger portion of the software system can be leveraged from reusable components.
The term greenfield (in Greenfield System, an alias of Reinvent the Wheel) originates from the construction industry. 
It refers to a new construction site where there are no legacy buildings to introduce constraints on the new building’s architecture.

---> General Form
Custom software systems are built from the ground up, even though several systems with overlapping functionality exist. 
The software process assumes “greenfield” (build from scratch) development of a single system. 
Because top−down analysis and design lead to new architectures and custom software, software reuse is limited and interoperability is accommodated after the fact.
Most current software methods assume that developers are building custom software from scratch, and that they are building a single system in isolation. 
These are called greenfield system assumptions. 
Greenfield systems inevitably become stovepipes that lack potential for interoperability, extension, and reuse. 
Greenfield assumptions are mismatched to most real−world software development problems, where legacy systems exist, and interoperation with them is an important requirement for many new systems. 
Greenfield assumptions also ignore significant reusable software assets in the form of Internet freeware and commercially available software.

---> Symptoms And Consequences
• Closed system architectures—architectures and software—that are designed for one system at a time without provision for reuse and interoperability.
• Replication of commercial software functions.
• Immature and unstable architectures and requirements.
• Inadequate support for change management and interoperability.
• Extended development cycles involving failed and dead−end prototypes before the architecture is mature enough to support long−term system development and maintenance.
• Poor management of risks and costs, leading to schedule and budget overruns.
• Inability to deliver the desired features to the end user; extensive effort to replicate the functionality already operational in existing systems.

---> Typical Causes
• No communication and technology transfer between software development projects.
• Absence of an explicit architecture process that includes architecture mining and domain engineering.
• Assumption of greenfield development; in other words, the process assumes that the system will be built from scratch.
• Lack of enterprise management of the computational viewpoint, leading to unique software interfaces in each system.

---> Known Exceptions
The Reinvent the Wheel AntiPattern is suitable for a research environment 
and in general software development to minimize coordination costs where developers with different skills work at logistically remote sites.

---> Refactored Solution
Architecture mining is a way to quickly create successful object−oriented architectures that are robust, product−independent, reusable, and extensible. 
Most object−oriented design approaches assume that design information is invented as the process proceeds. 
In a top−down process, design information is generated from requirements, which may be represented as use cases and object−oriented analysis models. 
Requirements−driven architecture design is called architecture farming. 
In a spiral process, design information is invented during each iteration. 
As the spiral process proceeds, architects derive new design information as they learn more about the application problem. 
It’s fair to say that these approaches reinvent much of their design information.
Precursor designs exist for most information systems applications and problems. 
These designs are in the form of legacy systems, commercial products, standards, prototypes, and design patterns. 
Experience proves it is not difficult to identify a half−dozen or more precursor designs for any given application problem. 
Valuable information is buried in preexisting designs, information that enabled earlier architects to build useful systems.
Extracting this information for use in object−oriented architectures is called architecture mining.

Mining may be applicable at the application level for certain complex design problems. 
In some cases, it may be less expensive and risky to exploit existing expertise than to create new code without exposure to preexisting solutions. 
Mining is applicable at enterprise levels, but less so at global levels, given the reduced access to information resources.
Mining is a bottom−up design approach, incorporating design knowledge from working implementations. 
Mining can incorporate design input from top−down design processes, too, so that there can be both top−down traceability and bottom−up realism.

“Immature artists imitate. Mature artists steal.” — Lionel Trilling

Before mining starts, it is necessary to identify a set of representative technologies that are relevant to the design problem. 
Technology identification can be done by various means, such as searching literature, interviewing experts, attending technical conferences, and surfing the Net. 
All available resources should be pursued.
The first mining step is to model each representative technology, to produce specifications of relevant software interfaces. 
We recommend using OMG IDL as the interface notation because it is concise and free from implementation detail. 
OMG IDL is also a good design notation for the target architecture because it is language−independent, platform−neutral, and distribution−transparent. 
Modeling everything in the same notation creates a good basis for design comparison and trade−off.

While modeling, it is important to describe the as−built system, not the intended or desired design. 
Frequently, relevant design information is not documented as software interfaces.
For example, some of the sought−after functionality may be accessible only through the user interface. 
Other key design lessons may be undocumented, and it is useful to capture this information, too.
In the second mining step, the designs are generalized to create a common interface specification. 
This step entails more art than science, as the goal is to create an initial “strawman” specification for the target architecture interfaces. 
It is usually not sufficient to generate a lowest−common denominator design from the representative technology. 
The generalized interfaces should resemble a best−of−breed solution that captures the common functionality, 
as well as some unique aspects inspired by particular systems. 
Unique aspects should be included when they create valuable features in the target architecture 
or represent areas of known system evolution. 
A robust assortment of representative technologies will contain indicators of likely areas of target system evolution.
At this point, it is appropriate to factor in the top−down design information as one of the inputs. 
Top−down information is usually at a much higher level of abstraction than bottom−up information. 
Reconciliation of these differences involves some important architecture trade−offs.
The final step in the mining process is to refine the design. 
Refinements can be driven by the architect’s judgment, informal walkthroughs, review processes, new requirements, or additional mining studies.

---> Variations
Within an organization, software reuse is difficult to achieve. 
In a survey of several dozen object−oriented application projects, Goldberg and Rubin found no significant reuse [Goldberg 95]. 
Even if successful, the cost benefits of internal reuse are usually less than 15 percent [Griss 97]. 
Industry experience indicates that the primary role of internal reuse is as a investment in software for resale. 
Where large volumes make the potential savings significant, reuse can shorten time−to−market and support product customization.
On the other hand, we claim that reuse is prevalent, but in different forms: reuse of commercially available software and reuse of freeware. 
Because of larger user bases, commercial software and freeware often have significantly higher quality than custom−developed software. 
For infrastructure components upon which much application software depends, this enhanced quality can be critical to project success. 
Commercial software and freeware can reduce maintenance costs when the software is used without modification and can be readily replaced with upgraded versions.

---> Example
Architecture mining requires the study of existing software architectures. 
Of particular interest are the software interfaces of extant systems. 
In our training courses on distributed object design patterns, we use the following example to illustrate the techniques and trade−offs required for architecture mining.

The architect studies the interfaces in the preceding code sample with the aid of developers who maintain the corresponding systems. 
He pays particular attention to how the documented interfaces are utilized, as well as any differences between the documentation and the actual usage in the system. 
The architect needs to understand each of the operations and the parameters in detail.

Note that not every nuance of the original interfaces is incorporated into the best of breed.
The design is not a simple, lowest−common denominator of the originals; neither is it a union of the two sets of interfaces and all of their features. 
The architect must generalize the features that are in common between the mined systems, 
then selectively incorporate the features that are unique to each system—some of which are predictive of future needs for the common interface. 
Other unique features will continue to be system−specific and will not belong in the common architecture definition.

---> Related Solutions
The impact upon management of complexity of architecture mining and the generalization to common interfaces is analyzed in Mowbray 95. 
Architecture mining is a recurring solution that addresses many of the problems caused by Stovepipe Systems. 
It is also one of the approaches for defining domain−specific component architectures.

---> Applicability To Other Viewpoints And Scales
The Reinvent the Wheel AntiPattern puts managers at higher risk, in the form of increased time−to−market and a lower degree of functionality than that expected of the end users.
Potential savings from reuse range from 15 to 75 percent of development cost, reduction of 2 to 5 times in time−to−market, and reduction of defects from 5 to 10 times [Jacobson 97].





The Grand Old Duke of York

---> Also Known As
Everyone Charges Up the Hill, Lack of Architecture Instinct, Abstractionists versus Implementationists

---> Anecdotal Evidence
Experts report that only 1 in 5 software developers is able to define good abstractions [Mowbray 95]. 
On hearing this, a practicing software architect retorted, “It’s more like 1 out of 50.”

---> Background
The term abstractionist originates from the fine arts community, where an abstractionist is an expressionist artist, 
who depicts his or her emotions and attitudes through nonrepresentational art. 
In our connotation, an abstractionist is an architect or software developer who has the architecture instinct.

---> AntiPattern Problem
Programming skill does not equate to skill in defining abstractions. 
There appear to be two distinct groups involved in software development: abstractionists and their counterparts (whom we call implementationists) [Riel 96]. 
Abstractionists are comfortable discussing software design concepts without delving into implementation details. 
As stated, they possess the architecture instinct, the ability to define and explain good software abstractions. 
Implementationists, on the other hand, often require source code examples before they can grasp abstract concepts; 
they are not particularly adept at defining new abstractions that can be readily understood by other developers.

Many object−oriented processes are egalitarian; design decisions made in meeting processes are approved by consensus (see the Design by Committee AntiPattern earlier in this chapter). 
According to experts, implementationists outnumber abstractionists approximately 4 to 1 [Mowbray 95]. 
Thus, unfortunately, abstractionists are often outvoted. 
Abstractionists know instinctively that management of complexity is a key design force. 
Good abstractions are often compromised because so few developers appreciate their significance. 
The primary consequence is software designs with excessive complexity, which make the system difficult to develop, modify, extend, document, and test. 
Software usability and system maintenance are impacted by a failure to use effective abstraction principles.
The egalitarian approach to object−oriented development has been rather ineffective in practice; it is reminiscent of a group of people charging up a hill simultaneously.

Everyone must understand and concur on numerous decisions, and even though there may be sophisticated members, 
the overall sophistication of the group is diminished to the lowest common denominator and inhibited by the communication process.

---> Refactored Solution
A more effective approach involves several distinct roles in a software development organization. 
Architects are abstractionists with significant experience in the majority of key technologies. 
They facilitate communication between end users and developers;
they are responsible for managing the complexity and ensuring the adaptability of systems. 
To do this, architects need to manage the computational architecture or system−level programming interfaces.
Component developers are highly skilled programmers. 
They work with systems programming languages such as C, C++, and Java; they create the software infrastructure and reusable software components.
Application developers are other programmers who integrate these components to create working systems. 
They primarily use scripting languages such as Visual Basic, JavaScript, Python, Tcl, and Perl. 
The higher−level nature of the scripting languages enables a wider range of programming skills to be productive.

---> Variations
The specialization of software development roles indicates that there are multiple disciplines required to build safe and effective software systems. 
Certification is a potential mechanism for establishing and validating professional capabilities.
Certification is required for many professionals, for example, cosmetologists, chauffeurs, lawyers, and certified public accountants. 
Why not for software architects?



