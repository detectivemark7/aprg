
Checklist:

•	1 Header Files 
•	1.1 Self-contained Headers
•	1.2 Header guard
•	1.3 Order of includes
•	1.4 Including C Headers
•	1.5 Always use forward slash / as path separator
•	1.6 Forward Declarations
•	1.7 Inline Functions
•	1.8 Don’t define entities with linkage in a header file
•	1.9 Each header file declares only one class.
•	1.10 Name the header file (.hpp) after the class
•	1.11 In a header file, include (# include) only files that are essential for the declarations in it.
•	1.12 When including headers, prefer using angle brackets than using quotations. 

•	2 Implementation Files 
•	2.1 Name the implementation file (.cpp) after the class.
•	2.2 The order of definitions in the implementation file follows the order of declarations in the header file.
•	2.3 Keep the maximum amount of lines in the source files below 1000.
•	2.4 In the implementation file, the first included file must be the header file of the own class.
•	3 Scoping 

•	3.1 Namespaces
•	3.2 Unnamed Namespaces and Static Variables
•	3.3 Nonmember, Static Member, and Global Functions
•	3.4 Local Variables
•	3.5 Static and Global Variables
•	3.6 Scoped enumeration

•	4 Classes 
•	4.1 Be clear what kind of class you’re writing
•	4.2 Prefer minimal classes to monolithic classes
•	4.3 Avoid virtual method calls in constructors, and avoid initialization that can fail if you can't signal an error.
•	4.4 Avoid calling virtual functions in constructors and destructors
•	4.5 Avoid accessing global data in the constructors
•	4.6 Implicit Conversions
•	4.7 Copyable and Movable Types
•	4.8 Prefer assignment operators to return a reference to *this.
•	4.9 Using default functions in a class/struct
•	4.10 Deleting functions in a class/struct
•	4.11 Structs vs. Classes
•	4.12 Structs vs. Pairs and Tuples
•	4.13 Inheritance
•	4.14 Avoid inheriting from classes that were not designed to be base classes
•	4.15 Do not redefine an inherited non virtual function.
•	4.16 Public inheritance is substitutability. Inherit, not to reuse, but to be reused
•	4.17 Prefer providing abstract interfaces
•	4.18 Pimpl judiciously
•	4.19 Practice safe overriding
•	4.20 Override keyword
•	4.21 Final keyword
•	4.22 Destructors, deallocation, and swap never fail
•	4.23 Virtual Destructor
•	4.24 Operator Overloading
•	4.25 Access Control
•	4.26 Prefer writing nonmember nonfriend functions
•	4.27 Define and initialize member variables in the same order (especially in the initializer list)
•	4.28 Prefer initialization to assignment
•	4.29 Do not write member function implementation in the class declaration.

•	5 Functions 
•	5.1 Write Short Functions
•	5.2 Output Parameters
•	5.3 Specify the names of the parameters in the function declaration. The parameter names in the function declaration and definition must be the same.
•	5.4 Reference Arguments
•	5.5 Pass by value (const) vs. Pass by const reference
•	5.6 Take parameters appropriately by value, (smart) pointer, or reference
•	5.7 Don’t write code that depends on the order of evaluation of function arguments
•	5.8 Function Overloading
•	5.9 Consider overloading to avoid implicit type conversions
•	5.10 Default Arguments
•	5.11 Always define a return type for a function.
•	5.12 Every implementation for functions having a non-void return type must return something.
•	5.13 Trailing Return Type Syntax
•	5.14 Prefer to have functions have one exit point (one return statement)
•	5.15 Prefer to have the "restrict" qualifier for functions

•	6 File Handling 
•	6.1 Identifying Files
•	6.2 Avoid fopen()
•	6.3 Minimal permissions
•	6.4 Use of path names
•	6.5 Close unneeded file descriptors
•	6.6 No simultaneous file access
•	6.7 Operate in secure directories
•	6.8 Check for IO errors

•	7 Other C++ guidelines 
•	7.1 Don’t take chances!
•	7.2 Prefer compile- and link-time errors to run-time errors
•	7.3 Write code that does not cause compiler warnings
•	7.4 Forbidden C++ Features
•	7.5 Forbidden Functions
•	7.6 Functions that need special attention
•	7.7 Always initialize variables/class attributes with default value
•	7.8 Avoid initialization dependencies across compilation units
•	7.9 Minimize definitional dependencies. Avoid cyclic dependencies
•	7.10 Avoid using varargs (ellipsis).
•	7.11 If/else content
•	7.12 Switch vs If-Else
•	7.13 Range-based for loop
•	7.14 Do not use goto
•	7.15 Do not assume one type of endianness
•	7.16 RAII and Smart Pointers
•	7.17 Ownership and Smart Pointers
•	7.18 Avoid allocating and deallocating memory in different modules
•	7.19 Rvalue References
•	7.20 Friends
•	7.21 Exceptions
•	7.22 noexcept
•	7.23 Run-Time Type Information (RTTI)
•	7.24 Casting
•	7.25 Preincrement and Predecrement
•	7.26 Constants should be defined as constant variables (constexpr) or enumerated constants (enum), not as preprocessor macros (#define).
•	7.27 Use of const
•	7.28 Use of constexpr
•	7.29 Magic Numbers are not allowed
•	7.30 Integer Types
•	7.31 64-bit Portability
•	7.32 Preprocessor Macros
•	7.33 Do not use pre-processor directives if possible
•	7.34 0 and nullptr/NULL
•	7.35 Don’t memcpy or memcmp for non-PODs
•	7.36 sizeof
•	7.37 C-Strings
•	7.38 std::string vs C-string
•	7.39 Never initialize std::string with a NULL pointer
•	7.40 Manipulate C-like strings using functions operating on controlled buffers (snprintf, strncpy…)
•	7.41 C++ Streams
•	7.42 Type deduction
•	7.43 Auto
•	7.44 Class template argument deduction
•	7.45 Lambda
•	7.45 .1Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms
•	7.45 .2Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread
•	7.46 Lambda expressions
•	7.47 Template metaprogramming
•	7.48 Use C++ standard library algorithms and data structures whenever possible
•	7.49 STL array/vector vs C array
•	7.50 std::hash
•	7.51 Aliases
•	7.52 Alias declaration vs typedefs
•	7.53 Machine dependent parts of code are isolated into separate files
•	7.54 The return type of main() must be int
•	7.55 Do not check lower or upper limits with“==”, always use "<=" or ">="
•	7.56 Use yoda condition style
•	7.57 Do not assume the bit width of any type.
•	7.58 Do not assume that a char is signed or unsigned.
•	7.59 Be careful not to make pointer type conversions from a pointer of a ”shorter” type to a one of a ”longer” type.
•	7.60 Do not assume that pointers and integers have the same size.
•	7.61 Use explicit type conversions for arithmetic using signed and unsigned values.
•	7.62 Do not assume that you know how an instance of a data type is represented in memory.
•	7.63 Do not assume that long, float, double or long double may begin at an address.
•	7.64 Do not depend on integer underflow or overflow functioning in any special way.
•	7.65 Do not assume that the operands in an expression are evaluated in any definite order.
•	7.66 Do not assume that static objects are initialised in any special order.
•	7.67 Do not write code that is dependent on the lifetime of a temporary object.
•	7.68 Exit handlers
•	7.69 No “volatile” synchronization for Threads
•	7.70 Be careful how to call other executables
•	7.71 Format Strings
•	7.72 Use of Environment variables
•	7.73 Signal Handlers
•	7.74 Prefer normal Functions over Signals
•	7.75 Array indices
•	7.76 No Polymorphism with arrays
•	7.77 Usage of c_str() when working with legacy C API
•	7.78 When doing bitwise operations, it must be ensured that the operands are always of the unsigned type.
•	7.79 Compare only same variable types
•	7.80 Floating point for accurate calculations

•	8Naming 
•	8.1 Choose meaningful names
•	8.2 File Names
•	8.3 Type Names
•	8.4 Variable Names
•	8.5 Enumerator names
•	8.6 Function Names
•	8.7 Namespace Names
•	8.8 Macro Names
•	8.9 Global Constants
•	8.10 Do not use Hungarian notation in a code
•	8.11 Do not use different multiple names that differ only in case.
•	8.12 Use names that can be pronounced.
•	8.13 Avoid numbers in names
•	8.14 Do not use standard C or C++ names
•	8.15 Do not use names that begin with more thatn one underscore

•	9Comments 
•	9.1 Comment Style
•	9.2 Write comments in English
•	9.3 Punctuation, Spelling, and Grammar
•	9.4 Prefer making the code more descriptive instead of putting comments
•	9.5 TODO Comments
•	9.6 Don't state the obvious
•	9.7 Avoid including such information in comments that is likely to become out-of-date.
•	9.8 Keep the comments up to date.
•	9.9 Remove outdated code instead of commenting it.
•	9.10 If multiple trailing comments are used in a block of code, they all should be indented to the same level.
•	9.11 Avoid commenting one matter in many places.
•	9.12 Avoid repeating code in comments.

•	10 Formatting 
•	10.1 Maximum line length
•	10.2 Non-ASCII Characters
•	10.3 Use spaces over tabs
•	10.4 Bracket Style
•	10.5 Loop/Conditional Block Whitespace
•	10.6 Binary/Ternary Operators and Commas Padding
•	10.7 Function/Class Spacing
•	10.8 Class Format
•	10.9 Switch format
•	10.10 Preprocessor Directives
•	10.11 Pointer, Reference, and Const placement
•	10.12 Maximum depth for nested blocks

•	11 Design 
•	11.1 Input validation
•	11.2 Give one entity one cohesive responsibility (Single responsibility principle).
•	11.3 Prefer low coupling
•	11.4 Correctness, simplicity, and clarity come first.
•	11.5 Know when and how to code for scalability.
•	11.6 Don’t optimize prematurely.
•	11.7 Don’t pessimize prematurely.
•	11.8 Minimize global and shared data.
•	11.9 Hide information.
•	11.10 Know when and how to code for concurrency.
•	11.11 Ensure resources are owned by objects. Use explicit RAII and smart pointers.
•	11.12 Isolate dependencies to external entities (create abstract interfaces to external entities)

•	12 Logging 
•	12.1 Use correct level of printing
•	12.2 Be aware of different log types
•	12.3 Be aware of filtering mechanisms of logging services
•	12.3 .1CC&S AaSysLog service filtering mechanism
•	12.4 Consider logging performance
•	12.5 Use standard priorities and numerical priority values when logging
•	12.6 Add inventory information in the logs
•	12.7 Add configuration details in the logs
•	12.8 Add logs from building blocks (subcomponents or subsystems)
•	12.9 Add logs based from platform symptoms and failures
•	12.9.1 Cloud and Distributed Architecture
•	12.10 Add logs when snapshot is collected
•	12.11 Add logs for interface and protocol symptoms
•	12.12 Add logs during startup
•	12.13 Add logs during install/upgrade/update
•	12.14 Add logs during backup/restore/recovery
•	12.15 Add logs for faults
•	12.16 Add logs regarding performance
•	12.17 Add NE/product specific logs
•	12.18 Use standard logging format
•	12.19 Use standard file naming conventions for logs
•	12.20 Use platform APIs and common functions for logging
•	12.21 Put necessary contents for each one log line
•	12.22 Put the unique log identifier or the reference IDs to differentiate similar logs
•	12.23 Avoid putting multiple same logs that are repeating
•	12.24 Be aware of the verbose and binary logs trade-offs
•	12.25 Analysis tools are mandatory when using binary logs
•	12.26 Be aware of log message transport and encryption
•	12.27 Follow the rules when logging customer sensitive data
•	12.28 Use debug for the prints that can only be understood by the SW developers.
•	12.29 Do not overuse debug prints
•	12.30 Consider logging frequency
•	12.31 Consider how to grep the logs
•	12.32 Consider impact on binary size for logging
•	12.33 Determine when and what to log
•	12.34 Prefer to add information so that it can be easily be located in the code
•	12.35 Prefer to add readable and easily understandable runtime information in the logs and prints.
•	12.36 Make sure that prints regarding state machines are sufficient for investigation
•	12.37 Make sure that prints regarding conditionals are sufficient for investigation
•	12.38 Make sure that prints regarding message handling are sufficient for investigation
•	12.39 Prefer to have prints one event per line
•	12.40 Prefer to log a single line per AaSysLog function call
•	12.41 Use same message and parameter names in the interface definitions when logging
•	12.42 Make sure that the logs used by test automation are updated.
•	12.43 Make sure that tools are updated for the current logs
•	12.44 In cases of failures, please make sure to add all the necessary information and context to diagnose the problem.
•	12.45 Remove redundant white space on the prints
•	12.46 Don't put any unnecessary characters and lines in order stylize the log
•	12.47 Use standard C++ numerical literal format when logging numerical values
•	12.48 Use camel case when printing the names
•	12.49 Make sure that the snapshot description files and trbl_log_list.csv are updated with the logs
•	12.50 Managing and maintaining log quality

•	13 Nokia/WBTS specific 
•	13.1 Exceptions
•	13.2 Assert
•	13.3 CP Common code
•	13.4 Global Type Definitions
•	13.5 Platform APIs
•	13.6 Sensitive Data

•	14Sana Top 25 Programming Errors 
•	14.116.1    CATEGORY: Insecure Interaction between Components
•	14.1.1CWE-20: Improper Input Validation
•	14.1.2CWE-116: Improper Encoding or Escaping of Output
•	14.1.3CWE-89: Failure to Preserve SQL Query Structure (aka 'SQL Injection')
•	14.1.4CWE-79: Failure to Preserve Web Page Structure (aka 'Cross-site Scripting')
•	14.1.5CWE-78: Failure to Preserve OS Command Structure (aka 'OS Command Injection')
•	14.1.6CWE-319: Cleartext Transmission of Sensitive Information
•	14.1.7CWE-352: Cross-Site Request Forgery (CSRF)
•	14.1.8CWE-362: Race Condition
•	14.216.2    CATEGORY: Risky Resource Management
•	14.2.1CWE-119: Failure to Constrain Operations within the Bounds of a Memory Buffer
•	14.2.2CWE-642: External Control of Critical State Data
•	14.2.3CWE-73: External Control of File Name or Path
•	14.2.4CWE-426: Untrusted Search Path
•	14.2.5CWE-94: Failure to Control Generation of Code (aka 'Code Injection')
•	14.2.6CWE-494: Download of Code without Integrity Check
•	14.2.7CWE-404: Improper Resource Shutdown or Release
•	14.2.8CWE-665: Improper Initialization
•	14.2.9CWE-682: Incorrect Calculation
•	14.316.3    CATEGORY: Porous Defenses
•	14.3.1CWE-285: Improper Access Control (Authorization)
•	14.3.2CWE-327: Use of a Broken or Risky Cryptographic Algorithm
•	14.3.3CWE-259: Hard-Coded Password
•	14.3.4CWE-732: Insecure Permission Assignment for Critical Resource
•	14.3.5CWE-330: Use of Insufficiently Random Values
•	14.3.6CWE-250: Execution with Unnecessary Privileges
•	14.3.7CWE-602: Client-Side Enforcement of Server-Side Security

Header Files 

Self-contained Headers
Header files should be self-contained (compile on their own) and end in .h or .hpp.
All header files should be self-contained. Users and refactoring tools should not have to adhere to special conditions to include the header. Specifically, a header should have header guards and include all other headers it needs.
Prefer placing the definitions for template and inline functions in the same file as their declarations. The definitions of these constructs must be included into every .c or .cpp file that uses them, or the program may fail to link in some build configurations. If declarations and definitions are in different files, including the former should transitively include the latter.
As an exception, a template that is explicitly instantiated for all relevant sets of template arguments, or that is a private implementation detail of a class, is allowed to be defined in the one and only .c or .cpp file that instantiates the template.
There are rare cases where a file designed to be included is not self-contained. These are typically intended to be included at unusual locations, such as the middle of another file. They might not use header guards, and might not include their prerequisites. Use sparingly, and prefer self-contained headers when possible.
Make header files self-sufficient. Behave responsibly: Ensure that each header you write is compilable standalone, by having it include any headers its contents depend upon.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Header guard
A header must have a header guard. Use #pragma once to prevent a header file from being included more than once. Although it is not part of the standard, most of the relevant compilers support it. This is preferred over #ifndef way as it is more practical from users POV and also easier to change if needed.
Always write internal #include guards. Never write external #include guards. Wear head(er) protection: Prevent unintended multiple inclusions by using #include guards with unique names for all of your header files.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 7.6: ALL FILES CREATED THAT MAY BE INCLUDED MUST CONTAIN THE PREPROCESSOR STRUCTURE TO PREVENT MULTIPLE INCLUSIONS OF FILES.


Order of includes
Put headers first before any code.


?
Own header in case of cpp file
[empty line]
Other headers of the project
[empty line]
Framework files
[empty line]
Sack includes
[empty line]
Headers from third party libraries and frameworks (boost and gtest)
[empty line]
Standard CPP headers
[empty line]
Codes for this file

Entries in each group should be placed in alphabetical order (letters first, numerals second, symbols last (based on ASCII value)).
#include must be followed by a single space.
WaitLtcom_BB_2_ConfigDataRespHandler.cpp
?
#include "WaitLtcom_BB_2_ConfigDataRespHandler.hpp"
 
#include <actions/cells/hspa/SendCchhCellConfigurationDataResp.hpp>
#include <Logger.hpp>
#include <messages/builders/SCchhCellConfigDataRespBuilder.hpp>
#include <utils/AddressUtils.hpp>
 
#include <framework/utils/SMessageAddressComparator.hpp>
 
#include <EStatus.h>
 
#include <algorithm>

Exception to this rule: There are times when code needs conditional include. Such code can put conditional includes after other includes.
?
#include "foo.hpp"
 
#include <utils/XUtility.hpp>
 
#include <algorithm>
 
#ifdef MT
#include <MTLogger.hpp>
#elif
#include <Logger.hpp>
#endif
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 7.8: Put a blank line after a section of includes.
•	RULE 7.10: GROUP INCLUDE DIRECTIVES TOWARDS THE BEGINNING OF THE FILE, BEFORE ANY CODE.


Including C Headers
Specify C linkage for included C headers. This only applies if any function provided by the C Header is compiled as C (not C++).
?
// SomeIInterfaceIf.h
void bar()
{
    // . . .
}
 
  
// DomainCode.cpp
extern "C"
{
#include <SomeIInterfaceHeader.h> // No indent Class Data Members
}
 
void myFunc()
{
    bar();
}
?
// SSomeSackStructure.h
struct SSomeSackStructure
{
    // . . .
}
  
  
// AnotherCode.cpp
#include <SSomeSackStructure.h>
// C linkage specifier not needed for the above include
  
void foo()
{
    SSomeSackStructure payload;
    // . . .
}


Always use forward slash / as path separator
Examples:
?
// Good examples
#include <framework/Platform/PlatformWrapper.hpp>
#include <framework/Telecom/ERadParametersManager.hpp>
 
//Bad examples
#include <framework\Platform\PlatformWrapper.hpp>
#include <framework\Telecom\ERadParametersManager.hpp>


Forward Declarations
Avoid using forward declarations where possible. Instead, #include the headers you need.
Definition:
A "forward declaration" is a declaration of a class, function, or template without an associated definition.
Pros:
•	Forward declarations can save compile time, as #includes force the compiler to open more files and process more input.
•	Forward declarations can save on unnecessary recompilation. #includes can force your code to be recompiled more often, due to unrelated changes in the header.
Cons:
•	Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when headers change.
•	A forward declaration may be broken by subsequent changes to the library. Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as widening a parameter type, adding a template parameter with a default value, or migrating to a new namespace.
•	Forward declaring symbols from namespace std:: yields undefined behavior.
•	It can be difficult to determine whether a forward declaration or a full #include is needed. Replacing an #include with a forward declaration can silently change the meaning of code:
?
// b.h:
struct B {};
struct D : B {};
 
// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
 
//If the #include was replaced with forward decls for B and D, test() would call f(void*).

•	Forward declaring multiple symbols from a header can be more verbose than simply #includeing the header.
•	Structuring code to enable forward declarations (e.g. using pointer members instead of object members) can make the code slower and more complex.
Decision:
•	Try to avoid forward declarations of entities defined in another project.
•	When using a function declared in a header file, always #include that header.
•	When using a class template, prefer to #include its header file.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Inline Functions
Define functions inline only when they are small (10 lines or fewer).
Definition:
•	You can declare functions in a way that allows the compiler to expand them inline rather than calling them through the usual function call mechanism.
Pros:
•	Inlining a function can generate more efficient (in terms of performance) object code, as long as the inlined function is small. Feel free to inline accessors and mutators, and other short, performance-critical functions.
Cons:
•	Overuse of inlining can actually make programs slower. Depending on a function's size, inlining it can cause the code size to increase or decrease. Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size. On modern processors smaller code usually runs faster due to better use of the instruction cache.
•	A decent rule of thumb is to not inline a function if it is more than 10 lines long. Beware of destructors, which are often longer than they appear because of implicit member- and base-destructor calls!
•	Another useful rule of thumb: it's typically not cost effective to inline functions with loops or switch statements (unless, in the common case, the loop or switch statement is never executed).
•	It is important to know that functions are not always inlined even if they are declared as such; for example, virtual and recursive functions are not normally inlined. Usually recursive functions should not be inline. The main reason for making a virtual function inline is to place its definition in the class, either for convenience or to document its behavior, e.g., for accessors and mutators.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.43: Keep inline functions simple.


Don’t define entities with linkage in a header file
Repetition causes bloat: Entities with linkage, including namespace-level variables or functions, have memory allocated for them. Defining such entities in header files results in either link-time errors or memory waste. Put all entities with linkage in implementation files.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Each header file declares only one class.
The purpose of this recommendation is to make code more readable and promote reuse by keeping header files concise and consistent. This will also minimise the need for additional "unnecessary" header files and implementation that might be associated with the extraneous declarations.
However, there are several exceptions to this recommendation, e.g.:
•	If there are classes that are tightly coupled, e.g. a list class and a corresponding iterator class, it is advisable to declare them in the same header file.
•	Generated code does not usually follow this convention.

Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 5.4: Each header file declares only one class.


Name the header file (.hpp) after the class
The name of the file is the same as the name of the class: <Class name> + extension
Exception: When the include file contains both C and C++ code, and it can be compiled (using conditional compilation) with both C and C++ compilers, the extension shall be .h, like with normal C include file.

Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 5.5: NAME THE HEADER FILE (.hpp) AFTER THE CLASS.


In a header file, include (# include) only files that are essential for the declarations in it.
Only header files that are required for compilation of the declarations are included in the header file. Header files required for the implementation are included in the implementation file.
Exception: Also files that are needed for using the module may be included, e.g. error number definitions for the program block.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 7.1: IN A HEADER FILE, INCLUDE (#include) ONLY FILES THAT ARE ESSENTIAL FOR THE DECLARATIONS IN IT.


When including headers, prefer using angle brackets than using quotations. 
The paths in the angle brackets will refer to the included directories when compiling the file.
The paths in quotations will refer to the current directory.
The angle brackets are preferred so there will be less changes when transferring files to different locations (because there is less dependencies of the file path in the includes).
Exception: Exception to this are files that are guaranteed to be on the same location such as a paired header file (MyClass.hpp) and implementation file (My Class.cpp).
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 7.3: IN INCLUDE DIRECTIVES ENCLOSE HEADER FILES LOCATED IN THE CURRENT PROCESS OR LIBRARY DIRECTORY BETWEEN QUOTATION MARKS (" "), OTHERS BETWEEN ANGLE BRACKETS (< >).


Implementation Files 

Name the implementation file (.cpp) after the class.
The name of the file is the same as the name of the class: <Class name> + extension
The methods of one class can also be introduced in several source files. All of these source files are named after the class, but there is an additional marking at the end of the filename to separate the source files from each other: <Class name><separator> + extension.
The separator must use some text extension related to the group of methods and/or attributes defined in the source file.
For example:
•	AnyClass_PublicMethods.cpp
•	AnyClass_PrivateMethods.cpp
•	AnyClass_PrivateAttributes.cpp
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 5.7: NAME THE IMPLEMENTATION FILE (.CPP) AFTER THE CLASS.


The order of definitions in the implementation file follows the order of declarations in the header file.

Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 5.8: The order of definitions in the implementation file follows the order of declarations in the header file.


Keep the maximum amount of lines in the source files below 1000.
Although there is no maximum length requirement for source files, files with more than about 1000 lines are cumbersome to deal with. If it is necessary that a class implementation exceed 1000 lines, follow the rule and separate the implementation into different source files. In addition, check your design, files of that magnitude may indicate a need for re-design.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 5.9: Keep the maximum amount of lines in the source files below 1000.


In the implementation file, the first included file must be the header file of the own class.
Otherwise, it just might go unnoticed that the header file is not including all definitions it needs; the compilation still can succeed if the definitions are coming from the header files included before the own header file. This is especially bad if the header file is for example containing an interface for some library, and the users have to add extraneous include directives just to be able to use the library.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 7.9: In the implementation file, the first included file must be the header file of the own class.


Scoping 

Namespaces
Definition:
•	Namespaces subdivide the global scope into distinct, named scopes, and so are useful for preventing name collisions in the global scope.
Pros:
•	Namespaces provide a method for preventing name conflicts in large programs while allowing most code to use reasonably short names.
•	For example, if two different projects have a class Foo in the global scope, these symbols may collide at compile time or at runtime. If each project places their code in a namespace, project1::Foo and project2::Foo are now distinct symbols that do not collide, and code within each project's namespace can continue to refer to Foo without the prefix.
•	Inline namespaces automatically place their names in the enclosing scope. Consider the following snippet, for example:
?
namespace outer 
{
inline namespace inner 
{
  void foo();
}  // namespace inner
}  // namespace outer
 
// The expressions outer::inner::foo() and outer::foo() are interchangeable. Inline namespaces are primarily intended for ABI compatibility across versions.
Cons:
•	Namespaces can be confusing, because they complicate the mechanics of figuring out what definition a name refers to.
•	Inline namespaces, in particular, can be confusing because names aren't actually restricted to the namespace where they are declared. They are only useful as part of some larger versioning policy.
•	In some contexts, it's necessary to repeatedly refer to symbols by their fully-qualified names. For deeply-nested namespaces, this can add a lot of clutter.
Decision:
All code should belong to an adequate namespace. Follow the naming convention here. Terminate namespaces with comment as shown in the given example. Namespaces wrap the entire source file after includes and other definitions/declarations from other namespaces. When definitions in a source(cpp) file do not need to be referenced outside that file, place them in an unnamed namespace or declare them static. Do not use either of this constructs in header files.
Sample.hpp
?
#pragma once
#include <SMessageAddress.h>
namespace dmgr
{
TAaSysComNid getNid(SMessageAddress const& address);
...
} // namespace dmgr
Sample.cpp
?
#include "AddressUtils.hpp"
  
#include <framework/utils/AddressConverter.hpp>
  
#include <TMsgHeaderTypes.h>
  
namespace
{
constexpr TBoard INVALID_BOARD_ID = 0;
constexpr TCpu INVALID_CPU_ID = 0;
...
} // namespace
 
namespace dmgr
{
 
TAaSysComNid getNid(SMessageAddress const& address)
{
    return fw::addressToNid(address);
}
...
} // namespace dmgr
To avoid confusion whether a class or function implementation is actually part of a namespace or not, explicitly put this inside a namespace block (similar to the example above).
Bad
?
//Sample.hpp
namespace samplenamespace
{
           
class SampleClass
{           
public:            
    void sampleFunction();
};
  
} // samplenamespace
  
  
//Sample.cpp
#include "Sample.hpp"
  
using namespace samplenamespace;
  
void SampleClass::sampleFunction() // it is unclear which namespace SampleClass belongs to
{
...
}
•	Do not declare anything in namespace std, including forward declarations of standard library classes. Declaring entities in namespace std is undefined behavior, i.e., not portable. To declare entities from the standard library, include the appropriate header file.
•	Do not use Namespace aliases at namespace scope in header files, because anything imported into a namespace in a header file becomes part of the public API exported by that file.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.11: USE NAMESPACES. ONLY NAMESPACE NAMES SHOULD BE GLOBAL.


Unnamed Namespaces and Static Variables
When definitions in a .cpp file do not need to be referenced outside that file, place them in an unnamed namespace or declare them static. Do not use either of these constructs in .h/.hpp files.
Definition:
•	All declarations can be given internal linkage by placing them in unnamed namespaces. Functions and variables can also be given internal linkage by declaring them static. This means that anything you're declaring can't be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.
Decision:
•	Use of internal linkage in .cpp files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in .h/.hpp files.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html

Nonmember, Static Member, and Global Functions
Prefer placing nonmember functions in a namespace; use completely global functions rarely. Do not use a class simply to group static functions. Static methods of a class should generally be closely related to instances of the class or the class's static data.
Pros:
•	Nonmember and static member functions can be useful in some situations. Putting nonmember functions in a namespace avoids polluting the global namespace.
Cons:
•	Nonmember and static member functions may make more sense as members of a new class, especially if they access external resources or have significant dependencies.
Decision:
•	Sometimes it is useful to define a function not bound to a class instance. Such a function can be either a static member or a nonmember function. Nonmember functions should not depend on external variables, and should nearly always exist in a namespace. Do not create classes only to group static member functions; this is no different than just giving the function names a common prefix, and such grouping is usually unnecessary anyway.
•	If you define a nonmember function and it is only needed in its .cpp file, use internal linkage to limit its scope.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Local Variables
Place a function's variables in the narrowest scope possible, and initialize variables in the declaration.
C++ allows you to declare variables anywhere in a function. We encourage you to declare them in as local a scope as possible, and as close to the first use as possible. This makes it easier for the reader to find the declaration and see what type the variable is and what it was initialized to. In particular, initialization should be used instead of declaration and assignment, e.g.:
?
int i;
i = f();      // Bad -- initialization separate from declaration.
 
int j = g();  // Good -- declaration has initialization.
 
std::vector<int> v;
v.emplace_back(1);  // Prefer initializing using brace initialization.
v.emplace_back(2);
 
std::vector<int> v = {1, 2};  // Good -- v starts initialized.

Variables needed for if, while and for statements should normally be declared within those statements, so that such variables are confined to those scopes. E.g.:
?
while (const char* p = strchr(str, '/')) str = p + 1;
 
 
//There is one caveat: if the variable is an object, its constructor is invoked every time it enters scope and is created, and its destructor is invoked every time it goes out of scope.
// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) 
{
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
 
//It may be more efficient to declare such a variable used in a loop outside that loop:
Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) 
{
  f.DoSomething(i);
}
Declare variables as locally as possible. Avoid scope bloat, as with requirements so too with variables: Variables introduce state, and you should have to deal with as little state as possible, with lifetimes as short as possible.
Don't introduce a variable (or constant) before you need to use it. Limit the scope in which the variable can be used to only what is necessary. Also helps improves readability(especially in reviews).
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.2: Keep the scope of variables as small as possible.


Static and Global Variables
Objects with static storage duration are forbidden unless they are trivially destructible. Informally this means that the destructor does not do anything, even taking member and base destructors into account. More formally it means that the type has no user-defined or virtual destructor and that all bases and non-static members are trivially destructible. Static function-local variables may use dynamic initialization. Use of dynamic initialization for static class member variables or variables at namespace scope is discouraged, but allowed in limited circumstances; see below for details.
As a rule of thumb: a global variable satisfies these requirements if its declaration, considered in isolation, could be constexpr.
Definition:
Every object has a storage duration, which correlates with its lifetime. Objects with static storage duration live from the point of their initialization until the end of the program. Such objects appear as variables at namespace scope ("global variables"), as static data members of classes, or as function-local variables that are declared with the static specifier. Function-local static variables are initialized when control first passes through their declaration; all other objects with static storage duration are initialized as part of program start-up. All objects with static storage duration are destroyed at program exit (which happens before unjoined threads are terminated).
Initialization may be dynamic, which means that something non-trivial happens during initialization. (For example, consider a constructor that allocates memory, or a variable that is initialized with the current process ID.) The other kind of initialization is static initialization. The two aren't quite opposites, though: static initialization always happens to objects with static storage duration (initializing the object either to a given constant or to a representation consisting of all bytes set to zero), whereas dynamic initialization happens after that, if required.
Pros:
Global and static variables are very useful for a large number of applications: named constants, auxiliary data structures internal to some translation unit, command-line flags, logging, registration mechanisms, background infrastructure, etc.
Cons:
Global and static variables that use dynamic initialization or have non-trivial destructors create complexity that can easily lead to hard-to-find bugs. Dynamic initialization is not ordered across translation units, and neither is destruction (except that destruction happens in reverse order of initialization). When one initialization refers to another variable with static storage duration, it is possible that this causes an object to be accessed before its lifetime has begun (or after its lifetime has ended). Moreover, when a program starts threads that are not joined at exit, those threads may attempt to access objects after their lifetime has ended if their destructor has already run.
Globals clutter the code flow by introducing non trivial dependencies between different parts of code. They also make automated testing hard or sometimes impossible.
Decision:
•	Decision on destruction:
•	When destructors are trivial, their execution is not subject to ordering at all (they are effectively not "run"); otherwise we are exposed to the risk of accessing objects after the end of their lifetime. Therefore, we only allow objects with static storage duration if they are trivially destructible. Fundamental types (like pointers and int) are trivially destructible, as are arrays of trivially destructible types. Note that variables marked with constexpr are trivially destructible.
?
// Good examples
const int kNum = 10;  // allowed
 
struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // allowed
 
void foo()
{
  static const char* const kMessages[] = {"hello", "world"};  // allowed
}
 
// allowed: constexpr guarantees trivial destructor
constexpr std::array<int, 3> kArray = {{1, 2, 3}};
 
 
 
//Bad examples
// bad: non-trivial destructor
const std::string kFoo = "foo";
 
// bad for the same reason, even though kBar is a reference (theDo not use goto
// rule also applies to lifetime-extended temporary objects)
const std::string& kBar = StrCat("a", "b", "c");
 
void bar()
{
  // bad: non-trivial destructor
  static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
•	Decision on initialization
•	Initialization is a more complex topic. This is because we must not only consider whether class constructors execute, but we must also consider the evaluation of the initializer:
?
int n = 5;    // fine
int m = f();  // ? (depends on f)
Foo x;        // ? (depends on Foo::Foo)
Bar y = g();  // ? (depends on g and on Bar::Bar)
•	All but the first statement expose us to indeterminate initialization ordering.
•	The concept we are looking for is called constant initialization in the formal language of the C++ standard. It means that the initializing expression is a constant expression, and if the object is initialized by a constructor call, then the constructor must be specified as constexpr, too:
?
struct Foo { constexpr Foo(int) {} };
int n = 5;  // fine, 5 is a constant expression
Foo x(2);   // fine, 2 is a constant expression and the chosen constructor is constexpr
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // fine
•	Constant initialization is always allowed. Constant initialization of static storage duration variables should be marked with constexpr. Any non-local static storage duration variable that is not so marked should be presumed to have dynamic initialization, and reviewed very carefully.
•	By contrast, the following initializations are problematic:
?
// Bad examples
// Some declarations used below.
time_t time(time_t*);      // not constexpr!
int f();                   // not constexpr!
struct Bar { Bar() {} };
 
// Problematic initializations.
time_t m = time(nullptr);  // initializing expression not a constant expression
Foo y(f());                // ditto
Bar b;                     // chosen constructor Bar::Bar() not constexpr
•	Dynamic initialization of nonlocal variables is discouraged, and in general it is forbidden. However, we do permit it if no aspect of the program depends on the sequencing of this initialization with respect to all other initializations. Under those restrictions, the ordering of the initialization does not make an observable difference. For example:
?
int p = getpid();  // allowed, as long as no other static variable
                   // uses p in its own initialization
•	Dynamic initialization of static local variables is allowed (and common).
•	Common patterns:
•	Global variables usually are a symptom of a bad design. Context should be provided by the caller/create of a class.
•	Use Singleton design pattern if necessary.
•	Global strings: if you require a global or static string constant, consider using a simple character array, or a char pointer to the first element of a string literal. String literals have static storage duration already and are usually sufficient.
•	Maps, sets, and other dynamic containers: if you require a static, fixed collection, such as a set to search against or a lookup table, you cannot use the dynamic containers from the standard library as a static variable, since they have non-trivial destructors. Instead, consider a simple array of trivial types, e.g. an array of arrays of ints (for a "map from int to int"), or an array of pairs (e.g. pairs of int and const char*).  If necessary, keep the collection in sorted order and use a binary search algorithm. If you do really prefer a dynamic container from the standard library, consider using a function-local static pointer, as described below.
•	Smart pointers (unique_ptr, shared_ptr): smart pointers execute cleanup during destruction and are therefore forbidden. Consider whether your use case fits into one of the other patterns described in this section. One simple solution is to use a plain pointer to a dynamically allocated object and never delete it (see last item).
•	Static variables of custom types: if you require static, constant data of a type that you need to define yourself, give the type a trivial destructor and a constexpr constructor.
•	If all else fails, you can create an object dynamically and never delete it by using a function-local static pointer or reference (e.g. static const auto& impl = *new T(args...);
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 8.7: Avoid the use of global variables.
•	RECOMMENDATION 9.36: Static class member variables are initialised globally in the beginning of the implementation file (.cpp) using the global scope operator "::”.


Scoped enumeration
Prefer scoped enumeration over unscoped enumeration. Scoped enums are only visible within the enum. With this, naming of enumerators can be done in a smarter way(see Enumerator names). Also conversion to other types can happen only with an explicit cast.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Classes 

Be clear what kind of class you’re writing
Know thyself: There are different kinds of classes. Know which kind you are writing. The name of the class should be clear as well.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Prefer minimal classes to monolithic classes
Divide and conquer: Small classes are easier to write, get right, test, and use. They are also more likely to be usable in a variety of situations. Prefer such small classes that embody simple concepts instead of kitchen-sink classes that try to implement many and/or complex concepts.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Avoid virtual method calls in constructors, and avoid initialization that can fail if you can't signal an error.
Definition:
It is possible to perform arbitrary initialization in the body of the constructor.
Pros:
•	No need to worry about whether the class has been initialized or not.
•	Objects that are fully initialized by constructor call can be const and may also be easier to use with standard containers or algorithms.
Cons:
•	If the work calls virtual functions, these calls will not get dispatched to the subclass implementations. Future modification to your class can quietly introduce this problem even if your class is not currently subclassed, causing much confusion.
•	There is no easy way for constructors to signal errors, short of crashing the program (not always appropriate) or using exceptions (which are forbidden).
•	If the work fails, we now have an object whose initialization code failed, so it may be an unusual state requiring a bool IsValid() state checking mechanism (or similar) which is easy to forget to call.
•	You cannot take the address of a constructor, so whatever work is done in the constructor cannot easily be handed off to, for example, another thread.
Decision:
Constructors should never call virtual functions. If appropriate for your code , terminating the program may be an appropriate error handling response. Otherwise, consider a factory function or Init() method as described in TotW #42 . Avoid Init() methods on objects with no other states that affect which public methods may be called (semi-constructed objects of this form are particularly hard to work with correctly).
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Avoid calling virtual functions in constructors and destructors
Virtual functions only “virtually” always behave virtually: Inside constructors and destructors, they don’t. Worse, any direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior. If your design wants virtual dispatch into a derived class from a base class constructor or destructor, you need other techniques such as post-constructors.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.52: DO NOT CALL PURE VIRTUAL MEMBER FUNCTIONS FROM CONSTRUCTORS/DESTRUCTORS.


Avoid accessing global data in the constructors
Compilation order between constructors and global data is not defined in C++ standard, so accessing global data from constructors is not safe.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.40: DO NOT ACCESS GLOBAL DATA FROM THE CONSTRUCTOR.

Implicit Conversions
Do not define implicit conversions. Use the explicit keyword for conversion operators and single-argument constructors.
Consider overloading to avoid implicit type conversions. Do not multiply objects beyond necessity (Occam’s Razor): Implicit type conversions provide syntactic convenience. But when the work of creating temporary objects is unnecessary and optimization is appropriate, you can provide overloaded functions with signatures that match common argument types exactly and won’t cause conversions.
Definition:
Implicit conversions allow an object of one type (called the source type) to be used where a different type (called the destination type) is expected, such as when passing an int argument to a function that takes a double parameter.
In addition to the implicit conversions defined by the language, users can define their own, by adding appropriate members to the class definition of the source or destination type. An implicit conversion in the source type is defined by a type conversion operator named after the destination type (e.g. operator bool()). An implicit conversion in the destination type is defined by a constructor that can take the source type as its only argument (or only argument with no default value).
The explicit keyword can be applied to a constructor or (since C++11) a conversion operator, to ensure that it can only be used when the destination type is explicit at the point of use, e.g. with a cast. This applies not only to implicit conversions, but to C++11's list initialization syntax:
?
class Foo {
  explicit Foo(int x, double y);
  ...
};
 
void Func(Foo f);
 
Func({42, 3.14});  // Error
 
//This kind of code isn't technically an implicit conversion, but the language treats it as one as far as explicit is concerned.
Pros:
•	Implicit conversions can make a type more usable and expressive by eliminating the need to explicitly name a type when it's obvious.
•	Implicit conversions can be a simpler alternative to overloading, such as when a single function with a string_view parameter takes the place of separate overloads for std::string and const char*.
•	List initialization syntax is a concise and expressive way of initializing objects.
Cons:
•	Implicit conversions can hide type-mismatch bugs, where the destination type does not match the user's expectation, or the user is unaware that any conversion will take place.
•	Implicit conversions can make code harder to read, particularly in the presence of overloading, by making it less obvious what code is actually getting called.
•	Constructors that take a single argument may accidentally be usable as implicit type conversions, even if they are not intended to do so.
•	When a single-argument constructor is not marked explicit, there's no reliable way to tell whether it's intended to define an implicit conversion, or the author simply forgot to mark it.
•	It's not always clear which type should provide the conversion, and if they both do, the code becomes ambiguous.
•	List initialization can suffer from the same problems if the destination type is implicit, particularly if the list has only a single element.
Decision:
Type conversion operators, and constructors that are callable with a single argument, must be marked explicit in the class definition. As an exception, copy and move constructors should not be explicit, since they do not perform type conversion. Implicit conversions can sometimes be necessary and appropriate for types that are designed to transparently wrap other types. In that case, contact your project leads to request a waiver of this rule.
Constructors that cannot be called with a single argument may omit explicit. Constructors that take a single std::initializer_list parameter should also omit explicit, in order to support copy-initialization (e.g. MyType m = {1, 2};).
Avoid providing implicit conversions. Not all change is progress: Implicit conversions can often do more damage than good. Think twice before providing implicit conversions to and from the types you define, and prefer to rely on explicit conversions (explicit constructors and named conversion functions).
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Copyable and Movable Types
A class's public API must make clear whether the class is copyable, move-only, or neither copyable nor movable. Support copying and/or moving if these operations are clear and meaningful for your type.
Definitions:
•	A movable type is one that can be initialized and assigned from temporaries.
•	A copyable type is one that can be initialized or assigned from any other object of the same type (so is also movable by definition), with the stipulation that the value of the source does not change. std::unique_ptr<int> is an example of a movable but not copyable type (since the value of the source std::unique_ptr<int> must be modified during assignment to the destination). int and std::string are examples of movable types that are also copyable. (For int, the move and copy operations are the same; for std::string, there exists a move operation that is less expensive than a copy.)
•	For user-defined types, the copy behavior is defined by the copy constructor and the copy-assignment operator. Move behavior is defined by the move constructor and the move-assignment operator, if they exist, or by the copy constructor and the copy-assignment operator otherwise.
•	The copy/move constructors can be implicitly invoked by the compiler in some situations, e.g. when passing objects by value.
Pros:
•	Objects of copyable and movable types can be passed and returned by value, which makes APIs simpler, safer, and more general. Unlike when passing objects by pointer or reference, there's no risk of confusion over ownership, lifetime, mutability, and similar issues, and no need to specify them in the contract. It also prevents non-local interactions between the client and the implementation, which makes them easier to understand, maintain, and optimize by the compiler. Further, such objects can be used with generic APIs that require pass-by-value, such as most containers, and they allow for additional flexibility in e.g., type composition.
•	Copy/move constructors and assignment operators are usually easier to define correctly than alternatives like Clone(), CopyFrom() or Swap(), because they can be generated by the compiler, either implicitly or with = default. They are concise, and ensure that all data members are copied. Copy and move constructors are also generally more efficient, because they don't require heap allocation or separate initialization and assignment steps, and they're eligible for optimizations such as copy elision.
•	Move operations allow the implicit and efficient transfer of resources out of rvalue objects. This allows a plainer coding style in some cases.
Cons:
•	Some types do not need to be copyable, and providing copy operations for such types can be confusing, nonsensical, or outright incorrect. Types representing singleton objects (Registerer), objects tied to a specific scope (Cleanup), or closely coupled to object identity (Mutex) cannot be copied meaningfully. Copy operations for base class types that are to be used polymorphically are hazardous, because use of them can lead to object slicing. Defaulted or carelessly-implemented copy operations can be incorrect, and the resulting bugs can be confusing and difficult to diagnose.
•	Copy constructors are invoked implicitly, which makes the invocation easy to miss. This may cause confusion for programmers used to languages where pass-by-reference is conventional or mandatory. It may also encourage excessive copying, which can cause performance problems.
Decision:
•	Support copying and/or moving if these operations are clear and meaningful for your type. Otherwise, disable the implicitly generated special functions that perform copies and moves.
•	If the type is copyable, do not define move operations unless they are significantly more efficient than the corresponding copy operations. If the type is not copyable, but the correctness of a move is obvious to users of the type, make the type move-only by defining both of the move operations.
•	Every class's public interface must make clear which copy and move operations the class supports. This should usually take the form of explicitly declaring and/or deleting the appropriate operations in the public section of the declaration.
•	Specifically, a copyable class should explicitly declare the copy operations, a move-only class should explicitly declare the move operations, and a non-copyable/movable class should explicitly delete the copy operations. Explicitly declaring or deleting all four copy/move operations is permitted, but not required. If you provide a copy or move assignment operator, you must also provide the corresponding constructor.
?
class Copyable {
 public:
  Copyable(const Copyable& other) = default;
  Copyable& operator=(const Copyable& other) = default;
 
  // The implicit move operations are suppressed by the declarations above.
};
 
class MoveOnly
{
 public:
  MoveOnly(MoveOnly&& other);
  MoveOnly& operator=(MoveOnly&& other);
 
  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&) = delete;
  MoveOnly& operator=(const MoveOnly&) = delete;
};
 
class NotCopyableOrMovable 
{
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
  NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
      = delete;
 
  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
  NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
      = delete;
};
These declarations/deletions can be omitted only if they are obvious:
•	If the class has no private section, like a struct or an interface-only base class, then the copyability/movability can be determined by the copyability/movability of any public data members.
•	If a base class clearly isn't copyable or movable, derived classes naturally won't be either. An interface-only base class that leaves these operations implicit is not sufficient to make concrete subclasses clear.
•	Note that if you explicitly declare or delete either the constructor or assignment operation for copy, the other copy operation is not obvious and must be declared or deleted. Likewise for move operations.
A type should not be copyable/movable if the meaning of copying/moving is unclear to a casual user, or if it incurs unexpected costs. Move operations for copyable types are strictly a performance optimization and are a potential source of bugs and complexity, so avoid defining them unless they are significantly more efficient than the corresponding copy operations. If your type provides copy operations, it is recommended that you design your class so that the default implementation of those operations is correct. Remember to review the correctness of any defaulted operations as you would any other code.
Due to the risk of slicing, prefer to avoid providing a public assignment operator or copy/move constructor for a class that's intended to be derived from (and prefer to avoid deriving from a class with such members). If your base class needs to be copyable, provide a public virtual Clone() method, and a protected copy constructor that derived classes can use to implement it.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 9.    Copy constructors (C++ only)
•	Flawed copy assignment operators might corrupt an object which is copied to it. Take this into account when designing operations requiring or allowing objects to be copied into them. If the corruption is allowed to happen, it can lead to undefined behavior.


Prefer assignment operators to return a reference to *this.
Having an assignment operator to return a reference to *this:
•	protects user from not knowing where the temporary created during operation gets destroyed, and
•	allows one to declare the assignment operator's parameter as a reference to const, which is safer than just declaring it a reference.
If the returned reference is to be used as an assigned value, or in simple comparisons, it should be declared const.
If assignments of the type Object1=Object2=Object3 are needed, then the returned reference cannot be const. If, on the other hand, those kind of chained assignments are not wanted, declaring the returned reference as const prevents those from compiling.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.39: An assignment operator should return a reference to *this.


Using default functions in a class/struct
Use default instead of empty definition( { } ) to specify that a special member function should be auto generated.
?
class Sample
{
public:
    Sample(Sample const& s);
    Sample& operator=(Sample const& s) = default;
    ~Sample();
};


Deleting functions in a class/struct
Prefer deleted function to private undefined ones as it is a clearer way of expressing that a function cannot be used.
Bad
?
class NonCopyableClass
{
public:
...
private:
    NonCopyableClass(Sample const& s); // not defined
    NonCopyableClass& operator=(Sample const& s); // not defined
};
Good
?
class NonCopyableClass
{
public:
...
private:
    NonCopyableClass(Sample const& s) = delete;
    NonCopyableClass& operator=(Sample const& s) = delete;
};


Structs vs. Classes
Use a struct only for passive objects that carry data; everything else is a class.
The struct and class keywords behave almost identically in C++. We add our own semantic meanings to each keyword, so you should use the appropriate keyword for the data-type you're defining.
structs should be used for passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. All fields must be public, and accessed directly rather than through getter/setter methods. The struct must not have invariants that imply relationships between different fields, since direct user access to those fields may break those invariants. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, Initialize(), Reset().
If more functionality or invariants are required, a class is more appropriate. If in doubt, make it a class.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Structs vs. Pairs and Tuples
Prefer to use a struct instead of a pair or a tuple whenever the elements can have meaningful names.
While using pairs and tuples can avoid the need to define a custom type, potentially saving work when writing code, a meaningful field name will almost always be much clearer when reading code than .first, .second, or std::get<X>. While C++14's introduction of std::get<Type> to access a tuple element by type rather than index (when the type is unique) can sometimes partially mitigate this, a field name is usually substantially clearer and more informative than a type.
Pairs and tuples may be appropriate in generic code where there are not specific meanings for the elements of the pair or tuple. Their use may also be required in order to interoperate with existing code or APIs.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Inheritance
Composition is often more appropriate than inheritance. When using inheritance, make it public (when inheriting a class).
Definition:
When a sub-class inherits from a base class, it includes the definitions of all the data and operations that the base class defines. "Interface inheritance" is inheritance from a pure abstract base class (one with no state or defined methods); all other inheritance is "implementation inheritance".
Pros:
•	Implementation inheritance reduces code size by re-using the base class code as it specializes an existing type. Because inheritance is a compile-time declaration, you and the compiler can understand the operation and detect errors. Interface inheritance can be used to programmatically enforce that a class expose a particular API. Again, the compiler can detect errors, in this case, when a class does not define a necessary method of the API.
Cons:
•	For implementation inheritance, because the code implementing a sub-class is spread between the base and the sub-class, it can be more difficult to understand an implementation. The sub-class cannot override functions that are not virtual, so the sub-class cannot change implementation.
•	Multiple inheritance is especially problematic, because it often imposes a higher performance overhead (in fact, the performance drop from single inheritance to multiple inheritance can often be greater than the performance drop from ordinary to virtual dispatch), and because it risks leading to "diamond" inheritance patterns, which are prone to ambiguity, confusion, and outright bugs.
Decision:
•	All inheritance should be public. If you want to do private inheritance, you should be including an instance of the base class as a member instead.
•	Do not overuse implementation inheritance. Composition is often more appropriate. Try to restrict use of inheritance to the "is-a" case: Bar subclasses Foo if it can reasonably be said that Bar "is a kind of" Foo.
•	Limit the use of protected to those member functions that might need to be accessed from subclasses. Note that data members should be private.
•	Explicitly annotate overrides of virtual functions or virtual destructors with exactly one of an override or (less frequently) final specifier. Do not use virtual when declaring an override. Rationale: A function or destructor marked override or final that is not an override of a base class virtual function will not compile, and this helps catch common errors. The specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to determine if the function or destructor is virtual or not.
•	Multiple inheritance is permitted, but multiple implementation inheritance is strongly discouraged.
•	Prefer composition to inheritance. Avoid inheritance taxes: Inheritance is the second-tightest coupling relationship in C++, second only to friendship. Tight coupling is undesirable and should be avoided where possible. Therefore, prefer composition to inheritance unless you know that the latter truly benefits your design.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.53: Inheritance is used only when the new class is a special case of a more general class (subtyping). Aggregation is used when conceptually an object of a class consists of other objects.


Avoid inheriting from classes that were not designed to be base classes
Some people don’t want to have kids: Classes meant to be used standalone obey a different blueprint than base classes (see Item 32). Using a standalone class as a base is a serious design error and should be avoided. To add behavior, prefer to add nonmember functions instead of member functions (see Item 44). To add state, prefer composition instead of inheritance (see Item 34). Avoid inheriting from concrete base classes (if possible make it abstract base class).
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.54: If the class is to be used only as a base class, make it abstract (pure virtual).


Do not redefine an inherited non virtual function.
Redefining an inherited non-virtual function may cause objects to behave incorrectly. For template programming exceptions are allowed.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.50: DO NOT REDEFINE AN INHERITED NON-VIRTUAL FUNCTION.


Public inheritance is substitutability. Inherit, not to reuse, but to be reused
Know what: Public inheritance allows a pointer or reference to the base class to actually refer to an object of some derived class, without destroying code correctness and without needing to change existing code. Know why: Don’t inherit publicly to reuse code (that exists in the base class); inherit publicly in order to be reused (by existing code that already uses base objects polymorphically).
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Prefer providing abstract interfaces
Love abstract art: Abstract interfaces help you focus on getting an abstraction right without muddling it with implementation or state management details. Prefer to design hierarchies that implement abstract interfaces that model abstract concepts.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Pimpl judiciously
Overcome the language’s separation anxiety: C++ makes private members inaccessible, but not invisible. Where the benefits warrant it, consider making private members truly invisible using the Pimpl idiom to implement compiler firewalls and increase information hiding.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Practice safe overriding
Override responsibly: When overriding a virtual function, preserve substitutability; in particular, observe the function’s pre- and post-conditions in the base class. Don’t change default arguments of virtual functions. Prefer explicitly redeclaring overrides as virtual. Beware of hiding overloads in the base class.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Override keyword
Specify explicitly that a derived class function is supposed to override a base class version. This makes overriding errors detectable at compile time. You do not need to explicitly mark the overriding function as virtual.
?
class Base 
{
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &;
    virtual void mf4() const;
    virtual ~Base();
};
 
class Derived: public Base 
{
public:
    void mf1() const override;
    void mf2(int x) override;
    void mf3() & override;
    void mf4() const override;
};


Final keyword
A class which uses inheritance should be marked as final by default. Final keyword should be removed only in case when the class should be used further as a base class.
?
class ChangeHspaState final : public MessageHandlingAction<TC_CCHH_CELL_CONFIGURATION_DATA_REQ_MSG>
{
public:
    ChangeHspaState(fw::MessagePtr<TC_CCHH_CELL_CONFIGURATION_DATA_REQ_MSG> message);
    ActionPtr execute() override;
};


Destructors, deallocation, and swap never fail
Everything they attempt shall succeed: Never allow an error to be reported from a destructor, a resource deallocation function (e.g., operator delete), or a swap function. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ standard library.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Virtual Destructor
Polymorphic base classes should declare virtual destructors. If a class has any virtual functions, it should have a virtual destructor.
?
class Base
{
public:
    virtual ~Base();
    virtual void foo();
}
  
class Derived : public Base { . . . }
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.49: IF A CLASS HAS VIRTUAL FUNCTIONS OR IT IS A BASE CLASS, DECLARE THE DESTRUCTOR AS VIRTUAL.


Operator Overloading
Overload operators judiciously. Do not use user-defined literals.
Definition:
C++ permits user code to declare overloaded versions of the built-in operators using the operator keyword, so long as one of the parameters is a user-defined type. The operator keyword also permits user code to define new kinds of literals using operator"", and to define type-conversion functions such as operator bool().
Pros:
•	Operator overloading can make code more concise and intuitive by enabling user-defined types to behave the same as built-in types. Overloaded operators are the idiomatic names for certain operations (e.g. ==, <, =, and <<), and adhering to those conventions can make user-defined types more readable and enable them to interoperate with libraries that expect those names.
•	User-defined literals are a very concise notation for creating objects of user-defined types.
Cons:
•	Providing a correct, consistent, and unsurprising set of operator overloads requires some care, and failure to do so can lead to confusion and bugs.
•	Overuse of operators can lead to obfuscated code, particularly if the overloaded operator's semantics don't follow convention.
•	The hazards of function overloading apply just as much to operator overloading, if not more so.
•	Operator overloads can fool our intuition into thinking that expensive operations are cheap, built-in operations.
•	Finding the call sites for overloaded operators may require a search tool that's aware of C++ syntax, rather than e.g. grep.
•	If you get the argument type of an overloaded operator wrong, you may get a different overload rather than a compiler error. For example, foo < bar may do one thing, while &foo < &bar does something totally different.
•	Certain operator overloads are inherently hazardous. Overloading unary & can cause the same code to have different meanings depending on whether the overload declaration is visible. Overloads of &&, ||, and , (comma) cannot match the evaluation-order semantics of the built-in operators.
•	Operators are often defined outside the class, so there's a risk of different files introducing different definitions of the same operator. If both definitions are linked into the same binary, this results in undefined behavior, which can manifest as subtle run-time bugs.
•	User-defined literals (UDLs) allow the creation of new syntactic forms that are unfamiliar even to experienced C++ programmers, such as "Hello World"sv as a shorthand for std::string_view("Hello World"). Existing notations are clearer, though less terse.
•	Because they can't be namespace-qualified, uses of UDLs also require use of either using-directives (which we ban) or using-declarations (which we ban in header files except when the imported names are part of the interface exposed by the header file in question). Given that header files would have to avoid UDL suffixes, we prefer to avoid having conventions for literals differ between header files and source files.
Decision:
•	Define overloaded operators only if their meaning is obvious, unsurprising, and consistent with the corresponding built-in operators. For example, use | as a bitwise- or logical-or, not as a shell-style pipe.
•	Define operators only on your own types. More precisely, define them in the same headers, .cc files, and namespaces as the types they operate on. That way, the operators are available wherever the type is, minimizing the risk of multiple definitions. If possible, avoid defining operators as templates, because they must satisfy this rule for any possible template arguments. If you define an operator, also define any related operators that make sense, and make sure they are defined consistently. For example, if you overload <, overload all the comparison operators, and make sure < and > never return true for the same arguments.
•	Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if a < b compiles but b < a doesn't.
•	Don't go out of your way to avoid defining operator overloads. For example, prefer to define ==, =, and <<, rather than Equals(), CopyFrom(), and PrintTo(). Conversely, don't define operator overloads just because other libraries expect them. For example, if your type doesn't have a natural ordering, but you want to store it in a std::set, use a custom comparator rather than overloading <.
•	Do not overload &&, ||, , (comma), or unary &. Do not overload operator"", i.e. do not introduce user-defined literals. Do not use any such literals provided by others (including the standard library).
•	Avoid overloading &&, ||, or ,(comma). Wisdom means knowing when to refrain: The built-in &&, ||, and , (comma) enjoy special treatment from the compiler. If you overload them, they become ordinary functions with very different semantics, and this is a sure way to introduce subtle bugs and fragilities. Don’t overload these operators naïvely.
•	Type conversion operators are covered in the section on implicit conversions. The = operator is covered in the section on copy constructors. Overloading << for use with streams is covered in the section on streams. See also the rules on function overloading, which apply to operator overloading as well.
•	Preserve natural semantics for overloaded operators. Programmers hate surprises: Overload operators only for good reason, and preserve natural semantics; if that’s difficult, you might be misusing operator overloading.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.60: Avoid overloading and if you use it take care that the semantics of overloaded functions are similar.
•	RULE 9.62: NEVER OVERLOAD OPERATORS '&&', '||', OR ','.


Access Control
Make classes' data members private, unless they are constants. This simplifies reasoning about invariants, at the cost of some easy boilerplate in the form of accessors (usually const) if necessary.
Avoid declaring class members as public. Public member variables are not allowed because they would break the data encapsulation. The member variables are accessed through member functions that are declared public in the class declaration.
Make data members private, except in behaviorless aggregates (C-style structs). They’re none of your caller’s business: Keep data members private. Only in the case of simple C-style struct types that aggregate a bunch of values but don’t pretend to encapsulate or provide behavior, make all data members public. Avoid mixes of public and nonpublic data, which almost always signal a muddled design.
Don’t give away your internals. Don’t volunteer too much: Avoid returning handles to internal data managed by your class (avoid returning a non const reference of a class member), so clients won’t uncontrollably modify state that your object thinks it owns.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.31: DECLARE ALL CLASS MEMBERS EXPLICITLY public, protected OR private.
•	RULE 9.32: DECLARE CLASS MEMBER VARIABLES private OR protected (NOT public).
•	RULE 9.41: INTERFACE MEMBER FUNCTIONS (DECLARED public) MUST NOT RETURN A NON-CONST REFERENCE TO (OR ADDRESS OF) A MEMBER VARIABLE.
•	RECOMMENDATION 9.44: The member function that sets the value of a member variable is named 'setSomething' and the function that returns the value of the member variable 'getSomething', or ‘isSomething’ for boolean values.


Prefer writing nonmember nonfriend functions
Avoid membership fees: Where possible, prefer making functions nonmember nonfriends.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Define and initialize member variables in the same order (especially in the initializer list)
Agree with your compiler: Member variables are always initialized in the order they are declared in the class definition; the order in which you write them in the constructor initialization list is ignored. Make sure the constructor code doesn’t confusingly specify a different order.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Prefer initialization to assignment
Set once, use everywhere: In constructors, using initialization instead of assignment to set member variables prevents needless run-time work and takes the same amount of typing.
Note the difference between initialisation and assignment. Initialisation is done when the object is constructed. Assignment can take place only after the object has been constructed and possibly initialised.
Initialisation of all variables prevents the problems caused by using uninitialised variables. In that respect it does not usually make any difference whether the variable is initialised or assigned to but sometimes the initialisation order is significant: initialisation takes always place before assignment. It has some impact on performance too especially when we are initialising objects.
Sometimes maintaining good program structure in co-operation with performance requirements may require advanced ways to combine initialisation and assignment, such as resource or object pooling. In multi-threaded environments, special care has to be taken that such solutions are thread-safe.
Initialisation is the only alternative for constant variables (const) and references (&).
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.3: USE INITIALISATION INSTEAD OF ASSIGNMENT
•	RECOMMENDATION 9.35: Non-static member variables of a class are initialised in the constructor.


Do not write member function implementation in the class declaration.
Member functions defined in the class declaration are implicitly declared inline, which is not usually the intent. As the function size grows in the course of time, the readability of the class declaration suffers and inlining the function increases the size of the object code unnecessarily.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.42: DO NOT WRITE MEMBER FUNCTION IMPLEMENTATION IN THE CLASS DECLARATION.


Functions 

Write Short Functions
Prefer small and focused functions.
We recognize that long functions are sometimes appropriate, so no hard limit is placed on functions length. If a function exceeds about 40 lines or one screen fold, think about whether it can be broken up without harming the structure of the program.
Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code. Small functions are also easier to test.
You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in several different contexts, consider breaking up the function into smaller and more manageable pieces.
Avoid long functions. Avoid deep nesting. Short is better than long, flat is better than deep: Excessively long functions and nested code blocks are often caused by failing to give one function one cohesive responsibility, and both are usually solved by better refactoring.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.7: Keep functions short and clear.


Output Parameters
The output of a C++ function is naturally provided via a return value and sometimes via output parameters.
Prefer using return values over output parameters: they improve readability, and often provide the same or better performance. If output-only parameters are used, they should appear after input parameters.
Parameters are either input to the function, output from the function, or both. Input parameters are usually values or const references, while output and input/output parameters will be pointers to non-const.
When ordering function parameters, put all input-only parameters before any output parameters. In particular, do not add new parameters to the end of the function just because they are new; place new input-only parameters before the output parameters.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Specify the names of the parameters in the function declaration. The parameter names in the function declaration and definition must be the same.
Function declarations (prototypes) in a header file must be complete because the header file defines the module interface. Formal parameter names explain the purpose of arguments to the user of the module.
?
// Prototypes of a function:
 
int setXY( int const, int const ); // bad example
int setXY( int const coordinateX, int const coordinateY ); // good example
 
// Implementation of the same function:
int setXY( int const coordinateX, int const coordinateY )
{
// code implementation
}

Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.8: SPECIFY THE IDENTIFIERS OF FORMAL PARAMETERS IN THE FUNCTION DECLARATION. THE PARAMETER IDENTIFIERS IN FUNCTION DECLARATION AND DEFINITION MUST BE THE SAME.


Reference Arguments
All parameters passed by lvalue reference must be labeled const.
Definitions:
In C, if a function needs to modify a variable, the parameter must use a pointer, eg int foo(int *pval). In C++, the function can alternatively declare a reference parameter: int foo(int &val).
Pros:
Defining a parameter as reference avoids ugly code like (*pval)++. Necessary for some applications like copy constructors. Makes it clear, unlike with pointers, that a null pointer is not a possible value.
Cons:
References can be confusing, as they have value syntax but pointer semantics.
Decisions:
Within function parameter lists all references must be const:
?
void Foo(const std::string &in, std::string *out)
In fact it is a very strong convention that input arguments are values or const references while output arguments are pointers. Input parameters may be const pointers, but we never allow non-const reference parameters except when required by convention, e.g., swap().
However, there are some instances where using const T* is preferable to const T& for input parameters. For example:
•	You want to pass in a null pointer.
•	The function saves a pointer or reference to the input.
Remember that most of the time input parameters are going to be specified as const T&. Using const T* instead communicates to the reader that the input is somehow treated differently. So if you choose const T* rather than const T&, do so for a concrete reason; otherwise it will likely confuse readers by making them look for an explanation that doesn't exist.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Pass by value (const) vs. Pass by const reference
Pass non-primitive type arguments by reference to const to avoid expensive copying, while primitive type arguments should be passed by value (with const) since majority of these types are smaller than a reference and passing them by reference prevents compiler from optimization due to aliasing.

?
bool isDspInScope(Dsp const& dsp, TAaSysComNid const scope); //Dsp is a non primitive type, and TAaSysComNid is a primitive type (unsigned short)
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.47: IF A FUNCTION IS NOT MODIFYING THE VALUE OF AN ARGUMENT, DECLARE THE ARGUMENT AS CONST.
•	RULE 9.48: DECLARE OBJECT ARGUMENTS OF CLASS TYPE AS A REFERENCE (I.E. AS A REFERENCE OR POINTER) IN A FUNCTION.


Take parameters appropriately by value, (smart) pointer, or reference
Parameterize well: Distinguish among input, output, and input/output parameters, and between value and reference parameters. Take them appropriately.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.46: If a function is intended to modify the value of an argument (pass-by-reference), declare the argument as a reference.


Don’t write code that depends on the order of evaluation of function arguments
Keep (evaluation) order: The order in which arguments of a function are evaluated is unspecified (C++ Standard), so don’t rely on a specific ordering.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Function Overloading
Use overloaded functions (including constructors) only if a reader looking at a call site can get a good idea of what is happening without having to first figure out exactly which overload is being called.
Definition:
You may write a function that takes a const std::string& and overload it with another that takes const char*. However, in this case consider std::string_view instead.
?
class MyClass {
 public:
  void Analyze(const std::string &text);
  void Analyze(const char *text, size_t textlen);
}
Pros:
•	Overloading can make code more intuitive by allowing an identically-named function to take different arguments. It may be necessary for templatized code, and it can be convenient for Visitors.
•	Overloading based on const or ref qualification may make utility code more usable, more efficient, or both. (See TotW 148 for more.)
Cons:
•	If a function is overloaded by the argument types alone, a reader may have to understand C++'s complex matching rules in order to tell what's going on. Also many people are confused by the semantics of inheritance if a derived class overrides only some of the variants of a function.
Decision:
•	You may overload a function when there are no semantic differences between variants. These overloads may vary in types, qualifiers, or argument count. However, a reader of such a call must not need to know which member of the overload set is chosen, only that something from the set is being called. If you can document all entries in the overload set with a single comment in the header, that is a good sign that it is a well-designed overload set.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Consider overloading to avoid implicit type conversions
Do not multiply objects beyond necessity (Occam’s Razor): Implicit type conversions provide syntactic convenience (but see Item 40). But when the work of creating temporary objects is unnecessary and optimization is appropriate (see Item 8), you can provide overloaded functions with signatures that match common argument types exactly and won’t cause conversions.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Default Arguments
Default arguments are allowed on non-virtual functions when the default is guaranteed to always have the same value. Follow the same restrictions as for function overloading, and prefer overloaded functions if the readability gained with default arguments doesn't outweigh the downsides below.
Pros:
•	Often you have a function that uses default values, but occasionally you want to override the defaults. Default parameters allow an easy way to do this without having to define many functions for the rare exceptions. Compared to overloading the function, default arguments have a cleaner syntax, with less boilerplate and a clearer distinction between 'required' and 'optional' arguments.
Cons:
•	Defaulted arguments are another way to achieve the semantics of overloaded functions, so all the reasons not to overload functions apply.
•	The defaults for arguments in a virtual function call are determined by the static type of the target object, and there's no guarantee that all overrides of a given function declare the same defaults.
•	Default parameters are re-evaluated at each call site, which can bloat the generated code. Readers may also expect the default's value to be fixed at the declaration instead of varying at each call.
•	Function pointers are confusing in the presence of default arguments, since the function signature often doesn't match the call signature. Adding function overloads avoids these problems.
Decision:
•	Do not use default arguments on virtual functions, as virtual functions are dynamically bound are statically bound. Default arguments are banned on virtual functions, where they don't work properly, and in cases where the specified default might not evaluate to the same value depending on when it was evaluated. (For example, don't write void f(int n = counter++);.).
?
class Foo
{
public:
    virtual void bar(int a, int b = 2); //BAD
}
 
class Yee : public Foo
{
public:
    void bar(int a, int b = 7) override; //BAD. This will now work
}
  
...
  
Foo* foo = new Yee;
foo->bar(1); //Will call Foo::bar where b = 2
•	In some other cases, default arguments can improve the readability of their function declarations enough to overcome the downsides above, so they are allowed. When in doubt, use overloads.
•	[CO GUILD DECISION]: Prefer refactoring the code (create functions with different variants or with less arguments) rather than using default values.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.51: DO NOT REDEFINE AN INHERITED VIRTUAL FUNCTION'S DEFAULT PARAMETER VALUE.


Always define a return type for a function.
If the function does not return anything, please explicitly use "void" as the return type.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.12: ALWAYS DEFINE A RETURN TYPE FOR A FUNCTION.


Every implementation for functions having a non-void return type must return something.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.13: EVERY IMPLEMENTATION FOR FUNCTIONS HAVING NON-VOID RETURN TYPE MUST RETURN SOMETHING.


Trailing Return Type Syntax
Use trailing return types only where using the ordinary syntax (leading return types) is impractical or much less readable.
Definition:
C++ allows two different forms of function declarations. In the older form, the return type appears before the function name. For example:
?
int foo(int x)
The newer form, introduced in C++11, uses the auto keyword before the function name and a trailing return type after the argument list. For example, the declaration above could equivalently be written:
?
auto foo(int x) -> int
Pros:
•	The trailing return type is in the function's scope. This doesn't make a difference for a simple case like int but it matters for more complicated cases, like types declared in class scope or types written in terms of the function parameters.
•	Trailing return types are the only way to explicitly specify the return type of a lambda expression. In some cases the compiler is able to deduce a lambda's return type, but not in all cases. Even when the compiler can deduce it automatically, sometimes specifying it explicitly would be clearer for readers.
•	Sometimes it's easier and more readable to specify a return type after the function's parameter list has already appeared. This is particularly true when the return type depends on template parameters. For example:
?
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u);
versus
?
template <typename T, typename U>
decltype(declval<T&>() + declval<U&>()) add(T t, U u);
Cons:
•	Trailing return type syntax is relatively new and it has no analogue in C++-like languages such as C and Java, so some readers may find it unfamiliar.
•	Existing code bases have an enormous number of function declarations that aren't going to get changed to use the new syntax, so the realistic choices are using the old syntax only or using a mixture of the two. Using a single version is better for uniformity of style.
Decisions:
•	In most cases, continue to use the older style of function declaration where the return type goes before the function name. Use the new trailing-return-type form only in cases where it's required (such as lambdas) or where, by putting the type after the function's parameter list, it allows you to write the type in a much more readable way. The latter case should be rare; it's mostly an issue in fairly complicated template code, which is discouraged in most cases.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Prefer to have functions have one exit point (one return statement)
Code having more than one exit point can be difficult to debug and/or maintain. For extremely time critical applications, multiple returns may be permitted.
Every deviation from this recommendation must be clearly documented.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.15: All functions should have only one exit point (return statement).


Prefer to have the "restrict" qualifier for functions
When functions with restrict-qualified pointers as arguments are called, it must be ensured that the arguments do not share any memory area. Calling a function with restrict-qualified pointers in arguments will result in undefined behavior.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 4.    “restrict” qualifier for Functions


File Handling 

Identifying Files
It should not be assumed that a file stayed the same between two successive accesses.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 1.    Identifying Files


Avoid fopen()
open() shall be used instead of fopen() if available. If fopen() is used, special precautions have to be taken to be able to differentiate if a new file has been created or an existing one has been opened for writing. If a FILE stream is mandatorily needed, fdopen() can be used to associating it with the file descriptor returned by open().
The GNU C Library provides an additional way to make fopen() fail instead of opening an existing file by adding “x” to the mode-string. It shall be taken into account that this might complicate porting the code to other compilers.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 2.    Avoid fopen()


Minimal permissions
Files must be created with minimal access permissions fitting their intended use.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 3.    Minimal permissions


Use of path names
Path names derived from untrusted sources must be sanitized by OS-specific canonicalization methods and checked against white lists. Failure to do so properly could result in enabling an attacker to access unintended files.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 4.    Use of path names


Close unneeded file descriptors
Files must be closed when they are no longer needed. Failure to close files properly can lead to file descriptor leakage.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 5.    Close unneeded file descriptors


No simultaneous file access
A file must not be opened more than once at the same time.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 6.    No simultaneous file access


Operate in secure directories
Operations on files must be executed in secure directories with suitable permissions. Precautions should be in place to limit operations only to needed directories under all circumstances.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 7.    Operate in secure directories


Check for IO errors
All IO errors must be detected and handled properly, by checking the functions’ return values and acting accordingly. It must never be assumed that a function has succeeded, e.g. that a character has been read.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	FIL 8.    Check for IO errors
Other C++ guidelines 

Don’t take chances!
Any program should rely only on fully understood structures. Incorporating functionalities relying on undefined behavior is a very risky endeavor, and must not be done.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 1.    Don’t take chances!


Prefer compile- and link-time errors to run-time errors
Don’t put off ’til run time what you can do at build time: Prefer to write code that uses the compiler to check for invariants during compilation, instead of checking them at run time. Run-time checks are control- and data-dependent, which means you’ll seldom know whether they are exhaustive. In contrast, compile-time checking is not control- or data-dependent and typically offers higher degrees of confidence.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Write code that does not cause compiler warnings
Some compiler warnings indicates a problem in the code, so its better to avoid them.
Compiler warnings are indications of possible problem places. Find out what is the cause for the warning. If the warning is harmless add a piece of code that suppresses the warning and document it with comments.
When the software build is compiled for commissioning, there should not be any unnecessary warnings.
Compile cleanly at high warning levels. Take warnings to heart: Use your compiler’s highest warning level. Require clean (warning-free) builds. Understand all warnings. Eliminate warnings by changing your code, not by reducing the warning level.
When using gcc/g++ the option -Werror can be used to to treat warnings as errors and thus making it easier to fix the warnings.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.1: Write code that does not cause compiler warnings.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 2.    Compiler Warnings
•	Builds must be done with maximum possible compiler warning levels and each warning should be carefully evaluated to properly decide whether there is a reason to fix its cause.


Forbidden C++ Features
The following C++ features may not be used:
•	Compile-time rational numbers (<ratio>), because of concerns that it's tied to a more template-heavy interface style.
•	The <cfenv> and <fenv.h> headers, because many compilers do not support those features reliably.
•	The <filesystem> header, which does not have sufficient support for testing, and suffers from inherent security vulnerabilities.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Forbidden Functions
While it may be argued that the execution of the listed commands might be safe under some circumstances, exceptions may be done only if the alternative cannot be used for a valid reason or when there are severe arguments against using it.
Function	Reason	Alternative
strcpy()	No bounds checking	strncpy() or better other, more secure functions[1]

gets()	No bounds checking	fgets()
sprintf()	No bounds checking, format string attacks	snprintf()
strcat()	No bounds checking	strncat()or better other, more secure functions[2]

		
execlp(), execvp()	Executed command is searched in the PATH variable; this might lead to undesired command execution.	execv(), execl(), execle()
rand()	Returned pseudorandom numbers might be predictable	random() or better functions
fopen() – permitted when used with the GNU C Library “x” mode-string.	Not possible to differentiate if a new file has been crated or an old one was opened for writing. See FIL 2.	open(), maybe in connection with fdopen()

________________________________________
[1] If possible, strlcpy() should be used. See [STRLCPY] for more information.
[2] If possible, strlcat() should be used. See [STRLCPY] for more information.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	11    Appendix A – List of Forbidden Functions


Functions that need special attention
Special attention has to be paid when the following functions are used in NSN code. In code written by a 3rd party, special attention has to be paid to these functions during the code audit.
Function	Reason	Attention
scanf(), sscanf()	Possibly no bounds checking, format string attacks	Ensure that all %-directives fit the corresponding arguments variable types. “%s” directives are prohibited as they pose a great danger to overflow the target C-sting; use “%ns” where the maximum field width n is the size of the corresponding target argument minus one for the NULL terminator. Use of tainted (un-validated data from an untrusted source) in the format string is prohibited.
printf(), fprintf(), snprintf(), vfprintf(), vsprintf(), syslog()	Format string attacks	Use of tainted data in the format string is prohibited. Ensure that destination size arguments are correct.
strncpy(), fgets(), strncat()	May not NULL terminate	Always explicitly NULL-terminate the destination buffer.
execv(), execl(), execle()	Danger of command injection if the parameters are not hardcoded and thus can be influenced from the outside.	If the parameters are a result of external input (also including configuration files) they must always be checked against a white list.
memcpy()	Possible out of bounds writing	Ensure that the target memory area is allocated big enough.
strlen()	Unpredictable result if argument is not NULL terminated.	Always explicitly NULL-terminate C-strings.
sizeof()	Delivers bad results when applied to a pointer to an array.	Take care not to use carelessly.
system(), popen()	Calls command processor which could invoke additional unintended functionality. See MSC 13.	Use execv(), execl() or execle() if command processor is not needed.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	12    Appendix B – List of Functions Requiring Special Attention


Always initialize variables/class attributes with default value
Do not rely on the non-standard/compilator specific/random initial values of class members for all of the Boolean, enumeration, numeric types and complex types.
Random data assigned to class attribute can cause hard to find errors. This also makes code more predictable during debugging (one can assume that if member is not changed then its value is always the same).
Always initialize variables. Start with a clean slate: Uninitialized variables are a common source of bugs in C and C++ programs. Avoid such bugs by being disciplined about cleaning memory before you use it; initialize variables upon definition.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 5.    Memory and Variable initialization


Avoid initialization dependencies across compilation units
Keep (initialization) order: Namespace-level objects in different compilation units should never depend on each other for initialization, because their initialization order is undefined. Doing otherwise causes headaches ranging from mysterious crashes when you make small changes in your project to severe nonportability even to new releases of the same compiler.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Minimize definitional dependencies. Avoid cyclic dependencies
Don’t be over-dependent: Don’t #include a definition when a forward declaration will do.
Don’t be co-dependent: Cyclic dependencies occur when two modules depend directly or indirectly on one another. A module is a cohesive unit of release; modules that are interdependent are not really individual modules, but super-glued together into what’s really a larger module, a larger unit of release. Thus, cyclic dependencies work against modularity and are a bane of large projects. Avoid them.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Avoid using varargs (ellipsis).
Ellipses cause collapses: The ellipsis is a dangerous carryover from C. Avoid varargs, and use higher-level C++ constructs and libraries instead.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


If/else content
Prefer verbose conditional instead of relying on implicit boolean conversion.
?
Dsp* dspPtr;
int size;
vector<string> myVector;
boost::optional<Parameter> param;
   
if (dspPtr) {} //BAD. This statement is relying on implicit boolean conversion.
  
if (size) {} // BAD.
  
if (dspPtr != nullptr) {} //GOOD. From the conditional statement alone we know that dsp is a pointer.
  
  
if (size > 0) {} //GOOD.
  
if (myVector.empty()) {} //GOOD. No need to be explicit as empty() already returns bool.
  
if (param == boost::none) {} //GOOD. From this statement we can deduce that param probably is a boost::optional type.

If applicable in conditionals, the “if part” should be responsible for handling the expected path of execution and the “else part” for error handling.
Good
?
if (dsp != nullptr)
{
   dsp->setLcgId(LCG_1);
}
else
{
    warning() << “dsp does not exist” << flush();
}
Bad
?
if (dsp == nullptr)
{
    warning() << “dsp does not exist” << flush();
}
else
{
   dsp->setLcgId(LCG_1);
}

If the “if part” returns then “else” should still be used.
Good
?
if (dsp != nullptr)
{
    processMessage(*dsp);
    return true;
}
else
{
    warning() << “dsp does not exist” << flush();
    return false;
}
Bad
?
if (dsp)
{
    processMessage(*dsp);
    return true;
}
 
warning() << “dsp does not exist” << flush();
return false;

Exception to this rule: If the procedure has multiple points in which it can be interrupted by not fulfilling requirements then the “if part” can be responsible for stopping the procedure and it doesn’t have to be followed by “else part”:
Bad
?
void setDspToOriginal(TAaSysComNid nid)
{
    if (!isValidDsp(nid))
    {
        warning() << “Invalid dsp address in request” << flush();
        return;
    }
  
    DspPtr dsp = DB.getDsp(nid);
  
    if (!dsp)
    {
        warning() << “Dsp does not exist in database” << flush();
        return;
    }
  
    dsp->setMode(EDspMode_Original);
}


Switch vs If-Else
Prefer a switch-statement to an if-statement when there is a choice. It is more readable, efficient(A switch compares against constants and is usually better optimized than a series of tests in an if-then-else chain), and  switch is enables some heuristic consistency checking. For example, have all values of an enum been covered? If not, is there a default?
Good
?
switch (severityLevel)
{
case SeverityLevel::DEBUG:
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::Low));
    break;
case SeverityLevel::INFO:
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::Normal));
    break;
default:
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::High));
    break;
}
Bad
?
if (severityLevel == SeverityLevel::DEBUG)
{
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::Low));
}
else if (severityLevel == SeverityLevel::INFO)
{
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::Normal));
}
else
{
    (*output).setLogPriority(static_cast<EAaSysLogPriority>(LogPriority::High));
}


Range-based for loop
Prefer a range-for-statement to a for-statement when there is a choice. It is more readable, efficient and less error prone.
?
for (int i = 0; i < v.size(); ++i)   // bad
    cout << v[i] << '\n';
 
for (auto p = v.begin(); p != v.end(); ++p)   // bad
    cout << *p << '\n';
 
for (auto const& x : v)    // OK
    cout << x << '\n';
 
for (int i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for
    cout << v[i] + v[i - 1] << '\n';
 
for (int i = 0; i < v.size(); ++i) // possible side-effect: can't be a range-for
    cout << f(v, &v[i]) << '\n';
 
for (int i = 0; i < v.size(); ++i) // body messes with loop variable: can't be a range-for
{ 
    if (i % 2)
        ++i;   // skip even elements
    else
        cout << v[i] << '\n';
}
Note
Don't use expensive copies of the loop variable of a range-for loop:
?
for (string s : vs) // ...
This will copy each elements of vs into s. Better:
?
for (string& s : vs) // ...
Better still, if the loop variable isn't modified or copied:
?
for (string const& s : vs) // ...



Do not use goto
it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. Any program that uses a goto can be rewritten so that it doesn't need the goto.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.67: DO NOT USE goto.


Do not assume one type of endianness
SCT/HOST builds might use little-endian ordering. However, target builds might use big-endian/little-endian ordering.
Try to make your code neutral if there is possibility that multi-byte raw data you use is ordered using scheme different than the platform.
Note that C++ bitwise operators are not affected by the endianness.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.14: Do not assume the endian-ness of words in memory.


RAII and Smart Pointers
Manual memory management could be error prone(i.e. memory leaks), and also makes the code harder to maintain and read. To resolve this, use RAII objects that acquire resources in their constructors and release them in their destructors. Use already existing smart pointers for this if applicable: std::unique_ptr for exclusive ownership, std::shared_ptr for exclusive ownership and std::weak_ptr for std::shared_ptr like pointers that can dangle. For creation of these smart pointers use std::make_shared for std::shared_ptr while std::make_unique for std::unique_ptr.
Avoid the use of new and delete directly and instead wrap it in RAII/smart pointers.


Ownership and Smart Pointers
Prefer to have single, fixed owners for dynamically allocated objects. Prefer to transfer ownership with smart pointers.
Definition:
"Ownership" is a bookkeeping technique for managing dynamically allocated memory (and other resources). The owner of a dynamically allocated object is an object or function that is responsible for ensuring that it is deleted when no longer needed. Ownership can sometimes be shared, in which case the last owner is typically responsible for deleting it. Even when ownership is not shared, it can be transferred from one piece of code to another.
"Smart" pointers are classes that act like pointers, e.g. by overloading the * and -> operators. Some smart pointer types can be used to automate ownership bookkeeping, to ensure these responsibilities are met. std::unique_ptr is a smart pointer type introduced in C++11, which expresses exclusive ownership of a dynamically allocated object; the object is deleted when the std::unique_ptr goes out of scope. It cannot be copied, but can be moved to represent ownership transfer. std::shared_ptr is a smart pointer type that expresses shared ownership of a dynamically allocated object. std::shared_ptrs can be copied; ownership of the object is shared among all copies, and the object is deleted when the last std::shared_ptr is destroyed.
Pros:
•	It's virtually impossible to manage dynamically allocated memory without some sort of ownership logic.
•	Transferring ownership of an object can be cheaper than copying it (if copying it is even possible).
•	Transferring ownership can be simpler than 'borrowing' a pointer or reference, because it reduces the need to coordinate the lifetime of the object between the two users.
•	Smart pointers can improve readability by making ownership logic explicit, self-documenting, and unambiguous.
•	Smart pointers can eliminate manual ownership bookkeeping, simplifying the code and ruling out large classes of errors.
•	For const objects, shared ownership can be a simple and efficient alternative to deep copying.
Cons:
•	Ownership must be represented and transferred via pointers (whether smart or plain). Pointer semantics are more complicated than value semantics, especially in APIs: you have to worry not just about ownership, but also aliasing, lifetime, and mutability, among other issues.
•	The performance costs of value semantics are often overestimated, so the performance benefits of ownership transfer might not justify the readability and complexity costs.
•	APIs that transfer ownership force their clients into a single memory management model.
•	Code using smart pointers is less explicit about where the resource releases take place.
•	std::unique_ptr expresses ownership transfer using C++11's move semantics, which are relatively new and may confuse some programmers.
•	Shared ownership can be a tempting alternative to careful ownership design, obfuscating the design of a system.
•	Shared ownership requires explicit bookkeeping at run-time, which can be costly.
•	In some cases (e.g. cyclic references), objects with shared ownership may never be deleted.
•	Smart pointers are not perfect substitutes for plain pointers.
Decision:
•	If dynamic allocation is necessary, prefer to keep ownership with the code that allocated it. If other code needs access to the object, consider passing it a copy, or passing a pointer or reference without transferring ownership. Prefer to use std::unique_ptr to make ownership transfer explicit. For example:
?
std::unique_ptr<Foo> FooFactory();
void FooConsumer(std::unique_ptr<Foo> ptr)
•	Do not design your code to use shared ownership without a very good reason. One such reason is to avoid expensive copy operations, but you should only do this if the performance benefits are significant, and the underlying object is immutable (i.e. std::shared_ptr<const Foo>). If you do use shared ownership, prefer to use std::shared_ptr.
•	Never use std::auto_ptr. Instead, use std::unique_ptr.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM51-CPP: Properly deallocate dynamically allocated resources


Avoid allocating and deallocating memory in different modules
Put things back where you found them: Allocating memory in one module and deallocating it in a different module makes your program fragile by creating a subtle long-distance dependency between those modules. They must be compiled with the same compiler version and same flags (notably debug vs. NDEBUG) and the same standard library implementation, and in practice the module allocating the memory had better still be loaded when the deallocation happens.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Rvalue References
Use rvalue references to:
•	Define move constructors and move assignment operators.
•	Define overload sets with const& and && variants if you have evidence that this provides meaningfully better performance than passing by value, or if you're writing low-overhead generic code that needs to support arbitrary types. Beware combinatorial overload sets, that is, seldom overload more than one parameter.
•	Support 'perfect forwarding' in generic code.
Definition:
•	Rvalue references are a type of reference that can only bind to temporary objects. The syntax is similar to traditional reference syntax. For example, void f(std::string&& s); declares a function whose argument is an rvalue reference to a std::string.
•	When the token '&&' is applied to an unqualified template argument in a function parameter, special template argument deduction rules apply. Such a reference is called forwarding reference.
Pros:
•	Defining a move constructor (a constructor taking an rvalue reference to the class type) makes it possible to move a value instead of copying it. If v1 is a std::vector<std::string>, for example, then auto v2(std::move(v1)) will probably just result in some simple pointer manipulation instead of copying a large amount of data. In many cases this can result in a major performance improvement.
•	Rvalue references make it possible to implement types that are movable but not copyable, which can be useful for types that have no sensible definition of copying but where you might still want to pass them as function arguments, put them in containers, etc.
•	std::move is necessary to make effective use of some standard-library types, such as std::unique_ptr.
•	Forwarding references which use the rvalue reference token, make it possible to write a generic function wrapper that forwards its arguments to another function, and works whether or not its arguments are temporary objects and/or const. This is called 'perfect forwarding'.
Cons:
•	Rvalue references are not yet widely understood. Rules like reference collapsing and the special deduction rule for forwarding references are somewhat obscure.
•	Rvalue references are often misused. Using rvalue references is counter-intuitive in signatures where the argument is expected to have a valid specified state after the function call, or where no move operation is performed.
Decision:
•	You may use rvalue references to define move constructors and move assignment operators (as described in Copyable and Movable Types). See the C++ Primer for more information about move semantics and std::move.
•	You may use rvalue references to define pairs of overloads, one taking Foo&& and the other taking const Foo&. Usually the preferred solution is just to pass by value, but an overloaded pair of functions sometimes yields better performance and is sometimes necessary in generic code that needs to support a wide variety of types. As always: if you're writing more complicated code for the sake of performance, make sure you have evidence that it actually helps.
•	You may use forwarding references in conjunction with std::forward, to support perfect forwarding.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Friends
We allow use of friend classes and functions, within reason.
Friends should usually be defined in the same file so that the reader does not have to look in another file to find uses of the private members of a class. A common use of friend is to have a FooBuilder class be a friend of Foo so that it can construct the inner state of Foo correctly, without exposing this state to the world. In some cases it may be useful to make a unittest class a friend of the class it tests.
Friends extend, but do not break, the encapsulation boundary of a class. In some cases this is better than making a member public when you want to give only one other class access to it. However, most classes should interact with other classes solely through their public members.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.66: Avoid using friend functions or classes.


Exceptions
We do not use C++ exceptions.
Pros:
•	Exceptions allow higher levels of an application to decide how to handle "can't happen" failures in deeply nested functions, without the obscuring and error-prone bookkeeping of error codes.
•	Exceptions are used by most other modern languages. Using them in C++ would make it more consistent with Python, Java, and the C++ that others are familiar with.
•	Some third-party C++ libraries use exceptions, and turning them off internally makes it harder to integrate with those libraries.
•	Exceptions are the only way for a constructor to fail. We can simulate this with a factory function or an Init() method, but these require heap allocation or a new "invalid" state, respectively.
•	Exceptions are really handy in testing frameworks.
Cons:
•	When you add a throw statement to an existing function, you must examine all of its transitive callers. Either they must make at least the basic exception safety guarantee, or they must never catch the exception and be happy with the program terminating as a result. For instance, if f() calls g() calls h(), and h throws an exception that f catches, g has to be careful or it may not clean up properly.
•	More generally, exceptions make the control flow of programs difficult to evaluate by looking at code: functions may return in places you don't expect. This causes maintainability and debugging difficulties. You can minimize this cost via some rules on how and where exceptions can be used, but at the cost of more that a developer needs to know and understand.
•	Exception safety requires both RAII and different coding practices. Lots of supporting machinery is needed to make writing correct exception-safe code easy. Further, to avoid requiring readers to understand the entire call graph, exception-safe code must isolate logic that writes to persistent state into a "commit" phase. This will have both benefits and costs (perhaps where you're forced to obfuscate code to isolate the commit). Allowing exceptions would force us to always pay those costs even when they're not worth it.
•	Turning on exceptions adds data to each binary produced, increasing compile time (probably slightly) and possibly increasing address space pressure.
•	The availability of exceptions may encourage developers to throw them when they are not appropriate or recover from them when it's not safe to do so. For example, invalid user input should not cause exceptions to be thrown. We would need to make the style guide even longer to document these restrictions!
Decision:
•	On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.
•	Given that Google's existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don't believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.
•	Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we'd like to use our open-source projects at Google and it's difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.
•	This prohibition also applies to the exception handling related features added in C++11, such as std::exception_ptr and std::nested_exception.
•	There is an exception to this rule (no pun intended) for Windows code.
•	[CO GUILD DECISION]: We do not use C++ exceptions.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	9.12 Exceptions:
•	There is still some controversy in NSN when, how and why to use exceptions. That's why in this Guide there is, for example, no rule to prefer exceptions to return codes. Those matters are left to specific product programs to decide. Only some general rules and recommendations are given.


noexcept
Specify noexcept when it is useful and correct.
Definition:
The noexcept specifier is used to specify whether a function will throw exceptions or not. If an exception escapes from a function marked noexcept, the program crashes via std::terminate.
The noexcept operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.
Pros:
•	Specifying move constructors as noexcept improves performance in some cases, e.g. std::vector<T>::resize() moves rather than copies the objects if T's move constructor is noexcept.
•	Specifying noexcept on a function can trigger compiler optimizations in environments where exceptions are enabled, e.g. compiler does not have to generate extra code for stack-unwinding, if it knows that no exceptions can be thrown due to a noexcept specifier.
Cons:
•	In projects following this guide that have exceptions disabled it is hard to ensure that noexcept specifiers are correct, and hard to define what correctness even means.
•	It's hard, if not impossible, to undo noexcept because it eliminates a guarantee that callers may be relying on, in ways that are hard to detect.
Decision:
You may use noexcept when it is useful for performance if it accurately reflects the intended semantics of your function, i.e. that if an exception is somehow thrown from within the function body then it represents a fatal error. You can assume that noexcept on move constructors has a meaningful performance benefit. If you think there is significant performance benefit from specifying noexcept on some other function, please discuss it with your project leads.
Prefer unconditional noexcept if exceptions are completely disabled (i.e. most Google C++ environments). Otherwise, use conditional noexcept specifiers with simple conditions, in ways that evaluate false only in the few cases where the function could potentially throw. The tests might include type traits check on whether the involved operation might throw (e.g. std::is_nothrow_move_constructible for move-constructing objects), or on whether allocation can throw (e.g. absl::default_allocator_is_nothrow for standard default allocation). Note in many cases the only possible cause for an exception is allocation failure (we believe move constructors should not throw except due to allocation failure), and there are many applications where it’s appropriate to treat memory exhaustion as a fatal error rather than an exceptional condition that your program should attempt to recover from. Even for other potential failures you should prioritize interface simplicity over supporting all possible exception throwing scenarios: instead of writing a complicated noexcept clause that depends on whether a hash function can throw, for example, simply document that your component doesn’t support hash functions throwing and make it unconditionally noexcept.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Run-Time Type Information (RTTI)
Avoid using Run Time Type Information (RTTI).
Definition:
RTTI allows a programmer to query the C++ class of an object at run time. This is done by use of typeid or dynamic_cast.
Pros:
•	The standard alternatives to RTTI (described below) require modification or redesign of the class hierarchy in question. Sometimes such modifications are infeasible or undesirable, particularly in widely-used or mature code.
•	RTTI can be useful in some unit tests. For example, it is useful in tests of factory classes where the test has to verify that a newly created object has the expected dynamic type. It is also useful in managing the relationship between objects and their mocks.
•	RTTI is useful when considering multiple abstract objects. Consider:
?
bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) 
{
  Derived* that = dynamic_cast<Derived*>(other);
  if (that == nullptr)
    return false;
  ...
Cons:
•	Querying the type of an object at run-time frequently means a design problem. Needing to know the type of an object at runtime is often an indication that the design of your class hierarchy is flawed.
•	Undisciplined use of RTTI makes code hard to maintain. It can lead to type-based decision trees or switch statements scattered throughout the code, all of which must be examined when making further changes.
Decision:
RTTI has legitimate uses but is prone to abuse, so you must be careful when using it. You may use it freely in unittests, but avoid it when possible in other code. In particular, think twice before using RTTI in new code. If you find yourself needing to write code that behaves differently based on the class of an object, consider one of the following alternatives to querying the type:
•	Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself.
•	If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system.
When the logic of a program guarantees that a given instance of a base class is in fact an instance of a particular derived class, then a dynamic_cast may be used freely on the object. Usually one can use a static_cast as an alternative in such situations.
Decision trees based on type are a strong indication that your code is on the wrong track.
?
// Bad code
if (typeid(*data) == typeid(D1)) 
{
  ...
} 
else if (typeid(*data) == typeid(D2)) 
{
  ...
} 
else if (typeid(*data) == typeid(D3)) 
{
...

Code such as this usually breaks when additional subclasses are added to the class hierarchy. Moreover, when properties of a subclass change, it is difficult to find and modify all the affected code segments.
Do not hand-implement an RTTI-like workaround. The arguments against RTTI apply just as much to workarounds like class hierarchies with type tags. Moreover, workarounds disguise your true intent.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Casting
Use C++-style casts like static_cast<float>(double_value), or brace initialization for conversion of arithmetic types like int64 y = int64{1} << 42. Do not use cast formats like int y = (int)x or int y = int(x) (but the latter is okay when invoking a constructor of a class type).
?
SFaultInd& faultInd = *(SFaultInd*)outgoingMsg.getPayload(); // BAD
  
SFaultInd& faultInd = *static_cast<SFaultInd*>(outgoingMsg.getPayload()); // GOOD
                                                                          // getPayload returns void*
Definition:
C++ introduced a different cast system from C that distinguishes the types of cast operations.
Pros:
•	The problem with C casts is the ambiguity of the operation; sometimes you are doing a conversion (e.g., (int)3.5) and sometimes you are doing a cast (e.g., (int)"hello"). Brace initialization and C++ casts can often help avoid this ambiguity. Additionally, C++ casts are more visible when searching for them.
Cons:
•	The C++-style cast syntax is verbose and cumbersome.
Decision:
•	Do not use C-style casts. Instead, use these C++-style casts when explicit type conversion is necessary.
•	Use brace initialization to convert arithmetic types (e.g. int64{x}). This is the safest approach because code will not compile if conversion can result in information loss. The syntax is also concise.
•	Use static_cast as the equivalent of a C-style cast that does value conversion, when you need to explicitly up-cast a pointer from a class to its superclass, or when you need to explicitly cast a pointer from a superclass to a subclass. In this last case, you must be sure your object is actually an instance of the subclass.
•	Use const_cast to remove the const qualifier (see const).
•	[CO GUILD DECISION] using const cast typically indicates a design issue.
•	In general need for const_cast<> should be considered as indication of bad design. Const_cast<> usage is allowed but only in well explained conditions.
•	Note that:
•	
•	If there is problem with passing char const * to function/method that require char* (e.g. legacy function/method requires such call), then copy should be made whenever possible.
•	std::string::.c_str() result not be passed through const_cast<> to function expecting char* since one can not be sure that this funciton is not going to change the buffer (and this will break std::string depending on the specific implementation).

•	Use reinterpret_cast to do unsafe conversions of pointer types to and from integer and other pointer types. Use this only if you know what you are doing and you understand the aliasing issues.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.65: Use C++ type conversion.
•	RECOMMENDATION 11.12: Do not use REINTERPRET_CAST<>.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 9.    Usage of casts
•	All data shall be cast to the right type before operating on it. Failing to cast the data to correct types before operating on them will produce undefined behavior.
•	Naturally, casting has to be done with care to make sure not to have undesired results. A developer must consider the reasons why the data is stored in a specific type. Special attention must be paid when casting to narrower types.
•	“const” qualifications shall be preserved during casts. Failure to do so would result in undefined behavior.
•	When using C++, C-style casts shall be avoided as C++ casts provide added checking options.


Preincrement and Predecrement
Use prefix form (++i) of the increment and decrement operators with iterators and other template objects.
Definition:
When a variable is incremented (++i or i++) or decremented (--i or i--) and the value of the expression is not used, one must decide whether to preincrement (decrement) or postincrement (decrement).
Pros:
•	When the return value is ignored, the "pre" form (++i) is never less efficient than the "post" form (i++), and is often more efficient. This is because post-increment (or decrement) requires a copy of i to be made, which is the value of the expression. If i is an iterator or other non-scalar type, copying i could be expensive. Since the two types of increment behave the same when the value is ignored, why not just always pre-increment?
Cons:
•	The tradition developed, in C, of using post-increment when the expression value is not used, especially in for loops. Some find post-increment easier to read, since the "subject" (i) precedes the "verb" (++), just like in English.
Decisions:
•	For simple scalar (non-object) values there is no reason to prefer one form and we allow either. For iterators and other template types, use pre-increment.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Constants should be defined as constant variables (constexpr) or enumerated constants (enum), not as preprocessor macros (#define).
The major advantages of using constant variables and enumerated constants are that they follow normal scope rules and type checking is also done in compilation.
Preprocessor macros are always defined in file scope; constants can be defined globally or in class scope. Constants also have types, which means that the whole type checking of the compiler is available which is of great importance for detecting inconsistencies and using overloading. The preprocessor macro identifiers will not be available in debugger because they are textually replaced with their values in the preprocessing phase.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.16: CONSTANTS ARE DEFINED AS CONSTANT VARIABLES (const) OR ENUMERATED CONSTANTS (enum), NOT AS PREPROCESSOR MACROS (#define).


Use of const
Note
const should be specified both in function signature and definition.
?
void foo(int const a, int const b, int const c, string const d); // function signature
  
void foo(int const a, int const b, int const c, string const d) //function definition
{
...
}
In APIs, use const whenever it makes sense. constexpr is a better choice for some uses of const.
Definition:
•	Declared variables and parameters can be preceded by the keyword const to indicate the variables are not changed (e.g., const int foo). Class functions can have the const qualifier to indicate the function does not change the state of the class member variables (e.g., class Foo { int Bar(char c) const; };).
Pros:
•	Easier for people to understand how variables are being used. Allows the compiler to do better type checking, and, conceivably, generate better code. Helps people convince themselves of program correctness because they know the functions they call are limited in how they can modify your variables. Helps people know what functions are safe to use without locks in multi-threaded programs.
Cons:
•	const is viral: if you pass a const variable to a function, that function must have const in its prototype (or the variable will need a const_cast). This can be a particular problem when calling library functions.
Decision:
We strongly recommend using const in APIs (i.e. on function parameters, methods, and non-local variables) wherever it is meaningful and accurate. This provides consistent, mostly compiler-verified documentation of what objects an operation can mutate. Having a consistent and reliable way to distinguish reads from writes is critical to writing thread-safe code, and is useful in many other contexts as well. In particular:
•	Declare methods to be const whenever possible. It should be const if they do not modify any data members, do not call any non-const methods, and do not return a non-const pointer or non-const reference to a data member.
•	Variables should be const if they do not need to be modified after initialization.
•	if value can be determine at compile time, prefer constexpr
•	If a function guarantees that it will not modify an argument passed by reference or by pointer, the corresponding function parameter should be a reference-to-const (T const&) or pointer-to-const (T const*), respectively. For the latter, if pointer will not be used to point to another object then it should be const too(T const*const)
All of a class's const operations should be safe to invoke concurrently with each other. If that's not feasible, the class must be clearly documented as "thread-unsafe".
Use const proactively. const is your friend: Immutable values are easier to understand, track, and reason about, so prefer constants over variables wherever it is sensible and make const your default choice when you define a value: It’s safe, it’s checked at compile time, and it’s integrated with C++’s type system. Don’t cast away const except to call a const-incorrect function.
Where to put the const:
•	Prefer to put const after the type. Please see the formatting section.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.45: IF A MEMBER FUNCTION DOES NOT ALTER THE MEMBER VARIABLES OF THE OBJECT, DECLARE THE FUNCTION const.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 8.    Qualify immutable objects with “const”


Use of constexpr
Use constexpr to define true constants or to ensure constant initialization.
Definition:
Some variables can be declared constexpr to indicate the variables are true constants, i.e. fixed at compilation/link time. Some functions and constructors can be declared constexpr which enables them to be used in defining a constexpr variable.
Pros:
•	Use of constexpr enables definition of constants with floating-point expressions rather than just literals; definition of constants of user-defined types; and definition of constants with function calls.
Cons:
•	Prematurely marking something as constexpr may cause migration problems if later on it has to be downgraded. Current restrictions on what is allowed in constexpr functions and constructors may invite obscure workarounds in these definitions.
Decision:
•	constexpr definitions enable a more robust specification of the constant parts of an interface. Use constexpr to specify true constants and the functions that support their definitions. Avoid complexifying function definitions to enable their use with constexpr. Do not use constexpr to force inlining.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Magic Numbers are not allowed
Every time there is a need to use constant numeric value, define constant (or enum if more suitable). Do not hardcode numeric values taken out of nowhere.
Avoid magic numbers. Programming isn’t magic, so don’t incant it: Avoid spelling literal constants like 42 or 3.14159 in code. They are not self-explanatory and complicate maintenance by adding a hard-to-detect form of duplication. Use symbolic names and expressions instead, such as width * aspectRatio.
Sample.hpp
?
float factor = ((a1 * 75.0F) / 80.0F) + 25.0F; // WRONG
 
float const windSpeed = 75;
float const otherFact = 80;
float const coefficient = 25;
float factor = (a1 * windSpeed) / otherFact) + coefficient; // GOOD
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.17: DO NOT USE MAGIC NUMBERS.


Integer Types
Of the built-in C++ integer types, the only one used is int. If a program needs a variable of a different size, use a precise-width integer type from <stdint.h>, such as int16_t. If your variable represents a value that could ever be greater than or equal to 2^31 (2GiB), use a 64-bit type such as int64_t. Keep in mind that even if your value won't ever be too large for an int, it may be used in intermediate calculations which may require a larger type. When in doubt, choose a larger type.
Definition:
C++ does not specify the sizes of integer types like int. Typically people assume that short is 16 bits, int is 32 bits, long is 32 bits and long long is 64 bits.
Pros:
•	Uniformity of declaration.
Cons:
•	The sizes of integral types in C++ can vary based on compiler and architecture.
Decision:
•	<cstdint> defines types like int16_t, uint32_t, int64_t, etc. You should always use those in preference to short, unsigned long long and the like, when you need a guarantee on the size of an integer. Of the C integer types, only int should be used. When appropriate, you are welcome to use standard types like size_t and ptrdiff_t.
•	We use int very often, for integers we know are not going to be too big, e.g., loop counters. Use plain old int for such things. You should assume that an int is at least 32 bits, but don't assume that it has more than 32 bits. If you need a 64-bit integer type, use int64_t or uint64_t.
•	For integers we know can be "big", use int64_t.
•	You should not use the unsigned integer types such as uint32_t, unless there is a valid reason such as representing a bit pattern rather than a number, or you need defined overflow modulo 2^N. In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.
•	If your code is a container that returns a size, be sure to use a type that will accommodate any possible usage of your container. When in doubt, use a larger type rather than a smaller type.
•	Use care when converting integer types. Integer conversions and promotions can cause undefined behavior, leading to security bugs and other problems.
On unsigned integers:
•	Unsigned integers are good for representing bitfields and modular arithmetic. Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point. The fact that unsigned arithmetic doesn't model the behavior of a simple integer, but is instead defined by the standard to model modular arithmetic (wrapping around on overflow/underflow), means that a significant class of bugs cannot be diagnosed by the compiler. In other cases, the defined behavior impedes optimization.
•	That said, mixing signedness of integer types is responsible for an equally large class of problems. The best advice we can provide: try to use iterators and containers rather than pointers and sizes, try not to mix signedness, and try to avoid unsigned types (except for representing bitfields or modular arithmetic). Do not use an unsigned type merely to assert that a variable is non-negative.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.5: Do not assume that an int and a long have the same size.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 3.    Integer Conversions
•	When integer conversions are needed, it must be made sure that no data is lost or corrupted in the process.
•	INT02-C: Understand integer conversion rules
•	INT31-C: Ensure that integer conversions do not result in lost or misinterpreted data
•	TYP 7.    Conversion of signed characters to large signed types
•	Prior to converting signed characters to larger signed types they have to be cast to unsigned types to avoid situations where certain data ranges can be erroneously interpreted as being negative.
•	STR34-C: Cast characters to unsigned types before converting to larger integer sizes


64-bit Portability
Code should be 64-bit and 32-bit friendly. Bear in mind problems of printing, comparisons, and structure alignment.
•	Correct portable printf() conversion specifiers for some integral typedefs rely on macro expansions that we find unpleasant to use and impractical to require (the PRI macros from <cinttypes>). Unless there is no reasonable alternative for your particular case, try to avoid or even upgrade APIs that rely on the printf family. Instead use a library supporting typesafe numeric formatting, such as StrCat or Substitute for fast simple conversions, or std::ostream.
•	Unfortunately, the PRI macros are the only portable way to specify a conversion for the standard bitwidth typedefs (e.g. int64_t, uint64_t, int32_t, uint32_t, etc). Where possible, avoid passing arguments of types specified by bitwidth typedefs to printf-based APIs. Note that it is acceptable to use typedefs for which printf has dedicated length modifiers, such as size_t (z), ptrdiff_t (t), and maxint_t (j).
•	Remember that sizeof(void *) != sizeof(int). Use intptr_t if you want a pointer-sized integer.
•	You may need to be careful with structure alignments, particularly for structures being stored on disk. Any class/structure with a int64_t/uint64_t member will by default end up being 8-byte aligned on a 64-bit system. If you have such structures being shared on disk between 32-bit and 64-bit code, you will need to ensure that they are packed the same on both architectures. Most compilers offer a way to alter structure alignment. For gcc, you can use __attribute__((packed)). MSVC offers #pragma pack() and __declspec(align()).
•	Use braced-initialization as needed to create 64-bit constants. For example:
?
int64_t my_value{0x123456789};
uint64_t my_mask{3ULL << 48}
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Preprocessor Macros
Avoid defining macros, especially in headers; prefer inline/constexpr functions, enums, and constexpr variables. Name macros with a project-specific prefix. Do not use macros to define pieces of a C++ API.
Macros mean that the code you see is different than what the compiler sees. This can introduce unexpected behavior, especially since macros have global scope.
However, Macros can do things that other techniques cannot. But before using a macro, consider carefully whether there's a non-macro way to achieve the same result. Consider the following:
•	Instead of using macro to inline performance-critical code, use inline/constexpr functions instead.
•	Instead of using macro to store a constant, use a constexpr variable instead.
•	Instead of using macro to "abbreviate" a long variable name, use a reference instead
The problems introduced by macros are especially severe when they are used to define pieces of a C++ API, and still more so for public APIs. Every error message from the compiler when developers incorrectly use that interface now must explain how the macros formed the interface. Refactoring and analysis tools have a dramatically harder time updating the interface. As a consequence, we specifically disallow using macros in this way. For example, avoid patterns like:
?
class WOMBAT_TYPE(Foo) 
{
  // ...
 
 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)
 
  EXPAND_WOMBAT_COMPARISONS(Foo, ==, <)
};
Luckily, macros are not nearly as necessary in C++ as they are in C. Instead of using a macro to inline performance-critical code, use an inline function. Instead of using a macro to store a constant, use a const variable. Instead of using a macro to "abbreviate" a long variable name, use a reference. Instead of using a macro to conditionally compile code ... well, don't do that at all (except, of course, for the #define guards to prevent double inclusion of header files). It makes testing much more difficult.
Macros can do things these other techniques cannot, and you do see them in the codebase, especially in the lower-level libraries. And some of their special features (like stringifying, concatenation, and so forth) are not available through the language proper. But before using a macro, consider carefully whether there's a non-macro way to achieve the same result. If you need to use a macro to define an interface, contact your project leads to request a waiver of this rule.
The following usage pattern will avoid many problems with macros; if you use macros, follow it whenever possible:
•	Don't define macros in a .h/.hpp file.
•	#define macros right before you use them, and #undef them right after.
•	Do not just #undef an existing macro before replacing it with your own; instead, pick a name that's likely to be unique.
•	Try not to use macros that expand to unbalanced C++ constructs, or at least document that behavior well.
•	Prefer not using ## to generate function/class/variable names.
Exporting macros from headers (i.e. defining them in a header without #undefing them before the end of the header) is extremely strongly discouraged. If you do export a macro from a header, it must have a globally unique name. To achieve this, it must be named with a prefix consisting of your project's namespace name (but upper case).
Avoid macros. Macros are the bluntest instrument of C and C++’s abstraction facilities, ravenous wolves in functions’ clothing, hard to tame, marching to their own beat all over your scopes. Avoid them.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.74: Prefer inline functions to preprocessor macros.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	PRE 2.    Inline functions are preferred over macros


Do not use pre-processor directives if possible
Even though pre-processor directives can make some things easier to use, it must be stated that maintenance of such is not trivial. Moreover debugging of such might be harder, no namespaces can be used - all of those shall make a one to strongly consider whether usage of a pre-processor directive is really needed. 


0 and nullptr/NULL
Use nullptr instead of NULL or 0 if you want to denote a null pointer. It is a clearer expression of the intent and less error prone as it has no implicit conversion to integral type.
For pointers (address values), use nullptr, as this provides type-safety.
?
auto result = findRecord( /* arguments */ );
if (result == nullptr) 
{
    ...
}
Use '\0' for chars (and not the 0 literal).
For C++03 projects, prefer NULL to 0. While the values are equivalent, NULL looks more like a pointer to the reader, and some C++ compilers provide special definitions of NULL which enable them to give useful warnings. Never use NULL for numeric (integer or floating-point) values.
Use '\0' for the null character. Using the correct type makes the code more readable.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 6.    Pointer Dereferencing
•	If dereferencing a pointer when it is not yet guaranteed that it is not NULL, a check must be performed. This check should always be done immediately after the function which obtains, creates or changes the pointer – if it is not guaranteed that it is not NULL, e.g. when using the “++”increment operator. Doing so avoids confusion during the further evolution of the code.
•	Compiler optimization (e.g. –fdelete-null-pointer-checks in GCC activated with -O2) might omit those checks from being included into the binary. This behavior must be taken into account e.g. when the binary would not fail in case a NULL pointer is dereferenced as when operating in kernel space.


Don’t memcpy or memcmp for non-PODs
Don’t try to X-ray objects. Don’t use memcpy and memcmp to copy or compare anything more structured than raw memory.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


sizeof
Prefer sizeof(varname) to sizeof(type).
Use sizeof(varname) when you take the size of a particular variable. sizeof(varname) will update appropriately if someone changes the variable type either now or later. You may use sizeof(type) for code unrelated to any particular variable, such as code that manages an external or internal data format where a variable of an appropriate C++ type is not convenient.

?
//Good example
StructType data;
memset(&data, 0, sizeof(data));
 
//Bad example because "data" variable is available
memset(&data, 0, sizeof(StructType));
 
//Good example because int type is needed here
if (raw_size < sizeof(int)) 
{
  LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
  return false;
}

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 2.    Determining variable, structure and class sizes
•	The use of sizeof() must be preferred to other methods for determining the size of a type or variable.
•	Special care must be taken when using sizeof() with pointers to an array


C-Strings
Careless use of strings and character arrays lead to risky flaws like buffer overflow and format string vulnerabilities.
It must always be ensured that byte strings are null terminated. Failure to ensure the null termination of a C-string can lead to a buffer overflow. When truncating or otherwise working with strings, it must always be made sure that the resulting strings are null terminated!
Data should always be sanitized before passing it to parts of the system that could, for example, have formatting character attack vulnerability. This is completely separate from, and not to be confused with, input validation, which should always be far stricter.
When wide character strings are used, the correct functions must be used for dealing with them. E.g. the strlen()-function from the standard C library yields false results when used on a wide character string.
gets(), strcpy() and similar functions that copy data from an unbound source to a fixed size array must not be used. Copying data to a fixed size array from an unbound source will create a classic buffer overflow situation.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	STR32-C: Do not pass a non-null-terminated character sequence to a library function that expects a string
•	STR02-C: Sanitize data passed to complex subsystems
•	STR33-C: Size wide character strings correctly
•	STR38-C: Do not use wide-char functions on narrow-char strings and vice versa


std::string vs C-string
Prefer using std::string over C-string as it is safer. C-string handling is more prone to errors.
Using the std::string class of the standard C++ library must be used if possible as it prevents most of the classical security flaws caused by C-strings.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	ARR 4.    Make use of the std::string class (C++ only)


Never initialize std::string with a NULL pointer
The behaviour is undefined and usually causes the program to crash. May lead to memory leaks or worse.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.4: NEVER INITIALISE STD::STRING WITH A NULL POINTER.


Manipulate C-like strings using functions operating on controlled buffers (snprintf, strncpy…)
When need to operate on C-like strings, use library functions that operate on controlled buffers. This is needed to avoid possible buffer overflows that can happen with malformed input data.
Note that for general purpose string handling and new functionalities std::string should be used instead of C-like strings.
This prevents writing memory below the allocated buffer boundaries.


C++ Streams
Use streams where appropriate, and stick to "simple" usages. Overload << for streaming only for types representing values, and write only the user-visible value, not any implementation details.

Definition:
•	Streams are the standard I/O abstraction in C++, as exemplified by the standard header <iostream>. They are widely used in Google code, mostly for debug logging and test diagnostics.
Pros:
•	The << and >> stream operators provide an API for formatted I/O that is easily learned, portable, reusable, and extensible. printf, by contrast, doesn't even support std::string, to say nothing of user-defined types, and is very difficult to use portably. printf also obliges you to choose among the numerous slightly different versions of that function, and navigate the dozens of conversion specifiers.
•	Streams provide first-class support for console I/O via std::cin, std::cout, std::cerr, and std::clog. The C APIs do as well, but are hampered by the need to manually buffer the input.
Cons:
•	Stream formatting can be configured by mutating the state of the stream. Such mutations are persistent, so the behavior of your code can be affected by the entire previous history of the stream, unless you go out of your way to restore it to a known state every time other code might have touched it. User code can not only modify the built-in state, it can add new state variables and behaviors through a registration system.
•	It is difficult to precisely control stream output, due to the above issues, the way code and data are mixed in streaming code, and the use of operator overloading (which may select a different overload than you expect).
•	The practice of building up output through chains of << operators interferes with internationalization, because it bakes word order into the code, and streams' support for localization is flawed.
•	The streams API is subtle and complex, so programmers must develop experience with it in order to use it effectively.
•	Resolving the many overloads of << is extremely costly for the compiler. When used pervasively in a large code base, it can consume as much as 20% of the parsing and semantic analysis time.
Decision:
•	Use streams only when they are the best tool for the job. This is typically the case when the I/O is ad-hoc, local, human-readable, and targeted at other developers rather than end-users. Be consistent with the code around you, and with the codebase as a whole; if there's an established tool for your problem, use that tool instead. In particular, logging libraries are usually a better choice than std::cerr or std::clog for diagnostic output, and the libraries in absl/strings or the equivalent are usually a better choice than std::stringstream.
•	Avoid using streams for I/O that faces external users or handles untrusted data. Instead, find and use the appropriate templating libraries to handle issues like internationalization, localization, and security hardening.
•	If you do use streams, avoid the stateful parts of the streams API (other than error state), such as imbue(), xalloc(), and register_callback(). Use explicit formatting functions (see e.g. absl/strings) rather than stream manipulators or formatting flags to control formatting details such as number base, precision, or padding.
•	Overload << as a streaming operator for your type only if your type represents a value, and << writes out a human-readable string representation of that value. Avoid exposing implementation details in the output of <<; if you need to print object internals for debugging, use named functions instead (a method named DebugString() is the most common convention).
•	Do not use C++ standard streams (cout, cerr, cinn) for debug output or input.
?
std::cerr << "Debug print" << std::endl; //WRONG
warning() << "TC_FEATURE_STATUS_IND_MSG received when hsdpa not configured for cellId: " << cell.getId() << flush(); // GOOD
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.63: Use C++ I/O.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INP 3.    Streams for C++
•	When working with C++, streams shall be utilized instead of C-style inputs and outputs when possible.


Type deduction
Use type deduction only if it makes the code clearer to readers who aren't familiar with the project, or if it makes the code safer. Do not use it merely to avoid the inconvenience of writing an explicit type.
Defintions:
There are several contexts in which C++ allows (or even requires) types to be deduced by the compiler, rather than spelled out explicitly in the code:
Function template argument deduction
•	A function template can be invoked without explicit template arguments. The compiler deduces those arguments from the types of the function arguments:
?
template <typename T>
void f(T t);
 
f(0);  // Invokes f<int>(0)
auto variable declarations
•	A variable declaration can use the auto keyword in place of the type. The compiler deduces the type from the variable's initializer, following the same rules as function template argument deduction with the same initializer (so long as you don't use curly braces instead of parentheses).
?
auto a = 42;  // a is an int
auto& b = a;  // b is an int&
auto c = b;   // c is an int
auto d{42};   // d is an int, not a std::initializer_list<int>
•	auto can be qualified with const, and can be used as part of a pointer or reference type, but it can't be used as a template argument. A rare variant of this syntax uses decltype(auto) instead of auto, in which case the deduced type is the result of applying decltype to the initializer.

Function return type deduction
•	auto (and decltype(auto)) can also be used in place of a function return type. The compiler deduces the return type from the return statements in the function body, following the same rules as for variable declarations:auto a = 42; // a is an int
?
auto f() { return 0; }  // The return type of f is int
•	Lambda expression return types can be deduced in the same way, but this is triggered by omitting the return type, rather than by an explicit auto. Confusingly, trailing return type syntax for functions also uses auto in the return-type position, but that doesn't rely on type deduction; it's just an alternate syntax for an explicit return type.
Generic lambdas
•	A lambda expression can use the auto keyword in place of one or more of its parameter types. This causes the lambda's call operator to be a function template instead of an ordinary function, with a separate template parameter for each auto function parameter:
?
// Sort `vec` in increasing order
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs > rhs; });
Lambda init captures
•	Lambda captures can have explicit initializers, which can be used to declare wholly new variables rather than only capturing existing ones:
?
[x = 42, y = "foo"] { ... }  // x is an int, and y is a const char*
//This syntax doesn't allow the type to be specified; instead, it's deduced using the rules for auto variables.
Class template argument deduction
    See below.
Structured bindings
•	When declaring a tuple, struct, or array using auto, you can specify names for the individual elements instead of a name for the whole object; these names are called "structured bindings", and the whole declaration is called a "structured binding declaration". This syntax provides no way of specifying the type of either the enclosing object or the individual names:
?
auto [iter, success] = my_map.insert({key, value});
if (!success) 
{
    iter->second = value;
}
•	The auto can also be qualified with const, &, and &&, but note that these qualifiers technically apply to the anonymous tuple/struct/array, rather than the individual bindings. The rules that determine the types of the bindings are quite complex; the results tend to be unsurprising, except that the binding types typically won't be references even if the declaration declares a reference (but they will usually behave like references anyway).
(These summaries omit many details and caveats; see the links for further information.)
Pros:
•	C++ type names can be long and cumbersome, especially when they involve templates or namespaces.
•	When a C++ type name is repeated within a single declaration or a small code region, the repetition may not be aiding readability.
•	It is sometimes safer to let the type be deduced, since that avoids the possibility of unintended copies or type conversions.
Cons:
•	C++ code is usually clearer when types are explicit, especially when type deduction would depend on information from distant parts of the code. In expressions like:
?
auto foo = x.add_foo();
auto i = y.Find(key);
it may not be obvious what the resulting types are if the type of y isn't very well known, or if y was declared many lines earlier.
•	Programmers have to understand when type deduction will or won't produce a reference type, or they'll get copies when they didn't mean to.
•	If a deduced type is used as part of an interface, then a programmer might change its type while only intending to change its value, leading to a more radical API change than intended.
Decision:
•	The fundamental rule is: use type deduction only to make the code clearer or safer, and do not use it merely to avoid the inconvenience of writing an explicit type. When judging whether the code is clearer, keep in mind that your readers are not necessarily on your team, or familiar with your project, so types that you and your reviewer experience as as unnecessary clutter will very often provide useful information to others. For example, you can assume that the return type of make_unique<Foo>() is obvious, but the return type of MyWidgetFactory() probably isn't.
•	These principles applies to all forms of type deduction, but the details vary, as described in the following sections.

Details and caveats:
Function template argument deduction
•	Function template argument deduction is almost always OK. Type deduction is the expected default way of interacting with function templates, because it allows function templates to act like infinite sets of ordinary function overloads. Consequently, function templates are almost always designed so that template argument deduction is clear and safe, or doesn't compile.
Local variable type deduction
•	For local variables, you can use type deduction to make the code clearer by eliminating type information that is obvious or irrelevant, so that the reader can focus on the meaningful parts of the code:
?
std::unique_ptr<WidgetWithBellsAndWhistles> widget_ptr =
    absl::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
absl::flat_hash_map<std::string,
                    std::unique_ptr<WidgetWithBellsAndWhistles>>::const_iterator
    it = my_map_.find(key);
std::array<int, 0> numbers = {4, 8, 15, 16, 23, 42};
 
auto widget_ptr = absl::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
auto it = my_map_.find(key);
std::array numbers = {4, 8, 15, 16, 23, 42};
•	Types sometimes contain a mixture of useful information and boilerplate, such as it in the example above: it's obvious that the type is an iterator, and in many contexts the container type and even the key type aren't relevant, but the type of the values is probably useful. In such situations, it's often possible to define local variables with explicit types that convey the relevant information:
?
auto it = my_map_.find(key);
if (it != my_map_.end()) 
{
  WidgetWithBellsAndWhistles& widget = *it->second;
  // Do stuff with `widget`
If the type is a template instance, and the parameters are boilerplate but the template itself is informative, you can use class template argument deduction to suppress the boilerplate. However, cases where this actually provides a meaningful benefit are quite rare. Note that class template argument deduction is also subject to a separate style rule.
•	Do not use decltype(auto) if a simpler option will work, because it's a fairly obscure feature, so it has a high cost in code clarity.
Return type deduction
•	Use return type deduction (for both functions and lambdas) only if the function body has a very small number of return statements, and very little other code, because otherwise the reader may not be able to tell at a glance what the return type is. Furthermore, use it only if the function or lambda has a very narrow scope, because functions with deduced return types don't define abstraction boundaries: the implementation is the interface. In particular, public functions in header files should almost never have deduced return types.
Parameter type deduction
•	auto parameter types for lambdas should be used with caution, because the actual type is determined by the code that calls the lambda, rather than by the definition of the lambda. Consequently, an explicit type will almost always be clearer unless the lambda is explicitly called very close to where it's defined (so that the reader can easily see both), or the lambda is passed to an interface so well-known that it's obvious what arguments it will eventually be called with (e.g. the std::sort example above).
Lambda init captures
•	Init captures are covered by a more specific style rule, which largely supersedes the general rules for type deduction.
Structured bindings
•	Unlike other forms of type deduction, structured bindings can actually give the reader additional information, by giving meaningful names to the elements of a larger object. This means that a structured binding declaration may provide a net readability improvement over an explicit type, even in cases where auto would not. Structured bindings are especially beneficial when the object is a pair or tuple (as in the insert example above), because they don't have meaningful field names to begin with, but note that you generally shouldn't use pairs or tuples unless a pre-existing API like insert forces you to.
•	If the object being bound is a struct, it may sometimes be helpful to provide names that are more specific to your usage, but keep in mind that this may also mean the names are less recognizable to your reader than the field names. We recommend using a comment to indicate the name of the underlying field, if it doesn't match the name of the binding, using the same syntax as for function parameter comments:
?
auto [/*field_name1=*/ bound_name1, /*field_name2=*/ bound_name2] = ..
As with function parameter comments, this can enable tools to detect if you get the order of the fields wrong.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Auto
Prefer auto to explicit type declarations if will be more convenient and specifying the type explicitly in current context will not provide any significant benefit.
Note
Do not forget to const qualify and/or use reference if applicable.
?
std::map<unsigned int, std::vector<ThisIsAType>> sampleMap;
. . .
for (auto const& p : sampleMap)
{
    . . .
}
Exception to this rule: Avoid auto for initializer lists and in cases where exact type is easily known or where an initializer might require conversion.

Bad
?
auto lst = { 1, 2, 3 };   // lst is an initializer list
[CO GUILD DECISION]: We only allow auto if the type can be determined in the same scope.


Class template argument deduction
Use class template argument deduction only with templates that have explicitly opted into supporting it.
Definition:
Class template argument deduction (often abbreviated "CTAD") occurs when a variable is declared with a type that names a template, and the template argument list is not provided (not even empty angle brackets):
?
std::array a = {1, 2, 3};  // `a` is a std::array<int, 3
The compiler deduces the arguments from the initializer using the template's "deduction guides", which can be explicit or implicit.
Explicit deduction guides look like function declarations with trailing return types, except that there's no leading auto, and the function name is the name of the template. For example, the above example relies on this deduction guide for std::array:
?
namespace std {
template <class T, class... U>
array(T, U...) -> std::array<T, 1 + sizeof...(U)>;
}
Constructors in a primary template (as opposed to a template specialization) also implicitly define deduction guides.
When you declare a variable that relies on CTAD, the compiler selects a deduction guide using the rules of constructor overload resolution, and that guide's return type becomes the type of the variable.
Pros:
•	CTAD can sometimes allow you to omit boilerplate from your code.
Cons:
•	The implicit deduction guides that are generated from constructors may have undesirable behavior, or be outright incorrect. This is particularly problematic for constructors written before CTAD was introduced in C++17, because the authors of those constructors had no way of knowing about (much less fixing) any problems that their constructors would cause for CTAD. Furthermore, adding explicit deduction guides to fix those problems might break any existing code that relies on the implicit deduction guides.
•	CTAD also suffers from many of the same drawbacks as auto, because they are both mechanisms for deducing all or part of a variable's type from its initializer. CTAD does give the reader more information than auto, but it also doesn't give the reader an obvious cue that information has been omitted.
Decision:
•	Do not use CTAD with a given template unless the template's maintainers have opted into supporting use of CTAD by providing at least one explicit deduction guide (all templates in the std namespace are also presumed to have opted in). This should be enforced with a compiler warning if available.
•	Uses of CTAD must also follow the general rules on Type deduction.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Lambda
Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms
For efficiency and correctness, always do capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.
?
void send_packets(buffers& bufs)
{
    stage encryptor([] (buffer& b){ encrypt(b); });
    stage compressor([&](buffer& b){ compress(b); encryptor.process(b); });
    stage decorator([&](buffer& b){ decorate(b); compressor.process(b); });
    for (auto& b : bufs) { decorator.process(b); }
}  // automatically blocks waiting for pipeline to finish
Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread
Pointers and references to locals shouldn't outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn't do so if they (or a copy) outlive the scope.
Bad
?
int local = 42;
 
// Want a reference to local.
// Note, that after program exits this scope,
// local no longer exists, therefore
// process() call will have undefined behavior!
thread_pool.queue_work([&]{ process(local); });
Good
?
int local = 42;
// Want a copy of local.
// Since a copy of local is made, it will be
// available at all times for the call.
thread_pool.queue_work([=]{ process(local); });


Lambda expressions
Use lambda expressions where appropriate. Prefer explicit captures when the lambda will escape the current scope.
Lambda expressions are a concise way of creating anonymous function objects. They're often useful when passing functions as arguments. For example:
?
std::sort(v.begin(), v.end(), [](int x, int y) 
{
  return Weight(x) < Weight(y);
})

They further allow capturing variables from the enclosing scope either explicitly by name, or implicitly using a default capture. Explicit captures require each variable to be listed, as either a value or reference capture:
?
int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &sum](int x) 
{
  sum += weight * x;
})

Default captures implicitly capture any variable referenced in the lambda body, including this if any members are used:
?
const std::vector<int> lookup_table = ...;
std::vector<int> indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&](int a, int b) 
{
  return lookup_table[a] < lookup_table[b];
});

A variable capture can also have an explicit initializer, which can be used for capturing move-only variables by value, or for other situations not handled by ordinary reference or value captures:
?
std::unique_ptr<Foo> foo = ...;
[foo = std::move(foo)] () 
{
  ...
}

Such captures (often called "init captures" or "generalized lambda captures") need not actually "capture" anything from the enclosing scope, or even have a name from the enclosing scope; this syntax is a fully general way to define members of a lambda object:
?
[foo = std::vector<int>({1, 2, 3})] () {
  ...
}

The type of a capture with an initializer is deduced using the same rules as auto.
Pros:
•	Lambdas are much more concise than other ways of defining function objects to be passed to STL algorithms, which can be a readability improvement.
•	Appropriate use of default captures can remove redundancy and highlight important exceptions from the default.
•	Lambdas, std::function, and std::bind can be used in combination as a general purpose callback mechanism; they make it easy to write functions that take bound functions as arguments.
Cons:
•	Variable capture in lambdas can be a source of dangling-pointer bugs, particularly if a lambda escapes the current scope.
•	Default captures by value can be misleading because they do not prevent dangling-pointer bugs. Capturing a pointer by value doesn't cause a deep copy, so it often has the same lifetime issues as capture by reference. This is especially confusing when capturing 'this' by value, since the use of 'this' is often implicit.
•	Captures actually declare new variables (whether or not the captures have initializers), but they look nothing like any other variable declaration syntax in C++. In particular, there's no place for the variable's type, or even an auto placeholder (although init captures can indicate it indirectly, e.g. with a cast). This can make it difficult to even recognize them as declarations.
•	Init captures inherently rely on type deduction, and suffer from many of the same drawbacks as auto, with the additional problem that the syntax doesn't even cue the reader that deduction is taking place.
•	It's possible for use of lambdas to get out of hand; very long nested anonymous functions can make code harder to understand.
Decision:
•	Use lambda expressions where appropriate, with formatting as described below.
•	Prefer explicit captures if the lambda may escape the current scope. For example, instead of:
?
{
  Foo foo;
  ...
  executor->Schedule([&] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.

prefer to write:
?
{
  Foo foo;
  ...
  executor->Schedule([&foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference
•	Use default capture by reference ([&]) only when the lifetime of the lambda is obviously shorter than any potential captures.
•	Use default capture by value ([=]) only as a means of binding a few variables for a short lambda, where the set of captured variables is obvious at a glance. Prefer not to write long or complex lambdas with default capture by value.
•	Use captures only to actually capture variables from the enclosing scope. Do not use captures with initializers to introduce new names, or to substantially change the meaning of an existing name. Instead, declare a new variable in the conventional way and then capture it, or avoid the lambda shorthand and define a function object explicitly.
•	See the section on type deduction for guidance on specifying the parameter and return types.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Template metaprogramming
Avoid complicated template programming.
Definition:
Template metaprogramming refers to a family of techniques that exploit the fact that the C++ template instantiation mechanism is Turing complete and can be used to perform arbitrary compile-time computation in the type domain.
Pros:
•	Template metaprogramming allows extremely flexible interfaces that are type safe and high performance. Facilities like Google Test, std::tuple, std::function, and Boost.Spirit would be impossible without it.
Cons:
•	The techniques used in template metaprogramming are often obscure to anyone but language experts. Code that uses templates in complicated ways is often unreadable, and is hard to debug or maintain.
•	Template metaprogramming often leads to extremely poor compile time error messages: even if an interface is simple, the complicated implementation details become visible when the user does something wrong.
•	Template metaprogramming interferes with large scale refactoring by making the job of refactoring tools harder. First, the template code is expanded in multiple contexts, and it's hard to verify that the transformation makes sense in all of them. Second, some refactoring tools work with an AST that only represents the structure of the code after template expansion. It can be difficult to automatically work back to the original source construct that needs to be rewritten.
Decision:
Template metaprogramming sometimes allows cleaner and easier-to-use interfaces than would be possible without it, but it's also often a temptation to be overly clever. It's best used in a small number of low level components where the extra maintenance burden is spread out over a large number of uses.
Think twice before using template metaprogramming or other complicated template techniques; think about whether the average member of your team will be able to understand your code well enough to maintain it after you switch to another project, or whether a non-C++ programmer or someone casually browsing the code base will be able to understand the error messages or trace the flow of a function they want to call. If you're using recursive template instantiations or type lists or metafunctions or expression templates, or relying on SFINAE or on the sizeof trick for detecting function overload resolution, then there's a good chance you've gone too far.
If you use template metaprogramming, you should expect to put considerable effort into minimizing and isolating the complexity. You should hide metaprogramming as an implementation detail whenever possible, so that user-facing headers are readable, and you should make sure that tricky code is especially well commented. You should carefully document how the code is used, and you should say something about what the "generated" code looks like. Pay extra attention to the error messages that the compiler emits when users make mistakes. The error messages are part of your user interface, and your code should be tweaked as necessary so that the error messages are understandable and actionable from a user point of view.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Use C++ standard library algorithms and data structures whenever possible
Do not implement code which you can reuse from STL.
Use container’s classes algorithms in first place since they tend to have superior performance then generic ones. When specific algorithm is not available or not suitable, use the generic version.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.63: Use C++ standard library.


STL array/vector vs C array
Prefer using STL array or vector instead of a C array
C arrays are less safe, and have no advantages over array and vector. For a fixed-length array, use std::array, which does not degenerate to a pointer when passed to a function and does know its size. Also, like a built-in array, a stack-allocated std::array keeps its elements on the stack. For a variable-length array, use std::vector, which additionally can change its size and handles memory allocation.
?
int v1[SIZE];                        // BAD
  
std::array<int, SIZE> w1;             // ok
  
int* v2 = new int[initial_size];     // BAD, owning raw pointer
delete[] v2;                         // BAD, manual delete
  
std::vector<int> w2(initial_size);   // ok


std::hash
Do not define specializations of std::hash.
Definition:
std::hash<T> is the function object that the C++11 hash containers use to hash keys of type T, unless the user explicitly specifies a different hash function. For example, std::unordered_map<int, std::string> is a hash map that uses std::hash<int> to hash its keys, whereas std::unordered_map<int, std::string, MyIntHash> uses MyIntHash.
std::hash is defined for all integral, floating-point, pointer, and enum types, as well as some standard library types such as string and unique_ptr. Users can enable it to work for their own types by defining specializations of it for those types.
Pros:
•	std::hash is easy to use, and simplifies the code since you don't have to name it explicitly. Specializing std::hash is the standard way of specifying how to hash a type, so it's what outside resources will teach, and what new engineers will expect.
Cons:
•	std::hash is hard to specialize. It requires a lot of boilerplate code, and more importantly, it combines responsibility for identifying the hash inputs with responsibility for executing the hashing algorithm itself. The type author has to be responsible for the former, but the latter requires expertise that a type author usually doesn't have, and shouldn't need. The stakes here are high because low-quality hash functions can be security vulnerabilities, due to the emergence of hash flooding attacks.
•	Even for experts, std::hash specializations are inordinately difficult to implement correctly for compound types, because the implementation cannot recursively call std::hash on data members. High-quality hash algorithms maintain large amounts of internal state, and reducing that state to the size_t bytes that std::hash returns is usually the slowest part of the computation, so it should not be done more than once.
•	Due to exactly that issue, std::hash does not work with std::pair or std::tuple, and the language does not allow us to extend it to support them.
Decision:
You can use std::hash with the types that it supports "out of the box", but do not specialize it to support additional types. If you need a hash table with a key type that std::hash does not support, consider using legacy hash containers (e.g. hash_map) for now; they use a different default hasher, which is unaffected by this prohibition.
If you want to use the standard hash containers anyway, you will need to specify a custom hasher for the key type, e.g.
?
std::unordered_map<MyKeyType, Value, MyKeyTypeHasher> my_map
Consult with the type's owners to see if there is an existing hasher that you can use; otherwise work with them to provide one, or roll your own.

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Aliases
Public aliases are for the benefit of an API's user, and should be clearly documented.
Definition:
There are several ways to create names that are aliases of other entities:
?
typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;

In new code, using is preferable to typedef, because it provides a more consistent syntax with the rest of C++ and works with templates.
Like other declarations, aliases declared in a header file are part of that header's public API unless they're in a function definition, in the private portion of a class, or in an explicitly-marked internal namespace. Aliases in such areas or in .cc files are implementation details (because client code can't refer to them), and are not restricted by this rule.
Pros:
•	Aliases can improve readability by simplifying a long or complicated name.
•	Aliases can reduce duplication by naming in one place a type used repeatedly in an API, which might make it easier to change the type later.
Cons:
•	When placed in a header where client code can refer to them, aliases increase the number of entities in that header's API, increasing its complexity.
•	Clients can easily rely on unintended details of public aliases, making changes difficult.
•	It can be tempting to create a public alias that is only intended for use in the implementation, without considering its impact on the API, or on maintainability.
•	Aliases can create risk of name collisions
•	Aliases can reduce readability by giving a familiar construct an unfamiliar name
•	Type aliases can create an unclear API contract: it is unclear whether the alias is guaranteed to be identical to the type it aliases, to have the same API, or only to be usable in specified narrow ways
Decision:
Don't put an alias in your public API (or in header files) just to save typing in the implementation; do so only if you intend it to be used by your clients.
When defining a public alias, document the intent of the new name, including whether it is guaranteed to always be the same as the type it's currently aliased to, or whether a more limited compatibility is intended. This lets the user know whether they can treat the types as substitutable or whether more specific rules must be followed, and can help the implementation retain some degree of freedom to change the alias.
Don't put namespace aliases in your public API (or in header files).
Don’t write namespace usings in a header file or before an #include. Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive. Corollary: In header files, don’t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)
For example, these aliases document how they are intended to be used in client code:
?
//Good example
namespace mynamespace 
{
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = foo::Bar*;
 
// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set<DataPoint, std::hash<DataPoint>, DataPointComparator>;
}  // namespace mynamespace

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.12: DO NOT USE USING DECLARATIONS OR USING DIRECTIVES IN HEADER FILES.


Alias declaration vs typedefs
Use alias declarations instead of typedefs. Alias declarations may be templatized, while typedefs cannot.
?
template<typename T>
using MyAllocList = std::list<T, MyAlloc<T>>;
 
MyAllocList<Widget> lw;
  
using Sccpchs = std::map<TCommonPhysicalChannelId, SCTCHSRSecondaryCCPCH>;


Machine dependent parts of code are isolated into separate files
Keeping the machine dependent code apart from other code is of great importance concerning portability of code.
Preprocessor directives (#define, #ifdef, #if defined) and environment variables can be used to accomplish conditional compilation when necessary. If possible, conditionally compiled code should be kept in separate files for the clarity of the code.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 5.3: Machine dependent parts of code are isolated into separate files.


The return type of main() must be int
According to the C++ standard, only two definitions of main() are portable:
?
int main()
{
}
and
?
int main(int argc, char* argv[]) //where argv (the array of command-line arguments) might also be defined as char**.
{
}
Unlike C, C++ defines an implicit "return 0;" at the end of the main function. It is therefore not required to end the main function with a return statement, unless something else than 0 is wanted to be returned (any value other than 0 represents a kind of failure). However, older compilers might print a warning message about missing return value or even handle that as an error.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.6: THE RETURN TYPE OF MAIN() MUST BE INT.


Do not check lower or upper limits with“==”, always use "<=" or ">="
The use of '==' is risky if the variable is long, float, or double, or some derivative of those since rounding errors might affect the value held in the variable. In addition, it is easier to escape some coding errors where a variable is erroneously incremented or decremented more than the programmer has expected.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.69: DO NOT CHECK CROSSING LOWER OR UPPER LIMITS WITH “==”, ALWAYS USE "<=" OR ">=".


Use yoda condition style
Yoda conditions (also called Yoda notation) is a programming style where the two parts of an expression are reversed from the typical order in a conditional statement. A Yoda condition places the constant portion of the expression on the left side of the conditional statement.
Usually a conditional statement would be written as:
?
//Bad example
if ($value == 42) { /* ... */ }
// Reads like: "If the value equals 42...
Yoda conditions describe the same expression, but reversed: 
?
//Good example
if (42 == $value) { /* ... */ }
// Reads like: "If 42 equals the value...
Reference:
•	Yoda conditions: https://en.wikipedia.org/wiki/Yoda_conditions
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.70: Always put the default operand on the left-hand side of an equality comparison.


Do not assume the bit width of any type.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.6: Do not assume the bit width of any type.


Do not assume that a char is signed or unsigned.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.7: Do not assume that a char is signed or unsigned.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 5.    Usage of char for numeric values
•	When using char type for numeric values, the type must be explicitly declared as either signed or unsigned. Failure to do so can produce a wide range of hard-to-detect errors.


Be careful not to make pointer type conversions from a pointer of a ”shorter” type to a one of a ”longer” type.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.9: Be careful not to make pointer type conversions from a pointer of a ”shorter” type to a one of a ”longer” type.


Do not assume that pointers and integers have the same size.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.10: Do not assume that pointers and integers have the same size.


Use explicit type conversions for arithmetic using signed and unsigned values.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.11: Use explicit type conversions for arithmetic using signed and unsigned values.


Do not assume that you know how an instance of a data type is represented in memory.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.13: Do not assume that you know how an instance of a data type is represented in memory.


Do not assume that long, float, double or long double may begin at an address.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.15: Do not assume that long, float, double or long double may begin at any arbitrary address.


Do not depend on integer underflow or overflow functioning in any special way.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.16: Do not depend on underflow or overflow functioning in any special way.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 1.    Integer Overflow


Do not assume that the operands in an expression are evaluated in any definite order.
It must not make a difference in what order the evaluation of sub-expressions is actually executed as that order is unspecified by the C11 standard, and as such may vary between implementations.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.16: Do not assume that the operands in an expression are evaluated in any definite order.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 5.    Evaluation Order


Do not assume that static objects are initialised in any special order.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.20: Do not assume that static objects are initialised in any special order.


Do not write code that is dependent on the lifetime of a temporary object.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 11.21: Do not write code that is dependent on the lifetime of a temporary object.


Exit handlers
All exit handles registered by atexit() must return normally. Calling exit () or longjmp() from an atexit() registered exit handler will result in undefined behavior!
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 7.    Exit handlers


No “volatile” synchronization for Threads
When programming threaded code, do not implement synchronization by using the volatile qualifier.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 8.    No “volatile” synchronization for Threads


Be careful how to call other executables
Calling other executables might create an easy attack opportunity. One has to understand that system() and popen() are calling the command processor such as a shell. This might in the end execute more than originally intended. If a command processor is not needed, execv(), execl() or execle() must be used.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 12.    Be careful how to call other executables


Format Strings
Format strings can be very risky, and thus they must be handled with care. Especially it must be ensured that user input is not used as input for format strings without being checked against white lists.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INP 2.    Format Strings


Use of Environment variables
As they are nothing else than external input, environment variables are to be treated with healthy suspicion. The content of an Environment variable must be checked against a white list before it is used.
Also it must not be assumed that an environment variable has a specific size.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INP 4.    Use of Environment variables


Signal Handlers
Reacting on received signals interrupts the normal execution of a program; special care must be taken to avoid race conditions when working with them.
Signal handlers should be asynchronous-safe. That means their execution continues as intended after being interrupted by another signal. If they are not asynchronous-safe, the signal must be masked while it is processed to avoid the handling to fail when it is interrupted.
All functions called from within signal handlers must be asynchronous-safe.
All objects that are modified or accessed from within a signal handler must be restricted for being used by the handler alone. Shared objects must not be accessed from within a signal handler. Exceptions from this may be made for single atomic operations on suitable types such as sig_atomic_t.
From within a signal handler, longjmp() or similar functionality must not be called as it causes a non-asynchronous-safe function to be called, with undefined results. This can lead to vulnerabilities

Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	SIG00-C: Mask signals handled by noninterruptible signal handlers
•	SIG30-C: Call only asynchronous-safe functions within signal handlers
•	SIG31-C: Do not access or modify shared objects in signal handlers
•	SIG32-C: Do not call longjmp() from inside a signal handler


Prefer normal Functions over Signals
When the same functionality can be achieved either by normal use of functions, or by using signals, the normal use of functions should be chosen as the solution. Signals should be reserved for special events not serviceable without their use.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INP 6.    Prefer normal Functions over Signals


Array indices
Failure to properly handle arrays can cause serious vulnerabilities in the form of buffer overflows. They should be handled with great care and diligence.  A good understanding of how they work is extremely important before using them. As C-strings are nothing else than character arrays, all array issues naturally also apply to them.
In case of C++, having a good understanding of vectors is just as important.
It must be ensured that array indices are always within the valid range. Reading or writing out of bounds is a common and very dangerous error.
Copying arrays of larger size to arrays of smaller size is a sure cause for a buffer overflow. It must always be ensured that the target array is large enough to hold the source array.
If implementing variable length arrays, make sure to check that used size arguments are not risky or invalid, but represent a value in a valid range. Be aware that variable length arrays are a non-standard conforming extension by GCC and may complicate portability.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	ARR30-: Guarantee that array indices are within the valid range
•	ARR33-C: Guarantee that copies are made into storage of sufficient size
•	ARR32-C: Ensure size arguments for variable length arrays are in a valid range


No Polymorphism with arrays
Polymorphism must not be used with arrays.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	ARR 3.    No Polymorphism with arrays (C++ only)


Usage of c_str() when working with legacy C API
When working with legacy C API using char pointers, the c_str() function should be used to retrieve data from a string object as the resulting string is null terminated. This use requires that the legacy C function does not attempt to modify the string produced, as this would result in undefined behavior. If the string has to be modified by the C function, its content should first be copied to an array, which is then used as input. Using the pointer returned by c_str() will result in undefined behavior if it is used after the original string goes out of scope. The string itself must be stored in a non-temporary item if needed for later use to avoid this.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	ARR 5.    Usage of c_str() when working with legacy C API (C++ only)


When doing bitwise operations, it must be ensured that the operands are always of the unsigned type.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INT30-C: Ensure that unsigned integer operations do not wrap
•	INT32-C: Ensure that integer operations do not result in an overflow


Compare only same variable types
Comparing must be done only between the same variable types. Smaller integer must be cast to a larger size when doing compare or other operations with integers of different size to avoid wrapping and possible subsequent buffer overflows.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 4.    Compare only same variable types
•	INT31-C: Ensure that integer conversions do not result in lost or misinterpreted data
•	FLP07-C: Cast the return value of a function that returns a floating-point type
•	INT18-C: Evaluate integer expressions in a larger size before comparing or assigning to that size


Floating point for accurate calculations
Floating point variables must not be used when accurate calculations are needed as they are approximations and prone to rounding-errors. Floating point implementation also varies greatly from compiler to compiler; therefore, understanding of the particular compiler in use is important. Complying with the limitations of particular floating point implementations prevents range and domain errors commonly associated with floating point calculations.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 6.    Floating point for accurate calculations

•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++

Naming 

Choose meaningful names
Names should be descriptive and chosen with care. All names and comments should be in English. Abbreviations/Acronyms are to be avoided, except where they are widely accepted(e.g. GRM instead of Global Resource Manager).
Acronyms are treated as words so it should not be all capitalized.

An abbreviation/acronym is considered acceptable if it is used in any official documentation
?
bool wasCellSetup;      // Good. No abbreviation.
TAaSysComNid picDspNid; // still Good. PIC is a TCOM abbreviation. DSP and NID is a well known Nokia abbreviation
 
int n;              // Bad. Meaningless.
void prntEndpnts(); // Bad. Deletes internal letters.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 8.1: Identifiers should be meaningful. That is, they should be easy to understand and provide good documentation about themselves.
•	RULE 8.2: AVOID ABBREVIATIONS, ESPECIALLY AD HOC ONES.
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MSC 6.    Unambiguous Identifiers


File Names
Filenames should be in Pascal case(start with a capital letter and have a capital letter for each new word), but can include underscores to clearly separate words/concepts.
Use meaningful and understandable filenames.
C++ source files should end in .cpp and header files should end in .hpp.
•	Wait_BbPicDeactivationResp.cpp
•	SendMessageToDsp.hpp
•	DspEndpointFactory_unit.cpp
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 5.1: Use meaningful and understandable filenames.
•	RULE 5.2: DIVIDE A CODE MODULE INTO A HEADER FILE (.hpp) AND AN IMPLEMENTATION FILE (.cpp).

Type Names
The names of all types — classes, structs, type aliases, enums, and type template parameters — should be in Pascal case
Enums should be prefixed with E.

?
//class
class HsdpaCell;
  
//typedefs
typedef std::pair<TLocalCellGroupId, TAaSysComSicad> LcgHsupaL2Pair;
  
//type alias
using CellIds = std::set<TCellId>;
using FunctionPtr = void (*)();
  
//struct
struct ToamError;
  
//enum
enum EFeatureControlBit;


Variable Names
A variable name should be a noun.
Common Variable names
Names of variables should be in Lower Camel Case(first letter of the entire word is lowercase, but subsequent first letters are uppercase)
?
string tableName;
int transportLayerAddress;
Class Data Members
Private data members of classes, both static and non-static, are named like ordinary nonmember variables but with m_ prefix.
?
class TableInfo 
{
public:
    int m_counter;
private:
    string m_tableName;
    static Pool<TableInfo> m_pool;
};
Struct Data Members
Data members of structs, both static and non-static, are named like ordinary nonmember variables. They do not have a prefix that data members in classes have.
?
struct UrlTableProperties 
{
    string name;
    int numEntries;
    static Pool<UrlTableProperties> pool;
};


Enumerator names
Unscoped Enumeration
For unscoped enumerations, enumerators should be in Pascal case, prefixed with the name of the enumeration trailed by an underscore.
Note
if implicit conversion to integral types is not needed then scoped enumeration should be preferred instead.
?
enum EFeatureControlBit //example for (1)
{
    EFeatureControlBit_MinimizedDriveTestSupport                     = 0,
    EFeatureControlBit_PrivateCause                                  = 1,
    EFeatureControlBit_BtsSupportRachCapaInc                         = 2,
    EFeatureControlBit_HsRachCommonEdchRes                           = 3,
    EFeatureControlBit_RuntimeCellUarfcn                             = 4,
    EFeatureControlBit_PicAdminState                                 = 5,
    EFeatureControlBit_MocnCapacityAssurance                         = 6,
    EFeatureControlBit_EnhancedPowerControl                          = 7,
    EFeatureControlBit_WcdmaSupportForDem                            = 8,
    EFeatureControlBit_UeTracingSupportEnabled                       = 9,
    EFeatureControlBit_UePowerHeadroomDedMeasurementReportingSupport = 10,
    EFeatureControlBit_EnhancedHspaCongestionControl                 = 11
};
Scoped Enumeration
For scoped enumerations, we use enum class as enum-key. Enumerators are in Pascal case(without prefix)
?
enum class ERecoveryType
{
    HwResource,
    IubLinkBreak,
    LcgSwitching,
    ModeChangeCleanup
};
Note
If Enumerator list size is greater than 10, all enumerators in the list should be explicitly initialized, even if their values are sequential.


Function Names
A function name should start with a verb and must reflect the action of that function. Member and nonmember functions should be in Lower Camel Case.
?
handleMessage();
HsdpaCell(...).setHsdpaState(...);


Namespace Names
Namespace names are all lower-case. Top-level namespace should usually be the name of the project or team whose code is contained in that namespace.
?
namespace dmgr
{
namespace uetracingcommissioning
{
    ...
} // namespace uetracingcommissioning
} // namespace dmgr


Macro Names
Avoid defining macros. However, if they are absolutely needed, then they should be named with all capitals with underscore as word separator. If they are to be exported, it must be prefixed with the project's namespace name. Macro's parameter names should be in lower camel case.
?
#define SHOW_TRANSACTION_WARNING(initialTransactionContextType)                                                                  \
void BasePicStateHandler::startTransaction(PicPoolPtr const &, initialTransactionContextType)                                    \
{                                                                                                                                \
    warning() << "BasePicStateHandler::startTransaction("#initialTransactionContextType"): Transaction not started." << flush(); \
}
. . .
#undef SHOW_TRANSACTION_WARNING
  
#define DMGR_ASSERT_MT(Expression, String) ...
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.24: PREPROCESSOR IDENTIFIERS AND MACROS ARE CAPITALISED, AND WORDS ARE SEPARATED WITH UNDERSCORES.


Global Constants
Global constants are named just like macros: they should be all caps with '_' as separators.
?
constexpr int A_GLOBAL_CONSTANT = 5;
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.23: CONSTANT IDENTIFIERS (CONST VARIABLES OR ENUMERATED CONSTANTS) ARE CAPITALISED, AND WORDS ARE SEPARATED WITH UNDERSCORES.


Do not use Hungarian notation in a code
Hungarian notation roots in the '80s. IDEs nowadays are good at pointing out where given variable is declared or what is its type. Adding type to a name makes refactoring harder. It also does not play well with generic programming.
?
//Bad examples:
int i_theAnswer = 42;
struct ImyBaseClass;
 
//Good examples:
int theAnswer = 42;
struct MyBaseClass;
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.9: DO NOT USE HUNGARIAN NOTATION PREFIXES.


Do not use different multiple names that differ only in case.
It easily causes difficulties if there are for example classes having names Shutdown and ShutDown. This causes misunderstandings and confusion.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.3: DO NOT USE IDENTIFIERS THAT DIFFER ONLY IN CASE.


Use names that can be pronounced.
The code must also be readable by other people than the author. Pronounceable names are more likely to be understood and they are easier to discuss e.g. in reviews.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 8.4: Use names that can be pronounced.


Avoid numbers in names
Explain the purpose of the item in the name instead of putting numbers in the name.
Numbers ‘1’ and ‘0’ can be mixed up with the letters ‘I’, ‘l’ (and see how hard it is to see difference between these two letters even here!) and ‘O’.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 8.5: Avoid numbers in names.


Do not use standard C or C++ names
This is to avoid conflict with the items used in the C++ standard.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.6: DO NOT USE STANDARD C OR C++ FUNCTION NAMES AS IDENTIFIERS


Do not use names that begin with more thatn one underscore
Names beginning with one or two underscores are usually recognised to be the ones
used by the system, or by the compiler.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 8.8: IDENTIFIER SHALL NOT BEGIN WITH MORE THAN ONE UNDERSCORE.



Comments 

Comment Style
Use either the // or /* */ syntax, as long as you are consistent.
You can use either the // or the /* */ syntax; however, // is much more common. Be consistent with how you comment and what style you use where.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Write comments in English
Comments must understandable by all developers so put comments in English.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 6.9: WRITE CODE AND COMMENTS IN ENGLISH.


Punctuation, Spelling, and Grammar
Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments than badly written ones.
Comments should be as readable as narrative text, with proper capitalization and punctuation. In many cases, complete sentences are more readable than sentence fragments. Shorter comments, such as comments at the end of a line of code, can sometimes be less formal, but you should be consistent with your style.
Although it can be frustrating to have a code reviewer point out that you are using a comma when you should be using a semicolon, it is very important that source code maintain a high level of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Prefer making the code more descriptive instead of putting comments
Putting comments are allowed but should be done sparingly because majority of the code should be readable and understandable enough.
Self documenting code is much more important because the comments can be outdated or not accurate anymore.
Examples:
?
//Bad example
double get(double const a) // function name and parameters names does not explain anything
{
    return 0.5* 9.8 * (a^2); // the variables and constant used don't convey what is computed here
}
 
 
//Bad example with wrong comments
/* This function computes the displacement from a free fall using the distance*/
double get(double const a) 
{
    /* compute time with Newton's equation: distance = ½at² */
    return 0.5 * 9.8 * (a^2);
}
// The comments are incorrect and can cause misunderstandings and can eventually cause incorrect behavior.
 
 
//Bad example with correct comments
/* This function computes the displacement from a free fall using the time */
double get(double const a) 
{
    /* compute displacement with Newton's equation distance  = ½at² */
    return 0.5 * 9.8 * (a^2);
}
// The comments describes the functionality but more descriptive code is much better.
 
 
//Bad example with redundant comments
/* This function computes the displacement from a free fall using the time */
double calculateDisplacementFromAFreeFall(double const timeInFreeFall) 
{
    /* compute displacement with Newton's equation distance  = ½at² */
    constexpr double gravitationalForce = 9.8;
    return 0.5 * gravitationalForce * (timeInFreeFall^2);
}
// The comments are redundant and not neccessary.
 
 
//Good example
double calculateDisplacementFromAFreeFall(double const timeInFreeFall) 
{
    constexpr double gravitationalForce = 9.8;
    return 0.5 * gravitationalForce * (timeInFreeFall^2);
}
 
 
//Good example with necessary comments
double calculateDisplacementFromAFreeFallInAlienPlanetX(double const timeInFreeFall) 
{
    constexpr double alienGravitationalConstant = 0.34834;
    /* calculate displacement Planet X using the NASA's experimental equation: displacement = log(0.34834*t²) */
    return log(alienGravitationalConstant * (timeInFreeFall^2));
}
//The comments are necessary to give information how displacement is calculated especially if the information is not available to the reader.


TODO Comments
Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.
TODOs should include the string TODO in all caps, followed by the name, e-mail address, bug ID, or other identifier of the person or issue with the best context about the problem referenced by the TODO. Reason why it cannot be done now should also be indicated.
If the TODO is of the form "At a future date do something" make sure that either a very specific date ("Fix by November 2016") or a very specific event ("Remove this code when all clients can handle XML responses.") is included.
?
// TODO(jairus.franco@nokia.com): Use a "*" here for concatenation operator when operator* is supported
// TODO(jfranco): change this to use relations. I don't have time for this currently
// TODO(CNI XXXX): remove the "Last visitors" feature. Cannot be removed now because Specification is not yet finalized
Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 6.2: MAKE COMMENTS ABOUT UNCOMPLETED WORK.


Don't state the obvious
Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing.
Compare this:
?
// Find the element in the vector.  <-- Bad: obvious!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) 
{
  Process(element);
}
To this:
?
// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) 
{
  Process(element);
}
Self-describing code doesn't need a comment. The comment from the example above would be obvious:
?
if (!IsAlreadyProcessed(element)) 
{
  Process(element);
}

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html


Avoid including such information in comments that is likely to become out-of-date.
For example, information about how the corresponding package is built or in which directory it resides in should not be included as a comment in a source file. Discussion of non-trivial design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for such redundant information to get out-of-date.

Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 6.1: Avoid including such information in comments that is likely to become out-of-date.


Keep the comments up to date.
For example, information about how the corresponding package is built or in which directory it resides in should not be included as a comment in a source file. Discussion of non-trivial design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for such redundant information to get out-of-date.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 6.5: KEEP THE COMMENTS UP TO DATE.


Remove outdated code instead of commenting it.
When changing the implementation of a code, old code should be removed completely instead of commenting it. Old implementation can still be found from version control so there is no need to keep it visible.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 6.4: REMOVE OUTDATED CODE INSTEAD OF COMMENTING IT


If multiple trailing comments are used in a block of code, they all should be indented to the same level.
?
if (FIXED_VALUE == numericValue)
{
    return true;   // expected value
}
else
{
    return false;  // not accepted value
}
Avoid the assembly language style of commenting every line of executable code with a trailing comment.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 6.8: If multiple trailing comments are used in a block of code, they all should be indented to the same level.


Avoid commenting one matter in many places.
Commenting a matter in many places quickly becomes a maintenance nightmare even in small programs. Comments lose their credibility if they are obsolete or not up to date; the reader has no means but reading the code to determine which comments are relevant.
Although for readability it might be beneficial to repeat a matter in several comments, it is usually better to avoid redundancy. Readability can be achieved by a terse but highly consistent way of commenting.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 6.12: Avoid commenting one matter in many places.


Avoid repeating code in comments.
Comments are supposed to represent the functionality of the code in an abstraction level above that of the program code itself. Repeating code details in comments does not provide additional value to the original code and it is error prone: the risk that code changes are not reflected in the comments is high. However, a comment that might provide additional value could be e.g. the rationale behind the code level solution.
Things to avoid in comments include e.g.
1.	exact signatures of functions,
2.	exact types of parameters and return values, and
3.	other declarations, e.g. class declaration details in implementation file comments
Note the difference between this recommendation and the description about strategic comments: strategic comments are more about what signatures, parameter types, and return values represent in the context of the current program.
?
//Bad example
 
// Do not comment like this:
/**
**************************************************************
* @brief verySimpleMethod(int value).
*
* @return bool.
**************************************************************/
bool verySimpleMethod(int value);
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 6.13: Avoid repeating code in comments.


Formatting 

Maximum line length
Each line of code should not exceed 120 columns. If a line should exceed this limit it should be broken into multiple lines.
•	The line should break on a logical conditional(||, &&, ...), comma, parentheses, semicolon, or space.
•	If there the many arguments, the line should break before the first parameter, and each parameter should be on new lines.
?
ThisIsAVeryVeryLengthyNamedType AReallyReallyLengthyNamedFunction(
        ThisIsAVeryVeryLengthyNamedType arbitraryName,        // This is
        int someArbitraryNumber,                              // the border
        ThisIsAMediumLengthTypeName someName);                //
                                                              //
 
ThisIsAVeryVeryLengthyNamedType AReallyReallyLengthyNamedFunction(
        ThisIsAVeryVeryLengthyNamedType arbitraryName,        //
        int someArbitraryNumber, int another number);         //
                                                              //
CRadioCell::CRadioCell(
        CPassiveClass* owner,
        SRadioConfigurationReqMsg const& radioConfigurationReqMsg,    // indention within context
        EState singleCellInUse) : CPassiveClass(owner),               //
    m_cellId(radioConfigurationReqMsg.cellId),                        // should still be
    m_lcrId(radioConfigurationReqMsg.localCellResId),                 // maintained
    m_lcgId(radioConfigurationReqMsg.lcgId)                           //
{
}


Non-ASCII Characters
Non-ASCII characters should be rare, and must use UTF-8 formatting.
You shouldn't hard-code user-facing text in source, even English, so use of non-ASCII characters should be rare. However, in certain cases it is appropriate to include such words in your code. For example, if your code parses data files from foreign sources, it may be appropriate to hard-code the non-ASCII string(s) used in those data files as delimiters. More commonly, unittest code (which does not need to be localized) might contain non-ASCII strings. In such cases, you should use UTF-8, since that is an encoding understood by most tools able to handle more than just ASCII.
Hex encoding is also OK, and encouraged where it enhances readability — for example, "\xEF\xBB\xBF", or, even more simply, u8"\uFEFF", is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.
Use the u8 prefix to guarantee that a string literal containing \uXXXX escape sequences is encoded as UTF-8. Do not use it for strings containing non-ASCII characters encoded as UTF-8, because that will produce incorrect output if the compiler does not interpret the source file as UTF-8.
You shouldn't use the C++11 char16_t and char32_t character types, since they're for non-UTF-8 text. For similar reasons you also shouldn't use wchar_t (unless you're writing code that interacts with the Windows API, which uses wchar_t extensively).

Reference:
•	Google C++ Style Guidelines: https://google.github.io/styleguide/cppguide.html
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	TYP 8.    Character Encoding


Use spaces over tabs
One tab should be equivalent to 4 spaces. The tabs should be converted to spaces.
There should be 4 spaces per indentation level. A tab could be a different number of columns depending on your environment, but a space is always one column. If you are using a well known editors, you can do this automatically as most IDE/editors can be configured to generate spaces instead when you hit the tab key.


Bracket Style
Use broken brackets for all blocks: opening and closing brackets should be in their own line.
One line conditional/loop statements(if, for, while...) should still be bracketed.
Namespaces do not add an extra level of indentation. Mark closing brace of a namespace with a comment in this format:
// namespace <name>
Closing brace and comment should be in the same line separated with a space.
?
namespace example
{
 
class Sample
{
    ...
}
 
 
int foo(bool isBar)
{
    if (isBar)
    {
        bar();
        return 1;
    }
    else
    {
        return 0;
    }    
}
 
} // namespace example


Loop/Conditional Block Whitespace
Pad empty lines around header blocks(e.g. if, for, while...).
There should be no space padding between a loop/conditional header(e.g.  if, for, while...) and the following parentheses
For for loops, semicolons should be succeeded by a space if it is not the end of the line.
?
vector<ObjectId> const ids {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 
for(auto it = ids.begin(); it != ids.end(); ++it)
{
    m_objectManager->add(*it);
}
 
m_objectManager->clear();


Binary/Ternary Operators and Commas Padding
Surround binary/ternary operators with space. For commas, there should be 1 space padding after it.
?
void func(T1 a, T2 b, T2 c);
 
if (bar == 99)
{
    foo = bar((b - c) * a, d--);
    x = isFoo ? foo : *a_ptr;
 
    if (ptr != std::nullptr && isFoo)
    {
        func(foo, x, ptr);
    }
}


Function/Class Spacing
Function/Class definitions should be separated by 2 empty lines.
?
class Foo
{
    ...
};
 
 
class Bar
{
    ...
};
 
 
void f()
{
    ...
}
 
 
int b(int x, int y)
{
    ...
}


Class Format
The public, protected, and private keywords should have no indentation. Class definition should start with its public section, followed by its protected section and then its private section. If any of these sections are empty, omit them.
Within each section, the declarations generally should be in the following order:
•	Types: classes, enums, and aliases (using)
•	Special member functions: Constructors and assignment operators, destructor, etc.
•	Methods(static methods first)
•	Data Members (static members first)
Each section is separated with an empty line.
Broken bracket style still applies for empty definitions.
?
class MyClass : public OtherClass
{
public:
    using MyType = int;
    MyClass();
    explicit MyClass(MyType var);
    ~MyClass()
    {
    }
  
    void someFunction();
    void set_some_var(MyType var);
    MyType some_var() const;
  
    MyType m_publicVar;
    MyType m_someOtherPublicVar;
  
private:
    bool someInternalFunction();
    MyType m_someVar;
    MyType m_someOtherVar;
};
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.33: The class declaration may include many sets of public, protected and private sections. The sections in sets are always introduced in this order.


Switch format
Case blocks in switch statements may use curly braces. No need to indent whole case block.
Switch statements should always have a default case. The default branch is required for handling unexpected cases. Those can arise when the code is only partially updated: a new possible value has been added but the programmer has forgotten to update the switch statement.
A program flow controlled by a case label must always be terminated with a break statement.
Write a break after the default branch. The last break in the switch is, strictly speaking, redundant, but it is required for readability.
?
switch(featureId)
{
case EFeatureId_1:
case EFeatureId_2:
    handleFeature1();
    break;
case EFeatureId_3:
{
    u32 someNumber = 333;
    handleFeature3();
    break;
}
default:
    logUnsupportedId(feature);
    break;
}
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 9.20: EVERY switch STATEMENT MUST HAVE A default: BRANCH.
•	RULE 9.21: A PROGRAM FLOW CONTROLLED BY A CASE LABEL MUST ALWAYS BE TERMINATED WITH A BREAK STATEMENT.
•	RULE 9.22: WRITE A break AFTER THE default: BRANCH.


Preprocessor Directives
The hash mark that starts a preprocessor directive should always be at the beginning of the line. Even when preprocessor directives are within the body of indented code, the directives should start at the beginning of the line.
?
if (conditionIsTrue)
{
#ifdef MT
    m_counterTable = pmCounterTable;
#else
    m_counterTable = dummyCounterTable
#endif
}


Pointer, Reference, and Const placement
Pointer(*) and reference(&) specifier should be attached to the type if it is not constant. If constant specifier is involved then put all specifiers on the right side of the type.
?
Cell& cellToSetup;
Cell* cellToSetup;
  
Cell const* cellToSetup;
Cell const*const cellToSetup;
Cell const& cellToSetup;
Cell const cellToSetup;
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 8.21: In pointer type identifiers place always the asterisk (*) close to the pointer type, not to the variable name.


Maximum depth for nested blocks
Nesting of blocks inside functions should not exceed 3 levels. If more depths are needed, consider putting it in another function instead.
Bad: 4 levels of nested block
?
void foo(int p)
{
    for (auto x : myList) // 1st level
    {
        // . . .
        if (x.ptr) // 2nd level
        {
            // . . .
            switch (p) // 3rd level
            {
            case 0:
                auto someVar = doSomething(); // 4th level! Consider extracting this into a function.
                if(someVar > MAX_VALUE_FOR THIS)
                {
                    doAnotherThing();
                    // . . .
                }
                break;
            // . . .
            }
        }
    }
}
Avoid long functions. Avoid deep nesting. Short is better than long, flat is better than deep: Excessively long functions and nested code blocks are often caused by failing to give one function one cohesive responsibility, and both are usually solved by better refactoring.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)




Design 

Input validation
All external input must be validated as strictly as possible. If possible, this should be done using white lists of allowed input. If unexpected content – a possible attack – is detected, appropriate countermeasures, e.g. blacklisting the source and logging the incident should be taken.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	INP 1.    Input validation


Give one entity one cohesive responsibility (Single responsibility principle).
Focus on one thing at a time: Prefer to give each entity (variable, class, function, namespace, module, library) one well-defined responsibility. As an entity grows, its scope of responsibility naturally increases, but its responsibility should not diverge.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Prefer low coupling
This means that classes should not have too many dependencies from each other. In addition, it is recommended that classes are doing only clearly defined tasks; both of these will help the reuse and code updating.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.75: Prefer low coupling.


Correctness, simplicity, and clarity come first.
KISS (Keep It Simple Software): Correct is better than fast. Simple is better than complex. Clear is better than cute. Safe is better than insecure.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Know when and how to code for scalability.
Beware of explosive data growth: Without optimizing prematurely, keep an eye on asymptotic complexity. Algorithms that work on user data should take a predictable, and preferably no worse than linear, time with the amount of data processed. When optimization is provably necessary and important, and especially if it’s because data volumes are growing, focus on improving big-Oh complexity rather than on micro-optimizations like saving that one extra addition.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Don’t optimize prematurely.
Spur not a willing horse (Latin proverb): Premature optimization is as addictive as it is unproductive. The first rule of optimization is: Don’t do it. The second rule of optimization (for experts only) is: Don’t do it yet. Measure twice, optimize once.
Think twice before you begin. Various tests are said to have demonstrated that programmers generally spend a lot of time optimising code that is never executed. Optimization should be done for the most frequently executed code path.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.5: Optimise code only if you know that you have a performance problem.


Don’t pessimize prematurely.
Easy on yourself, easy on the code: All other things being equal, notably code complexity and readability, certain efficient design patterns and coding idioms should just flow naturally from your fingertips and are no harder to write than the pessimized alternatives. This is not premature optimization; it is avoiding gratuitous pessimization.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Minimize global and shared data.
Sharing causes contention: Avoid shared data, especially global data. Shared data increases coupling, which reduces maintainability and often performance.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Hide information.
Don’t tell: Don’t expose internal information from an entity that provides an abstraction.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Know when and how to code for concurrency.
If your application uses multiple threads or processes, know how to minimize sharing objects where possible and share the right ones safely.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Ensure resources are owned by objects. Use explicit RAII and smart pointers.
Don’t saw by hand when you have power tools: C++’s “resource acquisition is initialization” (RAII) idiom is the power tool for correct resource handling. RAII allows the compiler to provide strong and automated guarantees that in other languages require fragile hand-coded idioms. When allocating a raw resource, immediately pass it to an owning object. Never allocate more than one resource in a single statement.
Reference:
•	C++ Coding Standards by Herb Sutter: C++ Coding Standards: 101 Rules, Guidelines, and Best Practices (Herb Sutter and Andrei Alexandrescu)


Isolate dependencies to external entities (create abstract interfaces to external entities)
When external entities (such as interface methods to a database, or to external libraries) are needed, isolate the code dependent on those entities to a special façade, or adaptor class. The rest of the code should use only those adaptor classes. In this way, if and when the use of external entities changes, only adaptor classes need to be updated.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.76: Isolate dependencies to external entities.


Logging 

Use correct level of printing
Logging Service classifies print importance by severity level. System log can be configured to adjust print filtering level of prints if necessary. In practice severity level filtering is only configured as “with debug” or “exclude debug” since number of ERROR, WARNING and INFO prints are quite limited and there is no need to filter these.
In SCT (system component test), PIT (product integration test) and FT (functional test) phase debug logging is enabled. In final tests and product the debug severity logging is disabled.
In addition to general log filtering the severity can be used to filter logging to real-time (UDP/TCP) output channel. Normal production SW should be configured so that real-time (UDP/TCP) printing is disabled and all logging excluded debugging severity is stored into system log.
The other important purpose of the severity is to help people in reading and filtering (grep) the logs. Application designer is responsible for assigning severity for each print.
Note that:
•	Error level printing can be forwarded to the Feature Ring Buffers to be saved in feature specific file in AaSysLog.
•	Debug print filtering can be further adjusted by application level using feature based filter by the means of R&D parameters – i.e. utilizing CC&S [AaConfig] service.
Different severity levels in CC&S/AaSysLog service:
Log level	Purpose	Should be active in Production?	Should be used for frequent events that can impact performance?





VIP	VIP stands for Very Important Print, these severity level prints are vital information: Kernel level errors, start-up information of SW, HW versions, etc.
In general, the usage of VIP should be avoided.  Consider “Error” in case of abnormality and “Info” if something else needs to be notified about the system state.	yes	no
ERROR	Error indicates an abnormal exception that should not be experienced in functional element. Error is always an indication of a failure but not necessarily causing an alarm. Error severity shall be used also when SW is able to recover but event is logged to notify about the anomaly.  However, Error cannot replace an alarm and proper recovery action in case of serious problem. Alarms are for the end users, and the Error logs are for troubleshooting purposes.
Examples of error cases are file checksum failure, invalid product code, invalid parameter, SW version conflict, protocol initialization failure, unknown message id, suspicious reset cause detected etc.
Error severity shall not be used in “normal” exception cases. In such a case “Warning” severity shall be used.
This is also used on unrecoverable failure situations.
And print is also used on failures that occurred due to wrong behavior and should be corrected.	yes	no
WARNING	Warning severity is used to inform about minor operation failure that are recoverable: e.g. retransmission required due to timeout, external message received in wrong state etc.
When suspicious situation happen, nacks, lack of resources, FS exceptions, should consist of debugging related information	yes	no
INFO	Info severity is treated as “important notification that is wanted to remain in system log” - information that is valuable or as an important event for testing or troubleshooting.
Information about user operations, e.g. start-up sequence main conditions, BTS, cell or HW resource state change, vendor / product code, SW version, result of configuration dependent calculations like max cell power level etc.
This includes steps important for a use case or a procedure.
This includes important periodic resource usage.
This also includes message logging/message monitoring.	yes	yes
DEBUG	Debug information is useful to developers for debugging the application.
Debug prints should not be overused, e.g. print should not be used for debugging each message sending/receiving. Message monitoring can be used for this purpose.
This includes transitions between transactions and transactions details.
Note: Debug prints activation on the field (customer networks) shall be controllable and by default the debug prints shall not be activated. There shall be possibility to activate online the dedicated Debug prints related to problem for troubleshooting purposes when necessary.	no (should not be needed because info level prints should be sufficient)	yes (but this prints should be not included in the production code)
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	4.1 Current Usage. This section describes the definitions of the different logging severities currently used in BTS.
•	Logging concepts and guidelines: Logging concepts and guidelines
•	1.4. Logging severities


Be aware of different log types
System log is a CC&S service provided for applications to collect logging events ie prints [AaSysLog], [CNI_2896], [CNI-23487]. Application has only one logging service but the same system log information is available for a tester via different “views”
•	Startup log contains defined amount (time and size) of system log print messages that are kept in processor volatile memory (/ram disk). In addition to startup SW fault localization the main purpose of the startup log is to provide information about HW auto detection, initialization and configuring phase.  [CNI-30704]
•	Runtime log is a snapshot from current system log FIFO (ring buffer) at the time element manager uploads BTS snapshot information (also called as BTS technical logs). System log FIFO is maintained by each CC&S syslog instance – ie typically FIFO per CPU.
In addition / instead of a FIFO the CC&S syslog service [AaSysLog] can be configured to forward syslog to another node – i.e. BTS master node. Syslog FIFO has a fixed size that is configured for each node during startup by a R&D parameter.
•	Realtime log is system log data sent to server, remote PC or local PC tool using TCP or UDP protocol in ASCII format. In final product in the field, using the realtime log is normally a painful process.
•	Post mortem log is a short FIFO (example 1MB) content of the system log just before any SW reset to aid in troubleshooting SW failures especially before SW crash. Post mortem is kept for three latest resets in a row.
•	History Buffer is an application specific ring buffer for tracing.  System Critical information (like “fatal” failures, critical configuration info etc.) shall be stored into History Buffers.
•	System Level Print (or log) is logfile which is stored on flash memory.  The content shall be specified on EFS level. [CNI-2896].  The interface for the file is provided by CC&S [AaSysLog][chapter 1.1.15 System level printing]. System Level Prints has only 2 level of severities: INFO and ERROR.
All the above log files are retrieved from BTS by site element manager (SEM) or WebUI using “File/save-as/BTS snapshot”. SEM will fetch all configuration and log etc files from BTS including all the above listed log files (except real time log) and create one “snap shot ZIP file” SEM puts also own files into this file archive.
There are binary files in snapshot those content is dependent of the producer, System Component specific history buffers:
•	TTI Tracer traces Cell and User specific TTI information and helps to analyze the behaviour of the Packet Scheduler. TTI Tracer data capturing is implemented as a 10MB ringbuffer which is filled up with information continously. It is not possible to stop and restart tracing. TTI Tracer runs on scheduler DSP cores separately for UL and DL and stores a binary file. [MAC PS TTI Trace]
•	ims for OAM stores the OAM information model behaviour.  WebUI shall be the main tool for getting the ims logs in future (once it replaces the SEM) on side of snapshot.
•	shb State History Buffer for CPlane is also a binary file is a logging mechanism implemented in CPLANE with customizable size of buffer for recording: incoming and outgoing messages, state transitions, and SCTP events (only in TUPC). [C-Plane Logging]
•	L2 Trace is a debugging tool consisting of internal API whose methods can be called by L2 software components to trace their contents. The result is a binary files that contain data from traced items [L2 TTI Trace].
As per LBT1446/CN5001 CC&S provides "Buffering Debug Feature prints", [AaSysLog][chapter 1.1.9 Feature Ring Buffers].  Purpose of Feature Ring Buffers is to generate application SW (subsystem/feature) specific ring buffer and store log prints of Application SW (subsystem/feature) with particular severity level to that buffer.  By System Component runtime buffers an application SW can register own system component runtime buffer and redirect own prints to that buffer [AaSysLog][chapter 1.1.10 System Component runtime buffers]. 
Apart from RFSW and TRSW, the files uploaded from BTS are controlled by a “technical log master”. Any number of “technical log clients” can be registered to this master to add any number of files depending on requested coverage to this file archive set. CC&S platform SW provides the above logs for the technical log master from each CPU environment.  The log files from TRSW and RFSW are collected directly by BTSOM, not via CC&S.

Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	1.2 Different log types


Be aware of filtering mechanisms of logging services
Basic rule is that in later test phases the same log filtering shall be used as in final product SW. However in EI and EV phase “real time logging” is preferred. Feature level detail debugging information is enabled on need bases – as suggested by SW designers.
In addition to severity level filtering provided by CC&S also application level filtering by means of ”R&D parameters” (-> CC&S AaConfig service) for DEBUG severity is recommended. This allows switching only a sub-set of a SCs DEBUG logs on or off.
All SC shall support the online modification (both activation and deactivation) of logging related R&D parameters, so that the detail of logging can be adjusted without BTS reset.
Logging prints should be planned in each SC in advance to handle also possible exception cases with configurable additional prints so that the need for knife files and BTS reset is minimized, when problems are discovered and additional debugging prints are needed.
SysLog printing levels can be enabled and disabled with a suitable tool (BTSLog or Emil). Besides manual commands the tool might also support more advanced triggering mechanisms to change the SysLog print level, e.g. tool notices from message trace decreased KPI ratios.
Once more – be aware not to use system log for “message logging”. Use message tracing instead to reduce effort and to keep SW size reasonable. Logging increases somewhat SW size and it depends on the application if this is an issue. For example, it is important to optimize the size of DSP SW that is kept in internal memory. Excessive long phrases in log text wastes both log and program memory.
In final SW there shall be reasonable high amount of prints. BTS filtering shall be maintained in such a level that information in log is relative high to be more likely that log contains enough symptoms to localize fault without regenerating same conditions in SW laboratory. It is costly to repeat same test cases with different log settings or trying to reproduce occasional error case detected on field.
Same reasoning applies for log level runtime variability: it is expensive / time consuming to make special test SW packet to adjust logging. Application domain and SW design competence can be “measured” how well SW is prepared for troubleshooting aids where prints play an important role.
Since log file browsing / “grepping” by some text tool is anyway required to filter needed information there is a basic principle for prints (and message tracing): “low level capture filtering in BTS” / “filter offline with PC tools”.
CC&S AaSysLog service filtering mechanism
Here is the description of the filtering mechanism on CC&S/AaSysLog service in particular:
Severity Level
Logging Service separates prints importance by severity level and may reduce prints if necessary. It is application developer responsibility to assign severity for each print. Logging Service supports five severity levels:
•	Debug - Information is useful to developers for debugging the application.
•	Info - Information of normal operations: reporting measuring, one time initialization, etc.
•	Warning - Warning severity is used to inform minor operation faults that are recoverable: e.g. retransmission required/timeout.
•	Error - Information of application errors: internal violation, unrecoverable faults.
•	Vip - VIP stand for Very Important, this severity level prints are vital information: Kernel level errors, start-up information of SW, HW versions, etc.
Filtering
Logging Service supports several filtering mechanisms:
•	Input filtering - filtering while prints are added into runtime buffer,
•	Output filtering - filtering while prints are forwarded out of the system.
Figure below presents AaSysLog service input filtering state diagram while adding single print into the AaSysLog runtime buffer.
 

Input filtering is multi-stage filtering - first state is filtering print against runtime buffer fullness and second is filtering on input filter level.

Filtering against runtime buffer fullness
Filtering against runtime buffer fullness requires that for AaSysLog print functions which do not have priority parameter shall have it - i.e. only AaSysLogPrintL and AaSysLogVPrintL supports priority parameter. For other print functions there’s mapping done according to table below.
Mapping of severity to priority:
Severity	Priority



EAaSysLogSeverityLevel_NotValid	EAaSysLogPriority_NoPrints
EAaSysLogSeverityLevel_Debug	EAaSysLogPriority_01
EAaSysLogSeverityLevel_Info	EAaSysLogPriority_02
EAaSysLogSeverityLevel_Warning	EAaSysLogPriority_02
EAaSysLogSeverityLevel_Error	EAaSysLogPriority_03
EAaSysLogSeverityLevel_Vip	EAaSysLogPriority_03
EAaSysLogSeverityLevel_NoPrints	EAaSysLogPriority_NoPrints

The figure below presents which prints are accepted and dropped taking into account runtime buffer fullness.
 
Note: Its important to note when priority and severity are used for filtering.
•	When using AaSysLogPrintL and AaSysLogVPrintL the priority is used for filtering (so severity is no longer relevant for filtering, but its AaSysLog service will still show this severity when its logged).
•	On other print functions, the severity of the log is used for filtering.
•	Kindly check the table above on how the mechanism maps and compare prints with different priorities and severities.
Reference:
•	CC-S API Specification and Customer Documentation / AaSysLog: CC&S API Specifications and Customer Documentation 
•	AaSyslog Service/SYSLOG SERVICE API SPECIFICATION
•	1.1.4 Severity Level
•	1.1.5 Filtering
•	Logging concepts and guidelines: Logging concepts and guidelines
•	7 Filtering


Consider logging performance
Here is the description of the performance of CC&S/AaSysLog service in particular:
AaSysLog is designed for minimum overhead but log performance depends on many other parameters. Syslog performance does not support logging in millisecond granularity. when such accuracy is needed, History Buffer, TTI Trace, L2 Trace or message trace should be considered.
Currently there are no performance requirements for logging but to get a picture of the logging performance some guideline figures are presented:
•	Max ~5% CPU overhead when real-time logging enabled and ~1000 prints per second. This is extrapolated for FSMF where 300 prints/second cpu load was ~5 %.
•	BTSlog PC is able to record total throughput up to 200 Mbps logging data from > 20 nodes simultaneously
•	To avoid SysLog buffer overflow single application should not be designed to print any more than absolutely needed. 100 prints per second (actual load dependence on size and number of logging messages and variables in an API call) means 10000 prints per second in case of 100 applications.
•	As described above runtime log is kept in a ring buffer. So old entries will be overwritten by new entries. So, there is always a compromise between history that is available in the buffer and the level of detail that can be logged.
An example from LTE L2:
Currently AirScale K2 ARM SoC is capable of printing max 12 Mbps (= 1500 * 8 (bits for syslog packet size) / 1ms (min timeout for syslog packet send timer) ) without loosing prints. In case the L2 is printing 1MBps with heavy load, the runtime 10MB ring buffer will be overwritten in about 84 seconds.
Guideline to make the best out of the limited ring buffer size:
•	Consider using statistical means for collecting data instead of logging.
•	For unexceptional situations logging is a must.  However, consider the usage of filters if it is possibility for exceptional case to be repeated in a row.  As an example, L2 Filter Service, see [LTE Userplane]
•	Limit the logging of “successful cases” that can occur frequently with the log levels that are active in field (VIP, ERR, WRN, INF) (e.g. packet processing, TTI based processing, call processing)
•	In “unsuccessful cases” (ERR, WRN) consider logging a lot of additional context information as you won’t have logged the successful steps before the error or warning occurred
•	It can be also beneficial to see that some functions/parts are working normally in order to locate the origin of a problem more easily. In those cases, consider to do periodic (but not so frequent) logging of resource status (peak, average rates, #active users, …) and/or to log some of the “successful operations”.
•	Consider feature logging (with additional R&D tags) for Info prints and especially DBG prints

Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	4.2 Log performance


Use standard priorities and numerical priority values when logging
RFC5424 Recommendations (refer section 6.2.1 in the link below)
•	https://datatracker.ietf.org/doc/rfc5424/
The following are the priorities defined:
Numerical value	Severity code



0	Emergency: system is unusable
1	Alert: action mst be taken immediately
2	Critical: critical conditions
3	Error: error conditions
4	Warning: warning conditions
5	Notice: normal but significant condition
6	Informational: informational messages
7	Debug: debug-level messages
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	4.2 Standardization


Add inventory information in the logs
The following information about the NE/Product shall be logged so that during troubleshooting, the information logged shall be useful in identifying the versions and the various components of the product:
•	Hardware Details – components identification
•	Software versions, release numbers, build numbers
•	License information – licensed features
•	Platform version - build number
•	File size
•	OS versions
•	Third party product versions (h/w, s/w)
•	DB versions
•	Firmware version – FPGA, CPLD devices
Note: Some of this items are already printed by other components (such as OAM and platform), please add only what is necessary and do not add redundant prints.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.1 NE Inventory Information


Add configuration details in the logs
All NE/product configurations shall be logged such that any wrong configurations shall be identifiable and help troubleshoot the problem.
•	List of configured parameters and values of the parameters
•	Changed parameters
•	Timestamp of the parameters changed
Note: When using AaSysLog service the logs already have a BTS timestamp so there is no need for timestamp for these logs.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.2 Network Element Configurations


Add logs from building blocks (subcomponents or subsystems)
Hardware, OS/Kernel, 3rd party products, Databases, etc. are considered as the building blocks of the product. Logs from such building blocks shall enable efficient troubleshooting for complex errors.
When a snapshot of the symptom data is collected from a NE/product, the snapshot shall include all the logs from the building blocks of the NE.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.3 Logs from the building blocks


Add logs based from platform symptoms and failures
NEs and products usually use the platforms like RCP, Flexi, etc. Logs from platforms shall be part of the snapshot of the symptom data so that platform anomalies can be addressed. Platform software is no different from any other software and hence logs from the platform shall help troubleshoot the problems
Cloud and Distributed Architecture
Cloud infrastructure (h/w and s./w components) are nothing different from the platform logs. Meaning, cloud infrastructure components and the VNFs shall produce logs relevant to the functionality that is offered and they shall adhere by the guidelines of this document.
While collecting the logs, relevant filters shall be set to get the logs.
Even in case of Distributed Architecture (like CU/DU split of BTS), each component shall produce the logs as mentioned in this document. It is only while collecting the logs, user may place appropriate filters to get the snapshots (e.g., user may be interested only in logs from a particular CU or DU, OR it can be from a particular CU and some DUs attached to the CU).
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.4 Logs/Symptoms from the Platforms
•	5.4.1 Cloud and Distributed Architecture


Add logs when snapshot is collected
Runtime Snapshot:
At any given point in time when the snapshot is collected from the NE, the following information shall be logged:
•	Memory, cpu utilization
•	processes exceptions
•	Thread/process failures
•	Process restart timestamp
•	Exceptions/errors in processes
•	Blocked alarms
•	HW Dumps (memory/register dumps, instruction traces, events and counters)
Network Snapshot:
Snapshots from the physical/transport network shall be part of the logging to troubleshoot the network related problems:
•	Health of the physical networks – heartbeat, packet loss, jitters
•	Network configurations
•	Link utilization
•	Configurations (IP addresses, Mapping IP addresses to VLANs, Mapping VLANS to correct physical addresses, Port Number configurations, DNS settings, Routing and ARP Tables, Firewalls)
•	Counters/information need to be implemented for uplink, downlink, packet loss, link delays, network sync status, etc.
•	For the IP packet capture, pcap files shall be available so that the protocol problems can be analysed using tools like wireshark
All the information above may not be known to the individual network elements, but at a network level these information shall be available.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.5 Runtime Snapshot
•	5.6 Network Snapshot


Add logs for interface and protocol symptoms
NEs/products shall be using the standard interfaces and protocols to communicate to other NEs/components and also the hardware.
 The following shall be logged so that any problem in the interfaces can be easily identified:
•	Version mismatch
•	Protocol errors, cause codes for failures, heartbeat
•	No response to messages
•	KPIs – counters and alarms
•	For every neighbouring NE and the protocol
•	NE shall be able to store traces for at least xx minutes
All interfaces/protocols to hardware shall produce similar logs as above.
It is observed that when a 3GPP specified interface is used, the cause codes mentioned in the specs are sometimes ignored. During the analysis of the cause of the failure, such cause codes are very helpful and therefore it is mandated that
•	The cause codes logged and compliant to the standard specifications.
•	The analysis tools shall show these causes codes and a human readable description of the same
•	The analysis tools shall also be able to use cause code occurrences and shall be able to analyse the data intelligently
E.g., for causes of X2 interface failures, see section 9.2.6 of the document 3GPP TS 36.423 V12.2.0 (2014-06).  For those who are not well versed with 3gpp cause codes, please see CauseCodes as return values detailing the reason for failure of an interface. Some example causes are – interface version mismatch, unknown parameter value/range, no_radio_resource_available, etc..
It should also be noted that logging the interface problems sometimes might degrade the performance and in such cases counters/alarms can be used to indicate the failure of the interfaces.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.7 Interface/Protocol Symptoms


Add logs during startup
Startup is a good example that is used to monitor functionality and performance.
Ideally, BTS startup sequence, pacing and completeness can be monitored. BTSOM is printing when each sub state has been completed like HWAPI startup completed, RF module <x> ready, Faraday <y> ready, clock stabilized, cell enabled etc – refer to BTS startup sequence / activity chart for the sub-states.  In addition, L3 BTS SW is printing  when all the cells are ready to take calls – ie when BTS has completed startup all startup procedures.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.2. Startup prints


Add logs during install/upgrade/update
Logs during the installation, upgrade, update of software shall be helpful in identifying and troubleshooting the errors during the process.
•	Failure/success with details of the different steps in install/upgrade/update indicated by logs. For each step in the Upgrade/update procedure the corresponding software must produce logs to indicate the problems encountered in that step.
•	Start time and end time shall be logged for the various steps and also the overall Upgrade/update procedures with the timestamp.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.8 Install/Upgrade/Update logs


Add logs during backup/restore/recovery
For backup and restore procedures logs produced shall be able to identify the anomalies in the procedures
•	Failure/success with details of the different steps in backup and restore indicated by logs. For each step in the Backup/Restore procedure the corresponding software must produce logs to indicate the problems encountered in that step.
•	Start time and end time shall be logged for the various steps and also the overall Backup/Resore procedures with the timestamp.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.8.1 Backup & Restore


Add logs for faults
All alarms/events raised by the NE/Product shall be part of the logs. And the description of the alarms and events are standardized.
•	The format of the alarms and events shall be standardized and the same is logged
•	The product shall not only log the current alarms but also keep the log of the history of alarms
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.9 Fault Management logs


Add logs regarding performance
Key Counters/KPIs shall be part of the logs indicating the counter/kpi name and the values along with the timestamp are logged.
E.g., Sleeping cells are identified by calculating a KPI, using a formula involving several counters. Depending on the performance issues, it might be decided to just log the KPI instead of all the counters involved.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.10 Performance Management logs


Add NE/product specific logs
Apart from the standard logs that are mentioned in the sections above, each NE/product shall produce logs specific to the functions and features of the products. This document does not describe the details of functionalities of the products. The following are some of the examples of the NE specific functions:
•	Handovers
•	Failure of all handovers with the root cause for the failure
•	Intersystem handover symptoms (logs and counters)
•	Inter PLMN handover/Inter Operator handover - symptoms (logs and counters)
•	Hard handover symptoms (logs and counters)
•	Billing
•	Logs for failure of billing/charging (CDR) related problems.
It is a good practice to make sure that products log enough details for every feature that is implemented, so that while troubleshooting an error, the logs can be classified based on the feature as well. E.g., syslogs of BTS fall into this category of NE specific logs.
NE specific logs shall also include the logs for the various features and the use cases that are supported.
NE/Product specific log parametrization
In final SW there shall be reasonable high amount of prints/logs. In cases of high amount of logs, log rotation (FIFO) shall be considered. NE filtering shall be maintained in such a level that information in log is relatively high to be more likely that log contains enough symptoms to localize fault without regenerating same conditions in SW laboratory. It is costly to repeat same test cases with different log settings or trying to reproduce occasional error case detected on field.
•	Each NE/product shall support the online modification (both activation and deactivation) of logging related parameters, so that the detail of logging can be adjusted without NE/product reset nor gap in traffic.
Logging prints should be planned to handle also possible exception cases with configurable additional prints so that the need for special SW deliveries (“knife” files in case of eNB/BTS) and NE/product reset is minimized, when problems are discovered, and additional debugging prints are needed.
For example, for eNB the mechanism of controlling R&D flags, used for log parametrization, shall be implemented so that eNB reset is not needed for activating/deactivating a flag.  In many cases the eNB recovers on reset and in other hand faulty situation is lost.  Also, high number of logs may hide the actual issue in the “noise” and low number of logs may leave valuable information out.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	5.11 NE/Product specific logs
•	5.11.1 NE/Product specific log parametrization


Use standard logging format
This section discusses about the format in which the logging is done. It has to be stated here that there were many attempts that were made to harmonize the format logs across products and business lines, but no common understanding was reached for various reasons. This section describes the format of the logs based on standards.
The general guideline to the format of the logging is as mentioned below:
•	follow standards (3GPP, IETF, RFC, etc.) where applicable
•	when standard does not exist use vendor naming convention
•	Nokia specific requirements as mentioned in architecture specifications
•	When parameter is Nokia interface specific follow naming from interface specification (coordinated by specification teams) and generally, require key parameters naming to be explicitly specified and look after consistency in specification and code review
Considering various options that we have on hand, it is recommended that we follow RFC5424.
Especially refer to RFC5424 chapter 6 describes the log line format.
Link to the RFC can be found here
•	https://datatracker.ietf.org/doc/rfc5424/
Any deviations from this section 6 of the document shall be documented and shall be made available to the users of the logs. It shall be noted that the tools which analyse these logs are dependent on the format and hence it is expected that the deviations are controlled and code review/inspections are carried out to keep the deviations to minimum.
Note: For WCDMA CP, use the utilities on CP framework (such as StructureLogger, EnumToString, MessageLogger, etc) to keep the deviations to a minimum.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.1 Standardization of Logging format


Use standard file naming conventions for logs
Snapshot/Techlog files shall follow the file naming conventions. It should be noted that the files shall be in the zipped format and the name of the file shall have the following information
•	<type of log>_<NE name and version>_<software version>_<siteInfo>_<timestamp>.zip
•	E.g., Snapshot_MRBTS-395393_FL17A_ENB_0000_000573_000067_L9M-Seraotani_20171209-0710.zip
It is observed that some products have additional information in the filename like what triggered the data collection, like RNC
E.g. RNC heath-check/sysdiag log:TSUPL_mcRNC_1009_User_diagnostic_20190820-162630.tar.gz
It is mandated that format suggested shall be followed but any additional information can also be added to filename which helps in diagnostics. The additions shall be documented in the product specific cookbook.

Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.2 File Naming conventions


Use platform APIs and common functions for logging
Platform that is used to build the product shall standardize on the logging format so that all the products/feature shall adhere to the logging format supported by the platform API.
Note: For WCDMA CP, use the utilities on CP framework (such as StructureLogger, EnumToString, MessageLogger, etc) to keep the deviations to a minimum.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.3 Platform Support


Put necessary contents for each one log line
For each log entry (log line), the following items are generally applicable (refer RFC5424 section 6 for details)
•	Timestamp
•	Severity
•	Node/NE name (optional)
•	Module name
•	Feature prefix
•	Unique log identifier or the actual string (reference ID)
•	Variables and values
This kind of formatting per line (RFC5424), would enable the user of the log file to visualize it as a table and hence log analysis tools can be used easily to parse and visually represent the data.
E.g., Unique Log Identifier identifies each of the messages uniquely. Like “Err404: File Not found”. But such a standardization was not possible earlier as it calls for extreme discipline across organizations (maintaining a table of Unique identifier and the message).
In many cases, source code filename and line number are also included as part of the logging. This is useful in many cases, however again not a standard practice.
The section above on “Platform Support” at least standardizes the logs per product as the platform APIs are used for the purpose and the section “Standardization of Logging format” indicates how each line of the log is constructed.
It is also observed that logging of hexadecimal values or the naming convention for the strings, do not follow a standard practice and hence it is mandated to have:
•	Hexadecimal values shall be logged with simple prefix 0x and no underscores are allowed
•	Naming conventions shall have standard practice of using a capital letter instead of blank spaces (camel case).
Example 1:  for hexadecimal values, instead of using 0x__ABC113 simply use 0xABC113
Example 2: for naming the parameters, instead of using “L2 Manager” use L2Manager
Note: Some of this items are already added by Platform/AaSysLog service (such as Hw resource (cpu) identifier, timestamp, operating system process ID, severity and SC name), please add only what is necessary and do not add redundant information.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.4 Logline Contents
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.1. Automatically added print content


Put the unique log identifier or the reference IDs to differentiate similar logs
If there are several logs for different IDs (for example, the log is per cell), make sure to add the neccessary reference IDs for the logs to differentiate it with the other logs (for example, put cellId in the log for cell-level logs).
This includes (but not limited to): cellId, nbccId, crnccId, rlId, cRnti, ueId, sicAddress.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.4 Logline Contents
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.1. Automatically added print content


Avoid putting multiple same logs that are repeating
Avoid putting multiple same logs, use a unique log indentifier or reference ID to differentiate logs.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	Example prints


Be aware of the verbose and binary logs trade-offs
This section addresses the issues of having a human readable ASCII logs versus the binary logs.
Verbose or Human readable/ASCII logs are easy to use and comprehend by humans. The logging would contain
-           Log event tagging to make logging events unique and self-explaining
-           Verbose parameter names
Binary logging will also have the following:
-           logging entry consists of data format and actual variables
-           logging data uses formatting string that defines constant text and places for variables are located
It should be noted that converting logs from binary to human readable need an explicit tool or enable online decoding in target. Benefit of binary log is to have 4x more information in same memory space and consume 4x less cpu cycles compared to real time formatting and decoding.
However, if the decision is to make it binary, it shall be noted that:
•	Analysis tool are supported
•	The tools, that are used to analyse/visualize the logs, are able to show the logs in a human readable way
There is no recommendation on whether the logs shall be in binary or not and it is left to the respective product/business lines, but for real time logs it is recommended to use the binary format and the tools shall be in sync with the format.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	6.5 Verbose & Binary


Analysis tools are mandatory when using binary logs
When creating/using binary logs, there should be mandatory analysis tools.
The analysis tools are used to analyse/visualize the logs and are able to show the logs in a human readable way.
Reference:
•	MN Logging: MN_Logging
•	Binary format


Be aware of log message transport and encryption
If Network Logging is needed for diagnostic the log messages should be transported with a reliable protocol, e.g. TCP, on order to avoid loss of messages.  If messages contain sensitive data furthermore a protocol encryption is required too, e.g. TLS.
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	7 Secure Network transport and storage of logs
•	Log Message transport and encryption


Follow the rules when logging customer sensitive data
System log contains data which is categorised as Customer Sensitive Data according to [Privacy Data Scrambling]. Such data contains Service Provider End User Information, Network Topological Information and Proprietary Customer Information including for example IMEI, TIMSI, GUMMEI, Site name and Site location.
All types of logging data shall be treated as it may include Customer Sensitive Data and will be encrypted according to appropriate process (like CAPS) nevertheless the market/customer.
[CNI-12795] defines the ‘pattern matching’ method for scrambling the Customer Sensitive Data: Snapshot Description File shall contain a specific section for scrambling.  The type of the Customer Sensitive Data is marked by specified tags.  On top of that, the full line example for each separate parameter expressions as it is printed in the log [TestConcept]. (Pattern Maching scrambling method is used and explained also in 5G)
Here are the parameters that are considered sensitive: https://caps.americas.nsn-net.net/attachments/21609571/Privacy-Sensitive-Information-new.xlsx
For WCDMA, here are some details regarding Privacy Data Scrambling: Privacy Data Scrambling
Reference:
•	Common logging guideline for MN: Common logging guideline for MN
•	7 Secure Network transport and storage of logs
•	Customer Sensitive Data
•	Logging concepts and guidelines: Logging concepts and guidelines
•	2 Customer Sensitive Data


Use debug for the prints that can only be understood by the SW developers.
Generally, the logs/prints should be understood by any reader (developer, tester or customer team). But in the case that the print is only intended to SW developers, use debug severity for these type of prints.
For these prints, the SW module name, source file and method name are useful.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Do not overuse debug prints
Do not over use debug prints – for example do not use print for debugging each message sending / receiving since message monitoring shall be used for this purpose.
Excessive debug printing may lead to missing important exceptions.  Debug prints shall always be behind component activation R&D flag.  R&D flag itself needs to be online modifiable.
However, justifying for debug severity is not straight forward: detail information for most of the log consumers may be irrelevant but is important for the SW developer. Basically, it is better to have “more than too little” – filtering (grep) shall practically anyway by used to focus on data of current interest. On the other hand, this does not justify that “everything” should be logged – be cautious not to overload log size.  “Module test phase prints” can be removed during compile time to filter these out in target SW to save program memory footprint.
The following rules should be remembered while printing debug prints:
•	Choose the log level according to the table above BUT
•	Try to avoid logging “successful cases” that can occur frequently with the log levels that are active in production environment (ERR, WRN, INF) (Call setup, packet processing, TTI based processing)
•	If you need information on the system status in normal operation consider to do periodic (but not so frequent) logging of resource status (peak, average rates, #active users, …)
•	Consider feature logging (with additional R&D tags) for DBG prints (AaSysLogPrintE. AaSysLogVPrintE and AaSysLogPrintF)
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	1.4. Logging severities


Consider logging frequency
Consider event frequency: when an event is “one time only” it is not so important to consider if print is needed.. But if the event causing print is a frequent one it requires more justification. That is selecting if print shall be used or not, is relative to print frequency.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	4. When to use Logging information


Consider how to grep the logs
In addition to “print-id” debug prints should select “unlike unique key word” for “grepping”.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	6.2. Use key word to help log file analyse (grepping)


Consider impact on binary size for logging
Normally, SW size is not an issue in making justification whether to print or not.
If there are a lot of prints to be added, determine the impact on binary size (using a sample build) before proceeding with refactoring/removing the prints.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	4. When to use Logging information


Determine when and what to log
This section will give guidelines what the print payload should contain.
During development phase debugging output will be essential for the SW developer himself. But later on, in later phases of project’s lifetime, debugging output will no longer be mandatory. Analyzing runtime situations, conceiving the system-status, detecting misbehaviour and abnormalities will become major aspects of logging.
The system will be also more stable, so that also the integrators no longer need so many details as in initial “bringing into operation” phases. They now will more rely on specific indicators showing that something does no longer behave as it has done in all the test-situations the time before.
What are the major duties of logging-output to fulfil?
Condition-monitoring
•	Give for example the system-technician in the field or the operator considerable hints in case of troubleshooting. There should be also verbose information available if the failure could not be cleared at once to give the back-office specialists a fair chance to track down the problem.
Identification of misbehaving interoperability
•	As the system-tester or the system-integrator wants to quickly identify misbehaving parts of the software, the logging-output should give exact information about internal systems causing trouble.
Failure analysis
•	The software-developer or experienced system-integrator will use a detailed version of logging-output to get deep into the details of the software to find bugs or confirm the correct behavior of applications.
White-box testing
•	Some software-developers will also use logging-output to debug their code.
•	Keeping these scenarios in focus we’ll get different requirements the logging output should fulfil.
•	Logging should be purposeful and targeting – enlightening the situation to get a complete overview of the running or even crashed system.
•	But who can add this sophisticated mixture of information? To answer this question we should have a look at the people adding the logging-output to the software.
•	In the natural primary position this is the software-developer.
Some software-developers haven’t found out, others do not keep in mind that debugging software is something completely different than analysing erroneous software out in the field or a crashing multi-application situation in the test-lab. They will not have a debugger or personal test-harness in such situations. They fully have to rely on the data given by the system to analyse the situation.
Software-developers should know which kind of debugging information they will get from field later. They should try to imagine the different situations how their software could probably fail in different environments and how this can be detected.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5. What should logging-output contain?


Prefer to add information so that it can be easily be located in the code
When useful, debug, error and warning messages can include source code file name and line number – ref CC&S AaSysLogPrintD() (or AaError ). Typical cases for “assertion” is when message content, state, condition (if) – integrity checking ends up to branch point where SW should never end up. Robust SW tolerates defects in incoming data but instead of silently ignoring consider logging these asserts into system log. These can be important in pinpointing SW (or HW) fault in the upper chain causing corrupted message.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Prefer to add readable and easily understandable runtime information in the logs and prints.
Hard-coded error messages usually do not provide enough information to handle the error. It is much better to report “Error opening file: /etc/passwd” than just “Error opening file”.
When there is a print related to a message (parameter out of range), use sack message (lexical) name instead of numerical values.
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RECOMMENDATION 9.73: Do not use static error messages but create them dynamically adding runtime information.
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Make sure that prints regarding state machines are sufficient for investigation
When print is related to state machine (message received in wrong state etc, state timeout expired), use name of the subsystem, data object and state / substate name.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Make sure that prints regarding conditionals are sufficient for investigation
When inconsistency is detected in logic series of switch / if statements, use the function/operation name and AaSysLogPrintD().
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Make sure that prints regarding message handling are sufficient for investigation
Here are some events that need to be considered:
•	Missing event or timeout (reply time out)
•	Duplicated or repeated event or events in wrong order (warning about receiving message in wrong state)
•	CPU reset during test (startup prints)
•	Parameter range exceeded (using SW for data integrity checking instead of manual tests)
•	Message is too short (if not validating and referring to data beyond message allocated space would cause unpredicted results).
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Prefer to have prints one event per line
This would be easier to understand when checking the logs.
When doing this approach, please consider that impact on performance of logging, the frequency of logging and the binary size.


Prefer to log a single line per AaSysLog function call
An application shall print data to a single line per syslog call – i.e. not to use “\n” in formatting. Even it is technically possible to use new line “\n” this is not allowed since unit name, time stamp etc would be missing from next line.
In addition it is better to try to print all information in one line instead of calling syslog API several times since it is more difficult to read realtime log when prints from several CPU’s are in shared (BTSlog) file.  When number of system log increases it is much more difficult to combine information from several lines from a large log file (both manually and by a script) since several matches may be detected when required to use too simple key words (due to main key word likely in first line). BTS CPU time spent on logging is mostly affected by the number of lines printed, not on their length.
“Multi column” instead of “multi line” is preferred to aid for analyzing data. It is time consuming for a human to combine information from several log lines. In addition it makes quite challenging to make such advanced scripts (looking forward – backward – several lines in between..).
It is typical to analyse numerical data using graphical charts. Parsing data from log files and analysing with Excel (or Matlab etc) is a lot easier when data is formatted one line per event and data column per information element / object.
Long log lines can be used up to 512 characters. Most important data (reference identifiers etc) shall be in the beginning of the line.  In addition to “log data consistency” longer line increases data density of the runtime log: less space is wasted to relative long log header. Runtime log has a limited space that defines time duration that fits into runtime log.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	6.1. Use single line


Use same message and parameter names in the interface definitions when logging
Please use same names when logging as with the inteface definitions (sack definitions, interface specifications (IFS)).
When there is a print related to a message (parameter out of range) use sack message (lexical) name instead of numerical values. Also, for the information elements use same name as in the message definition.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	5.1.2. Application requirements


Make sure that the logs used by test automation are updated.
Be aware of the logs used by test automation. Ask the testing teams if there are logs used by test automation, this is to avoid any problems if some logs are changed.


Make sure that tools are updated for the current logs
Be aware of the logs used by the tools, contact the different tool authors when checking and updating logs. This is to avoid any problems with the tools.


In cases of failures, please make sure to add all the necessary information and context to diagnose the problem.
In the event of faults, please make sure to add all the neccessary information in the logs to diagnose the problem.
In warning and error prints, please make sure to add all the necessary information in the logs to diagnose the problem.
And make sure that all the technical context are added in the logs (transition paths, which part of the code failed) in order to diagnose the problem.
This is to reduce the investigation time for issues/problems/prontos, which might be costly (consider the time of the testing teams and customer perspective)


Remove redundant white space on the prints
Putting spaces without any context should be avoided.
Even if the purpose is formatting the print is to aligned with other prints, this should be avoided because:
•	Platform/AaSysLog Service might put some prefixes which would ruin the alignment of prints anyway
•	Grepping them with other prints makes the indentions not useful
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	Example prints


Don't put any unnecessary characters and lines in order stylize the log
A example of bad logging:
Bad: 4 levels of nested block
?
INF/SOMECOMPONENT/IM, statistics_printer:  ***** INFO MODEL STATISTICS: ***** // unnecessary asterisks
INF/SOMECOMPONENT/IM, statistics_printer:  ----- No. of objects added        : 3 (5168) // unnecessary dash and spaces
INF/SOMECOMPONENT/IM, statistics_printer:  ----- No. of objects removed      : 3 (913)
INF/SOMECOMPONENT/IM, statistics_printer:  ----- Objects count               : 4255
INF/SOMECOMPONENT/IM, statistics_printer:  ----- Binary objects size [bytes] : 465301
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	Example prints


Use standard C++ numerical literal format when logging numerical values

For integer literals:
•	decimal-literal is a non-zero decimal digit (1, 2, 3, 4, 5, 6, 7, 8, 9), followed by zero or more decimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
•	For example: "42"
•	octal-literal is the digit zero (0) followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7)
•	For example: "052"
•	hex-literal is the character sequence 0x or the character sequence 0X followed by one or more hexadecimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F) 
•	Based from the MN Logging guideline, the hexadecimal values shall be logged with simple prefix 0x and no underscores are allowed.
•	For example: "0x2A"
•	binary-literal is the character sequence 0b or the character sequence 0B followed by one or more binary digits (0, 1)
•	For example: "0b101010"
•	integer-suffix, if provided, may contain one or both of the following (if both are provided, they may appear in any order:
•	unsigned-suffix (the character u or the character U)
•	long-suffix (the character l or the character L) or the long-long-suffix (the character sequence ll or the character sequence LL) (since C++11)
•	For example: "18446744073709550592ull"
For floating point literals:
•	digit-sequence representing a whole number without a decimal separator, in this case the exponent is not optional. 
•	For example: 1e10, 1e-5L
•	digit-sequence representing a whole number with a decimal separator, in this case the exponent is optional. 
•	For example: 1., 1.e-2
•	digit-sequence representing a fractional number. The exponent is optional. 
•	For example: 3.14, .1f, 0.1e-1L
•	Hexadecimal digit-sequence representing a whole number without a radix separator. The exponent is never optional for hexadecimal floating-point literals. 
•	For example: 0x1ffp10, 0X0p-1
•	Hexadecimal digit-sequence representing a whole number with a radix separator. The exponent is never optional for hexadecimal floating-point literals. 
•	For example: 0x1.p0, 0xf.p-1
•	Hexadecimal digit-sequence representing a fractional number with a radix separator. The exponent is never optional for hexadecimal floating-point literals. 
•	For example: 0x0.123p-1, 0xa.bp10l
Reference:
•	https://en.cppreference.com/w/cpp/language/integer_literal
•	https://en.cppreference.com/w/cpp/language/floating_literal
•	MN Logging: MN_Logging
•	Logline content


Use camel case when printing the names
Naming conventions shall have standard practice of using a capital letter instead of blank spaces.
For example: Instead of using “L2 Manager” use "L2Manager".
Reference:
•	MN Logging: MN_Logging
•	Logline content


Make sure that the snapshot description files and trbl_log_list.csv are updated with the logs
Please make sure that the snapshot description files and trbl_log_list.csv are updated, this is to make sure that the code is aligned with the documentation.


Managing and maintaining log quality
Even a system log information is very important for verification and troubleshooting it is easily overlooked at specification and design phase. As for any other SW change it is more expensive to change / add printing later (duplicate testing effort etc). It is lowest effort to prepare for decent logging in the early phase to aid for fault localizing.
For each feature it shall be considered how to test and troubleshoot the feature. In addition to ensure higher quality logging, specifying prints in requirement phase will assist in thinking in advance the exception cases.
Testing personnel should be proactive in specification phase to require for decent (and not excessive) logging.
Also, in the later phase of SW design it pops up frequently exceptions that are important to be logged. It is better to let SW to detect anomalies and indicate these in verbal text instead of indirect behaviour (or in extreme case debugging with emulator!). SW code review quality is measured how well SW is prepared for exception cases including exceptions indications by the means of prints.
In addition to SW review it is proposed that each SC reviews sample log file content for new features to remove unnecessary prints, add missing ones or to modify print when needed – especially in module test and SCT phase. For each increment each SC is encouraged to review the log content and use that as a feed back in “team self learning”.
In addition to proactively participating requirement management, I&V shall generate C-level pronto when a print content is seen defective or incomplete. In worst case a poor print may cause misunderstanding by operator and unnecessary HW replacement.
Reference:
•	Logging concepts and guidelines: Logging concepts and guidelines
•	6.4. Process in managing log quality


Nokia/WBTS specific 

Exceptions
C++ exceptions are not used in WBTS. It is turned off by default. This prohibition also applies to the exception-related features added in C++11, such as noexcept, std::exception_ptr, and std::nested_exception


Assert
Usage of assert (not static_assert) in production code is prohibited. Our software is not expected to crash when something unexpected happens.


CP Common code
Be aware that there is common code/library(implementation which can be used by any/all subsystems) which provides helpers and common utility functions.
CP Common code consists of the old part and the new part:
The old part, CP_Common, contains the legacy utility functions. Some of these are segregated by the BTS HW release for which they are intended to be used(i.e. src_rel2\ and src_rel3\) while some are grouped according to functionality(e.g. binary_logger)
The new part, CP_FRAMEWORK, contains the newer helpers which was introduced for the TCOM Single Branch Strategy. It uses C++11 features, unlike CP_Common. It provides functionality for logging, message representation/handling, state machine, timer, platform facade, and other common utilities such as address conversion, EBoolean conversion, Singleton class, and many more.
Before creating new helper or utility function, always check first the common code to avoid duplication. If there's none yet, coordinate with the CP code officers about whether or not this new helper or utility function should be added as part of the common code.


Global Type Definitions
Do not use primitive arithmetic types directly. Use the type definitions provided in the global definitions(glo_def.h) instead.
Excerpt from glo_def.h
?
/* Global type defintions */
typedef unsigned char  u8;
typedef unsigned short u16;
typedef unsigned int   u32;     /* int == long */
typedef signed char    i8;
typedef signed short   i16;
typedef signed int     i32;     /* int == long */
typedef float          r32;     /* Do not use this in DSP */
typedef double         r64;     /* Do not use this in DSP */
typedef long double    r128;    /* Do not use this in DSP */
typedef unsigned char  *pu8;
typedef u8             *pu8h;
typedef unsigned short *pu16;
typedef unsigned int   *pu32;
typedef signed char    *pi8;
typedef signed short   *pi16;
typedef signed int     *pi32;
Reference:
•	FlexiPlatform C++ Style guide: FlexiPlatform C++ Style guide
•	RULE 11.4: DO NOT USE PRE-DEFINED DATA TYPES IN DECLARATIONS. INSTEAD, DECLARE NEW TYPES OR USE TYPES DEFINED IN SYSTEM LIBRARIES.


Platform APIs
CC&S API must be used instead of operating system specific API every time it can provide needed functionality.
Excerpt from glo_def.h
?
int file = fopen("name.txt", "r"); // WRONG
TAaFile* file = AaFileOpen(filePath, "r"); //GOOD


Sensitive Data
As a very elementary precaution, sensitive data must never be written to swap files. Always make sure that sensitive data is only processed in memory and never written to disks.
Compiler optimization might render the overwriting of memory areas with sensitive data ineffective if the variable is not accessed anymore afterwards. Provisions must be taken that this does not happen if it is undesired.
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	MEM 10.    Sensitive Data
•	MEM 11.    Undesired Compiler Optimization when overwriting sensitive data



Sana Top 25 Programming Errors 

16.1    CATEGORY: Insecure Interaction between Components
CWE-20: Improper Input Validation
CWE-116: Improper Encoding or Escaping of Output
CWE-89: Failure to Preserve SQL Query Structure (aka 'SQL Injection')
CWE-79: Failure to Preserve Web Page Structure (aka 'Cross-site Scripting')
CWE-78: Failure to Preserve OS Command Structure (aka 'OS Command Injection')
CWE-319: Cleartext Transmission of Sensitive Information
CWE-352: Cross-Site Request Forgery (CSRF)
CWE-362: Race Condition
16.2    CATEGORY: Risky Resource Management
CWE-119: Failure to Constrain Operations within the Bounds of a Memory Buffer
CWE-642: External Control of Critical State Data
CWE-73: External Control of File Name or Path
CWE-426: Untrusted Search Path
CWE-94: Failure to Control Generation of Code (aka 'Code Injection')
CWE-494: Download of Code without Integrity Check
CWE-404: Improper Resource Shutdown or Release
CWE-665: Improper Initialization
CWE-682: Incorrect Calculation
16.3    CATEGORY: Porous Defenses
CWE-285: Improper Access Control (Authorization)
CWE-327: Use of a Broken or Risky Cryptographic Algorithm
CWE-259: Hard-Coded Password
CWE-732: Insecure Permission Assignment for Critical Resource
CWE-330: Use of Insufficiently Random Values
CWE-250: Execution with Unnecessary Privileges
CWE-602: Client-Side Enforcement of Server-Side Security
Reference:
•	Nokia Secure Coding Guide C/C++: Secure Coding Guide C/C++
•	16     Appendix F – SANS Top 25 Programming Errors


LikeBe the first to like this
•	No labels 
•	Edit Labels 
 
Top of Form
Write a comment…
Bottom of Form
•	Powered by Atlassian Confluence 6.13.6
•	Printed by Atlassian Confluence 6.13.6
•	Report a bug
•	Atlassian News
Atlassian
 
 
 
Edit
Preview
Save
Close
