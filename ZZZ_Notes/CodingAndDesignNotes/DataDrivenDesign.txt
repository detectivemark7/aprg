
Taken from Mike Acton's "Data-Oriented Design and C++" presentation

-> What does an "Engine" team do?
---> Runtime systems
-----> Rendering
-----> Animation and gestures
-----> Streaming
-----> Cinematics
-----> VFX
-----> Post-FX
-----> Navigation
-----> Localization
-----> Many many more!
---> Development tools
-----> Level creation
-----> Lighting
-----> Material editing
-----> VFX creation
-----> Animation/state machine editing
-----> Visual Scripting
-----> Scene paiting
-----> Cinematics creation
-----> Many many more!

-> Whats important to us?
---> Hard deadlines
-----> Time to market
-----> A lot of money/investing is riding on this.
-----> Theres no missing this.
---> Soft realtime perfomrance requirements (Soft=16ms or 33ms space)
---> Usability
-----> Easy and quick to use
---- Performance
-----> A lot of leeway to do a lot of things, if the engine performance is good
-----> Peformance is key
---> Maintenance
-----> Multiple games in flight
-----> We have to continue to ship out products
---> Debugability
-----> Hard ship days: Need to make sure we can solve problem quickly
-----> Being to reason about what had gone wrong is crucial to us.

-> Whats languages to do we use
---> C
---> C++ -> 70%
---> ASM ->  most preferred
---> Perl
---> Javascript
---> C#
---> Not all are used by the game itself but used in the development cycle.
---> Pixel shaders, vertex shaders, geometry shaders, compute shaders/

-> How are games like the Mars rovers?
---> Exceptions 
-----> Its avoided and turned off
-----> if there is third-party library that uses exceptions, its isolated
---> Templates
-----> There is no hard rule, but its avoided.
-----> Most of the time its a poor use, and its slows things down
-----> When developing at scale, templates slows compile times.
---> Iostream
-----> Cout is used for debugging and tty (TTY stands for TeleTYpewriter)
-----> We generally don't use them.
---> Multiple inheritance 
-----> This is not allowed out right
-----> This is just dumb
---> Operator overloading 
-----> There is no hard rule, but its avoided.
-----> Its super obvious what you are doing, we tend to let it go.
-----> Anything significantly more complicated heavily frown on (gets rejected).
---> RTTI
-----> This is off the table.
---> No STL
-----> STL doesn't solve problems we wanna solve.
---> Custom allocators
-----> Lots
-----> Dont use the general dynamic of heap management
-----> Divided into a set of heirarchies
---> Custom debugging tools
-----> A lot of tools that use this

-> Data-Oriented Design Principles
---> The purpose of all programs, and all parts of those programs, is to transform data from one form to another.
---> If you don't understand the data, then you dont understand the problem.
---> Conversely, understand the problem better by understanding the data.
---> Different problems require different solutions.
---> If you a different data, you have a different problem.
---> If you don't understand the cost of solving the problem, then you don't understand the problem.
---> If you dont understand the hardware, then you can't reason about the cost of solving the problem.
---> Everything is a data problem. Including usability, maintenance, debug-ability, etc. Everything. (Its not a code problem.)
---> Solving problems you probably don't have creates more problem you definitely do.
-----> Avoid adding problems to the space you dont have.
-----> And you know what problems you have because you analyzed the data.
---> Latency and throughput are only the same in sequential systems.
---> Rule of thumb: Where there is one, there are many. Try looking on the time axis
-----> Time as resource.
---> Rule of thumb: The more context you have, the better you can make the solution. Dont throw away data you need.
---> Rule of thumb: NUMA extends to I/O and pre-built data all the way back through time to original source creation.
-----> NUMA: Non uniform memory access
-----> Pipeline view on data and don't look at one individual set of data, but data process in parallel and over time.
---> Software does not run in a magic fairy aether powered by the fevered dreams of CS PhDs.
---> Reason must prevail
-----> If you what you are doing is unreasonable or imaginary then it has to go.

-> Is data-oriented even a thing...?
---> ... certainly not new ideas.
---> ... more of a reminder of first principles.
---> ... but it is a response to the culture of C++
---> ... and the Three Big Lies it has engendered 

-> Lies
---> Software is a platform
---> Code designed around model of the world
---> Code is more important than data

-> Lie #1: Software is a platform
---> Hardware is the platform 
-----> Different hardware, different solutions
-----> "6502 x86 solution" is different from "ARM cell solution" and its different from "PPC ATI 5870 solution"
---> Reality is not a hack you're forced to deal with to solve your abstract theoretical problem.
-----> Reality is the actual problem.

-> Lie #2: Code designed around model of the world
---> From object oriented space
---> Hiding data is implicit in world modeling 
-----> bad because it confuses two problems:
-------> (1) Maintenance (allow changes to access)
-------> (2) Understanding properties of data (Critical for solving problems)
---------> What is data? How big is it? How does it work? Whats in there?
---------> Data is the most important thing we need know before we can actually solve problems
-------> Confusing/Confounding this two things potentiall at the cost of a slightly better maintenance, we have now made are problems very very difficult to solve.
--> World modeling implies some relationship to real data or transforms
----> but... in real life "classes" are fundamentally similar
------> A chair is a chair
----> In terms of data transformations, "classes" are only superficially similar...
------> chair, physics chair, static chair, breakable chair, -> How similar are these really? Nothing at all!
--------> But because they tend to share world modeling similarities, they aught to be connected somehow.
--> World modeling leads to monolithic, unrelated, data structures and transforms.
--> World modeling tries to idealize the problem.
----> but you can't make a problem simpler than it is. 
--> World modeling is the equivalent of self-help books for pgramming
----> Engineer/Solve by analogy
----> Engineer/Solve by story telling.
----> Instead, engineer/solve the problem directly.

-> Lie #3: Code is more important than data.
---> When the vast majority of the time and code is not the real issue, the code is a minor issue in all the things that we work with.
-----> The data is real problem.
-----> We are here honestly to talk about the code.
-----> So much development time and brain power talking about the code.
-----> Only purpose of any code is to transofrm data
---> Programmer is fundamentally responsible for the data, not the code.
-----> Programmer's job is NOT to write code;
-----> Programmer's job is to solve (data transformation) problems.
-------> And to make sure that the transformation happens correctly, fast, and in a maintanable way. 
-------> The code is just the tool we use for the transformation.
-----> Writing the code is not your job, your job is to solve data transformation problems.
-----> Solving the problem is the job.
---> Only write code that has direct provable value.
-----> Example: Code the that transform data in meaningful way.
-----> Understand the data to understand the problem.
-----> Which means: There is no ideal abstract solution to the problem.
-----> You can't "future proof"
-------> This is a trap that some people fall in.
-------> "I can make a code and it will last forever" - This is a lie.
-------> Across all imaginary systems that could ever happen in the future.
---------> This is simply not possible.
---------> There is a finite range that you have not accounted for.
-------> We are not gonna take an engine that is developed on different architecture several years ago and apply it to a new architecture (the problem has fundamentally changed)

-> What problems do these lies cause?
---> Poor performance
---> Poor concurrency
---> Poor optimizability
---> Poor stability
---> Poor testability
---> =(
---> So we build-up all these infrastructure on top, all because of problems we introduced ourselves.
---> Solve for transforming the data you have, given the constraints of the platform (and nothing else)

-> A simple example
---> Dictionary lookup ("key" to "value")
-----> If your thinking about the code first, typical mental model is a table like structure.
-------> In the mental model of the programmer, its associated together as a key-value pair.
-----> The reality is that they are not associated together 
-------> The most common operations if we analyzed it is the search on the key.
-------> What is the statistical change of getting the "value"
---------> Pretty low, most of the time we are not getting value.
-------> Most of the time we are gonna be iterating thru the keys.
-------> Thats what the data tells us, thats what the problem is actually is.
-------> And this two things ("key","value") are not actually associated with each other.
-----> This scales toward the worst case!
-------> As you add more keys and more values, it gets less performant per pair.
-------> You are loading "values" into DCache when its actually not needed (and throwing it away because vast majority of the time you are not needing it at all).
-------> You are wasting the bandwidth of your machine.
-------> You are doing things that are unnecessary because of your mental model.
---> The realilty this is more the actual process is like. 
-----> Better solution
-------> Have a container of "keys" and separately have a container of "values"
-------> Find the "key" and get the "key-index"
-------> From that use the "key-index" to get the value
-----> This is faster majority of the time.
-----> Cache is loaded w/ most likely needed (the next key)
-----> Although getting "value" would result to a cache miss (its statistically the rare case)

-> Solve for the most common case first, NOT the most generic!

-> Can't the compiler do it?
---> Add more complexity to the language? No!

-> The battle of North Bridge!
-----> Access to main memory is too slow!

-> Analyze your memory hierarchy
-----> Identify which cache is too slow or the most painful.
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 
-----> 







