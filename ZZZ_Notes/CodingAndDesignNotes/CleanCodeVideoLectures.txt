
-> The Last Programming Language

---> Better hardware now, what have we done with it?
---> Plenty of languages, have we seen it all?

---> Organize languages in Syntax
-----> Infix, postfix, and prefix
--------> Smalltalk prefix
--------> Lisp prefix
--------> Forth programming language
-----> COBOL
-------> An attempt a natural language
-------> Worst idea ever
-------> We would like our code to be readable, we dont want to force sentence structure and english grammar into our code.
-----> Fortran (formula translator)
-------> Make programming more mathematical
-------> I didnt succeed
-----> Prolog
-------> logical programming
-------> Program using logic gates

---> Semantics paradigm
-----> Modular paradigm
-------> Discipline imposed filesize or program/module length
-----> Structure (structure means control structure)
-------> Discipline imposed upon direct access of control (Discipline imposed upon goto)
---------> Remember Djikstra paper on "Goto considered harmful"
---------> C is almost structural language (goto is not used)
---------> Pascal
-----> OO
-------> Discipline imposed upon indirect access of control (Disciplined imposed upon pointer to functions)
---------> Do pointer to functions without dealing with pointers to functions (hidden using vtable)
---------> This has a huge benefit: Source code dependencies opposed the flow of control
-----------> In most structure languages: Flow of control points to the same direction as code dependencies
-------> OO is really about polymorphism
-----> Functional
-------> Discipline imposed upon assignment
---------> We cannot assign values to variables (we can initialize variables)
-------> Important now because of multicore problem

---> Graphical languages
-----> It does not work.
-----> There something about when code is saved as text.

---> New languages now are based on old languages
-----> Closure is based on Lisp
-----> Functional programming languages now are based 50 years ago
-------> The hot new thing are 50 years old.

---> Unifying into one language
-----> C is like the defacto standard
-------> Ruby, C++, Java are based from this

---> Hybrid languages
-----> When a language belongs to all semantic classes, it doesnt belong to any of them.
-------> Paradigms are all about restrictions

---> Simplicity of syntax
-----> We should focus on semantic issues instead of language issues.
-----> Enough with the language lawyers.

---> Garbage collection?
-----> We dont like memory leaks anymore.

---> We want it to be textual language.

---> We want it to behomoiconic
-----> Manipulate themselves while its running. 
-----> The code is the data and the data is the code. 




-> Clean code

---> Does clean code matter?
------> The company killed by code. 
--------> Huge mess in code. 
-----> The productivity trap
--------> Fast at first
--------> Mess causes to be speed to be crawl
--------> Major redesign is needed
--------> But based on old code, but old code changes, so new code must change (its a circular race)

---> Code rot
------> Rigidity
---------> A rigid system is a system on which a single change or enhancement forces you to make dozen changes of within the body of the system.
---------> It gotten so tangled that you change one thing, you have to make multiple changes on different parts of the program.
---------> This make estimating the effort really difficult.
-----------> You dont know how many modules really need to be changed.
------> Fragility
---------> Fragile systems are system that break on many difference places when youre changing just one place.
---------> Problems occur that are not directly related to the changes made.
---------> This make estimating the effort really difficult. 
-----------> Because problems become unpredictable.
---------> When system is fragile, managers and users noticed. 
-----------> They see malfunctions that are supposed to work and this make them really nervous.
-----------> This make it seems that the system is unreliable.
------> Inseparable. 
---------> An inseparable system is system based on modules that cannot be separated and be reused on other purposes.
---------> We try to make a system that can be reused.
------------> This often fails because system designers often fails to enforce module boundaries.
------> Opacity
---------> Opaque code is code that does not communicate the authors intent.
---------> Its hard to read, hard to understand and hard to change.

---> Going fast
------> Deadlines and pressure from managers are just excuses, its programmers that make bad code.
------> Its the mess that slows us down. You know this already, you know you have impeded by bad code.
------> "The only way to go fast is to go well."
------> Everybody thinks that you can go fast by rushing but this is an illusion
--------> You can't rush to code by going fast. 
--------> Its faster on the short term but there is a long term cost.
------> Clean code has no short term cost, and you cannot go faster by rushing your code.

---> Sushi chefs
------> Watch a master sushi chefs prepare sushi.
------> The chefs move quickly, he know exactly where his knives and ingredients are, every motion is well practiced.
------> When he gives you food, look at his work space (its spotless).
--------> Hes been cleaning the whole time he was working.
--------> This is the only way he can go fast.

---> What is clean code?
-----> Bjarne Stroustrup: I like my code to elegant and efficient.
-------> Elegant code means it tells a lot in a few words
-------> Efficient code runs quickly with taking a few cycles.
-----> Grady Brooch: Clean code should be simple and correct. Clean code should read like well written prose.
-------> Can code read like well written prose? The short answer is "yes". The long answer is "almost".
-----> Michael Feathers: Clean code looks like it was written by someone who cares.
-------> Thats a lovely thought, but we all seen code that looks like nobody cares. 
-----> Ward Cunningham (inventor of wikis): You know you are reading clean code when each routine you read is pretty much what you expect.

---> The "Boy Scout" rule
-----> Sir Robert Baden-Powell, the founder of the Boy Scouts, told scouts to "try to leave this world a little better than you found it" in his last message.
-------> If every programmer did this, the code would just keep getting better and better. 




---> Naming

-----> Reveal your intent
-------> Every name should reveal intent, if you need a comment for this then its not a good name.
-------> Variable names form a compilable comment that explains the authors intent. 
----------> There was a time long ago, that doing this is considered wasteful of CPU cycles and memory. 
-------------> This concerns are badly misplaced the true cost of software is in maintenance.

-----> Describe the problem
-------> Names that describe implementation details does not express intent.
-------> They talk about the code as it is and why it was written that way but they dont talk about the problem being solved.

-----> Whenever you have to digest the code to understand the name, the name pretty much failed to communicate.
-------> Remember, names are not for your convenience, they are your primary tools for communicating intent.
-------> Communicating intent should always be your first priority, its even more important than making sure the code works.
---------> Always choose names that communicate your intent.

-----> Avoid disinformation
--------> Have you ever seen a name in code that didn't mean what its said? 
----------> Thats disinformation, and to disinformation, to say something that you didn't mean is one of the sins that a programmer can commit.

-----> A name should say what it means and means what its said.
--------> You should NOT tolerate any drifts of meaning in your name.
--------> If a meaning of a function, class, or variable change, then you should change the name.

-----> Pronouncable names
--------> Code is going to be discussed, dont make your readers invent things on how to pronounce them.

-----> Dont use prefixes for types of the variable.
--------> This isn't the 90s anymore
--------> IDEs are powerful enough to determine the type.

-----> Parts of speech
--------> Classes and variables should be nouns (or noun phrase).
----------> Avoid noise words like: Manager, Processor, Data, or Info
------------> This words just relay: "I dont know what to call this."
----------> Variables hold instances of classes so they should be nouns too.
----------> Boolean variables should be like predicates ("isEmpty", isTerminated)
--------> Functions should be verbs.
----------> Boolean function should be like predicates as well ("isEmpty", isTerminated)
----------> Dont use nouns for accessors like (firstName, fuelRate) instead include the word "get" (getFirstName, getFuelRate)
--------> Enums tend to be state or object descriptors so they are often adjectives.
-----> Remember Grady Brooch: Clean code should be simple and correct. Clean code should read like well written prose.
--------> One of the ways we can do this, is to use the appropriate part of speech for our variables, classes and functions.

-----> The scope length rule.
--------> For Variables:
----------> There should be a relationship of length of the name and length of its scope.
----------> The longer the scope of the variable, the longer the name of the variable.
----------> Short names should be done on short scopes.
-------------> Initials as variable names can be done on short scopes
----------> Long names should be done on long scopes.
--------> For Functions or Classes:
----------> The relationship should be the the OPPOSITE.
----------> The longer the scope of the variable, the shorter the name of the variable.
----------> Short names should be done on long scopes (more general function/class).
------------> Public functions should have short names because there are called in several places.
------------> Functions that are called in many places and have big long scopes should have nice short convenient names.
----------> Long names should be done on short scopes (more specific function/class).
------------> Private functions should have long names because they are only called in short scope so its not that inconvenient.

-----> Recap
--------> Choose your names thoughtfully
--------> Communicate your intent
--------> Avoid disinformation
--------> Pronounceable Names
--------> Avoid Encodings
--------> Choose parts for speech well
--------> The scope rule.

-----> Remember, Martin Fouler quote: "Any fool can write code a computer can understand, but it takes a good programmer to write code a human can understand."




---> Functions

-----> Write small, well named functions
-------> Large functions are where classes go to hide (if you want to find classes in your application, check your large functions)
-------> In order to have functions that do one thing, you need to write small functions -> this is where "extract till you drop" comes in.

-----> Functions structure
-------> Function signature should be small, the fewer the arguments the better.
-------> There should be careful consideration of types passed to each function.
-------> The organization should be self evident.

-----> Why does switch and if statement cause harm to software structure?
-----> Assignment statements were also considered harmful.
-------> My software problems can be avoided by significantly by constraining state changing operations and side effects.
-----> Checks, validation, exception handling can also ruin readability.
-----> Goto considered harmful by Edgar Djikstra

-----> Arguments
-------> We should treat every function argument as liability not an asset.
---------> Function arguments are hard to read, hard to understand, each one can confuse or confound, each one can break your flow when reading the code (causing a double take).
-------> Three function arguments max
---------> Zero is best
---------> One is okay
---------> I'll do three sometimes, but its bordering on sloppy.
------------> Once you get to three, its hard to remember the order or the thing they do.
------------> We dont want our readers to do double takes.
------------> Why are they not an object?
-------> How about constructors? Same rule on function arguments.
---------> Consider doing the "named constructor idiom" or creational design patterns (builder, factory, prototype)
 
-----> No boolean arguments
-------> When you add a boolean argument, you are declaring that function does two things: It does one thing for the true case, and one thing for the false case.
-------> Write two functions instead, one for the true case and one for the false case.
-------> A boolean hanging out as function argument can cause confusion -> Why does it mean if its true? What does it mean when its false?
-------> If having one boolean argument is a problem? Having two booleans will cause a double take indeed.

-----> Output arguments
-------> I dislike output arguments because people just dont expect data to be coming out of an argument (it causes a double take).

-----> The null defense
-------> Passing nulls to functions is as bad as passing a boolean to a function.
---------> It might actually be worse because its not obvious that there are two cases for the function 
-----------> Theres a behaviour for the null case and another for the non-null case
-----------> Don't use null as a pseudo boolean.
-------> Avoid defensive programming.
---------> Defensive programming means that you dont trust your team or your unit tests.
---------> In public APIs, its sensible to have checks because who knows what the user will be passing to the functions.
---------> For code written by team, theres no reason for defensive programming.
---------> A good offense, is a good suite of tests.

-----> The step down rule.
-------> Before we have the scissors rule (C++ rule)
----------> Have public (usually at the top) and private (usually at the bottom) parts of your class separated so you can take a scissor and cut the public part and give it to your users/testers.
-------> The step down rule -> important stuff go at the top, details go to the bottom.
---------> Benefit 1: You can cut off what you dont need, and you would still have the important stuff.
---------> Benefit 2: Readers can have one pass/scroll to your code, and they would have the general idea first, and they would have more details as they scroll through the bottom.
---------> The public methods should be at the top because they tell you what you can do with the class.
---------> All the private/intermediate/utility functions should be place down (lower to where are used).
---------> If possible, ALL the functions references should point down.
------------> This would also show how important the function is depending on the level on where its placed on the class.
-------> Step down rule by Uncle Bob
1) Private Variables
2) Public Methods
3) Private Methods 1
4) Private Methods 2
5) Private Methods 3
---------> We go from "abstract" to "detailed" as we go through the steps.

-----> Switch statements
-------> Why do we hate switch statements? Because its not OO.
-------> Why its not OO?
---------> Each case of a switch statement will most like depend on an external module.
-----------> Source code dependency will have same direction as flow of control
-----------> The is contrary to the OO style where the source code dependency is on an opposite direction as the flow of control (this is using interfaces and polymorphism)
---------> When there are many switch statements, and there are many external modules for each case, there will be many dependencies (we call this the fanout problem)
-----------> Need to invert source code dependency using interfaces and polymorphism.
-----> You should be able to divide your program to two part application partition and main(framework) partition.
-------> Dependency injection
---------> In software engineering, dependency injection is a technique in which an object receives other objects that it depends on, called dependencies. 
-------> Switch statements should be on the framework partition not on the application partition.
-----> A system that is independently pluggable is also idependently develop-able.
-------> A switch statement that ruins the pluggability of modules, also ruins its development.

-----> Functional programming
-------> Write a program without any assignment statements (however, you can initialize a variable).
-------> Instead of setting values to bunch of variables, you pass to values as arguments into functions.
-------> Instead of looping over a set of variables, you recurse to a set of function arguments.
-------> Benefit: You functions are a true mathematical function -> they always return the same value back (no state is saved)
-------> Benefit: There are no side effects.

-----> Side effects
-------> When a function changes a variable that outlives the function call (for example changing state of a private variable), then it has side effects.
-------> This makes programs difficult to understand and a persistent source of errors.
-------> This often comes in pairs: set/get, open/close, and new/delete (now you know i call this a persistent source of errors)
-------> It causes Temporal Coupling: These functions must called in order (open must be called before close). -> Note: this is before RAII.
-------> Extract coupled methods so that we can have one function with no visible changes in state: This is called "passing a block" -> RAII has this approach.

-----> Command Query Separation
-------> Commands changes the state.
---------> Functions that change state should NOT return values.
-------> Queries just return information and does not change the state.
---------> Functions that return values should NOT change state.
-------> Benefit: Its easy to recognize if the function has side effects.
---------> By checking the function signature you could tell if its a command or a query.

-----> Tell dont ask
-------> Tell objects what to do, and not to ask objects what their state is.
-------> We dont want to make decisions on the objects behalf, the object can decide for itself.
---------> This is aligned with SRP (this is the object responsibility and not other objects)
-------> Avoid "Train Wrecks"
---------> Train Wreaks are long chains of queries.
---------> .getX().getY().getZ().doSomething 
---------> They are called train wreaks because they look like box cars.
-------> Biological systems such as cells follow the "Tell dont ask" rule.

-----> The Law of Demeter
-------> Its a bad idea for single functions to know the entire navigation pattern of the system.
-------> You may call methods of objects that are:
----------> passed as arguments
----------> created locally
----------> instance variables
----------> globals
-------> You may NOT call methods of objects that are:
----------> returned from a previous method call
-------> Following this rule is hard, its been called as the "suggestion of demeter"
-------> From Wikipedia: The Law of Demeter (LoD) or principle of least knowledge is a design guideline for developing software, particularly object-oriented programs. 
In its general form, the LoD is a specific case of loose coupling. 
The guideline was proposed by Ian Holland at Northeastern University towards the end of 1987,[1] and can be succinctly summarized in each of the following ways:[2]
---> Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.
---> Each unit should only talk to its friends; don't talk to strangers.
---> Only talk to your immediate friends.

-----> Structured programming 
-------> Structured programming says that all algorithm must be composed of sequence, selection and iteration.
---------> Sequence is the arrangement of two blocks in time.
---------> Selection is just a boolean expression the split the flow control into mulitple path ways. (Each has block, one gets executed, then blocks get rejoined, and finallyexit)
---------> Iteration is the repeated execution of a block until some boolean expression is satisfied.
---------> Djisktra showed by just following this rules you can prove the your program is correct.
-----------> A provable system is an understandable system.
---------> All codes that follow this will have a single entry at the start and single exit when done.

-----> Early returns
-------> Does single entry single exit rule mean that you cant have multiple return for a function? 
---------> No not at all. So there is no violation of structure.
-------> Midloop returns that make the code have indirect exit condition are avoided.
-------> Continue is okay
-------> Break are avoided because they can cause an indirect exit condition.

-----> Error handling
-------> Error handling is important but if its obscure logic its wrong. - Michael Feathers
-------> Prefer exceptions.
-------> Null is a value, consider is a return for your functions.
-------> try-block should comes first for readability



---> Form

-----> Comments
-----> Coding standards
-------> This should also be visible on the code itself.
-------> It should be implicit in our code and written in separate document.
-------> Documenting everything in comments yields to code clutter. When comments are too frequent in our code we tend to ignore them (even the ones we shouldnt ignore). 

-----> Comments should be rare
-------> Our eyes tend to flint over comments in search of real code.
---------> Some IDEs color comments as light grey so it would be easier to the eyes (and it would be easier to miss them).
-------> "The boy who cried wolf."
-------> Comments should be reserved on those special cases were programmers attention is really neccessary.
-------> Comments should be reserved on cases that the programmer will be relieved with the comment because the comment is there.
-------> The code itself should be able to explain its purpose.
---------> Whenever there are multiple representations of a program, the possibility of discrepancy exists.
---------> If the code itself is in error, artistic flowcharts and comprehensive comments are to no avail.
---------> Only by reading the code, can programmer know what the program does.

-----> Comments are failures
-------> It should be the goal of every programmer, to write code that expresses its intent so well that it doesnt need comments.
---------> If we adhere to this goal, then every comment we write is a failure.
-------> Some languages (like assembly languages) arent expressive at all.
---------> Comments to this languages are absolutely essential.
---------> Some languages (Pascal, Fortran and even C) are so syntactily challenged that they might need comments as well.
-------> When cycle times are long and memory is in short supply, then its really difficult to be expressive.
---------> The resource constraints dominate the structure of the code.
-------> But modern languages (Java, Ruby, C#, and C++) are remarkably expressive.
---------> The have syntactic sugar that we can use to express our intent.
---------> Nowadays, processors are fast and memory is cheap.
---------> There is no excuse to make the code as expressive as possible.
---------> So in modern languages, every comment is a failure.

-----> Comments are lies
-------> Comments tend to be clutter and they tend to be lies.
-------> Its really difficult for comments to remain truthful.
-------> Over time, the comments degrade to misinformation and lies.
---------> You might think this is discipline problem:
-----------> But comments don't just rot because programmers tend be lazy, comments also rot because they tend to be non-local.
-----------> If you fix/change something in some module of the code, how do you know that you didnt just invalidated some comment in other modules?
-----------> So they become lies than do more harm than good.

-----> Good comments
-------> Legal comments 
---------> No choice, put it on the top of the file.
-------> Informative comments
---------> Useful in regex expressions and sql commands.
-------> Clarifications and explanation of intent
---------> It means you have failed to express your intent in the code, but its better to write a comment than to leave it unexplained.
-------> Warnings of consequences
---------> Comments can be used to warn that there are bad things to come (of course a good function name can do the same). 
-------> TODO comments
---------> I thought this were examples of good comments. :D
-------> Public API documentation
---------> The best public API documentation, is the documentation that you dont have to write.

-----> Bad comments
-------> Mumbling 
---------> Dont talk to yourself in the comments.
---------> Dont rant in the code.
---------> Dont talk about your life situation.
---------> Just shut up and code.
-------> Redundant explanations 
---------> When you write a comment make sure it adds something new.
---------> Dont tell me the algorithm if the algorithm is pretty clear from the code.
---------> Dont tell me what the variable holds when its pretty clear from the name of the variable.
---------> Remember the DRY principle: Dont Repeat Yourself. (not even in the comment)
-------> Mandated redundancy
---------> If you have a tool that mandate redundancy through comments, then turn it off.
-------> Journal comments
---------> You do have a version control system right? Then use it.
---------> Also delete old journal comments.
-------> Noise comments
-------> Big banner comments.
---------> This is a great way to make sure that the words inside it are NEVER read.  
---------> Nothing says "IGNORE ME" more than a big banner comment.
-------> Closing brace comments
---------> There used long ago, but nowadays are IDEs are too good to show blocks of code and ensure the opening and closing pairs are complete.
-------> Attributions
---------> The version control system will remembers this you dont have to put your name on everything. 
-------> HTML code in comments
---------> Might be used by tools.
---------> This ruins the documentation in the code so don't use them.
-------> Non local information.
---------> This will rot quickly.
---------> There is no way for someone that is modifying that code to know that this needs to be updated.
---------> If you write a comment, make sure that its next to something it describes.
-------> Commented out code
---------> DELETE THEM because they are NOT VALID.
---------> Every time I see a commented out code, I delete them on the spot.
---------> Your version control system will remember it anyway.

-----> Explanatory structures
-------> Make your code read like well written prose, by choosing the correct part of speech to your names.
-------> And composing readable sentences in your code.

-----> Formatting
-------> Its important in my opinion.
-------> When someone looks at your code, you want them to see that its done by professionals. 
---------> And the first thing they will see is the formatting.
---------> We want our readers to be impressed by the attention to detail, struck by how orderly it is, convinced that professionals were at work.
-------> Formatting is about communication, and communication is first order of business to the programmer. 
---------> Remember, getting your code to communicate is even more important than getting your code to work.
-------> White space discipline is important.

-----> File size
-------> Big projects does not imply big files.
-------> As in everthing else in software, "smaller is better", keep your filesizes small.

-----> Vertical formatting
-------> Blank lines should be consistent.
-------> Variables that are used together should be together (no blank lines between them)
-------> The general rule is pretty simple, things are related to each other should be vertically close to each other.
---------> The distance between them is a measure on how closely related they are.

-----> Horizontal formatting
-------> How long should a line of code be? I have a simple rule for this you never have to scroll right to see it.
-------> Horizontal scroll bars are demon spawn, manage your line lengths so you dont have to deal with them.

-----> Indentation
-------> I dont care what indentation style you use.
-------> I dont care if you use tabs or spaces. Use spaces.
-------> I dont care if your indent is 2,4,8 characters wide. Use 2.
-------> I dont care where you put your braces. Use the K&R style.
From wikipedia:
The K&R style (Kernighan & Ritchie Style), and the closely related "one true brace style" in hacker jargon[5][6] (abbreviated as 1TBS[7]), are commonly used in C, C++, and other curly brace programming languages. It was the style used in the original Unix kernel, Kernighan and Ritchie's book The C Programming Language, as well as Kernighan and Plauger's book The Elements of Programming Style.
When following K&R, each function has its opening brace at the next line on the same indentation level as its header, the statements within the braces are indented, and the closing brace at the end is on the same indentation level as the header of the function at a line of its own.
Multi-line blocks inside a function, however, have their opening braces at the same line as their respective control statements; closing braces remain in a line of their own, unless followed by a keyword else or while. Such non-aligned braces are nicknamed "Egyptian braces" (or "Egyptian brackets") for their resemblance to arms in some fanciful poses of ancient Egyptians.[8][9][10] In K&R, single-line blocks do not have braces. 
-------> The most important thing is that everyone on the team uses the exact same style.
-------> The code should look like the team wrote it, I shouldnt be able to tell which specific person wrote it.

-----> Class vs Data structure
-------> Data structure have public variables (POD, Plain Old Data).
-------> Classes have private variables and public methods.
-------> We use classes and objects when its types that are likely to be added.
---------> Adding a new type, does not break independent deployability (because of polymorphism)
-------> We use structures and switch statements when its methods that are likely to be added.
---------> Adding a new method, does not break independent deployability (because it just adding a new function with a switch statement for each type)
-------> Notice how these two schemes are the opposite of each other. 
---------> Classes protect us from new types but exposes us to new methods.
---------> Data structures protect us from new methods but exposes us to new types.
---------> Is there anyway to get protection from both (new methods and new types)?
-----------> This is called "The Expression Problem"

-----> Boundaries
-------> Normally one part is abstract and another is concrete. 
-------> You want all the parts of the concrete side to be pointing on the abstract side.

-----> The impedance mismatch
-------> Relational database vs object oriented design.
-------> Database have data structures not objects.




---> TDD

-----> Fear and code rot
-------> As design rots, it becomes rigid, fragile, inseparable and opaque
-------> Why do we allow this rot to persist? Why not fix it by cleaning the code?
---------> Because if we clean it, we might break something.
---------> We dont clean it because we're afraid.
---------> If you touch it you'll break it, and if you break it, it will become yours.
---------> Leave it in the system -> rot into chaos.
---------> This rot slows us down (quagmire).
---------> As uncertainty of the code base goes, so does our estimates. 

-------> Dedicated/concerted effort to clean it
---------> At first, our bosses might be inclined to support this (because of improvement of productivity).
-----------> And we promise them that is we clean the code, we will go faster and our estimates will shrink.
---------> We hand a partially cleaned system to QA.
-----------> Once QA got a hold of it, then will detect new defects that our testing could have not found.
-----------> The list of new defects are so long and we dont know how long to fix it. -> Desperately, we revert to a pre-cleaned state.
-----------> Because of this the team doesnt want to do cleanup again.

-----> Eliminating fear
-------> We can't clean code until we eliminate the fear of change.
-------> What if we have a suite of tests that is so comprehensive that no bugs can escape it?
-------> What if that suite of tests can execute in a matter of minutes?
-------> What if every programmer can run that suite of test by just clicking a button or just typing a command?
-------> What if that suite of tests can never be out of date with the system?
-------> If this suite of tests pass, we ship the code.
-------> When you have a long list of defects? That could only mean that the development team has been behaving unprofessionally.
-------> How to keep the list of defects short? By keeping a comprehensive test-suite that has very high coverage.
-------> Its really hard for a defect to get through in that kind of defense.
---------> The point is were not afraid to clean it.

-----> The real world
-------> How do you create a comprehensive suite of tests?

-----> Uncle Bobs Three Laws:
-------> Write NO production code except to pass a failing test.
---------> How can you tests if you dont know what your testing?
-------> Write only enough of a test to demonstrate a failure.
---------> You're not allowed to write more of a unit test if its already failing (and not compiling is failure).
-------> Write only enough production code to pass the test.
---------> You're not allowed to write production code that is sufficient to pass the currently failing test.

-----> Debugging time
-------> In just a minute ago, every tests were passing.
---------> How much debugging do you think you would do if everything worked just a minute ago?
---------> Imagine if you dont have to debug all the time.
---------> Its hard to spend a lot of time debugging something that worked a minute ago.
-----------> Just type ctrl-z
---------> Dont spend your time debugging, you should spend your time coding.

-----> Design documents
-------> The tests are the low level design documents.
---------> They are written in language that we understand.
---------> They are utterly unabiguous.
---------> They are so formal that they execute.
---------> They can't get out of sync with the application code.
---------> They are the perfect kind of low level design document.
-------> You wanna know how to create an object? -> There are tests for that.
-------> You wanna know how use an API function? -> There are tests for that.

-----> Decoupling
--------> When you write your tests first, you have to design your production code to be accessible from the test.
--------> Since you haven't written the production code, that tests have tremendous influence on the design of the code.
----------> Writing tests first makes the production code testable.
--------> Another word for testable is decoupled
----------> Writing tests first makes have you have a decoupled system. You get a better design simply by writing your tests first.

-----> Courage to change
--------> The tests eliminates the fear.
--------> The tests allowed you to clean the code. The tests stops the code from rotting.

------> Why are Design and Architecture considered to be so important?
--------> Why are there so many books written on these topics?
--------> Why is so much effort applied to getting design and architecture right?
--------> We want the structure of the system to be flexible, scalable, and maintanable. 
--------> When there is a new feature, we want the design to be flexible enough to allow those changes without breaking anything.
--------> Good designs do make system more flexible and maintainable. 
--------> But nothing makes a system more flexible that suite of tests because these tests eliminates fear.
----------> If I give a perfectly designed system with no tests, you'll be afraid to clean/improve it. 
------------> Overtime, it will gradually degrade and rot.
----------> If I give a terribly designed system but a comprehensive suite of tests, you'll be not be afraid to clean it.
------------> Overtime, it will gradually get better and better.
--------> Bottom line: If you want a flexible system? Get or create a suite of tests that you trust.

-----> Trust
-------> How much trust you say? 
---------> I want you to think about those tests that they are your parachutes that youre gonna jump from an airplane with.
---------> Changing a working system is very risky, its a lot like jumping on an airplane.
---------> You better have a good parachute.
-------> If you write your code after the tests, then you never trust that test suite.
---------> Testing after the fact is boring. You already know the code works because you tested it manually. 
-----------> Not neccessary part of making your code to work (you already know it works, you tested it manually), so it feels like make-work and it feels like waste.
-------------> That means youre gonna take shortcuts with it, youre gonna take shortcuts with your parachute.
-----------> There are some portions of the code that is difficult to write test for.
-------------> You tested them manually so you know they work and therefore you dont think its worth to write a unit test.
-------------> So your test suite has holes, and youre not gonna jump on an airplane if you parachute has holes.

-----> Red Green Refactor
-------> Red: Write only enough of a test to demonstrate a failure.
-------> Green: Write NO production code except to pass a failing test.
-------> Refactor

-----> Notes on TDD:
-------> We dont usually write tests that we know will pass on the current code.
-------> We refactor tests as well. We treat the tests just as though its production code. We dont treat tests as though they are second class citizens.

-----> Answering the objections
-------> Tests are code, by following TDD you are writing more code that normal. Therefore, TDD must slow you down.
---------> TDD makes you fast because you spend less time debugging, and youre working on a cleaner code base (TDD allows you to clean your code).
---------> If you wanna go fast, practice TDD.
---------> My answer: Youre gonna write that tests anyway because its needed prove that your code is working. Otherwise, you're shipping untested code.
-------> Managers dont allow to practice TDD.
---------> TDD is a personal practice. Permission is not required.
---------> Tell your boss you practice TDD in order to go fast.
---------> You are the SW expert, and he should mind his own business.
-------> Refactoring is rework. It will be better to write the code correctly the first time.
---------> If you know that, you have to tell me because I will be really interested.
---------> Meanwhile, every creative effort in the planet is done iteratively.
-----------> Portrait painters dont paint the perfect portrait the first time.
-----------> Songwriters dont compose the perfect song the first time.
-----------> Journalists dont write the perfect article the first time.
-----------> So programmers dont write the perfect program the first time either.
-------> Who tests the tests?
---------> Two streams of code: the tests and the production code. 
---------> The tests test the production code.
---------> And the production code tests the tests.
-------> Single change in production code causes many hundreds of tests to break.
---------> This happens when tests are poorly designed. 
---------> Design your tests well, and when you discover better design, then refactor your tests.
---------> Tests are just as important as production code, treat your tests as you treat your production code. Dont allow them to become a mess..
-------> Tests can prove the presence of bugs, but tests cannot prove the absense of bugs. A suite of tests cannot prove the program is correct.
---------> Our goal is not to prove that SW correct (thats infeasible). Our goal is create a parachute that eliminates the fear of making change.
---------> We may never achieve a 100%, but 99.99% is pretty damn good.
-------> TDD is a dogma and discipline. It encourages people to follow rules instead of using their minds and thinking.
---------> That's true. Disciplines are premade decisions. The reason we follow discipline is that we dont keep making those decisions again and again.
---------> This is both a strength and a weakness. In the heat of battle, we want to able to fall back to our training move effectively and efficiently (without constant questioning).
---------> However, from time to time its worth while to take a step back and evaluating your dogmas and discipline. You might make subtle or significant changes.
---------> Either way its both appropriate and necessary.
-------> Its the test that matter. Not when we write them.
---------> BALDERDASH! If you write test at the end, theyre not going to be complete and your not going to trust them.
---------> Its simple human nature. Humans consider things that comes first as more important that things at the end. Thats why there are the end (even worse, they are treated as optional).
---------> When you write test first, you trust those tests. Because every line of production code is tested.
---------> Tests comes first because they are more important than the production code. The tests are what makes the production code flexible. Without those tests the production code rots.
-------> Theres a lot of code already written and they dont have a suite of tests.
---------> This is hard because legacy code tends to be not testable. 
-----------> In order to test it, you need to a make series of decoupling design changes.
---------> Catch 22 scenario: In order to write tests, you need to refactor. But you can't refactor (with no fear) without tests.
---------> "Working with legacy code" book by Michael Feathers.
-----------> Find some part of the legacy code the you can test without making big changes.
-----------> Then use those tests to extend the design changes more safely.
---------> New features on the legacy codes are oppurtunities to write tests.
-----------> TDD approach on new codes.
-----------> Prefer to write new modules rather than modifying old untested code.
---------> My answer: One approach: Focus of fixing and writing new tests on problematic parts of your code (code that has previously a lot of bugs to maximize the impact of the refactoring).
---------> My answer: Another approach: Write a wrapper to test legacy code and confirm how its working on the legacy code and migrate those tests and behavior on new codes.
-------> How do you test GUI?
---------> For the most part, you dont.
---------> Formatting of the GUI, its hard to test (its often untestable).
----------> However, this only applies to the last thin outer layer of the GUI where all the formatting stuff is.
-----------> There is code one layer back that you can/should test.
-----------> The content of the screen can be tested, even if the final format cannot.
-------> How do you test database?
---------> For the most part, you dont.
---------> They are a black box component, which we are not responsible for testing.
---------> What you want to test is that your schema and queries works as intended.
-------> Some programmers complain that testing is not part of their job description. They are programmers, they assert and not testers.
---------> They need to grow up.
-------> TDD is too hard.
---------> They need to grow up.

-----> Discipline and professionalism
-------> Uncle Bob: TDD is a prerequisite of professional behavior.
---------> Strong statement, affected some feeling of some friends of Uncle Bob
-------> Double Entry Bookkeeping
---------> SW is a sensitive discipline. There are single bits of a binary application, that when set the wrong way its crash the system hard.
---------> Very few systems are that sensitive. 
-----------> If you go out to a bridge and remove a few bolts that bridge wont probably not collapse right away.
-----------> If you remove a single nail in a house, it wont cause for it to fall down.  
-----------> Accounting is also sensitive. One digit error can cause the whole company to fall down and send the executives to jail.
-------------> How do accountants deal with that sensistivity? 
---------------> 700 years ago they developed double entry bookkeeping. And this practice is still in use today.
-----------------> Very simple approach: Two entries for every transaction, one for the credit side, one for the debit side.
-----------------> They follow separate mathematical paths, and until they combine on final subtraction the balance sheet. That subtraction should yield a zero.
---------> TDD is double entry bookkeeping
-----------> Everything is said twice (one on the test side, one on the production code side)
-----------> They follow very different pathways.
-----------> And they meet at a successful execution (a green bar).

-----> QA should not find nothing
-------> If QA did found something, the development should be shocked and guarantee that it should never happen again.
-------> You don't ship code that you don't know works.
-------> To ensure the QA doesnt find anything, practice the three ways of TDD.

-----> 100% code coverage.
-------> How much of your code should be covered by tests? Should it 80% or 50%? 
---------> Frankly the question is absurd. Whats the point of covering any less than a 100%.
-------> After all, if you only cover 80% of your code, you dont know if 20% works. Theres no way thats acceptable.
---------> Can you realistically cover 100% of your code with tests?
-----------> Probably not, but that doesn't mean a lower goal is acceptable. This shouldn't mean that you should push as hard as possible to get to it.




---> Architecture

-----> Architecture is not just the foundation, Architecture is the whole enchilada
-------> It includes the grand shape of the system, tiniest low level design.
-------> It includes the most abstract of the module interfaces, and the most concrete of the method implementation.
-------> Programmers are all architects in one form or another. And architects who dont code, are not really architects at all.
-------> Architecture is the shape the system takes in order to meet its use cases. And in order to remain flexible and maintainable.

-----> Architecture exposes usage
-------> Imagine the architecture of a library, it would scream library at you (its readily apparent that its a library).
-------> Imagine the architecture of a church, it would scream church at you (its readily apparent that its a church).
-------> Thats what a good architecture is. A good architecture screams use cases.
-------> When you see Model View Controller as the architecture, its hiding the use cases and exposing the delivery mechanism.
-------> We dont want the use cases coupled to the delivery mechanism.
-------> We want the separation of the use cases and delivery mechanism to be very strong. 
-------> So strong in fact, that they can be deployed independently of each other. 
-------> We want the decision about the UI, the database, the framework, the service layers and tools to be completely independent about the use cases.
---------> The use cases should stand alone.
-------> A good architecture exposes usage and shows intent.

-----> Deferring decisions
-------> Thats one of the primary goals of good architecture. A good architecture allows you to postpone decisions.
-------> A good architect knows how to keep options open for as LONG AS POSSIBLE.
-------> A good architecture maximizes the decisions NOT made.
-------> A good architecture is not about tools and frameworks. A good architecture allows you defer those decisions.
---------> How do you defer those decisions? You design a structure the decouples from them and makes them irrelevant.
---------> How do you decouple from tools, frameworks and databases? You focus your architecture on the use cases and not on the software environment.

-----> Separation of value
-------> How about if the entire value of the system is actually in the user interface?
---------> All the business value is really in how the system is delivered and not what the system does (example CRUD (create read update delete) system).
---------> Seperation of entities (the use cases, the UI, the database and the tools), helps the business makes decisions (cost value analysis). 

-----> Use cases
-------> Use cases for an accounting system thats deployed on the web should scream accounting system at you (not a web system).
---------> The users should interact with the system in a "delivery independent way".
---------> We describe how the user interacts with the system WITHOUT using web related words (like link, button, click or page). 
-----------> We should use words that dont imply a delivery mechanism.
---------> Ivar Jacobson's book (Object Oriented Software Engineering, A use case driven approach).
-----------> Jacobson idea was that the development of software should be driven by this "delivery independent use cases".
-----------> Its the use cases that form the central organizing principles and the abstraction on how the system is built.
-------> When you look at the architecture of a use case driven system, you use the use cases not the delivery mechanism.
---------> What you see is the intent of the system.
-------> A use case is nothing more (and nothing less) than a formal description on how the user interacts with the system in order to achieve a specific goal.
---------> Writing Effective Use Cases by Alistair Cockburn is a good book on use cases
---------> User Stories Applied by Mike Cohn is a good book on user stories

-----> Boundary
-------> Boundary means the barrier between the abstract classes to concrete classes.

-----> Partitioning
-------> In Jacobson' book he recognized that there are three fundamental kinds of objects.
---------> Entities/Entity objects: Business objects
-----------> Entities have application independent business rules.
-----------> The methods on entity objects perform functions that are valid on any of the applications that the entity object can be used in.
-----------> All the code on entities should not contain code that would be specific to any of the application (application specific codes should go to the interactor object)
---------> Interactors/controls/Interactor objects: Use case objects
-----------> Interactions have application dependent business rules.
-----------> Use cases are application specific business rules.
---------> Boundaries/Boundary objects: User interface objects
-----------> Boundary objects isolate the use cases from the delivery mechanism.
-----------> It should be that the business rules (both the application specific and the application agnostic) are strongly decoupled from the delivery mechanism.
-----------> The delivery mechanism should hang off the side like an appendix.
-------> This then is how we partition the system:
---------> We describe the behavior of the system in terms of use cases.
---------> We capture the application specific behavior of those use cases into interactor objects.
---------> We capture the application agnostic behavior of those use cases into entity objects controlled by those interactors.
---------> Then we hang the UI into the side like a big appendix using boundary objects that communicate to the interactors.
-----------> The thing about appendix is that it should be easy to remove or excise so were careful to isolate those in our system.

-----> Isolation
-------> To keep a strong isolation, we need strictly control those source code dependencies so that cross the boundary in just one direction.
-------> Lets say the delivery mechanism is the web.
---------> The web server, the web framework, all the web trappings (URL, routing, html) should live on the delivery side of the boundary.
---------> The MVC (model view controller) lives on the delivery side of the boundary.
-------> Isolation makes it easy to test as well.

-----> Database
-------> Needs to be isolated as well.
-------> Needs a gateway/boundary that translate commands from interactor object to database API.

-----> Who is the architect?
-------> Architects who dont code quickly become irrelevant.
-------> Architects who make high level designs and dont code them, never lie on the beds that they make for the developers.
-------> If you are an architect and want to be effective in that role, then you should writ e code.




---> SOLID principles

-----> The source code is the design.
-------> "What is software design?" by Jack Reeves 
---------> What do engineers produce? Engineers produce documents that specifies how to build products.
-----------> Architects and building engineers produce blue prints and building diagrams.
-----------> Electronic engineers produce circuit diagrams and cmos layouts. 
-----------> Mechanical engineers produce mechanical drawings and documents that how to build machines. 
-----------> What do software engineers produce? The answer is obvious. Its the source code.
-------------> Isn't the source code the product? No, its not. The running program is the product or the final executable is the product.
-----------> The cost of building in software is cheap compared to other disciplines. However, the cost of designing in software is high.
-------------> The cost structure is inverted. The cost of design is high and the cost of building is cheap.
-------------> So this means that the strategy of building software should be different than the cost of building a house.
-------------> If building a house is cheap, the strategy would be is to build the house immediately and just change it later on according to your liking.
---------------> Its easy to evolve a system to something that works. 
---------------> Unfortunately, its also easy to make it hard to modify, hard to maintain and unstable. This is called a "big ball of mud".
---------------> How to avoid this? Clean code and TDD.
---------------> The problem is in order to clean our designs, we should be able to recognize that its going bad.
-----------------> We need to know what bad designs smell like.

-----> Design smells
-------> It might start fresh, but a sequence of bad decisions that are motivated by carelessness, fear and false expediency. 
-------> Rigidity
---------> A system is rigid when its that hard to change.
---------> Its hard to change when the cost of making a change is high.
---------> Lets say that each change requires you three hours to build and test. -> This system is rigid.
---------> Long build times are sometimes because of coupling. -> This means that the developers have been careless.
-----------> This is especially true in C++ when the build times is proportional to the number coupled modules squared. 
---------> When small changes causes large rebuilds its a symptom of high coupling.
---------> Therefore one of our design goals is to manage our dependencies between modules. 
-----------> To ensure that if one module is changed the other becomes unaffected.
-------> Fragility
---------> A system is fragile when one module causes other modules to misbehave.
---------> Imagine a car system, that system would be fragile if you fix a bug on the radio, it affected the electronic windows.
---------> This kind of long distance behavioral dependencies, are very scary. Especially to managers and customers, who view them as indications of significant incompetence.
---------> After all, if every time the developers fix a bug or add a new feature, something completely unrelated breaks or crashes, the only conclusion is the developers dont know what theyre doing.
---------> The more this happens, the more uneasy managers and customers become. In the end, they may even freeze development.
-------> Immobility
---------> A system is immobile when its internal components cannot easily be extracted and reused in new environments.
---------> Immobility is caused by couplings and dependencies of modules of the system.
---------> For example, a login module that uses a specific database with a specific schema. That login module cannot be used any where else.
---------> The strategy for avoiding immobility, you need to decouple the central abstractions of application (the database, the UI, and the frameworks).
-------> Viscosity
---------> A system is viscous when neccessary actions (building, testing, check-in, check-out, and merge) are difficult and take a long time to execute.
---------> The cause is always the same, irresponsible tolerance. Developers tolerate conditions they know to be bad and do nothing to correct them.
---------> The cause of this is coupling.
---------> The solution is to decouple the modules and manage the dependencies that remain.
-------> Needless complexity
---------> A real common issue on SW design discussions is how to deal with the future. 
---------> Should we design today's requirements only? or should we take the long view and anticipate all the future requirements? Should we put hook in for future extensions or not?
---------> Systems that carry a lot of anticipatory design is needless complex.
-----------> Each hook, each extension point is another weight added to the system that the developers must carry in the present.
---------> This normally happens if your afraid to change the design or code that you need to put hooks in order accomodate changes from the future.
-----------> If on the other hand, you have a suite of tests, then you wont be afraid of changes from the future.
-----------> You dont have to litter it with a whole bunch of anticipatory elements.
-----------> Your design will be simpler, easy to maintain and they dont have to be complex.

-----> What is OO? 
-------> OO is to invert key dependencies using dynamic polymorphism (dependency inversion).
-------> Flow of control is opposed to the source code dependency.
-------> Its often said that OO is about modeling the real world. Theres truth to this, but its not really limited to OO.
-------> Its often said that OO is inheritance, encapsulation and polymorphism.
---------> You can uses these concepts to write code that rots as well as other programs not written in OO.
---------> Inheritance, encapsulation and polymorphism are mechanism within OO but theyre not its essential quality.
-------> OO is really about dependency management.

-----> Dependency management principles
-------> SOLID (these principle talk about the relationships and operations between classes)
---------> The single responsibility principle
---------> The open closed principle
---------> The liskov substitution principle
---------> The interface segregation principle
---------> The dependency inversion principle
-------> Component cohesion principles
---------> The release-reuse equivalency principle.
---------> The common closure principle.
---------> The common reuse principle.
-------> Component coupling principles
---------> The Acyclic Dependencies Principle
---------> The Stable Dependencies Principle
---------> The Stable Abstraction Principle




---> Single Responsibility Principle (SRP)

-----> The principle states that: "The module should have one and only one reason to change. One and only one responsiblity."

-----> Responsibility
-------> The best modules are ones that has one responsibility.
-------> Its about users.
---------> The responsiblities that it talks about are responsibilities that are classes and functions have to those users (specifically users who request changes to the SW).
---------> So a responsibility can be viewed as a source of change. Because the entities served by that responsibility will certainly request changes on the future.
---------> So the responsibilities that the SRP is talking about are responsibilities that your software have to all the different set of people that it serves.
-------> Its about roles.
---------> When users play certain roles, we call them actors. Responsibilities are tied to actors not to individuals.
---------> Whenever the needs of an actor change, the functions that serves that actor will also have to change.
---------> So a responsibility is a family functions thatwes serves one particular actor.
---------> Whenever the needs of an actor change, it becomes a source of change for that family of functions.
---------> The actor for a responsibility is the single point of change for that responsibility.

-----> The two values of software
-------> The user usually expects value from the software that we make them (either to save them money or make them money).
-------> Often they pay us money, in exchange for that value.
-------> SECONDARY VALUE: BEHAVIOR
---------> If the software does what the users need without bugs, crashes or delays. Then the secondary value is high.
---------> This secondary value of software is achieved when the current software meets current needs of the current user.
---------> But the needs of the users change (they change frequently), so the behavior of software gets out of sync with the current needs and secondary value of software WANES.
-------> PRIMARY VALUE: SOFT (ability to change based on the current and future needs of its users)
---------> Imagine a system that meets the current needs but its really hard to change.
-----------> Secondary value is really high, but the primary value is low.
-----------> Profits are high initially, but once changing the software becomes expensive the profits rapidly decreases.
---------> Imagine a system that has a high primary value, but a low secondary value.
-----------> Such systems are dissapointing to the users at first, because it doesn't satisfies they're needs right away.
-----------> But because the primarily value is high and the system is flexible, the users gets more and more satisfied over time, because more and more of their needs are met.
-----------> And so at the end, profitability increases.
-----------> Sustainable profitability is therefore tied to the primary value of software (thats why its primary).
---------> In short, if the software is easy to change its good for business. If the software is hard to change, its bad for business.
-----------> Therefore its the first responsibility of software developers to keep the primary value of software high.
---------> Perhaps you thought your job was to get the software to work, of course it is, but thats just your secondary job.
-----------> Your primary job was to give the software its structure that makes it easy to change.
-----------> If you dont do that, then everything else you do will be in vain.

-----> Function
-------> Where does the secondary value of software comes from? What is it that meets the needs of the users? 
---------> It is of course the responsibilities that we mentioned previously.
---------> Those responsibilities are families of functions that serves the needs of particular actors.
-------> As programmers, we allocate the responsibilities to modules, by writing the corresponding functions into those modules. 
---------> And its in this allocation of function to modules that much of the primary value of software is achieved.
---------> We can make our software much more easier to maintain and enhance by carefully choosing which modules to put our functions in.

-----> CM collision
-------> Multiple people working on the same module because of a shared responsibility of the module will reduce the primary value of software.

-----> Fan out
-------> When there are multiple responsibilities put on to a module, each of these responsibilities needs to use other classes on the system.
---------> This means that this module will have a huge fan out and that fan out makes the module sensitive to changes in the lower parts of the system.
-------> In general, its always a good idea to restrict the fan out of a class, and one way to do that is to minimize the responsibility in that class.

-----> Colocation is coupling
-------> When changing a module in languages like Java and C++, any code that calls that module is going to be recompiled and redeployed (this applies to header changes in C++).
---------> Even if they dont use the changes in that module.
---------> This means that this module is coupled with other modules.
---------> The colocation of responsibilities couples the modules.

-----> Encroaching fragility.
-------> Once two responsibilities are coupled by accident, other couplings tend to accumulate over time.
-------> Developers starts to share resources between the two responsibilities simply because they appear on the same module. 
-------> Sharing a responsibility is bad because responsibilities changes at different times for different reasons.
---------> Any coincidences are likely to be short lived.
---------> Any shared responsiblity are most likely to be diverged at some point.
-------> Changing a module with shared responsibilities can also break its other responsibilities.
---------> So now the system is beginning the exhibits the symptoms of fragility.
---------> Remember how managers and users react to fragility
-----------> When a small change on one part of the system affects and breaks other parts of the system, they draw the same conclusion: The SW developers dont know what they're doing.

-----> Single responsibility principle
-------> The principle states that: "The module should have one and only one reason to change. One and only one responsiblity."
-------> We gather together the change that changes for the same reasons and we separate the change that changes for different reasons.
---------> When we design a system, we are careful to design who the actors are.
-----------> Then we define the responsibilities that serves those actors and allocate those responsibilities to modules, such that each module should have one and only one responsibility.
-------------> This means that:
---------------> We do not mix SQL and HTML on the same module.
---------------> We do not put business rules into JSPs(Java Server Pages).
---------------> We do not implement business rules with store procedures. 
---------------> We do not mix strings and message s with business rules.
---------------> We do not mix access and control code with business rules.
-----------> We keep all this responsibilities separate from each other.
-------------> We dont put them on the same function, the same class, or the same source file.
-------------> We do this because these responsibilities at different times for different reasons and for the benefit of different actors.
---------> Boundaries must be kept 
-----------> Application code should be separate with UI code, database code, and delivery mechanism code, etc.
-----------> Why? Because of SRP.
---------> When we keep our responsibilities separate, we can change them with minimum impact.
-----------> We structure our software such that those responsibilities can be plug-ins for the rest of the application.
-----------> You cannot have plug-ins unless you're separated.
---------> Conformance to SRP occurs in many different levels in the code. 
-----------> Sometimes it causes us to pull code apart into different source files.
-----------> Sometimes it causes us to pull classes and functions apart into sub functions and inner classes.
-----------> Sometimes it causes us to pull whole components apart.
-----------> But in every case, the goal is separate responsiblities and to create physical locations in the code, where single responsibilities exists.
-----------> Those physical locations maybe functions, classes, source files, modules, or even higher level structures.
-------------> As we climb this ladder from the small to the large, will be merging small responsibilities into larger ones.
---------------> Responsiblities that we keep in separate functions will be merged into single classes.
---------------> Responsiblities that we keep in separate classes will be merged into single modules.
---------------> And so on.

-----> Welcome to engineering
-------> Welcome to the world of perpetual tradeoffs, perfect solutions are for mathematicians and fiction writers.
-------> The rest of us that lives on the real world, we are stuck managing a plethora of mutually exclusive forces.
-------> Software is art and a craft but its also an engineering discipline.





---> Open close principle (OCP)

-----> The principle states that: "A software module should be opened for extension but closed for modification."

-----> Book: Bertrand Meyer's "Object Oriented Software Construction"
-------> In this book, the concept of Open-Close Principle was discussed. 
-------> The principle states that: "A software module should be opened for extension but closed for modification."
---------> What the hell that this mean? It sounds like an oxymoron. How can something be both open and close?
-----------> "Opened for extension": It should be very simple to change the behavior of that module.
-----------> "Close for modification": The source code should not change.

-----> This principle can be done by abstraction and inversion.
-------> First, insert an abstract interface between modules.
-------> This cause to invert the dependencies, so that modules dont depend on each other.
-------> Instead, modules depend on the new abstraction.
-------> And thats how you conform to the open close principle. 
---------> Whenever you have a module with behavior you would like to extend without modifying it, 
---------> seperate the extensible behavior behind an abstract interface and turn dependencies around.

-----> Implications
-------> Think about what this means, if you can truly design a system that follows the "open close principle", it mean new feature only results to new code (and not modifying old codes).
-------> Thats quite a thought isn't it, if the old code doesn't ever get to be modified then it cannot rot.
---------> You can write the modules once(nice and clean) and never worrying about messing them up.
-------> It also make sense from the customer point of view, when they think about adding a new feature, they are thinking about adding it and not thinking about modifying anything.
---------> They find it strange that we need to modify a bunch of code in order to have a new feature.
---------> Code that conforms to the Open Close Principle also conforms to the way customers think about software.

-----> Is this possible?
-------> Theoretically yes, but its hard very hard.
---------> So hard in fact that, often its not practical.
-------> The problem of "main".
---------> "Main" should be separated from the rest of the application, by moving it across the boundary and causing all the dependencies that cross that boundary to point away from "main".
-----------> If you follow this, "Main" cannot conform to the "Open close principle" because its responsible for loading resources, strategies and factories to the application.
-----------> Dependency injection frameworks only moves the problem and not solve it.
-------> The crystal ball problem.
---------> This makes it certain that we cannot fully conform to the "Open close principle".
-----------> That this mean that we should give up to the "Open close principle" entirely? 
-------------> It maybe difficult to entire systems to conform to OCP, but its not at all difficult to get functions, classes, and small components to conform
---------> It turns out the difficulty to conform to the open close principle is a matter of size.
-----------> Small things like functions, classes and small components can conform very easily.
-----------> Its in large systems that we start getting into trouble.

-----> The Lie
-------> Things that you dont know or dont anticipate can still yield to modifying some source code.
-------> The open close principle works on things that you know is gonna happen.
-------> Its easy to design abstractions that protect you from future changes if you what those changes are going to be.
---------> But there is not crystal ball to help us with that.
-------> This is the dirty little secret about object oriented design and the open close principle that people dont like to talk about.
---------> It only protects you from change if you can predict the future.

-----> Two solutions
-------> There are two major approaches to eliminate the need for a crystal ball.
-------> Big Design Up Front (BDUF)
---------> The first is to think really hard.
-----------> You carefully consider the customer and the problem domain.
-----------> You create a domain model that anticipates the customer needs and desires.
-----------> You adorn that domain model with abstractions that isolate the components, making them open for extension but close for modification.
-----------> You continue this until you thought of everything that could possibly change.
---------> The problem with BDUF is that it creates large complex designs littered with abstractions which for the most part aren't necessary.
-----------> As useful and powerful as abstractions are, they are also expensive. 
-------------> They produce indirections, they disconnect that we think are connected.
-------------> They make it hard to follow from cause to effect. 
-------------> Me: They are also have a huge performance penalty due to cache misses.
-----------> When we need these abstractions, the cost are bearable. But when its not currently needed, then the cost can be overwhelming.
---------> And remember, customer have the uncanny ability to change the one thing that you forgot to protect yourself from.
-----------> And when they do, changing an over engineered design is a lot harder than changing a simple design.
-------> Agile Design
---------> This is both pragmatic and reactive.
---------> The best way to demonstrate this is through a metaphor.
-----------> Imagine you're a part of squad of soldiers pinned down by enemy fire.
-----------> Youre hunkered down in fox hole with your buddies while bullets zip by over your head.
-----------> If you focus your fire to the enemy, you could probably win the battle.
-----------> The problem is you dont know where the enemy is. You dont know the direction hes firing from. If stand around to find him, he will cut you down before you can focus your aim. 
-----------> So the sergeant makes a executive decision, he says "Johnson stand up" *Johnson gets hit* and now you know the direction of the bullets.
---------> Agile design is like that, you do the simplest thing you possibly can, you get it out in front of the customer, and then you will get shot with change requests. 
-----------> And then you know what kind of change requests are likely.
-----------> One of the best predictors of change are past changes. 
-------------> Once you know that something is likely to change, you can protect yourself from that kind of change in the future. 
-----------> Agile designers deliver something simple every week or so. 
-------------> And when customers make changes, those agile designers refactor the code adding the abstractions that make that kind of change easy to make in the future.
-------------> Thus the system becomes open for extension but closed for future modification.
-------> Agile Design in Practice
---------> Of course in practice, we live somewhere between this two extremes. 
---------> We avoid "big design up front", but we also avoid "no design up front".
---------> Theyre is real value of thinking through the system, and creating a decoupled domain model up front. 
-----------> But we err on the side of the small and the simple.
-----------> Our goal is to establish the basic shape of system and not think through every little detail.
-----------> If you overthink the problem, you create a lot of unnecessary abstractions that are very expensive to maintain.
---------> There are also real value of delivering early and often and refactoring based on changes the customers made.
-----------> In fact this where the open close principle really shines.
-----------> But doing this without a simple domain model, will often leave you with a undirected chaotic structure.

-----> Reprise
-------> If you follow this guidelines, you will be able to create systems that are very flexible, robust, and more.
---------> However this engineering and not magic, there is no way to perfectly conform to the open close principle, you just can't think of everything.
-----------> Eventually the customer will think of some change that will force major modifications through out the structure of the entire system.
-----------> Your goal is not to completely eliminate the pain of change thats just not feasible, your goal is minimize that pain.
-----------> Remeber the open close principle is the moral center of system architecture and while moral perfection will not be attainable, its certainly worth striving for.




---> The Liskov Substitution Principle (LSP)

-----> In short, the principle states that: "Subtypes can be used as their parent types without any side effects."

-----> Type theory
-------> "Begriffsschrift : A formal language for pure thought modeled on arithmetic." by  Gottlob Frege
-------> Not only mathematics can be described by Frege in his formulation, he can virtually describe anything.
-------> Bertrand Russel discovered some problem on Frege's formulation: Russel Paradox
---------> Does the set of all sets that dont contain themselves contain itself?

-----> Types
-------> Frege introduces the notion of types (types that can be operated by functions).
-------> The loop in Russel Paradox can be avoided by having a hierarchical order for types.
-------> Kurt Godel's quote:
By the theory of simple types I mean the doctrine which says that the objects of thought (or, in another interpretation, the symbolic expressions) are divided into types, namely: individuals, properties of individuals, relations between individuals, properties of such relations, etc.
---------> Thats sounds like classes and objects in an OOP language.
-------> Fortran was immediately designed after.
---------> Fortran had a rudimentary type system.
-------> Algol have a type system from its humble beginnings. And this is the proginator of the pascal, modula and even C++.
-------> In short, the type system of modern languages can trace their origins back to the type theory of Frege, Russel and Godel.

-----> What is a type?
-------> It does matter whats inside a type.
-------> All that matters are operations performed in that type.
-------> A type is usually just a bag of operations.
-------> Do you care what the floating point representation of a floating number is? Or you just care that 1.0/2.0 = 0.5.
-------> There might be data within a type, but the structure and its existence behind that data is hidden behind its operations.
-------> And that of course is what a class is, and data within is hidden behind its methods.

-----> Subtypes
-------> A subtype relationship is a asymmetric hierarchical relationship.
-------> It was in simula-67 that a notion of subtype really has taken its form.
---------> It was in this programming language, that classes and subtypes appeared in the form that we recognize today.
---------> The C++ inheritance scheme (and all those that derived from it) can be traced directly back by this language.

-----> Liskov and subtype
-------> Barbara Liskov provided a formal definition.
-------> According to Barbara Liskov: 
---------> "What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T."
-------> In short, the principle states that: "Subtypes can be used as their parent types without any side effects."
---------> Jim Coplien's book ("Advanced C++ Programming Styles and Idioms"): coined the phrase "Liskov substitution principle".

-----> Duck Typing
-------> "Whenever I see a bird that walks like a duck and quacks like a duck and swims like a duck. I call that bird a duck!"
-------> A type is a bag of methods, and since a subtype is a type, its too is a bag of methods.
-------> Since it should substitutable, then it should have the same method that its parent has.
---------> Even if they have different implementations.

-----> Refused bequest
-------> This is mentioned on Martin Fowler's book: [Refactoring: Improving the Design of Existing Code]
-------> This happens when the Liskov substitution principle is violated.
-------> Most languages would likely yield an exception.
-------> This occurs when method of a subtype does something that the client of the super type does not expect. 
---------> For example, the derive class might throw an exception that the users of the base class dont expect.
---------> Or, the derive class might cause a side effect that the users of the base class dont expect.

-----> The representative rule.
-------> Rule: Representatives do not share the relationships of the things they represent.
-------> Example: A square is a rectangle, so square is a subtype of a rectangle. Should square have getLength/setLength,getWidth/setWidth or getSides/setSides.
-------> According to LSP, a square should have getLength/setLength,getWidth/setWidth. 
---------> We can implement this as setting the sides of the square with setLength and setWidth.
---------> But this becomes problematic, should the programmer expect that setting the length might change the width?
---------> Its a rectangle, so the height and width should not interfere with one another.
-----------> If you set the width of a rectangle the height does not change.
-----------> But if you use a square, the width can change the height.
-----------> What happens when a function does something you dont expect? This is called undefined behavior.
----------> This violates the expection of the callers.
-------> The latent OCP violation.
---------> Putting an if statement to check if its really a square is an Open Close Principle violation.
---------> Every "Refused Bequest", every violation of the Liskov Substitution Principle is a latent violation of the Open Close Principle.
---------> Remember when OCP is violated, the software becomes rigid and fragile.
-------> Solution
---------> (1) How about we invert the inheritance? What do we call the side of a rectangle? Should it be other side?
---------> (2) How about we make this classes immutable? The names are still not appropriate. And there is still additional redundant memory used by square.
---------> (3) Best way to deal this problem is to make square and rectangle totally different unrelated types.
-----------> Isn't a square a rectangle? Mathematically it is. But our representation in the code does not fit the subtype relationship.
---------> So while geometrically a square is a rectangle, the software representative of those objects dont share the subtype relationship.
---------> Me: This is the problem when your coding around the model of the world.
-------> Consider Integers
---------> Every integer is a real number.
---------> Every real number is a complex number.
---------> But every complex number holds two real number inside it.
---------> How do you code this? It becomes non-sensical because its involves recursive definitions (just like Russels paradox).
---------> This is an example that its perfect sense of the real world but makes no sense in the computer.
---------> Why because that integer class is not actually an integer its just a representation.
-------> Consider Lists
---------> If S is a subtype of T, then a list of S is not a subtype of T.
---------> For example, a list of circles cannot be used as a list of shapes.
-----------> Why because if we allow it then a square might be put on the list of circle (since its treated as a list of shapes).
---------> Remember the Principle of representatives.
-------> Principle of representatives
---------> The representative of things do not share the relationship of the things themselves. 
-------> This principle can be generalized further:
---------> If S is a subtype of T, then generic class P of S is not automatically a subtype of the generic class P of T.

-----> How do you know if youre violating the LSP? 
-----> How can you be sure that youre not setting yourself up for a "Refused Bequest" (and the horrible OSP violation that follows from it)?
-----> Here are some simple heuretics that you can follow that you can find helpful:
-------> (1) If the base class does something the derived class must do it too. And must do it in a way that does not violate the expectation of the callers.
---------> This means that you cannot take expected behaviors away from a subtype, a subtype can do more than its parent type, but it can never do less.
---------> This means that if you a derived class that has denegerate (empty) functions in it. Then you possibly got a LSP violation.
-----------> Especially if those functions are implemented in the base class.
-----------> Not all degenerative implementation are a violation. So dont make this a hard and fast rule. But you should all be suspicious whenever you see a degenerative implementation.
-------------> Exception to this is when all the methods in the class are "empty". Then it follows the "Null Object Pattern" and is NOT a violation of the LSP.
-------> (2) A derived function is written to unconditionally throw an exception, this is always almost a violation of LSP.
---------> This is because the author of the derived function clearly doesn't want you to call it.
---------> How would you know that youre not supposed to call the derived function when all you have is the base class.
-------> (3) If "instanceof" statement can also indicate a violation of LSP.
---------> This isn't always a violation, there are sometimes good reason to check the type of an object, but its very suspicious.
---------> When is it safe to check the type of an instance? There is only one rule. You are allowed to check the type of an instance, if already know what type it is.
---------> Why would we bother to check the type if we already know it? Only if the compiler has forgotten it.

-----> Statics vs Dynamics
-------> Inheritance is the strongest relationship that can exist between two types.
---------> When you derived from a class, you inherit everything in that class.
---------> The design smell of rigidity is caused by an unrestrained accumulation of dependencies.
-----------> Therefore, inheritance breeds rigidity.
-------> What this means is the relationship that gives us flexibility, also makes us rigid.
---------> This means the flexible solutions to OCP (dependency inversion), also gives us rigidity.
-------> This isn't the case for dynamic languages like Ruby, Python or Smalltalk.
---------> Because they dont rely on inheritance for subtyping.
---------> This mean they can create flexible structures without causing rigidity.
---------> By dynamic languages have a problem of failing at runtime what Java/C++ can catch in compile time.
-----------> This is why Java/C++ are considered to be typesafe.
-----------> If you make a type error in Java, the program wont compile.
-----------> If you make a type error in Ruby, the program crashes.
-----------> Thats a huge difference and its proven to be significant disincentive for using dynamic languages.
-----------> TDD can help. If you dont have type checker (compiler), you need to have a test for it.
-------------> If unit test protect you from type errors, why do you need a language the imposes rigidity on you.
---------------> This is how the rebirth of dynamic type languages began.

-----> Design by contract
-------> A type-safe compiler do not find all the type errors.
---------> They only find the type errors that can be found through static analysis.
-------> Every type has a certain invariance (which are statement that always be true). 
---------> Every function in class can be surrounded by preconditions and postconditions.
---------> Preconditions are statements (can be boolean expressions) that must be true before a function can be called.
---------> Preconditions are statements (can be boolean expressions) that must be true when a function returns.
---------> Now its must be clear that if you carefully express your pre and post conditions.
-----------> Then you will providing the precisely functions necessary to do dynamic type checking.
-------> If you encounter a problem on runtime, it will be discovered easily by your pre and post conditions and can be pinpointed for you so you can fix it.
---------> Eiffel language has this concept.
-------> If there is no TDD, then Design by Contract might have taken hold.
---------> TDD is a more general solution to the problem.
---------> Nowadays its TDD and NOT Design by Contract are the primary means of preventing dynamic type errors.

-----> The modem problem.
-------> Check the lecture its quite lengthy but informative.




---> The Interface Segregation Principle (ISP)

-----> The principle states that: "Don't depend on things, you dont need."

-----> Interface
-------> Inheritance while its the strongest of the physical couplings, its also the weakest of the logical couplings.
---------> Interfaces are weak logical couplings.
-------> Switch class example (with light, fan, TV, and blender) 
---------> Common interface for light, fan, TV, and blender
---------> Switch with common interface can be deployed separately, and the other are the concrete light, fan, TV, and blender classes.
---------> Whats the name of the common interface? TurnOnAble, Activatable, SwitchAble. SwitchAble sounds like the best name.
-----------> The name also presents the coupling of the Switch class and SwitchAble class.
-------> What is an interface?
---------> An interface is nothing more than an abstract class with abstract methods in it. 
---------> Why do we need a special syntax for that? 
-----------> In C++ its just abstract class. So why then in Java and C# however they have special syntax element with its own grammar? Whats that for?
-------------> Multiple inheritance problem.
-------------> In Java and C#, interfaces can be multiply inherited while classes cannot. This is to avoid the diamond problem.

-----> Fat classes
-------> These are classes that have lots and lots of methods.
-------> These can be problematic because of longer build times, and something is changed all the dependent modules need to be recompiled.
-------> These classes normally have a lot of smaller subsystems on it.
---------> And these subsystems need to manage a lot data, you cannot split the subsystems because all the data needs to be managed in one place.
---------> So the job class have a lots of fan in, this creates major bottleneck for the project.
-------> Another problem is the coupling involved in fat classes can be so severe that it can be difficult to take clients and put them into separate components (DLLs and JAR files).
---------> And then independently deploy them.
-------> Solution
---------> When faced with a fat class, we isolate that fat class from its clients by creating interfaces that those clients can use.
---------> Since interface are more logically coupled to the clients that call them, than to the classes that implement them, 
-----------> we make sure that those interfaces only contain the methods that the client wishes to call.
---------> And then we multiply inherit those interfaces into the original fat class.
---------> By doing this, changes made to the function signatures of certain clients will not cause the other clients to change (recompilation avoided).
---------> This means that we can place to clients into separate components (DLLs and JAR files) and deploy them separately.
-----------> When components can be deployed separately that means it can be developed separately (keeps the development team from interfering with each other).
-------> Photocopier Job software example of a fat clases
---------> Check the lecture its quite lengthy but informative.
-------> In WCDMA CP, you could have done this on Environment class that is used on multiple files.
---------> You can have written an interface (base class) on MessageFactory, MessageHandler, ETC to avoid recompilation.

-----> Physical structure
-------> The goal of the ISP is to prevent that backwards coupling by ensuring that you dont depend on methods you dont call.
-------> This can be put simply: "Don't depend on things, you dont need. Otherwise, you can create coupling that make your SW rigid and fragile."
-------> Its main that should create the concrete instances. Its main that should create all the interactors. 
---------> Main should take those interactors and pass them all through the boundary into the application. Use Dependency Injection if you have to.

-----> "The need to know."
-------> On the surface of it, the ISP seems to be about static typing.
---------> The proof of this, is that in dynamically type languages like Python or Ruby, the strange reverse dependencies in Java and C++, simply don't exist.
---------> No interface exist on Python or Ruby, no abstract class needs to be created.
---------> Interface on dynamically type languages are already segregated.
-------> So does that mean that principle doesn't apply on Python or Ruby?
---------> It applies all right, just not in the glaring way in Java/C++.
-------> The principle states that: "Don't depend on things, you dont need."
---------> Dont leak your abstractions all over your users, dont force them to do things they dont need.
-----------> It is ultimate arrogance of library designers, that they force you to use strong physical coupling like inheritance.
-----------> They ask you to derive from their base classes, or they ask you to create instance of their concrete classes.
-----------> They force ugly dependencies on you, they violate the ISP, by foisting their needs upon you.
-------> Final lesson: 
---------> Dont force your users to depend on things they dont need.
-----------> This includes modules, people or tests. Dont force them to know more than they need to know.
-----------> The ISP is all about the need to know.
-----------> "Loose lips sink ships, and leaky abstractions create distractions."
-----------> Keep your abstractions private, dispense knowledge only to those that need to know, play your cards close to your chest. And be wary of systems that blab too much details.




---> The Dependency Inversion Principle (DIP)

-----> The principle states that: "High level policies should not depend on low level details, but low level details should depend on high level policies".

-----> What is dependency?
-------> Two dependencies that we are going to consider: Runtime dependencies and compile time dependencies
-------> Runtime Dependency
---------> When the flow of control leaves one module and enters another, there's a runtime dependency between those two modules.
---------> When one module access the variables inside another module, there's a runtime dependency there.
---------> A Runtime Dependency exists whenever two modules interact at runtime.
-------> Compile Time Dependency
---------> When a name is defined in one module, and it appears in another module, then that module has source code or compile-time dependency on the defining module.
---------> In Statically Type Languages (C,C++,C#,Java), compile time/source code dependency come at a significant cost.
---------> You cannot simply compile one module, in order to compile that module, you must first compile all the other dependent modules of it. (Not necessary true for C++)
-------> Nowadays, computers are fast enough that compile time is seldom an issue.
-------> But deployment can be an issue, if a source code change causes a lot of recompiles, we might to redeploy a lot binary modules.
-------> More importantly, in an environment where there are many teams, it is neccessary to independently develop the code as components. 
-------> For if one team makes a source code change, that causes other teams to recompile and redeploy their source code, then there will be confusion and chaos.
-------> And so we carefully design the source code dependencies across team boundaries to minimize the impact between teams.

-----> Structured design
-------> Top down methodology
---------> (1) You start with main, and then you design the subroutines that main should call, and then you design the subroutines that those subroutines should call.
---------> (2) And continue to explode the tree downwards until you have specified every subroutine in the system.
---------> (3) And then you write the code.
---------> Today of course, we do things differently (at least I hope we do).
---------> The dependency structure is interesting. The source code dependency is the same with the runtime dependency.
---------> When source code dependencies are like this, we have a tough time keeping those dependencies crossing team boundaries.
---------> We need to find for some way so that the runtime dependency structure is different from the source code dependency structure.
-----------> We dont want them to look the same.

-----> Dependency inversion
-------> How can we break the correspondence between the compile time and the runtime dependency structures? 
---------> Simple, we use polymorphism.
---------> You can create an interface (abstract class) between the modules that is dependent with each other.
---------> Now, although there still a runtime dependency between the two modules, it doesn't have the corresponding compile time/source code dependency.
---------> Both modules will have compile time/source code dependencies only on the interface.
---------> This is dependency inversion.
-------> Dependencies are inverted, whenever the source code dependencies opposed the direction of the flow of control.
-------> The principle states that: "High level policies should not depend on low level details, but low level details should depend on high level policies".

-----> Plugins
-------> Inverting dependencies is the means we create boundaries between software modules.
-------> Whenever we want boundaries to exist, we carefully choose which dependencies to invert against the flow of control.
---------> This is so that all the dependencies point in the same direction across the boundary.
-------> Boundaries like this are the way that we create plugins.
-------> A plugin is a module that is anonymous called by another module.
---------> The caller has no idea who or what hes calling.
-------> The way you create an independently deployable and developable architecture is to compose it out of plugins.
---------> That means you divide the system with boundaries and then invert the dependencies that cross those boundaries.
-------> A good application architecture is a plugin architecture
---------> And a plugin architecture is achieved through careful use of the dependency inversion principle.

-----> Architectural implications
-------> The formal definition of the DIP: "High level policies should not depend on low level details, but low level details should depend on high level policies".
---------> Modules that contain high level policy (such use cases) should not depend on modules that contain low level details (such as databases and web formatting).

-----> A reusable framework
-------> The common problem when creating a reusable framework for one application, is that the framework tends to be tailored made for that application.
---------> When using that framework for creating another application, you will find out that its NOT reusable at all.
---------> Better to create a reusable framework when there are multiple applications, so you can determine the common parts definitively. 
---------> Building a reusable framework is hard, if you dont build it in parallel with more than one application that reuses it, you most certainly fail.

-----> The inversion
-------> It should be that the applications have dependencies on the framework, but the framework has no dependencies back on the applications.
-------> The high level policies of the framework have no knowledge or any source code dependencies on the low level details of the applications.
-------> This is when the phrase "dependency inversion" first to occur.

-----> Independent Developability
-------> The beauty of this kind of framework, is that the developers can work on applications independently and just use the common framework.

-----> Dependence inversion examples
-------> The ROM telephone example.
-------> The IO Driver example.
-------> The Furnace example.

-----> YAGNI
-------> YAGNI: "You ain't gonna need it."
---------> Applies to class diagrams as well (because it contains short term decisions, that going to be out of date)



---> Now that you know this principles, how do you use them?
-----> Are they laws? Rules? or are they more like Guidelines?
-----> Each principle illuminates a particular SW design issue.
-----> Each principle gives you the context for making a decision.
-----> You dont have to decide in favor of the principle.
-------> However, you should know you are ignoring it.
-------> You should know what principle you're ignoring.
-------> You should make the decision to ignore it.




---> SOLID Components

-----> What is a component?
-------> A component is nothing more than a independently deployable library. (DLL, JAR, GEM file)
-------> Independently deployable means that a change in one doesnt cause other to be recompiled of redeployed.
-----> Subroutine libraries are independently deployable.
-------> I can change the application without recompiling or redeploying the subroutine library.
-----> Framework libraries too are independently deployable.
-----> The reason for the "independent deployability" is the one way relationship.
-------> Applications depend on framework/subroutine libraries, but framework/subroutine libraries do not depend on the application.
-----> The advantage of components is independence.
-------> Wouldn't it be nice if we can make a change to our system and recompile and redeploy one DLL or one JAR file instead recompiling the whole system?
---------> Indeed, you should be able to hot swap those components without bringing the system down.
-------> Wouldn't it be nice if the teams on your organization could work on their components independently without interfering with each other?
-----> You should aim to have your components have the maximum amount of independence.

-----> Noun Verb Analysis of User Requirments.
-------> Noun: Candidate objects in our designs
-------> Verb: Functions/Methods in our designs

-----> Coffee Maker example

-----> Elements of good component design:
-------> Interchangeability and independent deployability
-------> The physical separation of high level policy from low level detail.

-----> What are the rules? How do you know what classes go in an component? 
-----> How do you know how to manage the dependencies of those components?
-----> What principles of design you should use?
-------> The three principles of Component Cohesion
-------> The three principles of Component Coupling




---> Component Cohesion

-----> High level policy should be kept ignorant of low level detail.
-------> The components that contain detail depend on the components the contain policy.

-----> Three components of component cohesion:
-------> Release Reuse Equivalency Principle
-------> Common Closure Principle
-------> Common Reuse Principle

-----> Cohesion
-------> Recap: What is a component?
---------> A component is nothing more than a independently deployable library. Ready to run. They are deployable as part of a running system.
-------> What inside a component? What are the pieces its made of? What are forces that binds the pieces together into independently deployable unit?
-------> The pieces are functions.
-------> The forces that bind those functions are called cohesion.
-------> Classes are just the first layer of cohesions for functions.
---------> Those functions that deal with common data elements are grouped together into classes.

-----> False Cohesion
-------> Classes can be cohesive too, sometimes they belong together, sometimes they dont.
-------> It is this force of class cohesion that we will use to define our components.
-------> Subsystem error
---------> The fact that a group of classes work together to achieve a certain goal is not neccesarily a good reason to bind them together in a single component.
-----------> For example: A class that formats the report does not belong in the same component with the class the calculates the value of the report.
-----------> It is unlikely that the classes that query the data, should be combined together in the same component that used the queried data.
---------> In short, you should put classes together in the same component just because it feels right. Feeling has nothing to do with it, instead look at the architecture and dependencies.
-------> Another common error that developers make is to bundle whole inheritance hierarchies together in a single component.
---------> Remember that dependencies are inverted across inheritance relationships.
-----------> The Flow of Control opposes the Source Code Dependency.
---------> Base classes and their derivatives are often packaged into separate components. 
-------> There many others forces of false cohesion that we could study.
-------> Suffice to say that if you fall prey to these, your components will become too tightly coupled.
---------> You know this has happened if you find it difficult to independently deploy them.
-------> The goal of good component structure is be able to change one component without having to redeploy any of the others.
---------> The goal is independent deployability.

-----> The release reuse equivalence principle. (RRP)
-------> The principle states that: "A component needs to be large enough to justify the cost of managing a release cycle."
-------> Lets say I've got a component and I want you to use it.
---------> What do you want from me?
-----------> I want the component itself delivered in a convenient package.
-----------> Testsuite of the component 
-----------> Documentation
-----------> Support (If there's a bug, there support so that it can be fixed. Im gonna maintain this, not you.)
-----------> I dont want to change anything that I depend upon. I dont want you to change my codes just because you change yours.
-------------> I've got lots of users. I can't really guarantee that those changes wont affect you.
-------------> What if I give you a warning in advance before I make this changes?
-------------> What if you try the new version and see if it works?
-------------> What if I maintain the old version and give you time to migrate to the new version?
-------------> What if I let you forked the code branch?
---------------> You will manage lot of release cycles, release numbers and lifetimes.
---------> This is the point of the release reuse equivalence principle. 
-----------> The granular of reuse is the granular of release.
-----------> You can't reuse a component unless its author manage it thru a release cycle.
-------------> But managing a release cycle is expensive, the more components a team has the more time they spend administrating the release cycle and the less time they have for code.
-------> The principle states that: "A component needs to be large enough to justify the cost of managing a release cycle."
---------> You rather manage a few strategic components rather than hundreds.
---------> You dont want your component saddled hundred with these. What you want is a few strategic components not a plethora of little tiny ones.
---------> Every component deserves to be managed by a release cycle. That makes the component the granular of reuse and granular of release.

-----> The common closure principle (CCP)
-------> The principle states that: "The classes the we group together into components should be closed against the same kind of changes."
-------> What goes into a component? What are the partitioning rules? How do we know what classes to group together? What classes to keep apart?
-------> If the requirements change, how many components should change? 
---------> There should be only ONE component that should change per layer.
---------> Is this attainable? Hard to attain in practice, but that doesn't mean that we should target less.
-------> The principle states that: "The classes the we group together into components should be closed against the same kind of changes."
-------> The principle states that: "We gather together classes that change for the same reasons, we separate classes that change for different reasons."
---------> The reasons here are the same reasons in SRP
---------> Its a restatement of the interface segregation principle. 
-----------> In the case of the ISP, we were talking about grouping function into classes.
-----------> In this case of the common closure principle, we were talking about grouping classes into components.
-------> "Closure" means that all the classes in the components are closed against the same kind of changes.
---------> The classes within the component are closed to all but their prime responsibility.
---------> They are closed to the needs of every other actor.
---------> Each component in a layer serves a particular actor, so when that actor request a change, only one component per layer will have to be changed.

-----> The common reuse principle (CRP)
-------> The principle states that: "You should group classes that are used together, separate classes that arent use together."
-------> Similar to ISP
-------> Imagine you have a SINGLE common class in your component that is used by another component.
---------> If OTHER parts of the orginal components changed (not the common class), it will trigger recompilation and retesting of the other component.
---------> A lot of recompilation and retesting for no good reason.
---------> This isn't ideal, we dont want to make busy work on consumers of our component.
-------> If this principle is not followed, components have too much knowledge which affects their deployability and independence.
-------> The principle states that: "You should group classes that are used together, separate classes that arent use together."
---------> Construct your component so that when you use that component, you use all the classes within that component
---------> This is similar to ISP. 
---------> The ISP: "Avoid creating classes that depend upon methods they dont call." 
---------> The principle states that: "Avoid making components that depend upon classes they dont use." 
---------> Loose abstractions, sink applications
-------> We should limit the constituents of our component to those classes that are used together.

-----> The tension diagram
-------> Its a triangle
---------> Vertices are the component principles
-----------> The release reuse equivalence principle (RRP)
-----------> The common closure principle (CCP)
-----------> The common reuse principle (CRP)
---------> Edges:
-----------> CRP <- "components affected by many responsibilities" ->  RRP
-----------> RRP <- "components are needlessly affected" ->  CCP
-----------> CRP <- "components that are reusable" ->  CCP
-------> You cannot satify all these principles at the same time.
---------> You must choose the ones that are important to you.
---------> You must choose your position in the triangle.
-----------> The position in the triangle is function how mature your project is.
-----------> The emphasis of the project which is more towards reuse and less towards developability.
-------> Early project you might use CRP and CCP, as the project matures it move more and more towards RRP. 
-------> The component partitioning that you use today might be different on the future.
---------> This depends on project maturity.


---> Component Coupling

-----> The Acyclic Dependencies Principle
-------> The principle states that: "A software system is composed of components and the dependencies between those components must not form a cycle."
-------> The morning after syndrome: You work all night, only to find out in the next morning that your stuff is broken again because some code you depend on was changed.
---------> This is caused by large teams with inappropriate development processes.
---------> There have been two treatment options in this condition.
-----------> (1) The weekly build: On friday, let the devs get together and integrate. Usually friday is not enough and you get to work on a saturday. Not fun.
-------------> As teams grow and system get larger, friday is usually not sufficient. Then it turns to a biweekly build, and then it turns into a monthly build.
-----------> (2) Follow the Acyclic Dependencies Principle
-------> The principle states that: "A software system is composed of components and the dependencies between those components must not form a cycle."
---------> If you start a component and follow the dependencies, you must not wind up at that original component.
---------> The result of this is the dependency structure of the components forms a directed acyclic graph (DAG).
---------> Quick check: Draw the component graph like a tree, and make sure all the arrows point downwards.
-------> Why would cycles cause problems?
---------> Following a DAG, when one component updates its code, its only affecting its adjacent dependent components in the system.
-----------> Following a release process, the dependent components can localize the impact and dont affect other components in the system.
-----------> Following a release process, the component can continue working on a new release in parallel, while the dependent components migrate to the current one.
-----------> Each release will travel up the diagram like a wave, requiring careful project management.
---------> If its not a DAG, there can be a scenario that several components are dependent with each other in a cycle.
-----------> This causes many developers from all components to work together to have one working release (weekly build).
-----------> Unintended dependencies are possible just because its part of the cycle (transitive dependencies).
-----------> There is also no valid build order for the system.
-------> Two Solutions:
---------> (1) Split the component into smaller components (with the dependencies) to remove the cycle.
---------> (2) Use the dependency inversion principle. Invert the dependencies to remove the cycle.

-----> The Stable Dependencies Principle
-------> The principle states that: "A component should only depend on other components than are more stable than it is."
-------> Which you rather depend upon? A component that is stable or not stable?
---------> Stable, of course. But Why?
-------> What is stability?
---------> Is a standing pen stable?
-----------> Its not stable because it could fall at any moment.
-----------> Its not unstable too because since its not falling over.
-----------> However, the standing pen is considered not very stable. This is because it does take a lot of work to upset it.
---------> Something that is hard to change is stable, and something that is easy to change is instable.
-------> Which you rather depend upon? Something hard to change (stable) or something easy to change (instable)?
---------> Since you want stability, you want something that is hard to change.
---------> Economics to change: "When someone changes you depend upon, make sure it hurts them more than it hurts you."
-------> The principle states that: "A component should only depend on other components than are more stable than it is."
---------> Or to put in a different way: "All the dependencies of a component architecture, should be pointing in the direction of increasing stability."
-------> How do you know if its stable?
---------> A component can be hard to change because its badly written, complicated and large.
---------> The more other components that depend on the component (incoming dependencies), the more stable it is.
-----------> If youre going to modify it in anyway, you have to check all the other components that depend upon it to see if something was broken.
-----------> Thats something that is hard to do, and that means its hard to change, which makes it stable.
-----------> Its considered an "adult", because its independent and stable.
---------> The more the component depends on other components (outgoing dependencies), the more instable it is.
-----------> The dependencies might force this component to change, which makes is suceptible/easy to change, which makes it instable.
-----------> Its considered an "teenager", because its dependent and instable.
-------> Do you really want to make a component that instable? Isn't that bogus?
---------> On the contrary, we want certain components to be instable.
---------> In these components we will put the code that we expect will change frequently.
---------> Anything you put in a stable component will be hard to change, so if you want something change frequently put it in a instable component.
-------> Once you put an instable component dependent to a stable component, it will be hard to change.
---------> "It is the perversity of software that someone else can completely ruin the maintenance characteristics of your component simply by mentioning its name."
-------> When you follow this principle, you will ensure that components that you planned on being easy to change, will remain easy to change.
-------> All instable components should depend on stable components. 
-------> All the dependency arrows should be pointing on stability (careful on the arrow direction, it should have the same direction as interface arrows).
-------> Solution to problems:
---------> Similar to how to fix a cycle in a dependency graph.
---------> (1) Split the component into smaller components (with the dependencies) to split the dependencies.
---------> (2) Use the dependency inversion principle to invert the dependencies.

-----> The I Metric
-------> How do we know which components are stable than others?
---------> ME: Check the arrow directions in your diagram, it should have the same direction as interface arrows
---------> Count the fan-in dependencies (afferent couplings (ca)) and count the fan-out dependencies (efferent couplings (ce))
---------> Instability = number of fan-out dependencies / (number of fan-in dependencies + number of fan-out dependencies)
---------> I = ce / (ca + ce)
---------> I=0, means its very stable.
---------> I=1, means its very instable.
-------> The Stable Dependencies Principle can also be stated as:
---------> The component that is the source of the dependency should have a higher I metric than the component that is the target of the dependency.
---------> All the dependency arrows should be pointing on decreasing I (careful on the arrow direction, it should have the same direction as interface arrows).

-----> The Stable Abstractions Principle
-------> The principle states that: "The more stable the component is, the more abstracted it should be."
-------> All the stable components at the bottom will be really hard to change. Is that good?
---------> Not its not good. In fact its very bad. This makes our system inflexible.
---------> We can do something about it. The fact that module is hard to change, does not mean its hard to extend.
-----------> So follow the Open Close Principle to make it easy to extend.
-----------> So use abstractions to conform to the open close principle (check the discussion above for details).
-------> The principle states that: "The more stable the component is, the more abstracted it should be."
-------> The concrete stuff should go at the top of the dependency diagram and the more abstracted stuff should go at the bottom.
---------> Concrete stuffs are instable and easy to change
---------> Abstracted stuff are stable and hard to change (dont always change so much)
-------> We can find the abstractness of a component by taking the ratio of the number of classes on it.
---------> Abstractness (A) = Abstract classes / Total classes
---------> ME: We should be careful that abstract classes here mean that they are used for boundary interface for components.
-------> How do we know that your components are as abstract as they are stable?
---------> It should be that A + I = 1
---------> Consider what it means when A+I is not equal to 1
-----------> (1) It either means that theres a whole bunch of concrete classes which lots of incoming dependencies
-----------> (2) Or a whole bunch of abstract classes with no incoming dependencies.
-----------> In either case, its a violation of the dependency inversion principle.
-------------> So A + I = 1, is a numeric indication on how well your component structure adheres to the dependency inversion principle.

-----> Distance
-------> If we graph the two values on cartesian plane with x as I and y as A (I,A), we can see interesting points.
---------> As we get nearer to top left corner (0,1), we get nearer to adults (stable and abstract).
---------> As we get nearer to bottom right corner (1,0), we get nearer to teenagers (instable and concrete).
---------> As we get nearer to top right corner (1,1), we get nearer to "zone of uselessness" (instable and abstract).
---------> As we get nearer to bottom left corner (0,0), we get nearer to "zone of pain" (stable and concrete).
---------> We should target the line A+I=1 (the main sequence line) because: 
-----------> We need to keep our components as far away of the "zone of uselessness" and "zone of pain".
-----------> We need conform to the dependency inversion principle as much as possible.
-------> The distance metric can be computed as such:
---------> D = |A+I-1|
---------> D=0, is on the main sequence line.
---------> D=1, is farthest you can go on the main sequence line.
---------> This ia single numeric indicator of the dependency inversion principle.
-------> These metrics can help analyze system if youre not familiar with it. 
---------> These metrics can point you to the right direction is something is rotting.



