#include "IntegrationGeometryUtilities.hpp"

#include <Algebra/Differentiation/Differentiation.hpp>
#include <Algebra/Differentiation/DifferentiationUtilities.hpp>
#include <Algebra/Functions/CommonFunctionLibrary.hpp>
#include <Algebra/Integration/Integration.hpp>
#include <Algebra/Retrieval/VariableNamesRetriever.hpp>
#include <Algebra/Term/Operators/TermOperators.hpp>
#include <Algebra/Term/Utilities/TermUtilities.hpp>

#include <algorithm>

using namespace alba::algebra::Functions;
using namespace std;

namespace alba
{

namespace algebra
{

Term getAreaInBetweenTwoTermsInAnInterval(
        Term const& lowerTerm,
        Term const& higherTerm,
        DetailsForDefiniteIntegralWithValues const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    Term difference(higherTerm-lowerTerm);
    return integration.integrateAtDefiniteValues(difference, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getVolumeUsingOnCrossSectionalArea(
        Term const& crossSectionalArea,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    return integration.integrateAtDefiniteTerms(crossSectionalArea, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getVolumeUsingOnSolidOfRevolution(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // Let the function f be continuous on the closed interval [a, b], and assume that f(x) >= 0 for all x in [a, b].
    // If S is the solid of revolution obtained by revolving about the x axis the region bounded by the curve y=f(x),
    // the x axis and the lines x=a and x=b, and if the V cubic is the volume of S, then

    // The volume is equal to pi times the definite integral of square of f(x) from a to b.
    // This method uses disks.

    Integration integration(integralDetails.variableName);
    Term termToIntegrate = getPiAsATerm()*(term^2);
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getSurfaceAreaUsingOnSolidOfRevolution(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // Let the function f be continuous on the closed interval [a, b], and assume that f(x) >= 0 for all x in [a, b].
    // If S is the solid of revolution obtained by revolving about the x axis the region bounded by the curve y=f(x),
    // the x axis and the lines x=a and x=b, and if the V cubic is the volume of S, then

    // The surface area is equal to 2*pi times the definite integral of y times the square root of (1+yPrime^2)) from a to b.
    // Notice that the formula for length of arc is the definite integral of the square root of (1+fPrime^2).

    Differentiation differentiation(integralDetails.variableName);
    Integration integration(integralDetails.variableName);
    Term differentiatedTerm(differentiation.differentiate(term));
    Term termToIntegrate = Term(2) * getPiAsATerm() * term * ((1 + (differentiatedTerm^2)) ^ AlbaNumber::createFraction(1, 2));
    termToIntegrate.simplify();
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getVolumeUsingOnSolidOfRevolution(
        Term const& lowerFunctionTerm,
        Term const& higherFunctionTerm,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // Let the functions f and g be continuous on the closed interval [a, b], and assume that f(x) >= g(x) >= 0 for all x in [a, b].
    // If V cubic units is the volume of the solid of revolution generated by revolving about the x axis the region
    // bounded by the curves y=f(x) and y=g(x) and the lines x=a and x=b, then

    // The volume is equal to pi times the definite integral of square of (f(x)-g(x)) from a to b.
    // This method uses washers(disks with holes).

    Integration integration(integralDetails.variableName);
    Term termToIntegrate = getPiAsATerm()*((higherFunctionTerm-lowerFunctionTerm)^2);
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getVolumeUsingCylindricalShells(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // Let the function f be continuous on the closed interval [a, b], where a>=0.
    // Assume that f(x) >= 0 for all x in [a, b].
    // If R is the region bounded by the curve y=f(x), the x axis and the lines x=a and x=b,
    // if S is the solid of revolution obtained by revolving R about the y axis, and if V cubic units is the volume of S, then

    // The volume is equal to 2*pi times the definite integral of x times f(x) from a to b.
    // This method uses cylindrical shells (like a can without the top and bottom)

    Integration integration(integralDetails.variableName);
    Term termToIntegrate = 2 * getPiAsATerm() * integralDetails.variableName * term;
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getLengthOfArc(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // If the function f and its derivative fPrime are continuous on the closed interval [a, b],
    // then the length of arc of the curve y=f(x) from the point (a, f(a) to the point (b, f(b)) is given by:

    // The length is equal to the the definite integral of the square root of (1+fPrime^2) from a to b.

    Differentiation differentiation(integralDetails.variableName);
    Integration integration(integralDetails.variableName);
    Term differentiatedTerm(differentiation.differentiate(term));
    Term termToIntegrate = (1 + (differentiatedTerm^2)) ^ AlbaNumber::createFraction(1, 2);
    termToIntegrate.simplify();
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getLengthOfArcInPolarCoordinates(
        Term const& radiusInTermsOfTheta,
        DetailsForDefiniteIntegralWithTerms const& thetaDetails)
{
    Differentiation differentiation(thetaDetails.variableName);
    Integration integration(thetaDetails.variableName);
    Term drOverDTheta(differentiation.differentiate(radiusInTermsOfTheta));
    Term termToIntegrate = ((drOverDTheta^2)+(radiusInTermsOfTheta^2)) ^ AlbaNumber::createFraction(1, 2);
    termToIntegrate.simplify();
    return integration.integrateAtDefiniteTerms(termToIntegrate, thetaDetails.lowerEnd, thetaDetails.higherEnd);
}

Term getTotalMassOfARod(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // A rod of length L meters has its left endpoint at the origin.
    // If p(x) kilograms per meter is the linear density at a point x meters from the origin, where p is continuous on [0, L], then:

    // The total mass of the rod is the definite integral of p(x) from 0 to L.

    Integration integration(integralDetails.variableName);
    return integration.integrateAtDefiniteTerms(term, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getMomentOfMassOfARod(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    // A rod of length L meters its left endpoint at the origin and p(x) kilograms per meter is the linear density at a point x meters from the origin,
    // where p is continuous on [0, L].

    // The moment of mass of the rod is the definite integral of x*p(x) from 0 to L.

    Integration integration(integralDetails.variableName);
    Term termToIntegrate = integralDetails.variableName * term;
    return integration.integrateAtDefiniteTerms(termToIntegrate, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getCenterOfMassOfARod(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    return getMomentOfMassOfARod(term, integralDetails)
            / getTotalMassOfARod(term, integralDetails);
}

Term getTotalMassOfALamina(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    return integration.integrateAtDefiniteTerms(term, integralDetails.lowerEnd, integralDetails.higherEnd);
}

TermPair getMomentOfMassOfALamina(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    Term termToIntegrateInX = AlbaNumber::createFraction(1, 2) * (term^2);
    Term termToIntegrateInY = integralDetails.variableName * term;
    TermPair xyPair;
    xyPair.first = integration.integrateAtDefiniteTerms(termToIntegrateInX, integralDetails.lowerEnd, integralDetails.higherEnd);
    xyPair.second = integration.integrateAtDefiniteTerms(termToIntegrateInY, integralDetails.lowerEnd, integralDetails.higherEnd);
    return xyPair;
}

TermPair getCenterOfMassOfALamina(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Term totalMass(getTotalMassOfALamina(term, integralDetails));
    TermPair xyPair(getMomentOfMassOfALamina(term, integralDetails));
    xyPair.first = xyPair.first/totalMass;
    xyPair.second = xyPair.second/totalMass;
    return xyPair;
}

TermPair getCentroid(
        Term const& term,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    Term area(integration.integrateAtDefiniteTerms(term, integralDetails.lowerEnd, integralDetails.higherEnd));
    TermPair xyPair(getMomentOfMassOfALamina(term, integralDetails));
    xyPair.first = xyPair.first / area;
    xyPair.second = xyPair.second / area;
    return xyPair;
}

Term getWork(
        Term const& force,
        DetailsForDefiniteIntegralWithTerms const& integralDetails)
{
    Integration integration(integralDetails.variableName);
    return integration.integrateAtDefiniteTerms(force, integralDetails.lowerEnd, integralDetails.higherEnd);
}

Term getLiquidPressure(
        Term const& massDensity,
        Term const& accelerationDueToGravity,
        Term const& length,
        DetailsForDefiniteIntegralWithTerms const& depthDetails)
{
    Integration integration(depthDetails.variableName);
    Term termToIntegrate = massDensity * accelerationDueToGravity * depthDetails.variableName * length;
    return integration.integrateAtDefiniteTerms(termToIntegrate, depthDetails.lowerEnd, depthDetails.higherEnd);
}

Term integrateInPolarCoordinates(
        Term const& radiusInTermsOfTheta,
        DetailsForDefiniteIntegralWithTerms const& thetaDetails)
{
    Integration integration(thetaDetails.variableName);
    Term radiusSquared(radiusInTermsOfTheta^2);
    radiusSquared.simplify();
    return integration.integrateAtDefiniteTerms(radiusSquared, thetaDetails.lowerEnd, thetaDetails.higherEnd);
}

Term getDoubleIntegralInCartesianCoordinates(
        Term const& termWithXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    return integrateWithCoordinateDetails(termWithXAndY, {xDetails, yDetails});
}

Term getTotalMassOfALamina(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    return getDoubleIntegralInCartesianCoordinates(areaDensityAtPointInXAndY, xDetails, yDetails);
}

Term getMomentOfMassOfALaminaWithRespectToXAxis(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term termToIntegrate(areaDensityAtPointInXAndY * yDetails.variableName);
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

Term getMomentOfMassOfALaminaWithRespectToYAxis(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term termToIntegrate(areaDensityAtPointInXAndY * xDetails.variableName);
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

TermPair getCenterOfMassOfALamina(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term totalMass = getTotalMassOfALamina(areaDensityAtPointInXAndY, xDetails, yDetails);
    Term centerOfMassInX = getMomentOfMassOfALaminaWithRespectToYAxis(areaDensityAtPointInXAndY, xDetails, yDetails) / totalMass;
    Term centerOfMassInY = getMomentOfMassOfALaminaWithRespectToXAxis(areaDensityAtPointInXAndY, xDetails, yDetails) / totalMass;
    return TermPair{centerOfMassInX, centerOfMassInY};
}

Term getMomentOfInertiaAboutTheXAxis(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term termToIntegrate(areaDensityAtPointInXAndY * (yDetails.variableName^2));
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

Term getMomentOfInertiaAboutTheYAxis(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term termToIntegrate(areaDensityAtPointInXAndY * (xDetails.variableName^2));
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

Term getMomentOfInertiaAboutTheOrigin(
        Term const& areaDensityAtPointInXAndY,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term termToIntegrate(areaDensityAtPointInXAndY * ((xDetails.variableName^2) + (yDetails.variableName^2)));
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

Term getRadiusOfGyration(
        Term const& momentOfInertia,
        Term const& totalMass)
{
    // Radius of gyration or gyradius of a body about an axis of rotation is defined
    // as the radial distance to a point which would have a moment of inertia the same as the body's actual distribution of mass,
    // if the total mass of the body were concentrated there.
    // This is applicable to any type of moment of inertia (x axis, y axis, origin)
    return (momentOfInertia/totalMass)^AlbaNumber::createFraction(1, 2);
}

Term getDoubleIntegralInPolarCoordinates(
        Term const& termWithRadiusAndTheta,
        DetailsForDefiniteIntegralWithTerms const& radiusDetails,
        DetailsForDefiniteIntegralWithTerms const& thetaDetails)
{
    Term termToIntegrate(termWithRadiusAndTheta * radiusDetails.variableName);
    return integrateWithCoordinateDetails(termToIntegrate, {radiusDetails, thetaDetails});
}

Term getSurfaceAreaWithZInCartesianCoordinates(
        Term const& z,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails)
{
    Term derivativeInX(getPartialDerivative(z, xDetails.variableName));
    Term derivativeInY(getPartialDerivative(z, yDetails.variableName));
    Term termInsideSquareRoot((derivativeInX^2) + (derivativeInY^2) + 1);
    Term termToIntegrate(termInsideSquareRoot^AlbaNumber::createFraction(1, 2));
    return getDoubleIntegralInCartesianCoordinates(termToIntegrate, xDetails, yDetails);
}

Term getTripleIntegralInCartesianCoordinates(
        Term const& termWithXAndYAndZ,
        DetailsForDefiniteIntegralWithTerms const& xDetails,
        DetailsForDefiniteIntegralWithTerms const& yDetails,
        DetailsForDefiniteIntegralWithTerms const& zDetails)
{
    return integrateWithCoordinateDetails(termWithXAndYAndZ, {xDetails, yDetails, zDetails});
}

Term getTripleIntegralInCylindricalCoordinates(
        Term const& termWithRadiusAndThetaAndZ,
        DetailsForDefiniteIntegralWithTerms const& radiusDetails,
        DetailsForDefiniteIntegralWithTerms const& thetaDetails,
        DetailsForDefiniteIntegralWithTerms const& zDetails)
{
    Term termToIntegrate(termWithRadiusAndThetaAndZ * radiusDetails.variableName);
    return integrateWithCoordinateDetails(termToIntegrate, {radiusDetails, thetaDetails, zDetails});
}

Term getTripleIntegralInSphericalCoordinates(
        Term const& termWithRawAndThetaAndPhi,
        DetailsForDefiniteIntegralWithTerms const& rawDetails,
        DetailsForDefiniteIntegralWithTerms const& thetaDetails,
        DetailsForDefiniteIntegralWithTerms const& phiDetails)
{
    Term termToIntegrate(termWithRawAndThetaAndPhi * (rawDetails.variableName^2) * sin(phiDetails.variableName));
    return integrateWithCoordinateDetails(termToIntegrate, {rawDetails, thetaDetails, phiDetails});
}

Term integrateWithCoordinateDetails(
        Term const& term,
        DetailsForDefiniteIntegralsWithTerms const& integralsDetails)
{
    Term result(term);
    DetailsForDefiniteIntegralsWithTerms integralsDetailsToEvaluate(integralsDetails);
    sortIntegralsDetailsToEvaluate(integralsDetailsToEvaluate);
    for(DetailsForDefiniteIntegralWithTerms const& details : integralsDetailsToEvaluate)
    {
        Integration integration(details.variableName);
        result = integration.integrateAtDefiniteTerms(result, details.lowerEnd, details.higherEnd);
    }
    return result;
}

void sortIntegralsDetailsToEvaluate(DetailsForDefiniteIntegralsWithTerms & integralsDetails)
{
    stable_sort(integralsDetails.begin(), integralsDetails.end(), [](
                DetailsForDefiniteIntegralWithTerms const& integral1,
                DetailsForDefiniteIntegralWithTerms const& integral2)
    {
        VariableNamesRetriever retriever1;
        VariableNamesRetriever retriever2;
        retriever1.retrieveFromTerm(integral1.lowerEnd);
        retriever1.retrieveFromTerm(integral1.higherEnd);
        retriever2.retrieveFromTerm(integral2.lowerEnd);
        retriever2.retrieveFromTerm(integral2.higherEnd);

        return retriever1.getSavedData().size() > retriever2.getSavedData().size();
    });
}



}

}
